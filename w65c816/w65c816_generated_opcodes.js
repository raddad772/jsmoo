"use strict";

const decoded_opcodes = Object.freeze(
{
    // E0 M0 X0
    0: {
        0x00: new opcode_functions(opcode_matrix[0x00],
            function(regs, pins) { // BRK s
                switch(regs.TCU) {
                        // BRK s E=0 M=0 X=0
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 3: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 6: // 7
                        pins.Addr = (0xFFE6); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 7: // 8
                        pins.Addr = (0xFFE7); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x01: new opcode_functions(opcode_matrix[0x01],
            function(regs, pins) { // ORA (d,x)
                switch(regs.TCU) {
                        // ORA (d,x) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x02: new opcode_functions(opcode_matrix[0x02],
            function(regs, pins) { // COP s
                switch(regs.TCU) {
                        // COP s E=0 M=0 X=0
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 3: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 6: // 7
                        pins.Addr = (0xFFE4); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 7: // 8
                        pins.Addr = (0xFFE5); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x03: new opcode_functions(opcode_matrix[0x03],
            function(regs, pins) { // ORA d,s
                switch(regs.TCU) {
                        // ORA d,s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x04: new opcode_functions(opcode_matrix[0x04],
            function(regs, pins) { // TSB d
                switch(regs.TCU) {
                        // TSB d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFFFF;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x05: new opcode_functions(opcode_matrix[0x05],
            function(regs, pins) { // ORA d
                switch(regs.TCU) {
                        // ORA d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x06: new opcode_functions(opcode_matrix[0x06],
            function(regs, pins) { // ASL d
                switch(regs.TCU) {
                        // ASL d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x07: new opcode_functions(opcode_matrix[0x07],
            function(regs, pins) { // ORA [d]
                switch(regs.TCU) {
                        // ORA [d] E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x08: new opcode_functions(opcode_matrix[0x08],
            function(regs, pins) { // PHP s
                switch(regs.TCU) {
                        // PHP s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.P.getbyte_native();
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x09: new opcode_functions(opcode_matrix[0x09],
            function(regs, pins) { // ORA #
                switch(regs.TCU) {
                        // ORA # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0A: new opcode_functions(opcode_matrix[0x0A],
            function(regs, pins) { // ASL A
                switch(regs.TCU) {
                        // ASL A E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0B: new opcode_functions(opcode_matrix[0x0B],
            function(regs, pins) { // PHD s
                switch(regs.TCU) {
                        // PHD s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.D);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x0C: new opcode_functions(opcode_matrix[0x0C],
            function(regs, pins) { // TSB a
                switch(regs.TCU) {
                        // TSB a E=0 M=0 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFFFF;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0D: new opcode_functions(opcode_matrix[0x0D],
            function(regs, pins) { // ORA a
                switch(regs.TCU) {
                        // ORA a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0E: new opcode_functions(opcode_matrix[0x0E],
            function(regs, pins) { // ASL a
                switch(regs.TCU) {
                        // ASL a E=0 M=0 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0F: new opcode_functions(opcode_matrix[0x0F],
            function(regs, pins) { // ORA al
                switch(regs.TCU) {
                        // ORA al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x10: new opcode_functions(opcode_matrix[0x10],
            function(regs, pins) { // BPL r
                switch(regs.TCU) {
                        // BPL r E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x11: new opcode_functions(opcode_matrix[0x11],
            function(regs, pins) { // ORA (d),y
                switch(regs.TCU) {
                        // ORA (d),y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x12: new opcode_functions(opcode_matrix[0x12],
            function(regs, pins) { // ORA (d)
                switch(regs.TCU) {
                        // ORA (d) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x13: new opcode_functions(opcode_matrix[0x13],
            function(regs, pins) { // ORA (d,s),y
                switch(regs.TCU) {
                        // ORA (d,s),y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x14: new opcode_functions(opcode_matrix[0x14],
            function(regs, pins) { // TRB d
                switch(regs.TCU) {
                        // TRB d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFFFF;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x15: new opcode_functions(opcode_matrix[0x15],
            function(regs, pins) { // ORA d,x
                switch(regs.TCU) {
                        // ORA d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x16: new opcode_functions(opcode_matrix[0x16],
            function(regs, pins) { // ASL d,x
                switch(regs.TCU) {
                        // ASL d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x17: new opcode_functions(opcode_matrix[0x17],
            function(regs, pins) { // ORA [d],y
                switch(regs.TCU) {
                        // ORA [d],y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x18: new opcode_functions(opcode_matrix[0x18],
            function(regs, pins) { // CLC i
                switch(regs.TCU) {
                        // CLC i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x19: new opcode_functions(opcode_matrix[0x19],
            function(regs, pins) { // ORA a,y
                switch(regs.TCU) {
                        // ORA a,y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1A: new opcode_functions(opcode_matrix[0x1A],
            function(regs, pins) { // INC A
                switch(regs.TCU) {
                        // INC A E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1B: new opcode_functions(opcode_matrix[0x1B],
            function(regs, pins) { // TCS i
                switch(regs.TCU) {
                        // TCS i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.C;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x1C: new opcode_functions(opcode_matrix[0x1C],
            function(regs, pins) { // TRB a
                switch(regs.TCU) {
                        // TRB a E=0 M=0 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFFFF;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1D: new opcode_functions(opcode_matrix[0x1D],
            function(regs, pins) { // ORA a,x
                switch(regs.TCU) {
                        // ORA a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1E: new opcode_functions(opcode_matrix[0x1E],
            function(regs, pins) { // ASL a,x
                switch(regs.TCU) {
                        // ASL a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1F: new opcode_functions(opcode_matrix[0x1F],
            function(regs, pins) { // ORA al,x
                switch(regs.TCU) {
                        // ORA al,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x20: new opcode_functions(opcode_matrix[0x20],
            function(regs, pins) { // JSR a
                switch(regs.TCU) {
                        // JSR a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.PDV = 0;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 6
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x21: new opcode_functions(opcode_matrix[0x21],
            function(regs, pins) { // AND (d,x)
                switch(regs.TCU) {
                        // AND (d,x) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x22: new opcode_functions(opcode_matrix[0x22],
            function(regs, pins) { // JSL al
                switch(regs.TCU) {
                        // JSL al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        regs.TA += pins.D << 8;
                        pins.D = (regs.PBR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 1;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 6: // 7
                        regs.PBR = pins.D;
                        pins.RW = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF;
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 7: // 8
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x23: new opcode_functions(opcode_matrix[0x23],
            function(regs, pins) { // AND d,s
                switch(regs.TCU) {
                        // AND d,s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x24: new opcode_functions(opcode_matrix[0x24],
            function(regs, pins) { // BIT d
                switch(regs.TCU) {
                        // BIT d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        regs.P.V = (regs.TR & 0x4000) >>> 14;
                        regs.P.N = (regs.TR & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x25: new opcode_functions(opcode_matrix[0x25],
            function(regs, pins) { // AND d
                switch(regs.TCU) {
                        // AND d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x26: new opcode_functions(opcode_matrix[0x26],
            function(regs, pins) { // ROL d
                switch(regs.TCU) {
                        // ROL d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x27: new opcode_functions(opcode_matrix[0x27],
            function(regs, pins) { // AND [d]
                switch(regs.TCU) {
                        // AND [d] E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x28: new opcode_functions(opcode_matrix[0x28],
            function(regs, pins) { // PLP s
                switch(regs.TCU) {
                        // PLP s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.setbyte_native(regs.TR);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x29: new opcode_functions(opcode_matrix[0x29],
            function(regs, pins) { // AND #
                switch(regs.TCU) {
                        // AND # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2A: new opcode_functions(opcode_matrix[0x2A],
            function(regs, pins) { // ROL A
                switch(regs.TCU) {
                        // ROL A E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2B: new opcode_functions(opcode_matrix[0x2B],
            function(regs, pins) { // PLD s
                switch(regs.TCU) {
                        // PLD s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.D = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x2C: new opcode_functions(opcode_matrix[0x2C],
            function(regs, pins) { // BIT a
                switch(regs.TCU) {
                        // BIT a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        regs.P.V = (regs.TR & 0x4000) >>> 14;
                        regs.P.N = (regs.TR & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2D: new opcode_functions(opcode_matrix[0x2D],
            function(regs, pins) { // AND a
                switch(regs.TCU) {
                        // AND a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2E: new opcode_functions(opcode_matrix[0x2E],
            function(regs, pins) { // ROL a
                switch(regs.TCU) {
                        // ROL a E=0 M=0 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2F: new opcode_functions(opcode_matrix[0x2F],
            function(regs, pins) { // AND al
                switch(regs.TCU) {
                        // AND al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x30: new opcode_functions(opcode_matrix[0x30],
            function(regs, pins) { // BMI r
                switch(regs.TCU) {
                        // BMI r E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x31: new opcode_functions(opcode_matrix[0x31],
            function(regs, pins) { // AND (d),y
                switch(regs.TCU) {
                        // AND (d),y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x32: new opcode_functions(opcode_matrix[0x32],
            function(regs, pins) { // AND (d)
                switch(regs.TCU) {
                        // AND (d) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x33: new opcode_functions(opcode_matrix[0x33],
            function(regs, pins) { // AND (d,s),y
                switch(regs.TCU) {
                        // AND (d,s),y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x34: new opcode_functions(opcode_matrix[0x34],
            function(regs, pins) { // BIT d,x
                switch(regs.TCU) {
                        // BIT d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        regs.P.V = (regs.TR & 0x4000) >>> 14;
                        regs.P.N = (regs.TR & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x35: new opcode_functions(opcode_matrix[0x35],
            function(regs, pins) { // AND d,x
                switch(regs.TCU) {
                        // AND d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x36: new opcode_functions(opcode_matrix[0x36],
            function(regs, pins) { // ROL d,x
                switch(regs.TCU) {
                        // ROL d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x37: new opcode_functions(opcode_matrix[0x37],
            function(regs, pins) { // AND [d],y
                switch(regs.TCU) {
                        // AND [d],y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x38: new opcode_functions(opcode_matrix[0x38],
            function(regs, pins) { // SEC i
                switch(regs.TCU) {
                        // SEC i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x39: new opcode_functions(opcode_matrix[0x39],
            function(regs, pins) { // AND a,y
                switch(regs.TCU) {
                        // AND a,y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3A: new opcode_functions(opcode_matrix[0x3A],
            function(regs, pins) { // DEC A
                switch(regs.TCU) {
                        // DEC A E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3B: new opcode_functions(opcode_matrix[0x3B],
            function(regs, pins) { // TSC i
                switch(regs.TCU) {
                        // TSC i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.S);
                        regs.P.Z = +((regs.S) === 0);
                        regs.P.N = ((regs.S) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x3C: new opcode_functions(opcode_matrix[0x3C],
            function(regs, pins) { // BIT a,x
                switch(regs.TCU) {
                        // BIT a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        regs.P.V = (regs.TR & 0x4000) >>> 14;
                        regs.P.N = (regs.TR & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3D: new opcode_functions(opcode_matrix[0x3D],
            function(regs, pins) { // AND a,x
                switch(regs.TCU) {
                        // AND a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3E: new opcode_functions(opcode_matrix[0x3E],
            function(regs, pins) { // ROL a,x
                switch(regs.TCU) {
                        // ROL a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3F: new opcode_functions(opcode_matrix[0x3F],
            function(regs, pins) { // AND al,x
                switch(regs.TCU) {
                        // AND al,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x40: new opcode_functions(opcode_matrix[0x40],
            function(regs, pins) { // RTI s
                switch(regs.TCU) {
                        // RTI s E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        pins.PDV = 1;
                        break;
                    case 4: // 5
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.P.setbyte_native(pins.D);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        if (regs.P.E) regs.S = (regs.S & 0xFF) | 0x100;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.TA = pins.D;
                        break;
                    case 6: // 7
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.TA += pins.D << 8;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TA;
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x41: new opcode_functions(opcode_matrix[0x41],
            function(regs, pins) { // EOR (d,x)
                switch(regs.TCU) {
                        // EOR (d,x) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x42: new opcode_functions(opcode_matrix[0x42],
            function(regs, pins) { // WDM i
                switch(regs.TCU) {
                        // WDM i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x43: new opcode_functions(opcode_matrix[0x43],
            function(regs, pins) { // EOR d,s
                switch(regs.TCU) {
                        // EOR d,s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x44: new opcode_functions(opcode_matrix[0x44],
            function(regs, pins) { // MVP xyc
                switch(regs.TCU) {
                        // MVP xyc E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D
                        pins.Addr = (regs.X); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X - 1) & 0xFFFF;
                        regs.Y = (regs.Y - 1) & 0xFFFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x45: new opcode_functions(opcode_matrix[0x45],
            function(regs, pins) { // EOR d
                switch(regs.TCU) {
                        // EOR d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x46: new opcode_functions(opcode_matrix[0x46],
            function(regs, pins) { // LSR d
                switch(regs.TCU) {
                        // LSR d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x47: new opcode_functions(opcode_matrix[0x47],
            function(regs, pins) { // EOR [d]
                switch(regs.TCU) {
                        // EOR [d] E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x48: new opcode_functions(opcode_matrix[0x48],
            function(regs, pins) { // PHA s
                switch(regs.TCU) {
                        // PHA s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.C);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x49: new opcode_functions(opcode_matrix[0x49],
            function(regs, pins) { // EOR #
                switch(regs.TCU) {
                        // EOR # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4A: new opcode_functions(opcode_matrix[0x4A],
            function(regs, pins) { // LSR A
                switch(regs.TCU) {
                        // LSR A E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4B: new opcode_functions(opcode_matrix[0x4B],
            function(regs, pins) { // PHK s
                switch(regs.TCU) {
                        // PHK s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.PBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4C: new opcode_functions(opcode_matrix[0x4C],
            function(regs, pins) { // JMP a
                switch(regs.TCU) {
                        // JMP a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4D: new opcode_functions(opcode_matrix[0x4D],
            function(regs, pins) { // EOR a
                switch(regs.TCU) {
                        // EOR a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4E: new opcode_functions(opcode_matrix[0x4E],
            function(regs, pins) { // LSR a
                switch(regs.TCU) {
                        // LSR a E=0 M=0 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4F: new opcode_functions(opcode_matrix[0x4F],
            function(regs, pins) { // EOR al
                switch(regs.TCU) {
                        // EOR al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x50: new opcode_functions(opcode_matrix[0x50],
            function(regs, pins) { // BVC r
                switch(regs.TCU) {
                        // BVC r E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x51: new opcode_functions(opcode_matrix[0x51],
            function(regs, pins) { // EOR (d),y
                switch(regs.TCU) {
                        // EOR (d),y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x52: new opcode_functions(opcode_matrix[0x52],
            function(regs, pins) { // EOR (d)
                switch(regs.TCU) {
                        // EOR (d) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x53: new opcode_functions(opcode_matrix[0x53],
            function(regs, pins) { // EOR (d,s),y
                switch(regs.TCU) {
                        // EOR (d,s),y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x54: new opcode_functions(opcode_matrix[0x54],
            function(regs, pins) { // MVN xyc
                switch(regs.TCU) {
                        // MVN xyc E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D;
                        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X + 1) & 0xFFFF;
                        regs.Y = (regs.Y + 1) & 0xFFFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x55: new opcode_functions(opcode_matrix[0x55],
            function(regs, pins) { // EOR d,x
                switch(regs.TCU) {
                        // EOR d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x56: new opcode_functions(opcode_matrix[0x56],
            function(regs, pins) { // LSR d,x
                switch(regs.TCU) {
                        // LSR d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x57: new opcode_functions(opcode_matrix[0x57],
            function(regs, pins) { // EOR [d],y
                switch(regs.TCU) {
                        // EOR [d],y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x58: new opcode_functions(opcode_matrix[0x58],
            function(regs, pins) { // CLI i
                switch(regs.TCU) {
                        // CLI i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 0;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x59: new opcode_functions(opcode_matrix[0x59],
            function(regs, pins) { // EOR a,y
                switch(regs.TCU) {
                        // EOR a,y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5A: new opcode_functions(opcode_matrix[0x5A],
            function(regs, pins) { // PHY s
                switch(regs.TCU) {
                        // PHY s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.Y);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x5B: new opcode_functions(opcode_matrix[0x5B],
            function(regs, pins) { // TCD i
                switch(regs.TCU) {
                        // TCD i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.D = (regs.C);
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5C: new opcode_functions(opcode_matrix[0x5C],
            function(regs, pins) { // JMP al
                switch(regs.TCU) {
                        // JMP al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = regs.TA + (pins.D << 8);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5D: new opcode_functions(opcode_matrix[0x5D],
            function(regs, pins) { // EOR a,x
                switch(regs.TCU) {
                        // EOR a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5E: new opcode_functions(opcode_matrix[0x5E],
            function(regs, pins) { // LSR a,x
                switch(regs.TCU) {
                        // LSR a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5F: new opcode_functions(opcode_matrix[0x5F],
            function(regs, pins) { // EOR al,x
                switch(regs.TCU) {
                        // EOR al,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x60: new opcode_functions(opcode_matrix[0x60],
            function(regs, pins) { // RTS s
                switch(regs.TCU) {
                        // RTS s E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x61: new opcode_functions(opcode_matrix[0x61],
            function(regs, pins) { // ADC (d,x)
                switch(regs.TCU) {
                        // ADC (d,x) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x62: new opcode_functions(opcode_matrix[0x62],
            function(regs, pins) { // PER s
                switch(regs.TCU) {
                        // PER s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x63: new opcode_functions(opcode_matrix[0x63],
            function(regs, pins) { // ADC d,s
                switch(regs.TCU) {
                        // ADC d,s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x64: new opcode_functions(opcode_matrix[0x64],
            function(regs, pins) { // STZ d
                switch(regs.TCU) {
                        // STZ d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x65: new opcode_functions(opcode_matrix[0x65],
            function(regs, pins) { // ADC d
                switch(regs.TCU) {
                        // ADC d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x66: new opcode_functions(opcode_matrix[0x66],
            function(regs, pins) { // ROR d
                switch(regs.TCU) {
                        // ROR d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x67: new opcode_functions(opcode_matrix[0x67],
            function(regs, pins) { // ADC [d]
                switch(regs.TCU) {
                        // ADC [d] E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x68: new opcode_functions(opcode_matrix[0x68],
            function(regs, pins) { // PLA s
                switch(regs.TCU) {
                        // PLA s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.C = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x69: new opcode_functions(opcode_matrix[0x69],
            function(regs, pins) { // ADC #
                switch(regs.TCU) {
                        // ADC # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6A: new opcode_functions(opcode_matrix[0x6A],
            function(regs, pins) { // ROR A
                switch(regs.TCU) {
                        // ROR A E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6B: new opcode_functions(opcode_matrix[0x6B],
            function(regs, pins) { // RTL s
                switch(regs.TCU) {
                        // RTL s E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x6C: new opcode_functions(opcode_matrix[0x6C],
            function(regs, pins) { // JMP (a)
                switch(regs.TCU) {
                        // JMP (a) E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x6D: new opcode_functions(opcode_matrix[0x6D],
            function(regs, pins) { // ADC a
                switch(regs.TCU) {
                        // ADC a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6E: new opcode_functions(opcode_matrix[0x6E],
            function(regs, pins) { // ROR a
                switch(regs.TCU) {
                        // ROR a E=0 M=0 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6F: new opcode_functions(opcode_matrix[0x6F],
            function(regs, pins) { // ADC al
                switch(regs.TCU) {
                        // ADC al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x70: new opcode_functions(opcode_matrix[0x70],
            function(regs, pins) { // BVS r
                switch(regs.TCU) {
                        // BVS r E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x71: new opcode_functions(opcode_matrix[0x71],
            function(regs, pins) { // ADC (d),y
                switch(regs.TCU) {
                        // ADC (d),y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x72: new opcode_functions(opcode_matrix[0x72],
            function(regs, pins) { // ADC (d)
                switch(regs.TCU) {
                        // ADC (d) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x73: new opcode_functions(opcode_matrix[0x73],
            function(regs, pins) { // ADC (d,s),y
                switch(regs.TCU) {
                        // ADC (d,s),y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x74: new opcode_functions(opcode_matrix[0x74],
            function(regs, pins) { // STZ d,x
                switch(regs.TCU) {
                        // STZ d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x75: new opcode_functions(opcode_matrix[0x75],
            function(regs, pins) { // ADC d,x
                switch(regs.TCU) {
                        // ADC d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x76: new opcode_functions(opcode_matrix[0x76],
            function(regs, pins) { // ROR d,x
                switch(regs.TCU) {
                        // ROR d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x77: new opcode_functions(opcode_matrix[0x77],
            function(regs, pins) { // ADC [d],y
                switch(regs.TCU) {
                        // ADC [d],y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x78: new opcode_functions(opcode_matrix[0x78],
            function(regs, pins) { // SEI i
                switch(regs.TCU) {
                        // SEI i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 1;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x79: new opcode_functions(opcode_matrix[0x79],
            function(regs, pins) { // ADC a,y
                switch(regs.TCU) {
                        // ADC a,y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7A: new opcode_functions(opcode_matrix[0x7A],
            function(regs, pins) { // PLY s
                switch(regs.TCU) {
                        // PLY s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x7B: new opcode_functions(opcode_matrix[0x7B],
            function(regs, pins) { // TDC i
                switch(regs.TCU) {
                        // TDC i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.D);
                        regs.P.Z = +((regs.D) === 0);
                        regs.P.N = ((regs.D) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7C: new opcode_functions(opcode_matrix[0x7C],
            function(regs, pins) { // JMP (a,x)
                switch(regs.TCU) {
                        // JMP (a,x) E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        regs.TA = (regs.X + regs.TA) & 0xFFFF;
                        pins.PDV = 0;
                        break;
                    case 4:
                        pins.PDV = 1;
                        pins.Addr = regs.TA; pins.BA = regs.PBR;
                        break;
                    case 5:
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7D: new opcode_functions(opcode_matrix[0x7D],
            function(regs, pins) { // ADC a,x
                switch(regs.TCU) {
                        // ADC a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7E: new opcode_functions(opcode_matrix[0x7E],
            function(regs, pins) { // ROR a,x
                switch(regs.TCU) {
                        // ROR a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7F: new opcode_functions(opcode_matrix[0x7F],
            function(regs, pins) { // ADC al,x
                switch(regs.TCU) {
                        // ADC al,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x80: new opcode_functions(opcode_matrix[0x80],
            function(regs, pins) { // BRA r
                switch(regs.TCU) {
                        // BRA r E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = true;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x81: new opcode_functions(opcode_matrix[0x81],
            function(regs, pins) { // STA (d,x)
                switch(regs.TCU) {
                        // STA (d,x) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x82: new opcode_functions(opcode_matrix[0x82],
            function(regs, pins) { // BRL rl
                switch(regs.TCU) {
                        // BRL rl E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TA = mksigned16(regs.TA + (pins.D << 8));
                        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x83: new opcode_functions(opcode_matrix[0x83],
            function(regs, pins) { // STA d,s
                switch(regs.TCU) {
                        // STA d,s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x84: new opcode_functions(opcode_matrix[0x84],
            function(regs, pins) { // STY d
                switch(regs.TCU) {
                        // STY d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x85: new opcode_functions(opcode_matrix[0x85],
            function(regs, pins) { // STA d
                switch(regs.TCU) {
                        // STA d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x86: new opcode_functions(opcode_matrix[0x86],
            function(regs, pins) { // STX d
                switch(regs.TCU) {
                        // STX d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x87: new opcode_functions(opcode_matrix[0x87],
            function(regs, pins) { // STA [d]
                switch(regs.TCU) {
                        // STA [d] E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x88: new opcode_functions(opcode_matrix[0x88],
            function(regs, pins) { // DEY i
                switch(regs.TCU) {
                        // DEY i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x89: new opcode_functions(opcode_matrix[0x89],
            function(regs, pins) { // BIT #
                switch(regs.TCU) {
                        // BIT # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8A: new opcode_functions(opcode_matrix[0x8A],
            function(regs, pins) { // TXA i
                switch(regs.TCU) {
                        // TXA i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.X);
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8B: new opcode_functions(opcode_matrix[0x8B],
            function(regs, pins) { // PHB s
                switch(regs.TCU) {
                        // PHB s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.DBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8C: new opcode_functions(opcode_matrix[0x8C],
            function(regs, pins) { // STY a
                switch(regs.TCU) {
                        // STY a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.Y;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8D: new opcode_functions(opcode_matrix[0x8D],
            function(regs, pins) { // STA a
                switch(regs.TCU) {
                        // STA a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8E: new opcode_functions(opcode_matrix[0x8E],
            function(regs, pins) { // STX a
                switch(regs.TCU) {
                        // STX a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.X;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8F: new opcode_functions(opcode_matrix[0x8F],
            function(regs, pins) { // STA al
                switch(regs.TCU) {
                        // STA al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 5a
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x90: new opcode_functions(opcode_matrix[0x90],
            function(regs, pins) { // BCC r
                switch(regs.TCU) {
                        // BCC r E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x91: new opcode_functions(opcode_matrix[0x91],
            function(regs, pins) { // STA (d),y
                switch(regs.TCU) {
                        // STA (d),y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x92: new opcode_functions(opcode_matrix[0x92],
            function(regs, pins) { // STA (d)
                switch(regs.TCU) {
                        // STA (d) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 6: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x93: new opcode_functions(opcode_matrix[0x93],
            function(regs, pins) { // STA (d,s),y
                switch(regs.TCU) {
                        // STA (d,s),y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x94: new opcode_functions(opcode_matrix[0x94],
            function(regs, pins) { // STY d,x
                switch(regs.TCU) {
                        // STY d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x95: new opcode_functions(opcode_matrix[0x95],
            function(regs, pins) { // STA d,x
                switch(regs.TCU) {
                        // STA d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x96: new opcode_functions(opcode_matrix[0x96],
            function(regs, pins) { // STX d,y
                switch(regs.TCU) {
                        // STX d,y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x97: new opcode_functions(opcode_matrix[0x97],
            function(regs, pins) { // STA [d],y
                switch(regs.TCU) {
                        // STA [d],y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x98: new opcode_functions(opcode_matrix[0x98],
            function(regs, pins) { // TYA i
                switch(regs.TCU) {
                        // TYA i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.Y);
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x99: new opcode_functions(opcode_matrix[0x99],
            function(regs, pins) { // STA a,y
                switch(regs.TCU) {
                        // STA a,y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9A: new opcode_functions(opcode_matrix[0x9A],
            function(regs, pins) { // TXS i
                switch(regs.TCU) {
                        // TXS i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.X
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9B: new opcode_functions(opcode_matrix[0x9B],
            function(regs, pins) { // TXY i
                switch(regs.TCU) {
                        // TXY i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = (regs.X);
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9C: new opcode_functions(opcode_matrix[0x9C],
            function(regs, pins) { // STZ a
                switch(regs.TCU) {
                        // STZ a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9D: new opcode_functions(opcode_matrix[0x9D],
            function(regs, pins) { // STA a,x
                switch(regs.TCU) {
                        // STA a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9E: new opcode_functions(opcode_matrix[0x9E],
            function(regs, pins) { // STZ a,x
                switch(regs.TCU) {
                        // STZ a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9F: new opcode_functions(opcode_matrix[0x9F],
            function(regs, pins) { // STA al,x
                switch(regs.TCU) {
                        // STA al,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA0: new opcode_functions(opcode_matrix[0xA0],
            function(regs, pins) { // LDY #
                switch(regs.TCU) {
                        // LDY # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA1: new opcode_functions(opcode_matrix[0xA1],
            function(regs, pins) { // LDA (d,x)
                switch(regs.TCU) {
                        // LDA (d,x) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA2: new opcode_functions(opcode_matrix[0xA2],
            function(regs, pins) { // LDX #
                switch(regs.TCU) {
                        // LDX # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA3: new opcode_functions(opcode_matrix[0xA3],
            function(regs, pins) { // LDA d,s
                switch(regs.TCU) {
                        // LDA d,s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA4: new opcode_functions(opcode_matrix[0xA4],
            function(regs, pins) { // LDY d
                switch(regs.TCU) {
                        // LDY d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA5: new opcode_functions(opcode_matrix[0xA5],
            function(regs, pins) { // LDA d
                switch(regs.TCU) {
                        // LDA d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA6: new opcode_functions(opcode_matrix[0xA6],
            function(regs, pins) { // LDX d
                switch(regs.TCU) {
                        // LDX d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA7: new opcode_functions(opcode_matrix[0xA7],
            function(regs, pins) { // LDA [d]
                switch(regs.TCU) {
                        // LDA [d] E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA8: new opcode_functions(opcode_matrix[0xA8],
            function(regs, pins) { // TAY i
                switch(regs.TCU) {
                        // TAY i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = (regs.C);
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xA9: new opcode_functions(opcode_matrix[0xA9],
            function(regs, pins) { // LDA #
                switch(regs.TCU) {
                        // LDA # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAA: new opcode_functions(opcode_matrix[0xAA],
            function(regs, pins) { // TAX i
                switch(regs.TCU) {
                        // TAX i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = (regs.C);
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAB: new opcode_functions(opcode_matrix[0xAB],
            function(regs, pins) { // PLB s
                switch(regs.TCU) {
                        // PLB s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAC: new opcode_functions(opcode_matrix[0xAC],
            function(regs, pins) { // LDY a
                switch(regs.TCU) {
                        // LDY a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAD: new opcode_functions(opcode_matrix[0xAD],
            function(regs, pins) { // LDA a
                switch(regs.TCU) {
                        // LDA a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAE: new opcode_functions(opcode_matrix[0xAE],
            function(regs, pins) { // LDX a
                switch(regs.TCU) {
                        // LDX a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAF: new opcode_functions(opcode_matrix[0xAF],
            function(regs, pins) { // LDA al
                switch(regs.TCU) {
                        // LDA al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB0: new opcode_functions(opcode_matrix[0xB0],
            function(regs, pins) { // BCS r
                switch(regs.TCU) {
                        // BCS r E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB1: new opcode_functions(opcode_matrix[0xB1],
            function(regs, pins) { // LDA (d),y
                switch(regs.TCU) {
                        // LDA (d),y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB2: new opcode_functions(opcode_matrix[0xB2],
            function(regs, pins) { // LDA (d)
                switch(regs.TCU) {
                        // LDA (d) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB3: new opcode_functions(opcode_matrix[0xB3],
            function(regs, pins) { // LDA (d,s),y
                switch(regs.TCU) {
                        // LDA (d,s),y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB4: new opcode_functions(opcode_matrix[0xB4],
            function(regs, pins) { // LDY d,x
                switch(regs.TCU) {
                        // LDY d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB5: new opcode_functions(opcode_matrix[0xB5],
            function(regs, pins) { // LDA d,x
                switch(regs.TCU) {
                        // LDA d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB6: new opcode_functions(opcode_matrix[0xB6],
            function(regs, pins) { // LDX d,y
                switch(regs.TCU) {
                        // LDX d,y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB7: new opcode_functions(opcode_matrix[0xB7],
            function(regs, pins) { // LDA [d],y
                switch(regs.TCU) {
                        // LDA [d],y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB8: new opcode_functions(opcode_matrix[0xB8],
            function(regs, pins) { // CLV i
                switch(regs.TCU) {
                        // CLV i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.V = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB9: new opcode_functions(opcode_matrix[0xB9],
            function(regs, pins) { // LDA a,y
                switch(regs.TCU) {
                        // LDA a,y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBA: new opcode_functions(opcode_matrix[0xBA],
            function(regs, pins) { // TSX i
                switch(regs.TCU) {
                        // TSX i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = (regs.S);
                        regs.P.Z = +((regs.S) === 0);
                        regs.P.N = ((regs.S) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBB: new opcode_functions(opcode_matrix[0xBB],
            function(regs, pins) { // TYX i
                switch(regs.TCU) {
                        // TYX i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = (regs.Y);
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBC: new opcode_functions(opcode_matrix[0xBC],
            function(regs, pins) { // LDY a,x
                switch(regs.TCU) {
                        // LDY a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBD: new opcode_functions(opcode_matrix[0xBD],
            function(regs, pins) { // LDA a,x
                switch(regs.TCU) {
                        // LDA a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBE: new opcode_functions(opcode_matrix[0xBE],
            function(regs, pins) { // LDX a,y
                switch(regs.TCU) {
                        // LDX a,y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBF: new opcode_functions(opcode_matrix[0xBF],
            function(regs, pins) { // LDA al,x
                switch(regs.TCU) {
                        // LDA al,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC0: new opcode_functions(opcode_matrix[0xC0],
            function(regs, pins) { // CPY #
                switch(regs.TCU) {
                        // CPY # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.Y) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC1: new opcode_functions(opcode_matrix[0xC1],
            function(regs, pins) { // CMP (d,x)
                switch(regs.TCU) {
                        // CMP (d,x) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC2: new opcode_functions(opcode_matrix[0xC2],
            function(regs, pins) { // REP #
                switch(regs.TCU) {
                        // REP # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_native(regs.P.getbyte_native() & (~regs.TR & 0xFF));
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC3: new opcode_functions(opcode_matrix[0xC3],
            function(regs, pins) { // CMP d,s
                switch(regs.TCU) {
                        // CMP d,s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC4: new opcode_functions(opcode_matrix[0xC4],
            function(regs, pins) { // CPY d
                switch(regs.TCU) {
                        // CPY d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.Y) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC5: new opcode_functions(opcode_matrix[0xC5],
            function(regs, pins) { // CMP d
                switch(regs.TCU) {
                        // CMP d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC6: new opcode_functions(opcode_matrix[0xC6],
            function(regs, pins) { // DEC d
                switch(regs.TCU) {
                        // DEC d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC7: new opcode_functions(opcode_matrix[0xC7],
            function(regs, pins) { // CMP [d]
                switch(regs.TCU) {
                        // CMP [d] E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC8: new opcode_functions(opcode_matrix[0xC8],
            function(regs, pins) { // INY i
                switch(regs.TCU) {
                        // INY i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC9: new opcode_functions(opcode_matrix[0xC9],
            function(regs, pins) { // CMP #
                switch(regs.TCU) {
                        // CMP # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCA: new opcode_functions(opcode_matrix[0xCA],
            function(regs, pins) { // DEX i
                switch(regs.TCU) {
                        // DEX i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCB: new opcode_functions(opcode_matrix[0xCB],
            function(regs, pins) { // WAI i
                switch(regs.TCU) {
                        // WAI i E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.WAI = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCC: new opcode_functions(opcode_matrix[0xCC],
            function(regs, pins) { // CPY a
                switch(regs.TCU) {
                        // CPY a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.Y) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xCD: new opcode_functions(opcode_matrix[0xCD],
            function(regs, pins) { // CMP a
                switch(regs.TCU) {
                        // CMP a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCE: new opcode_functions(opcode_matrix[0xCE],
            function(regs, pins) { // DEC a
                switch(regs.TCU) {
                        // DEC a E=0 M=0 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCF: new opcode_functions(opcode_matrix[0xCF],
            function(regs, pins) { // CMP al
                switch(regs.TCU) {
                        // CMP al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD0: new opcode_functions(opcode_matrix[0xD0],
            function(regs, pins) { // BNE r
                switch(regs.TCU) {
                        // BNE r E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD1: new opcode_functions(opcode_matrix[0xD1],
            function(regs, pins) { // CMP (d),y
                switch(regs.TCU) {
                        // CMP (d),y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD2: new opcode_functions(opcode_matrix[0xD2],
            function(regs, pins) { // CMP (d)
                switch(regs.TCU) {
                        // CMP (d) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD3: new opcode_functions(opcode_matrix[0xD3],
            function(regs, pins) { // CMP (d,s),y
                switch(regs.TCU) {
                        // CMP (d,s),y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD4: new opcode_functions(opcode_matrix[0xD4],
            function(regs, pins) { // PEI s
                switch(regs.TCU) {
                        // PEI s E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.D = regs.TR
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xD5: new opcode_functions(opcode_matrix[0xD5],
            function(regs, pins) { // CMP d,x
                switch(regs.TCU) {
                        // CMP d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD6: new opcode_functions(opcode_matrix[0xD6],
            function(regs, pins) { // DEC d,x
                switch(regs.TCU) {
                        // DEC d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD7: new opcode_functions(opcode_matrix[0xD7],
            function(regs, pins) { // CMP [d],y
                switch(regs.TCU) {
                        // CMP [d],y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD8: new opcode_functions(opcode_matrix[0xD8],
            function(regs, pins) { // CLD i
                switch(regs.TCU) {
                        // CLD i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD9: new opcode_functions(opcode_matrix[0xD9],
            function(regs, pins) { // CMP a,y
                switch(regs.TCU) {
                        // CMP a,y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDA: new opcode_functions(opcode_matrix[0xDA],
            function(regs, pins) { // PHX s
                switch(regs.TCU) {
                        // PHX s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.X);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xDB: new opcode_functions(opcode_matrix[0xDB],
            function(regs, pins) { // STP i
                switch(regs.TCU) {
                        // STP i E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.STP = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDC: new opcode_functions(opcode_matrix[0xDC],
            function(regs, pins) { // JML (a)
                switch(regs.TCU) {
                        // JML (a) E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.PC = regs.TR + (pins.D << 8);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDD: new opcode_functions(opcode_matrix[0xDD],
            function(regs, pins) { // CMP a,x
                switch(regs.TCU) {
                        // CMP a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDE: new opcode_functions(opcode_matrix[0xDE],
            function(regs, pins) { // DEC a,x
                switch(regs.TCU) {
                        // DEC a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDF: new opcode_functions(opcode_matrix[0xDF],
            function(regs, pins) { // CMP al,x
                switch(regs.TCU) {
                        // CMP al,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE0: new opcode_functions(opcode_matrix[0xE0],
            function(regs, pins) { // CPX #
                switch(regs.TCU) {
                        // CPX # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.X) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE1: new opcode_functions(opcode_matrix[0xE1],
            function(regs, pins) { // SBC (d,x)
                switch(regs.TCU) {
                        // SBC (d,x) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE2: new opcode_functions(opcode_matrix[0xE2],
            function(regs, pins) { // SEP #
                switch(regs.TCU) {
                        // SEP # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_native(regs.P.getbyte_native() | regs.TR);
                        if (regs.P.X) { regs.X &= 0xFF, regs.Y &= 0xFF; }
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE3: new opcode_functions(opcode_matrix[0xE3],
            function(regs, pins) { // SBC d,s
                switch(regs.TCU) {
                        // SBC d,s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE4: new opcode_functions(opcode_matrix[0xE4],
            function(regs, pins) { // CPX d
                switch(regs.TCU) {
                        // CPX d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.X) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE5: new opcode_functions(opcode_matrix[0xE5],
            function(regs, pins) { // SBC d
                switch(regs.TCU) {
                        // SBC d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE6: new opcode_functions(opcode_matrix[0xE6],
            function(regs, pins) { // INC d
                switch(regs.TCU) {
                        // INC d E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE7: new opcode_functions(opcode_matrix[0xE7],
            function(regs, pins) { // SBC [d]
                switch(regs.TCU) {
                        // SBC [d] E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE8: new opcode_functions(opcode_matrix[0xE8],
            function(regs, pins) { // INX i
                switch(regs.TCU) {
                        // INX i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE9: new opcode_functions(opcode_matrix[0xE9],
            function(regs, pins) { // SBC #
                switch(regs.TCU) {
                        // SBC # E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEA: new opcode_functions(opcode_matrix[0xEA],
            function(regs, pins) { // NOP i
                switch(regs.TCU) {
                        // NOP i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEB: new opcode_functions(opcode_matrix[0xEB],
            function(regs, pins) { // XBA i
                switch(regs.TCU) {
                        // XBA i E=0 M=0 X=0
                    case 1:
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2:
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >>> 8) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEC: new opcode_functions(opcode_matrix[0xEC],
            function(regs, pins) { // CPX a
                switch(regs.TCU) {
                        // CPX a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.X) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xED: new opcode_functions(opcode_matrix[0xED],
            function(regs, pins) { // SBC a
                switch(regs.TCU) {
                        // SBC a E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEE: new opcode_functions(opcode_matrix[0xEE],
            function(regs, pins) { // INC a
                switch(regs.TCU) {
                        // INC a E=0 M=0 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEF: new opcode_functions(opcode_matrix[0xEF],
            function(regs, pins) { // SBC al
                switch(regs.TCU) {
                        // SBC al E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF0: new opcode_functions(opcode_matrix[0xF0],
            function(regs, pins) { // BEQ r
                switch(regs.TCU) {
                        // BEQ r E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF1: new opcode_functions(opcode_matrix[0xF1],
            function(regs, pins) { // SBC (d),y
                switch(regs.TCU) {
                        // SBC (d),y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF2: new opcode_functions(opcode_matrix[0xF2],
            function(regs, pins) { // SBC (d)
                switch(regs.TCU) {
                        // SBC (d) E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF3: new opcode_functions(opcode_matrix[0xF3],
            function(regs, pins) { // SBC (d,s),y
                switch(regs.TCU) {
                        // SBC (d,s),y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF4: new opcode_functions(opcode_matrix[0xF4],
            function(regs, pins) { // PEA s
                switch(regs.TCU) {
                        // PEA s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xF5: new opcode_functions(opcode_matrix[0xF5],
            function(regs, pins) { // SBC d,x
                switch(regs.TCU) {
                        // SBC d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF6: new opcode_functions(opcode_matrix[0xF6],
            function(regs, pins) { // INC d,x
                switch(regs.TCU) {
                        // INC d,x E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF7: new opcode_functions(opcode_matrix[0xF7],
            function(regs, pins) { // SBC [d],y
                switch(regs.TCU) {
                        // SBC [d],y E=0 M=0 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF8: new opcode_functions(opcode_matrix[0xF8],
            function(regs, pins) { // SED i
                switch(regs.TCU) {
                        // SED i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF9: new opcode_functions(opcode_matrix[0xF9],
            function(regs, pins) { // SBC a,y
                switch(regs.TCU) {
                        // SBC a,y E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFA: new opcode_functions(opcode_matrix[0xFA],
            function(regs, pins) { // PLX s
                switch(regs.TCU) {
                        // PLX s E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xFB: new opcode_functions(opcode_matrix[0xFB],
            function(regs, pins) { // XCE i
                switch(regs.TCU) {
                        // XCE i E=0 M=0 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        let TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
                        if (regs.E) {
                            regs.P.X = regs.P.M = 1;
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                            regs.S = (regs.S & 0xFF) | 0x100;
                        }
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xFC: new opcode_functions(opcode_matrix[0xFC],
            function(regs, pins) { // JSR (a,x)
                switch(regs.TCU) {
                        // JSR (a,x) E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.RW = 1;
                        regs.TA = pins.D;
                        pins.D = ((regs.PC) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 4
                        pins.D = (regs.PC) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 6: // 7
                        pins.PDV = 1;
                        pins.Addr = regs.TA;
                        break;
                    case 7: // 8
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.PC = pins.D;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xFD: new opcode_functions(opcode_matrix[0xFD],
            function(regs, pins) { // SBC a,x
                switch(regs.TCU) {
                        // SBC a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFE: new opcode_functions(opcode_matrix[0xFE],
            function(regs, pins) { // INC a,x
                switch(regs.TCU) {
                        // INC a,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFF: new opcode_functions(opcode_matrix[0xFF],
            function(regs, pins) { // SBC al,x
                switch(regs.TCU) {
                        // SBC al,x E=0 M=0 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x100: new opcode_functions(opcode_matrix[0x100],
            function(regs, pins) { // S_RESET s
                switch(regs.TCU) {
                        // S_RESET s E=0 M=0 X=0
                    case 1: // 3
                        pins.RW = 0; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFFC); pins.BA = (0);
                        regs.DBR = 0;
                        regs.D = 0;
                        regs.PBR = 0;
                        regs.X &= 0xFF;
                        regs.Y &= 0xFF;
                        regs.S = (regs.S & 0xFF) | 0x100;
                        regs.E = 1;
                        regs.P.M = regs.P.X = regs.P.I = regs.P.C = 1;
                        regs.P.D = 0;
                        regs.STP = regs.WAI = false;
                        break;
                    case 6: // 8
                        regs.PC = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        pins.PDV = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x101: new opcode_functions(opcode_matrix[0x101],
            function(regs, pins) { // S_ABORT s
                switch(regs.TCU) {
                        // S_ABORT s E=0 M=0 X=0
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFE8); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFE9); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x102: new opcode_functions(opcode_matrix[0x102],
            function(regs, pins) { // S_IRQ s
                switch(regs.TCU) {
                        // S_IRQ s E=0 M=0 X=0
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFEE); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFEF); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x103: new opcode_functions(opcode_matrix[0x103],
            function(regs, pins) { // S_NMI s
                switch(regs.TCU) {
                        // S_NMI s E=0 M=0 X=0
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFEA); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFEB); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false)
},
    // E0 M0 X1
    4: {
        0x00: new opcode_functions(opcode_matrix[0x00],
            function(regs, pins) { // BRK s
                switch(regs.TCU) {
                        // BRK s E=0 M=0 X=1
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 3: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 6: // 7
                        pins.Addr = (0xFFE6); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 7: // 8
                        pins.Addr = (0xFFE7); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x01: new opcode_functions(opcode_matrix[0x01],
            function(regs, pins) { // ORA (d,x)
                switch(regs.TCU) {
                        // ORA (d,x) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x02: new opcode_functions(opcode_matrix[0x02],
            function(regs, pins) { // COP s
                switch(regs.TCU) {
                        // COP s E=0 M=0 X=1
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 3: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 6: // 7
                        pins.Addr = (0xFFE4); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 7: // 8
                        pins.Addr = (0xFFE5); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x03: new opcode_functions(opcode_matrix[0x03],
            function(regs, pins) { // ORA d,s
                switch(regs.TCU) {
                        // ORA d,s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x04: new opcode_functions(opcode_matrix[0x04],
            function(regs, pins) { // TSB d
                switch(regs.TCU) {
                        // TSB d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFFFF;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x05: new opcode_functions(opcode_matrix[0x05],
            function(regs, pins) { // ORA d
                switch(regs.TCU) {
                        // ORA d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x06: new opcode_functions(opcode_matrix[0x06],
            function(regs, pins) { // ASL d
                switch(regs.TCU) {
                        // ASL d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x07: new opcode_functions(opcode_matrix[0x07],
            function(regs, pins) { // ORA [d]
                switch(regs.TCU) {
                        // ORA [d] E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x08: new opcode_functions(opcode_matrix[0x08],
            function(regs, pins) { // PHP s
                switch(regs.TCU) {
                        // PHP s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.P.getbyte_native();
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x09: new opcode_functions(opcode_matrix[0x09],
            function(regs, pins) { // ORA #
                switch(regs.TCU) {
                        // ORA # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0A: new opcode_functions(opcode_matrix[0x0A],
            function(regs, pins) { // ASL A
                switch(regs.TCU) {
                        // ASL A E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0B: new opcode_functions(opcode_matrix[0x0B],
            function(regs, pins) { // PHD s
                switch(regs.TCU) {
                        // PHD s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.D);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x0C: new opcode_functions(opcode_matrix[0x0C],
            function(regs, pins) { // TSB a
                switch(regs.TCU) {
                        // TSB a E=0 M=0 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFFFF;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0D: new opcode_functions(opcode_matrix[0x0D],
            function(regs, pins) { // ORA a
                switch(regs.TCU) {
                        // ORA a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0E: new opcode_functions(opcode_matrix[0x0E],
            function(regs, pins) { // ASL a
                switch(regs.TCU) {
                        // ASL a E=0 M=0 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0F: new opcode_functions(opcode_matrix[0x0F],
            function(regs, pins) { // ORA al
                switch(regs.TCU) {
                        // ORA al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x10: new opcode_functions(opcode_matrix[0x10],
            function(regs, pins) { // BPL r
                switch(regs.TCU) {
                        // BPL r E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x11: new opcode_functions(opcode_matrix[0x11],
            function(regs, pins) { // ORA (d),y
                switch(regs.TCU) {
                        // ORA (d),y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x12: new opcode_functions(opcode_matrix[0x12],
            function(regs, pins) { // ORA (d)
                switch(regs.TCU) {
                        // ORA (d) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x13: new opcode_functions(opcode_matrix[0x13],
            function(regs, pins) { // ORA (d,s),y
                switch(regs.TCU) {
                        // ORA (d,s),y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x14: new opcode_functions(opcode_matrix[0x14],
            function(regs, pins) { // TRB d
                switch(regs.TCU) {
                        // TRB d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFFFF;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x15: new opcode_functions(opcode_matrix[0x15],
            function(regs, pins) { // ORA d,x
                switch(regs.TCU) {
                        // ORA d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x16: new opcode_functions(opcode_matrix[0x16],
            function(regs, pins) { // ASL d,x
                switch(regs.TCU) {
                        // ASL d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x17: new opcode_functions(opcode_matrix[0x17],
            function(regs, pins) { // ORA [d],y
                switch(regs.TCU) {
                        // ORA [d],y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x18: new opcode_functions(opcode_matrix[0x18],
            function(regs, pins) { // CLC i
                switch(regs.TCU) {
                        // CLC i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x19: new opcode_functions(opcode_matrix[0x19],
            function(regs, pins) { // ORA a,y
                switch(regs.TCU) {
                        // ORA a,y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1A: new opcode_functions(opcode_matrix[0x1A],
            function(regs, pins) { // INC A
                switch(regs.TCU) {
                        // INC A E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1B: new opcode_functions(opcode_matrix[0x1B],
            function(regs, pins) { // TCS i
                switch(regs.TCU) {
                        // TCS i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.C;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x1C: new opcode_functions(opcode_matrix[0x1C],
            function(regs, pins) { // TRB a
                switch(regs.TCU) {
                        // TRB a E=0 M=0 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFFFF;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1D: new opcode_functions(opcode_matrix[0x1D],
            function(regs, pins) { // ORA a,x
                switch(regs.TCU) {
                        // ORA a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1E: new opcode_functions(opcode_matrix[0x1E],
            function(regs, pins) { // ASL a,x
                switch(regs.TCU) {
                        // ASL a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = (regs.TR & 0x7FFF) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1F: new opcode_functions(opcode_matrix[0x1F],
            function(regs, pins) { // ORA al,x
                switch(regs.TCU) {
                        // ORA al,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C |= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x20: new opcode_functions(opcode_matrix[0x20],
            function(regs, pins) { // JSR a
                switch(regs.TCU) {
                        // JSR a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.PDV = 0;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 6
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x21: new opcode_functions(opcode_matrix[0x21],
            function(regs, pins) { // AND (d,x)
                switch(regs.TCU) {
                        // AND (d,x) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x22: new opcode_functions(opcode_matrix[0x22],
            function(regs, pins) { // JSL al
                switch(regs.TCU) {
                        // JSL al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        regs.TA += pins.D << 8;
                        pins.D = (regs.PBR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 1;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 6: // 7
                        regs.PBR = pins.D;
                        pins.RW = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF;
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 7: // 8
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x23: new opcode_functions(opcode_matrix[0x23],
            function(regs, pins) { // AND d,s
                switch(regs.TCU) {
                        // AND d,s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x24: new opcode_functions(opcode_matrix[0x24],
            function(regs, pins) { // BIT d
                switch(regs.TCU) {
                        // BIT d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        regs.P.V = (regs.TR & 0x4000) >>> 14;
                        regs.P.N = (regs.TR & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x25: new opcode_functions(opcode_matrix[0x25],
            function(regs, pins) { // AND d
                switch(regs.TCU) {
                        // AND d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x26: new opcode_functions(opcode_matrix[0x26],
            function(regs, pins) { // ROL d
                switch(regs.TCU) {
                        // ROL d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x27: new opcode_functions(opcode_matrix[0x27],
            function(regs, pins) { // AND [d]
                switch(regs.TCU) {
                        // AND [d] E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x28: new opcode_functions(opcode_matrix[0x28],
            function(regs, pins) { // PLP s
                switch(regs.TCU) {
                        // PLP s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.setbyte_native(regs.TR);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x29: new opcode_functions(opcode_matrix[0x29],
            function(regs, pins) { // AND #
                switch(regs.TCU) {
                        // AND # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2A: new opcode_functions(opcode_matrix[0x2A],
            function(regs, pins) { // ROL A
                switch(regs.TCU) {
                        // ROL A E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2B: new opcode_functions(opcode_matrix[0x2B],
            function(regs, pins) { // PLD s
                switch(regs.TCU) {
                        // PLD s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.D = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x2C: new opcode_functions(opcode_matrix[0x2C],
            function(regs, pins) { // BIT a
                switch(regs.TCU) {
                        // BIT a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        regs.P.V = (regs.TR & 0x4000) >>> 14;
                        regs.P.N = (regs.TR & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2D: new opcode_functions(opcode_matrix[0x2D],
            function(regs, pins) { // AND a
                switch(regs.TCU) {
                        // AND a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2E: new opcode_functions(opcode_matrix[0x2E],
            function(regs, pins) { // ROL a
                switch(regs.TCU) {
                        // ROL a E=0 M=0 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2F: new opcode_functions(opcode_matrix[0x2F],
            function(regs, pins) { // AND al
                switch(regs.TCU) {
                        // AND al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x30: new opcode_functions(opcode_matrix[0x30],
            function(regs, pins) { // BMI r
                switch(regs.TCU) {
                        // BMI r E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x31: new opcode_functions(opcode_matrix[0x31],
            function(regs, pins) { // AND (d),y
                switch(regs.TCU) {
                        // AND (d),y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x32: new opcode_functions(opcode_matrix[0x32],
            function(regs, pins) { // AND (d)
                switch(regs.TCU) {
                        // AND (d) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x33: new opcode_functions(opcode_matrix[0x33],
            function(regs, pins) { // AND (d,s),y
                switch(regs.TCU) {
                        // AND (d,s),y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x34: new opcode_functions(opcode_matrix[0x34],
            function(regs, pins) { // BIT d,x
                switch(regs.TCU) {
                        // BIT d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        regs.P.V = (regs.TR & 0x4000) >>> 14;
                        regs.P.N = (regs.TR & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x35: new opcode_functions(opcode_matrix[0x35],
            function(regs, pins) { // AND d,x
                switch(regs.TCU) {
                        // AND d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x36: new opcode_functions(opcode_matrix[0x36],
            function(regs, pins) { // ROL d,x
                switch(regs.TCU) {
                        // ROL d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x37: new opcode_functions(opcode_matrix[0x37],
            function(regs, pins) { // AND [d],y
                switch(regs.TCU) {
                        // AND [d],y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x38: new opcode_functions(opcode_matrix[0x38],
            function(regs, pins) { // SEC i
                switch(regs.TCU) {
                        // SEC i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x39: new opcode_functions(opcode_matrix[0x39],
            function(regs, pins) { // AND a,y
                switch(regs.TCU) {
                        // AND a,y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3A: new opcode_functions(opcode_matrix[0x3A],
            function(regs, pins) { // DEC A
                switch(regs.TCU) {
                        // DEC A E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3B: new opcode_functions(opcode_matrix[0x3B],
            function(regs, pins) { // TSC i
                switch(regs.TCU) {
                        // TSC i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.S);
                        regs.P.Z = +((regs.S) === 0);
                        regs.P.N = ((regs.S) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x3C: new opcode_functions(opcode_matrix[0x3C],
            function(regs, pins) { // BIT a,x
                switch(regs.TCU) {
                        // BIT a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        regs.P.V = (regs.TR & 0x4000) >>> 14;
                        regs.P.N = (regs.TR & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3D: new opcode_functions(opcode_matrix[0x3D],
            function(regs, pins) { // AND a,x
                switch(regs.TCU) {
                        // AND a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3E: new opcode_functions(opcode_matrix[0x3E],
            function(regs, pins) { // ROL a,x
                switch(regs.TCU) {
                        // ROL a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x8000) >>> 15;
                        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3F: new opcode_functions(opcode_matrix[0x3F],
            function(regs, pins) { // AND al,x
                switch(regs.TCU) {
                        // AND al,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C &= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x40: new opcode_functions(opcode_matrix[0x40],
            function(regs, pins) { // RTI s
                switch(regs.TCU) {
                        // RTI s E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        pins.PDV = 1;
                        break;
                    case 4: // 5
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.P.setbyte_native(pins.D);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        if (regs.P.E) regs.S = (regs.S & 0xFF) | 0x100;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.TA = pins.D;
                        break;
                    case 6: // 7
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.TA += pins.D << 8;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TA;
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x41: new opcode_functions(opcode_matrix[0x41],
            function(regs, pins) { // EOR (d,x)
                switch(regs.TCU) {
                        // EOR (d,x) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x42: new opcode_functions(opcode_matrix[0x42],
            function(regs, pins) { // WDM i
                switch(regs.TCU) {
                        // WDM i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x43: new opcode_functions(opcode_matrix[0x43],
            function(regs, pins) { // EOR d,s
                switch(regs.TCU) {
                        // EOR d,s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x44: new opcode_functions(opcode_matrix[0x44],
            function(regs, pins) { // MVP xyc
                switch(regs.TCU) {
                        // MVP xyc E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D
                        pins.Addr = (regs.X); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X - 1) & 0xFF;
                        regs.Y = (regs.Y - 1) & 0xFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x45: new opcode_functions(opcode_matrix[0x45],
            function(regs, pins) { // EOR d
                switch(regs.TCU) {
                        // EOR d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x46: new opcode_functions(opcode_matrix[0x46],
            function(regs, pins) { // LSR d
                switch(regs.TCU) {
                        // LSR d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x47: new opcode_functions(opcode_matrix[0x47],
            function(regs, pins) { // EOR [d]
                switch(regs.TCU) {
                        // EOR [d] E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x48: new opcode_functions(opcode_matrix[0x48],
            function(regs, pins) { // PHA s
                switch(regs.TCU) {
                        // PHA s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.C);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x49: new opcode_functions(opcode_matrix[0x49],
            function(regs, pins) { // EOR #
                switch(regs.TCU) {
                        // EOR # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4A: new opcode_functions(opcode_matrix[0x4A],
            function(regs, pins) { // LSR A
                switch(regs.TCU) {
                        // LSR A E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4B: new opcode_functions(opcode_matrix[0x4B],
            function(regs, pins) { // PHK s
                switch(regs.TCU) {
                        // PHK s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.PBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4C: new opcode_functions(opcode_matrix[0x4C],
            function(regs, pins) { // JMP a
                switch(regs.TCU) {
                        // JMP a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4D: new opcode_functions(opcode_matrix[0x4D],
            function(regs, pins) { // EOR a
                switch(regs.TCU) {
                        // EOR a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4E: new opcode_functions(opcode_matrix[0x4E],
            function(regs, pins) { // LSR a
                switch(regs.TCU) {
                        // LSR a E=0 M=0 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4F: new opcode_functions(opcode_matrix[0x4F],
            function(regs, pins) { // EOR al
                switch(regs.TCU) {
                        // EOR al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x50: new opcode_functions(opcode_matrix[0x50],
            function(regs, pins) { // BVC r
                switch(regs.TCU) {
                        // BVC r E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x51: new opcode_functions(opcode_matrix[0x51],
            function(regs, pins) { // EOR (d),y
                switch(regs.TCU) {
                        // EOR (d),y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x52: new opcode_functions(opcode_matrix[0x52],
            function(regs, pins) { // EOR (d)
                switch(regs.TCU) {
                        // EOR (d) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x53: new opcode_functions(opcode_matrix[0x53],
            function(regs, pins) { // EOR (d,s),y
                switch(regs.TCU) {
                        // EOR (d,s),y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x54: new opcode_functions(opcode_matrix[0x54],
            function(regs, pins) { // MVN xyc
                switch(regs.TCU) {
                        // MVN xyc E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D;
                        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X + 1) & 0xFF;
                        regs.Y = (regs.Y + 1) & 0xFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x55: new opcode_functions(opcode_matrix[0x55],
            function(regs, pins) { // EOR d,x
                switch(regs.TCU) {
                        // EOR d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x56: new opcode_functions(opcode_matrix[0x56],
            function(regs, pins) { // LSR d,x
                switch(regs.TCU) {
                        // LSR d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x57: new opcode_functions(opcode_matrix[0x57],
            function(regs, pins) { // EOR [d],y
                switch(regs.TCU) {
                        // EOR [d],y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x58: new opcode_functions(opcode_matrix[0x58],
            function(regs, pins) { // CLI i
                switch(regs.TCU) {
                        // CLI i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 0;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x59: new opcode_functions(opcode_matrix[0x59],
            function(regs, pins) { // EOR a,y
                switch(regs.TCU) {
                        // EOR a,y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5A: new opcode_functions(opcode_matrix[0x5A],
            function(regs, pins) { // PHY s
                switch(regs.TCU) {
                        // PHY s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.Y) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x5B: new opcode_functions(opcode_matrix[0x5B],
            function(regs, pins) { // TCD i
                switch(regs.TCU) {
                        // TCD i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.D = (regs.C);
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5C: new opcode_functions(opcode_matrix[0x5C],
            function(regs, pins) { // JMP al
                switch(regs.TCU) {
                        // JMP al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = regs.TA + (pins.D << 8);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5D: new opcode_functions(opcode_matrix[0x5D],
            function(regs, pins) { // EOR a,x
                switch(regs.TCU) {
                        // EOR a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5E: new opcode_functions(opcode_matrix[0x5E],
            function(regs, pins) { // LSR a,x
                switch(regs.TCU) {
                        // LSR a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5F: new opcode_functions(opcode_matrix[0x5F],
            function(regs, pins) { // EOR al,x
                switch(regs.TCU) {
                        // EOR al,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C ^= regs.TR;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x60: new opcode_functions(opcode_matrix[0x60],
            function(regs, pins) { // RTS s
                switch(regs.TCU) {
                        // RTS s E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x61: new opcode_functions(opcode_matrix[0x61],
            function(regs, pins) { // ADC (d,x)
                switch(regs.TCU) {
                        // ADC (d,x) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x62: new opcode_functions(opcode_matrix[0x62],
            function(regs, pins) { // PER s
                switch(regs.TCU) {
                        // PER s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x63: new opcode_functions(opcode_matrix[0x63],
            function(regs, pins) { // ADC d,s
                switch(regs.TCU) {
                        // ADC d,s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x64: new opcode_functions(opcode_matrix[0x64],
            function(regs, pins) { // STZ d
                switch(regs.TCU) {
                        // STZ d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x65: new opcode_functions(opcode_matrix[0x65],
            function(regs, pins) { // ADC d
                switch(regs.TCU) {
                        // ADC d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x66: new opcode_functions(opcode_matrix[0x66],
            function(regs, pins) { // ROR d
                switch(regs.TCU) {
                        // ROR d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x67: new opcode_functions(opcode_matrix[0x67],
            function(regs, pins) { // ADC [d]
                switch(regs.TCU) {
                        // ADC [d] E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x68: new opcode_functions(opcode_matrix[0x68],
            function(regs, pins) { // PLA s
                switch(regs.TCU) {
                        // PLA s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.C = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x69: new opcode_functions(opcode_matrix[0x69],
            function(regs, pins) { // ADC #
                switch(regs.TCU) {
                        // ADC # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6A: new opcode_functions(opcode_matrix[0x6A],
            function(regs, pins) { // ROR A
                switch(regs.TCU) {
                        // ROR A E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        regs.C = regs.TR & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6B: new opcode_functions(opcode_matrix[0x6B],
            function(regs, pins) { // RTL s
                switch(regs.TCU) {
                        // RTL s E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x6C: new opcode_functions(opcode_matrix[0x6C],
            function(regs, pins) { // JMP (a)
                switch(regs.TCU) {
                        // JMP (a) E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x6D: new opcode_functions(opcode_matrix[0x6D],
            function(regs, pins) { // ADC a
                switch(regs.TCU) {
                        // ADC a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6E: new opcode_functions(opcode_matrix[0x6E],
            function(regs, pins) { // ROR a
                switch(regs.TCU) {
                        // ROR a E=0 M=0 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6F: new opcode_functions(opcode_matrix[0x6F],
            function(regs, pins) { // ADC al
                switch(regs.TCU) {
                        // ADC al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x70: new opcode_functions(opcode_matrix[0x70],
            function(regs, pins) { // BVS r
                switch(regs.TCU) {
                        // BVS r E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x71: new opcode_functions(opcode_matrix[0x71],
            function(regs, pins) { // ADC (d),y
                switch(regs.TCU) {
                        // ADC (d),y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x72: new opcode_functions(opcode_matrix[0x72],
            function(regs, pins) { // ADC (d)
                switch(regs.TCU) {
                        // ADC (d) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x73: new opcode_functions(opcode_matrix[0x73],
            function(regs, pins) { // ADC (d,s),y
                switch(regs.TCU) {
                        // ADC (d,s),y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x74: new opcode_functions(opcode_matrix[0x74],
            function(regs, pins) { // STZ d,x
                switch(regs.TCU) {
                        // STZ d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x75: new opcode_functions(opcode_matrix[0x75],
            function(regs, pins) { // ADC d,x
                switch(regs.TCU) {
                        // ADC d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x76: new opcode_functions(opcode_matrix[0x76],
            function(regs, pins) { // ROR d,x
                switch(regs.TCU) {
                        // ROR d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x77: new opcode_functions(opcode_matrix[0x77],
            function(regs, pins) { // ADC [d],y
                switch(regs.TCU) {
                        // ADC [d],y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x78: new opcode_functions(opcode_matrix[0x78],
            function(regs, pins) { // SEI i
                switch(regs.TCU) {
                        // SEI i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 1;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x79: new opcode_functions(opcode_matrix[0x79],
            function(regs, pins) { // ADC a,y
                switch(regs.TCU) {
                        // ADC a,y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7A: new opcode_functions(opcode_matrix[0x7A],
            function(regs, pins) { // PLY s
                switch(regs.TCU) {
                        // PLY s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x7B: new opcode_functions(opcode_matrix[0x7B],
            function(regs, pins) { // TDC i
                switch(regs.TCU) {
                        // TDC i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.D);
                        regs.P.Z = +((regs.D) === 0);
                        regs.P.N = ((regs.D) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7C: new opcode_functions(opcode_matrix[0x7C],
            function(regs, pins) { // JMP (a,x)
                switch(regs.TCU) {
                        // JMP (a,x) E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        regs.TA = (regs.X + regs.TA) & 0xFFFF;
                        pins.PDV = 0;
                        break;
                    case 4:
                        pins.PDV = 1;
                        pins.Addr = regs.TA; pins.BA = regs.PBR;
                        break;
                    case 5:
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7D: new opcode_functions(opcode_matrix[0x7D],
            function(regs, pins) { // ADC a,x
                switch(regs.TCU) {
                        // ADC a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7E: new opcode_functions(opcode_matrix[0x7E],
            function(regs, pins) { // ROR a,x
                switch(regs.TCU) {
                        // ROR a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let carry = regs.P.C << 15;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFFFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7F: new opcode_functions(opcode_matrix[0x7F],
            function(regs, pins) { // ADC al,x
                switch(regs.TCU) {
                        // ADC al,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let result;
                        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
                            if (result > 0x0009) result += 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result > 0x009F) result += 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result > 0x09FF) result += 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result > 0x9FFF) result += 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +(((result & 0xFFFF)) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x80: new opcode_functions(opcode_matrix[0x80],
            function(regs, pins) { // BRA r
                switch(regs.TCU) {
                        // BRA r E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = true;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x81: new opcode_functions(opcode_matrix[0x81],
            function(regs, pins) { // STA (d,x)
                switch(regs.TCU) {
                        // STA (d,x) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x82: new opcode_functions(opcode_matrix[0x82],
            function(regs, pins) { // BRL rl
                switch(regs.TCU) {
                        // BRL rl E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TA = mksigned16(regs.TA + (pins.D << 8));
                        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x83: new opcode_functions(opcode_matrix[0x83],
            function(regs, pins) { // STA d,s
                switch(regs.TCU) {
                        // STA d,s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x84: new opcode_functions(opcode_matrix[0x84],
            function(regs, pins) { // STY d
                switch(regs.TCU) {
                        // STY d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x85: new opcode_functions(opcode_matrix[0x85],
            function(regs, pins) { // STA d
                switch(regs.TCU) {
                        // STA d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x86: new opcode_functions(opcode_matrix[0x86],
            function(regs, pins) { // STX d
                switch(regs.TCU) {
                        // STX d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x87: new opcode_functions(opcode_matrix[0x87],
            function(regs, pins) { // STA [d]
                switch(regs.TCU) {
                        // STA [d] E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x88: new opcode_functions(opcode_matrix[0x88],
            function(regs, pins) { // DEY i
                switch(regs.TCU) {
                        // DEY i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) - 1) & 0xFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x89: new opcode_functions(opcode_matrix[0x89],
            function(regs, pins) { // BIT #
                switch(regs.TCU) {
                        // BIT # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) === 0);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8A: new opcode_functions(opcode_matrix[0x8A],
            function(regs, pins) { // TXA i
                switch(regs.TCU) {
                        // TXA i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.X);
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8B: new opcode_functions(opcode_matrix[0x8B],
            function(regs, pins) { // PHB s
                switch(regs.TCU) {
                        // PHB s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.DBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8C: new opcode_functions(opcode_matrix[0x8C],
            function(regs, pins) { // STY a
                switch(regs.TCU) {
                        // STY a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.Y & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8D: new opcode_functions(opcode_matrix[0x8D],
            function(regs, pins) { // STA a
                switch(regs.TCU) {
                        // STA a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8E: new opcode_functions(opcode_matrix[0x8E],
            function(regs, pins) { // STX a
                switch(regs.TCU) {
                        // STX a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.X & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8F: new opcode_functions(opcode_matrix[0x8F],
            function(regs, pins) { // STA al
                switch(regs.TCU) {
                        // STA al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 5a
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x90: new opcode_functions(opcode_matrix[0x90],
            function(regs, pins) { // BCC r
                switch(regs.TCU) {
                        // BCC r E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x91: new opcode_functions(opcode_matrix[0x91],
            function(regs, pins) { // STA (d),y
                switch(regs.TCU) {
                        // STA (d),y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x92: new opcode_functions(opcode_matrix[0x92],
            function(regs, pins) { // STA (d)
                switch(regs.TCU) {
                        // STA (d) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 6: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x93: new opcode_functions(opcode_matrix[0x93],
            function(regs, pins) { // STA (d,s),y
                switch(regs.TCU) {
                        // STA (d,s),y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x94: new opcode_functions(opcode_matrix[0x94],
            function(regs, pins) { // STY d,x
                switch(regs.TCU) {
                        // STY d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x95: new opcode_functions(opcode_matrix[0x95],
            function(regs, pins) { // STA d,x
                switch(regs.TCU) {
                        // STA d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x96: new opcode_functions(opcode_matrix[0x96],
            function(regs, pins) { // STX d,y
                switch(regs.TCU) {
                        // STX d,y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x97: new opcode_functions(opcode_matrix[0x97],
            function(regs, pins) { // STA [d],y
                switch(regs.TCU) {
                        // STA [d],y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 7: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x98: new opcode_functions(opcode_matrix[0x98],
            function(regs, pins) { // TYA i
                switch(regs.TCU) {
                        // TYA i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.Y);
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x99: new opcode_functions(opcode_matrix[0x99],
            function(regs, pins) { // STA a,y
                switch(regs.TCU) {
                        // STA a,y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9A: new opcode_functions(opcode_matrix[0x9A],
            function(regs, pins) { // TXS i
                switch(regs.TCU) {
                        // TXS i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.X
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9B: new opcode_functions(opcode_matrix[0x9B],
            function(regs, pins) { // TXY i
                switch(regs.TCU) {
                        // TXY i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.X) & 0xFF);
                        regs.P.Z = +((regs.X & 0xFF) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9C: new opcode_functions(opcode_matrix[0x9C],
            function(regs, pins) { // STZ a
                switch(regs.TCU) {
                        // STZ a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9D: new opcode_functions(opcode_matrix[0x9D],
            function(regs, pins) { // STA a,x
                switch(regs.TCU) {
                        // STA a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9E: new opcode_functions(opcode_matrix[0x9E],
            function(regs, pins) { // STZ a,x
                switch(regs.TCU) {
                        // STZ a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9F: new opcode_functions(opcode_matrix[0x9F],
            function(regs, pins) { // STA al,x
                switch(regs.TCU) {
                        // STA al,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA0: new opcode_functions(opcode_matrix[0xA0],
            function(regs, pins) { // LDY #
                switch(regs.TCU) {
                        // LDY # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA1: new opcode_functions(opcode_matrix[0xA1],
            function(regs, pins) { // LDA (d,x)
                switch(regs.TCU) {
                        // LDA (d,x) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA2: new opcode_functions(opcode_matrix[0xA2],
            function(regs, pins) { // LDX #
                switch(regs.TCU) {
                        // LDX # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA3: new opcode_functions(opcode_matrix[0xA3],
            function(regs, pins) { // LDA d,s
                switch(regs.TCU) {
                        // LDA d,s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA4: new opcode_functions(opcode_matrix[0xA4],
            function(regs, pins) { // LDY d
                switch(regs.TCU) {
                        // LDY d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA5: new opcode_functions(opcode_matrix[0xA5],
            function(regs, pins) { // LDA d
                switch(regs.TCU) {
                        // LDA d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA6: new opcode_functions(opcode_matrix[0xA6],
            function(regs, pins) { // LDX d
                switch(regs.TCU) {
                        // LDX d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA7: new opcode_functions(opcode_matrix[0xA7],
            function(regs, pins) { // LDA [d]
                switch(regs.TCU) {
                        // LDA [d] E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA8: new opcode_functions(opcode_matrix[0xA8],
            function(regs, pins) { // TAY i
                switch(regs.TCU) {
                        // TAY i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.C) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xA9: new opcode_functions(opcode_matrix[0xA9],
            function(regs, pins) { // LDA #
                switch(regs.TCU) {
                        // LDA # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAA: new opcode_functions(opcode_matrix[0xAA],
            function(regs, pins) { // TAX i
                switch(regs.TCU) {
                        // TAX i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.C) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAB: new opcode_functions(opcode_matrix[0xAB],
            function(regs, pins) { // PLB s
                switch(regs.TCU) {
                        // PLB s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAC: new opcode_functions(opcode_matrix[0xAC],
            function(regs, pins) { // LDY a
                switch(regs.TCU) {
                        // LDY a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAD: new opcode_functions(opcode_matrix[0xAD],
            function(regs, pins) { // LDA a
                switch(regs.TCU) {
                        // LDA a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAE: new opcode_functions(opcode_matrix[0xAE],
            function(regs, pins) { // LDX a
                switch(regs.TCU) {
                        // LDX a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAF: new opcode_functions(opcode_matrix[0xAF],
            function(regs, pins) { // LDA al
                switch(regs.TCU) {
                        // LDA al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB0: new opcode_functions(opcode_matrix[0xB0],
            function(regs, pins) { // BCS r
                switch(regs.TCU) {
                        // BCS r E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB1: new opcode_functions(opcode_matrix[0xB1],
            function(regs, pins) { // LDA (d),y
                switch(regs.TCU) {
                        // LDA (d),y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB2: new opcode_functions(opcode_matrix[0xB2],
            function(regs, pins) { // LDA (d)
                switch(regs.TCU) {
                        // LDA (d) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB3: new opcode_functions(opcode_matrix[0xB3],
            function(regs, pins) { // LDA (d,s),y
                switch(regs.TCU) {
                        // LDA (d,s),y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB4: new opcode_functions(opcode_matrix[0xB4],
            function(regs, pins) { // LDY d,x
                switch(regs.TCU) {
                        // LDY d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB5: new opcode_functions(opcode_matrix[0xB5],
            function(regs, pins) { // LDA d,x
                switch(regs.TCU) {
                        // LDA d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB6: new opcode_functions(opcode_matrix[0xB6],
            function(regs, pins) { // LDX d,y
                switch(regs.TCU) {
                        // LDX d,y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB7: new opcode_functions(opcode_matrix[0xB7],
            function(regs, pins) { // LDA [d],y
                switch(regs.TCU) {
                        // LDA [d],y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB8: new opcode_functions(opcode_matrix[0xB8],
            function(regs, pins) { // CLV i
                switch(regs.TCU) {
                        // CLV i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.V = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB9: new opcode_functions(opcode_matrix[0xB9],
            function(regs, pins) { // LDA a,y
                switch(regs.TCU) {
                        // LDA a,y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBA: new opcode_functions(opcode_matrix[0xBA],
            function(regs, pins) { // TSX i
                switch(regs.TCU) {
                        // TSX i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X  = regs.S & 0xFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBB: new opcode_functions(opcode_matrix[0xBB],
            function(regs, pins) { // TYX i
                switch(regs.TCU) {
                        // TYX i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.Y) & 0xFF);
                        regs.P.Z = +((regs.Y & 0xFF) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBC: new opcode_functions(opcode_matrix[0xBC],
            function(regs, pins) { // LDY a,x
                switch(regs.TCU) {
                        // LDY a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBD: new opcode_functions(opcode_matrix[0xBD],
            function(regs, pins) { // LDA a,x
                switch(regs.TCU) {
                        // LDA a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBE: new opcode_functions(opcode_matrix[0xBE],
            function(regs, pins) { // LDX a,y
                switch(regs.TCU) {
                        // LDX a,y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBF: new opcode_functions(opcode_matrix[0xBF],
            function(regs, pins) { // LDA al,x
                switch(regs.TCU) {
                        // LDA al,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.C = regs.TR & 0xFFFF;
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC0: new opcode_functions(opcode_matrix[0xC0],
            function(regs, pins) { // CPY #
                switch(regs.TCU) {
                        // CPY # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.Y & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC1: new opcode_functions(opcode_matrix[0xC1],
            function(regs, pins) { // CMP (d,x)
                switch(regs.TCU) {
                        // CMP (d,x) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC2: new opcode_functions(opcode_matrix[0xC2],
            function(regs, pins) { // REP #
                switch(regs.TCU) {
                        // REP # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_native(regs.P.getbyte_native() & (~regs.TR & 0xFF));
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC3: new opcode_functions(opcode_matrix[0xC3],
            function(regs, pins) { // CMP d,s
                switch(regs.TCU) {
                        // CMP d,s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC4: new opcode_functions(opcode_matrix[0xC4],
            function(regs, pins) { // CPY d
                switch(regs.TCU) {
                        // CPY d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.Y & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC5: new opcode_functions(opcode_matrix[0xC5],
            function(regs, pins) { // CMP d
                switch(regs.TCU) {
                        // CMP d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC6: new opcode_functions(opcode_matrix[0xC6],
            function(regs, pins) { // DEC d
                switch(regs.TCU) {
                        // DEC d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC7: new opcode_functions(opcode_matrix[0xC7],
            function(regs, pins) { // CMP [d]
                switch(regs.TCU) {
                        // CMP [d] E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC8: new opcode_functions(opcode_matrix[0xC8],
            function(regs, pins) { // INY i
                switch(regs.TCU) {
                        // INY i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) + 1) & 0xFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC9: new opcode_functions(opcode_matrix[0xC9],
            function(regs, pins) { // CMP #
                switch(regs.TCU) {
                        // CMP # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCA: new opcode_functions(opcode_matrix[0xCA],
            function(regs, pins) { // DEX i
                switch(regs.TCU) {
                        // DEX i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) - 1) & 0xFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCB: new opcode_functions(opcode_matrix[0xCB],
            function(regs, pins) { // WAI i
                switch(regs.TCU) {
                        // WAI i E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.WAI = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCC: new opcode_functions(opcode_matrix[0xCC],
            function(regs, pins) { // CPY a
                switch(regs.TCU) {
                        // CPY a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.Y & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xCD: new opcode_functions(opcode_matrix[0xCD],
            function(regs, pins) { // CMP a
                switch(regs.TCU) {
                        // CMP a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCE: new opcode_functions(opcode_matrix[0xCE],
            function(regs, pins) { // DEC a
                switch(regs.TCU) {
                        // DEC a E=0 M=0 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCF: new opcode_functions(opcode_matrix[0xCF],
            function(regs, pins) { // CMP al
                switch(regs.TCU) {
                        // CMP al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD0: new opcode_functions(opcode_matrix[0xD0],
            function(regs, pins) { // BNE r
                switch(regs.TCU) {
                        // BNE r E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD1: new opcode_functions(opcode_matrix[0xD1],
            function(regs, pins) { // CMP (d),y
                switch(regs.TCU) {
                        // CMP (d),y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD2: new opcode_functions(opcode_matrix[0xD2],
            function(regs, pins) { // CMP (d)
                switch(regs.TCU) {
                        // CMP (d) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD3: new opcode_functions(opcode_matrix[0xD3],
            function(regs, pins) { // CMP (d,s),y
                switch(regs.TCU) {
                        // CMP (d,s),y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD4: new opcode_functions(opcode_matrix[0xD4],
            function(regs, pins) { // PEI s
                switch(regs.TCU) {
                        // PEI s E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.D = regs.TR
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xD5: new opcode_functions(opcode_matrix[0xD5],
            function(regs, pins) { // CMP d,x
                switch(regs.TCU) {
                        // CMP d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD6: new opcode_functions(opcode_matrix[0xD6],
            function(regs, pins) { // DEC d,x
                switch(regs.TCU) {
                        // DEC d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD7: new opcode_functions(opcode_matrix[0xD7],
            function(regs, pins) { // CMP [d],y
                switch(regs.TCU) {
                        // CMP [d],y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD8: new opcode_functions(opcode_matrix[0xD8],
            function(regs, pins) { // CLD i
                switch(regs.TCU) {
                        // CLD i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD9: new opcode_functions(opcode_matrix[0xD9],
            function(regs, pins) { // CMP a,y
                switch(regs.TCU) {
                        // CMP a,y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDA: new opcode_functions(opcode_matrix[0xDA],
            function(regs, pins) { // PHX s
                switch(regs.TCU) {
                        // PHX s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.X) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xDB: new opcode_functions(opcode_matrix[0xDB],
            function(regs, pins) { // STP i
                switch(regs.TCU) {
                        // STP i E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.STP = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDC: new opcode_functions(opcode_matrix[0xDC],
            function(regs, pins) { // JML (a)
                switch(regs.TCU) {
                        // JML (a) E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.PC = regs.TR + (pins.D << 8);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDD: new opcode_functions(opcode_matrix[0xDD],
            function(regs, pins) { // CMP a,x
                switch(regs.TCU) {
                        // CMP a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDE: new opcode_functions(opcode_matrix[0xDE],
            function(regs, pins) { // DEC a,x
                switch(regs.TCU) {
                        // DEC a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDF: new opcode_functions(opcode_matrix[0xDF],
            function(regs, pins) { // CMP al,x
                switch(regs.TCU) {
                        // CMP al,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.C) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE0: new opcode_functions(opcode_matrix[0xE0],
            function(regs, pins) { // CPX #
                switch(regs.TCU) {
                        // CPX # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.X & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE1: new opcode_functions(opcode_matrix[0xE1],
            function(regs, pins) { // SBC (d,x)
                switch(regs.TCU) {
                        // SBC (d,x) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE2: new opcode_functions(opcode_matrix[0xE2],
            function(regs, pins) { // SEP #
                switch(regs.TCU) {
                        // SEP # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_native(regs.P.getbyte_native() | regs.TR);
                        if (regs.P.X) { regs.X &= 0xFF, regs.Y &= 0xFF; }
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE3: new opcode_functions(opcode_matrix[0xE3],
            function(regs, pins) { // SBC d,s
                switch(regs.TCU) {
                        // SBC d,s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE4: new opcode_functions(opcode_matrix[0xE4],
            function(regs, pins) { // CPX d
                switch(regs.TCU) {
                        // CPX d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.X & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE5: new opcode_functions(opcode_matrix[0xE5],
            function(regs, pins) { // SBC d
                switch(regs.TCU) {
                        // SBC d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE6: new opcode_functions(opcode_matrix[0xE6],
            function(regs, pins) { // INC d
                switch(regs.TCU) {
                        // INC d E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE7: new opcode_functions(opcode_matrix[0xE7],
            function(regs, pins) { // SBC [d]
                switch(regs.TCU) {
                        // SBC [d] E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE8: new opcode_functions(opcode_matrix[0xE8],
            function(regs, pins) { // INX i
                switch(regs.TCU) {
                        // INX i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) + 1) & 0xFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE9: new opcode_functions(opcode_matrix[0xE9],
            function(regs, pins) { // SBC #
                switch(regs.TCU) {
                        // SBC # E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEA: new opcode_functions(opcode_matrix[0xEA],
            function(regs, pins) { // NOP i
                switch(regs.TCU) {
                        // NOP i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEB: new opcode_functions(opcode_matrix[0xEB],
            function(regs, pins) { // XBA i
                switch(regs.TCU) {
                        // XBA i E=0 M=0 X=1
                    case 1:
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2:
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >>> 8) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEC: new opcode_functions(opcode_matrix[0xEC],
            function(regs, pins) { // CPX a
                switch(regs.TCU) {
                        // CPX a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.X & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xED: new opcode_functions(opcode_matrix[0xED],
            function(regs, pins) { // SBC a
                switch(regs.TCU) {
                        // SBC a E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEE: new opcode_functions(opcode_matrix[0xEE],
            function(regs, pins) { // INC a
                switch(regs.TCU) {
                        // INC a E=0 M=0 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 7: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEF: new opcode_functions(opcode_matrix[0xEF],
            function(regs, pins) { // SBC al
                switch(regs.TCU) {
                        // SBC al E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins. D & 0xFF) << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF0: new opcode_functions(opcode_matrix[0xF0],
            function(regs, pins) { // BEQ r
                switch(regs.TCU) {
                        // BEQ r E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF1: new opcode_functions(opcode_matrix[0xF1],
            function(regs, pins) { // SBC (d),y
                switch(regs.TCU) {
                        // SBC (d),y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF2: new opcode_functions(opcode_matrix[0xF2],
            function(regs, pins) { // SBC (d)
                switch(regs.TCU) {
                        // SBC (d) E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF3: new opcode_functions(opcode_matrix[0xF3],
            function(regs, pins) { // SBC (d,s),y
                switch(regs.TCU) {
                        // SBC (d,s),y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF4: new opcode_functions(opcode_matrix[0xF4],
            function(regs, pins) { // PEA s
                switch(regs.TCU) {
                        // PEA s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xF5: new opcode_functions(opcode_matrix[0xF5],
            function(regs, pins) { // SBC d,x
                switch(regs.TCU) {
                        // SBC d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF6: new opcode_functions(opcode_matrix[0xF6],
            function(regs, pins) { // INC d,x
                switch(regs.TCU) {
                        // INC d,x E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 16L
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // fetch_rmw_8or16 16H
                        regs.TR += pins.D << 8;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr = (pins.Addr - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF7: new opcode_functions(opcode_matrix[0xF7],
            function(regs, pins) { // SBC [d],y
                switch(regs.TCU) {
                        // SBC [d],y E=0 M=0 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF8: new opcode_functions(opcode_matrix[0xF8],
            function(regs, pins) { // SED i
                switch(regs.TCU) {
                        // SED i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF9: new opcode_functions(opcode_matrix[0xF9],
            function(regs, pins) { // SBC a,y
                switch(regs.TCU) {
                        // SBC a,y E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFA: new opcode_functions(opcode_matrix[0xFA],
            function(regs, pins) { // PLX s
                switch(regs.TCU) {
                        // PLX s E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xFB: new opcode_functions(opcode_matrix[0xFB],
            function(regs, pins) { // XCE i
                switch(regs.TCU) {
                        // XCE i E=0 M=0 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        let TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
                        if (regs.E) {
                            regs.P.X = regs.P.M = 1;
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                            regs.S = (regs.S & 0xFF) | 0x100;
                        }
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xFC: new opcode_functions(opcode_matrix[0xFC],
            function(regs, pins) { // JSR (a,x)
                switch(regs.TCU) {
                        // JSR (a,x) E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.RW = 1;
                        regs.TA = pins.D;
                        pins.D = ((regs.PC) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 4
                        pins.D = (regs.PC) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 6: // 7
                        pins.PDV = 1;
                        pins.Addr = regs.TA;
                        break;
                    case 7: // 8
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.PC = pins.D;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xFD: new opcode_functions(opcode_matrix[0xFD],
            function(regs, pins) { // SBC a,x
                switch(regs.TCU) {
                        // SBC a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFE: new opcode_functions(opcode_matrix[0xFE],
            function(regs, pins) { // INC a,x
                switch(regs.TCU) {
                        // INC a,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 5a
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        pins.PDV = 0;
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 7: // finish_rmw mem16 H
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 8: // finish_rmw mem16 L
                        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 9: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFF: new opcode_functions(opcode_matrix[0xFF],
            function(regs, pins) { // SBC al,x
                switch(regs.TCU) {
                        // SBC al,x E=0 M=0 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        let data = (~regs.TR) & 0xFFFF;
                        let result;
                        if (!regs.P.D) result = regs.C + data + regs.P.C;
                        else {
                            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
                            if (result <= 0x000F) result -= 0x0006;
                            regs.P.C = +(result > 0x000F);
                            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
                            if (result <= 0x00FF) result -= 0x0060;
                            regs.P.C = +(result > 0x00FF);
                            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
                            if (result <= 0x0FFF) result -= 0x0600;
                            regs.P.C = +(result > 0x0FFF);
                            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
                        }
                        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >>> 15;
                        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
                        regs.P.C = +(result > 0xFFFF);
                        regs.P.Z = +((result & 0xFFFF) === 0);
                        regs.P.N = ((result) & 0x8000) >>> 15;
                        regs.C = (result & 0xFFFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x100: new opcode_functions(opcode_matrix[0x100],
            function(regs, pins) { // S_RESET s
                switch(regs.TCU) {
                        // S_RESET s E=0 M=0 X=1
                    case 1: // 3
                        pins.RW = 0; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFFC); pins.BA = (0);
                        regs.DBR = 0;
                        regs.D = 0;
                        regs.PBR = 0;
                        regs.X &= 0xFF;
                        regs.Y &= 0xFF;
                        regs.S = (regs.S & 0xFF) | 0x100;
                        regs.E = 1;
                        regs.P.M = regs.P.X = regs.P.I = regs.P.C = 1;
                        regs.P.D = 0;
                        regs.STP = regs.WAI = false;
                        break;
                    case 6: // 8
                        regs.PC = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        pins.PDV = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x101: new opcode_functions(opcode_matrix[0x101],
            function(regs, pins) { // S_ABORT s
                switch(regs.TCU) {
                        // S_ABORT s E=0 M=0 X=1
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFE8); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFE9); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x102: new opcode_functions(opcode_matrix[0x102],
            function(regs, pins) { // S_IRQ s
                switch(regs.TCU) {
                        // S_IRQ s E=0 M=0 X=1
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFEE); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFEF); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x103: new opcode_functions(opcode_matrix[0x103],
            function(regs, pins) { // S_NMI s
                switch(regs.TCU) {
                        // S_NMI s E=0 M=0 X=1
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFEA); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFEB); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false)
},
    // E0 M1 X0
    2: {
        0x00: new opcode_functions(opcode_matrix[0x00],
            function(regs, pins) { // BRK s
                switch(regs.TCU) {
                        // BRK s E=0 M=1 X=0
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 3: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 6: // 7
                        pins.Addr = (0xFFE6); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 7: // 8
                        pins.Addr = (0xFFE7); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x01: new opcode_functions(opcode_matrix[0x01],
            function(regs, pins) { // ORA (d,x)
                switch(regs.TCU) {
                        // ORA (d,x) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x02: new opcode_functions(opcode_matrix[0x02],
            function(regs, pins) { // COP s
                switch(regs.TCU) {
                        // COP s E=0 M=1 X=0
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 3: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 6: // 7
                        pins.Addr = (0xFFE4); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 7: // 8
                        pins.Addr = (0xFFE5); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x03: new opcode_functions(opcode_matrix[0x03],
            function(regs, pins) { // ORA d,s
                switch(regs.TCU) {
                        // ORA d,s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x04: new opcode_functions(opcode_matrix[0x04],
            function(regs, pins) { // TSB d
                switch(regs.TCU) {
                        // TSB d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x05: new opcode_functions(opcode_matrix[0x05],
            function(regs, pins) { // ORA d
                switch(regs.TCU) {
                        // ORA d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x06: new opcode_functions(opcode_matrix[0x06],
            function(regs, pins) { // ASL d
                switch(regs.TCU) {
                        // ASL d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x07: new opcode_functions(opcode_matrix[0x07],
            function(regs, pins) { // ORA [d]
                switch(regs.TCU) {
                        // ORA [d] E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x08: new opcode_functions(opcode_matrix[0x08],
            function(regs, pins) { // PHP s
                switch(regs.TCU) {
                        // PHP s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.P.getbyte_native();
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x09: new opcode_functions(opcode_matrix[0x09],
            function(regs, pins) { // ORA #
                switch(regs.TCU) {
                        // ORA # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0A: new opcode_functions(opcode_matrix[0x0A],
            function(regs, pins) { // ASL A
                switch(regs.TCU) {
                        // ASL A E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0B: new opcode_functions(opcode_matrix[0x0B],
            function(regs, pins) { // PHD s
                switch(regs.TCU) {
                        // PHD s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.D);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x0C: new opcode_functions(opcode_matrix[0x0C],
            function(regs, pins) { // TSB a
                switch(regs.TCU) {
                        // TSB a E=0 M=1 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0D: new opcode_functions(opcode_matrix[0x0D],
            function(regs, pins) { // ORA a
                switch(regs.TCU) {
                        // ORA a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0E: new opcode_functions(opcode_matrix[0x0E],
            function(regs, pins) { // ASL a
                switch(regs.TCU) {
                        // ASL a E=0 M=1 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0F: new opcode_functions(opcode_matrix[0x0F],
            function(regs, pins) { // ORA al
                switch(regs.TCU) {
                        // ORA al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x10: new opcode_functions(opcode_matrix[0x10],
            function(regs, pins) { // BPL r
                switch(regs.TCU) {
                        // BPL r E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x11: new opcode_functions(opcode_matrix[0x11],
            function(regs, pins) { // ORA (d),y
                switch(regs.TCU) {
                        // ORA (d),y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x12: new opcode_functions(opcode_matrix[0x12],
            function(regs, pins) { // ORA (d)
                switch(regs.TCU) {
                        // ORA (d) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x13: new opcode_functions(opcode_matrix[0x13],
            function(regs, pins) { // ORA (d,s),y
                switch(regs.TCU) {
                        // ORA (d,s),y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x14: new opcode_functions(opcode_matrix[0x14],
            function(regs, pins) { // TRB d
                switch(regs.TCU) {
                        // TRB d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x15: new opcode_functions(opcode_matrix[0x15],
            function(regs, pins) { // ORA d,x
                switch(regs.TCU) {
                        // ORA d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x16: new opcode_functions(opcode_matrix[0x16],
            function(regs, pins) { // ASL d,x
                switch(regs.TCU) {
                        // ASL d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x17: new opcode_functions(opcode_matrix[0x17],
            function(regs, pins) { // ORA [d],y
                switch(regs.TCU) {
                        // ORA [d],y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x18: new opcode_functions(opcode_matrix[0x18],
            function(regs, pins) { // CLC i
                switch(regs.TCU) {
                        // CLC i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x19: new opcode_functions(opcode_matrix[0x19],
            function(regs, pins) { // ORA a,y
                switch(regs.TCU) {
                        // ORA a,y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1A: new opcode_functions(opcode_matrix[0x1A],
            function(regs, pins) { // INC A
                switch(regs.TCU) {
                        // INC A E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1B: new opcode_functions(opcode_matrix[0x1B],
            function(regs, pins) { // TCS i
                switch(regs.TCU) {
                        // TCS i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.C;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x1C: new opcode_functions(opcode_matrix[0x1C],
            function(regs, pins) { // TRB a
                switch(regs.TCU) {
                        // TRB a E=0 M=1 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1D: new opcode_functions(opcode_matrix[0x1D],
            function(regs, pins) { // ORA a,x
                switch(regs.TCU) {
                        // ORA a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1E: new opcode_functions(opcode_matrix[0x1E],
            function(regs, pins) { // ASL a,x
                switch(regs.TCU) {
                        // ASL a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1F: new opcode_functions(opcode_matrix[0x1F],
            function(regs, pins) { // ORA al,x
                switch(regs.TCU) {
                        // ORA al,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x20: new opcode_functions(opcode_matrix[0x20],
            function(regs, pins) { // JSR a
                switch(regs.TCU) {
                        // JSR a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.PDV = 0;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 6
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x21: new opcode_functions(opcode_matrix[0x21],
            function(regs, pins) { // AND (d,x)
                switch(regs.TCU) {
                        // AND (d,x) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x22: new opcode_functions(opcode_matrix[0x22],
            function(regs, pins) { // JSL al
                switch(regs.TCU) {
                        // JSL al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        regs.TA += pins.D << 8;
                        pins.D = (regs.PBR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 1;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 6: // 7
                        regs.PBR = pins.D;
                        pins.RW = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF;
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 7: // 8
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x23: new opcode_functions(opcode_matrix[0x23],
            function(regs, pins) { // AND d,s
                switch(regs.TCU) {
                        // AND d,s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x24: new opcode_functions(opcode_matrix[0x24],
            function(regs, pins) { // BIT d
                switch(regs.TCU) {
                        // BIT d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x25: new opcode_functions(opcode_matrix[0x25],
            function(regs, pins) { // AND d
                switch(regs.TCU) {
                        // AND d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x26: new opcode_functions(opcode_matrix[0x26],
            function(regs, pins) { // ROL d
                switch(regs.TCU) {
                        // ROL d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x27: new opcode_functions(opcode_matrix[0x27],
            function(regs, pins) { // AND [d]
                switch(regs.TCU) {
                        // AND [d] E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x28: new opcode_functions(opcode_matrix[0x28],
            function(regs, pins) { // PLP s
                switch(regs.TCU) {
                        // PLP s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.setbyte_native(regs.TR);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x29: new opcode_functions(opcode_matrix[0x29],
            function(regs, pins) { // AND #
                switch(regs.TCU) {
                        // AND # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2A: new opcode_functions(opcode_matrix[0x2A],
            function(regs, pins) { // ROL A
                switch(regs.TCU) {
                        // ROL A E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2B: new opcode_functions(opcode_matrix[0x2B],
            function(regs, pins) { // PLD s
                switch(regs.TCU) {
                        // PLD s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.D = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x2C: new opcode_functions(opcode_matrix[0x2C],
            function(regs, pins) { // BIT a
                switch(regs.TCU) {
                        // BIT a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2D: new opcode_functions(opcode_matrix[0x2D],
            function(regs, pins) { // AND a
                switch(regs.TCU) {
                        // AND a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2E: new opcode_functions(opcode_matrix[0x2E],
            function(regs, pins) { // ROL a
                switch(regs.TCU) {
                        // ROL a E=0 M=1 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2F: new opcode_functions(opcode_matrix[0x2F],
            function(regs, pins) { // AND al
                switch(regs.TCU) {
                        // AND al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x30: new opcode_functions(opcode_matrix[0x30],
            function(regs, pins) { // BMI r
                switch(regs.TCU) {
                        // BMI r E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x31: new opcode_functions(opcode_matrix[0x31],
            function(regs, pins) { // AND (d),y
                switch(regs.TCU) {
                        // AND (d),y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x32: new opcode_functions(opcode_matrix[0x32],
            function(regs, pins) { // AND (d)
                switch(regs.TCU) {
                        // AND (d) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x33: new opcode_functions(opcode_matrix[0x33],
            function(regs, pins) { // AND (d,s),y
                switch(regs.TCU) {
                        // AND (d,s),y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x34: new opcode_functions(opcode_matrix[0x34],
            function(regs, pins) { // BIT d,x
                switch(regs.TCU) {
                        // BIT d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x35: new opcode_functions(opcode_matrix[0x35],
            function(regs, pins) { // AND d,x
                switch(regs.TCU) {
                        // AND d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x36: new opcode_functions(opcode_matrix[0x36],
            function(regs, pins) { // ROL d,x
                switch(regs.TCU) {
                        // ROL d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x37: new opcode_functions(opcode_matrix[0x37],
            function(regs, pins) { // AND [d],y
                switch(regs.TCU) {
                        // AND [d],y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x38: new opcode_functions(opcode_matrix[0x38],
            function(regs, pins) { // SEC i
                switch(regs.TCU) {
                        // SEC i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x39: new opcode_functions(opcode_matrix[0x39],
            function(regs, pins) { // AND a,y
                switch(regs.TCU) {
                        // AND a,y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3A: new opcode_functions(opcode_matrix[0x3A],
            function(regs, pins) { // DEC A
                switch(regs.TCU) {
                        // DEC A E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3B: new opcode_functions(opcode_matrix[0x3B],
            function(regs, pins) { // TSC i
                switch(regs.TCU) {
                        // TSC i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.S);
                        regs.P.Z = +((regs.S) === 0);
                        regs.P.N = ((regs.S) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x3C: new opcode_functions(opcode_matrix[0x3C],
            function(regs, pins) { // BIT a,x
                switch(regs.TCU) {
                        // BIT a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3D: new opcode_functions(opcode_matrix[0x3D],
            function(regs, pins) { // AND a,x
                switch(regs.TCU) {
                        // AND a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3E: new opcode_functions(opcode_matrix[0x3E],
            function(regs, pins) { // ROL a,x
                switch(regs.TCU) {
                        // ROL a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3F: new opcode_functions(opcode_matrix[0x3F],
            function(regs, pins) { // AND al,x
                switch(regs.TCU) {
                        // AND al,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x40: new opcode_functions(opcode_matrix[0x40],
            function(regs, pins) { // RTI s
                switch(regs.TCU) {
                        // RTI s E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        pins.PDV = 1;
                        break;
                    case 4: // 5
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.P.setbyte_native(pins.D);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        if (regs.P.E) regs.S = (regs.S & 0xFF) | 0x100;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.TA = pins.D;
                        break;
                    case 6: // 7
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.TA += pins.D << 8;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TA;
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x41: new opcode_functions(opcode_matrix[0x41],
            function(regs, pins) { // EOR (d,x)
                switch(regs.TCU) {
                        // EOR (d,x) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x42: new opcode_functions(opcode_matrix[0x42],
            function(regs, pins) { // WDM i
                switch(regs.TCU) {
                        // WDM i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x43: new opcode_functions(opcode_matrix[0x43],
            function(regs, pins) { // EOR d,s
                switch(regs.TCU) {
                        // EOR d,s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x44: new opcode_functions(opcode_matrix[0x44],
            function(regs, pins) { // MVP xyc
                switch(regs.TCU) {
                        // MVP xyc E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D
                        pins.Addr = (regs.X); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X - 1) & 0xFFFF;
                        regs.Y = (regs.Y - 1) & 0xFFFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x45: new opcode_functions(opcode_matrix[0x45],
            function(regs, pins) { // EOR d
                switch(regs.TCU) {
                        // EOR d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x46: new opcode_functions(opcode_matrix[0x46],
            function(regs, pins) { // LSR d
                switch(regs.TCU) {
                        // LSR d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x47: new opcode_functions(opcode_matrix[0x47],
            function(regs, pins) { // EOR [d]
                switch(regs.TCU) {
                        // EOR [d] E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x48: new opcode_functions(opcode_matrix[0x48],
            function(regs, pins) { // PHA s
                switch(regs.TCU) {
                        // PHA s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.C) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x49: new opcode_functions(opcode_matrix[0x49],
            function(regs, pins) { // EOR #
                switch(regs.TCU) {
                        // EOR # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4A: new opcode_functions(opcode_matrix[0x4A],
            function(regs, pins) { // LSR A
                switch(regs.TCU) {
                        // LSR A E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4B: new opcode_functions(opcode_matrix[0x4B],
            function(regs, pins) { // PHK s
                switch(regs.TCU) {
                        // PHK s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.PBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4C: new opcode_functions(opcode_matrix[0x4C],
            function(regs, pins) { // JMP a
                switch(regs.TCU) {
                        // JMP a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4D: new opcode_functions(opcode_matrix[0x4D],
            function(regs, pins) { // EOR a
                switch(regs.TCU) {
                        // EOR a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4E: new opcode_functions(opcode_matrix[0x4E],
            function(regs, pins) { // LSR a
                switch(regs.TCU) {
                        // LSR a E=0 M=1 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4F: new opcode_functions(opcode_matrix[0x4F],
            function(regs, pins) { // EOR al
                switch(regs.TCU) {
                        // EOR al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x50: new opcode_functions(opcode_matrix[0x50],
            function(regs, pins) { // BVC r
                switch(regs.TCU) {
                        // BVC r E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x51: new opcode_functions(opcode_matrix[0x51],
            function(regs, pins) { // EOR (d),y
                switch(regs.TCU) {
                        // EOR (d),y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x52: new opcode_functions(opcode_matrix[0x52],
            function(regs, pins) { // EOR (d)
                switch(regs.TCU) {
                        // EOR (d) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x53: new opcode_functions(opcode_matrix[0x53],
            function(regs, pins) { // EOR (d,s),y
                switch(regs.TCU) {
                        // EOR (d,s),y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x54: new opcode_functions(opcode_matrix[0x54],
            function(regs, pins) { // MVN xyc
                switch(regs.TCU) {
                        // MVN xyc E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D;
                        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X + 1) & 0xFFFF;
                        regs.Y = (regs.Y + 1) & 0xFFFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x55: new opcode_functions(opcode_matrix[0x55],
            function(regs, pins) { // EOR d,x
                switch(regs.TCU) {
                        // EOR d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x56: new opcode_functions(opcode_matrix[0x56],
            function(regs, pins) { // LSR d,x
                switch(regs.TCU) {
                        // LSR d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x57: new opcode_functions(opcode_matrix[0x57],
            function(regs, pins) { // EOR [d],y
                switch(regs.TCU) {
                        // EOR [d],y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x58: new opcode_functions(opcode_matrix[0x58],
            function(regs, pins) { // CLI i
                switch(regs.TCU) {
                        // CLI i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 0;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x59: new opcode_functions(opcode_matrix[0x59],
            function(regs, pins) { // EOR a,y
                switch(regs.TCU) {
                        // EOR a,y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5A: new opcode_functions(opcode_matrix[0x5A],
            function(regs, pins) { // PHY s
                switch(regs.TCU) {
                        // PHY s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.Y);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x5B: new opcode_functions(opcode_matrix[0x5B],
            function(regs, pins) { // TCD i
                switch(regs.TCU) {
                        // TCD i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.D = (regs.C);
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5C: new opcode_functions(opcode_matrix[0x5C],
            function(regs, pins) { // JMP al
                switch(regs.TCU) {
                        // JMP al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = regs.TA + (pins.D << 8);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5D: new opcode_functions(opcode_matrix[0x5D],
            function(regs, pins) { // EOR a,x
                switch(regs.TCU) {
                        // EOR a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5E: new opcode_functions(opcode_matrix[0x5E],
            function(regs, pins) { // LSR a,x
                switch(regs.TCU) {
                        // LSR a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5F: new opcode_functions(opcode_matrix[0x5F],
            function(regs, pins) { // EOR al,x
                switch(regs.TCU) {
                        // EOR al,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x60: new opcode_functions(opcode_matrix[0x60],
            function(regs, pins) { // RTS s
                switch(regs.TCU) {
                        // RTS s E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x61: new opcode_functions(opcode_matrix[0x61],
            function(regs, pins) { // ADC (d,x)
                switch(regs.TCU) {
                        // ADC (d,x) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x62: new opcode_functions(opcode_matrix[0x62],
            function(regs, pins) { // PER s
                switch(regs.TCU) {
                        // PER s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x63: new opcode_functions(opcode_matrix[0x63],
            function(regs, pins) { // ADC d,s
                switch(regs.TCU) {
                        // ADC d,s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x64: new opcode_functions(opcode_matrix[0x64],
            function(regs, pins) { // STZ d
                switch(regs.TCU) {
                        // STZ d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x65: new opcode_functions(opcode_matrix[0x65],
            function(regs, pins) { // ADC d
                switch(regs.TCU) {
                        // ADC d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x66: new opcode_functions(opcode_matrix[0x66],
            function(regs, pins) { // ROR d
                switch(regs.TCU) {
                        // ROR d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x67: new opcode_functions(opcode_matrix[0x67],
            function(regs, pins) { // ADC [d]
                switch(regs.TCU) {
                        // ADC [d] E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x68: new opcode_functions(opcode_matrix[0x68],
            function(regs, pins) { // PLA s
                switch(regs.TCU) {
                        // PLA s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x69: new opcode_functions(opcode_matrix[0x69],
            function(regs, pins) { // ADC #
                switch(regs.TCU) {
                        // ADC # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6A: new opcode_functions(opcode_matrix[0x6A],
            function(regs, pins) { // ROR A
                switch(regs.TCU) {
                        // ROR A E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6B: new opcode_functions(opcode_matrix[0x6B],
            function(regs, pins) { // RTL s
                switch(regs.TCU) {
                        // RTL s E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x6C: new opcode_functions(opcode_matrix[0x6C],
            function(regs, pins) { // JMP (a)
                switch(regs.TCU) {
                        // JMP (a) E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x6D: new opcode_functions(opcode_matrix[0x6D],
            function(regs, pins) { // ADC a
                switch(regs.TCU) {
                        // ADC a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6E: new opcode_functions(opcode_matrix[0x6E],
            function(regs, pins) { // ROR a
                switch(regs.TCU) {
                        // ROR a E=0 M=1 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6F: new opcode_functions(opcode_matrix[0x6F],
            function(regs, pins) { // ADC al
                switch(regs.TCU) {
                        // ADC al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x70: new opcode_functions(opcode_matrix[0x70],
            function(regs, pins) { // BVS r
                switch(regs.TCU) {
                        // BVS r E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x71: new opcode_functions(opcode_matrix[0x71],
            function(regs, pins) { // ADC (d),y
                switch(regs.TCU) {
                        // ADC (d),y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x72: new opcode_functions(opcode_matrix[0x72],
            function(regs, pins) { // ADC (d)
                switch(regs.TCU) {
                        // ADC (d) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x73: new opcode_functions(opcode_matrix[0x73],
            function(regs, pins) { // ADC (d,s),y
                switch(regs.TCU) {
                        // ADC (d,s),y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x74: new opcode_functions(opcode_matrix[0x74],
            function(regs, pins) { // STZ d,x
                switch(regs.TCU) {
                        // STZ d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x75: new opcode_functions(opcode_matrix[0x75],
            function(regs, pins) { // ADC d,x
                switch(regs.TCU) {
                        // ADC d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x76: new opcode_functions(opcode_matrix[0x76],
            function(regs, pins) { // ROR d,x
                switch(regs.TCU) {
                        // ROR d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x77: new opcode_functions(opcode_matrix[0x77],
            function(regs, pins) { // ADC [d],y
                switch(regs.TCU) {
                        // ADC [d],y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x78: new opcode_functions(opcode_matrix[0x78],
            function(regs, pins) { // SEI i
                switch(regs.TCU) {
                        // SEI i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 1;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x79: new opcode_functions(opcode_matrix[0x79],
            function(regs, pins) { // ADC a,y
                switch(regs.TCU) {
                        // ADC a,y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7A: new opcode_functions(opcode_matrix[0x7A],
            function(regs, pins) { // PLY s
                switch(regs.TCU) {
                        // PLY s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x7B: new opcode_functions(opcode_matrix[0x7B],
            function(regs, pins) { // TDC i
                switch(regs.TCU) {
                        // TDC i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.D);
                        regs.P.Z = +((regs.D) === 0);
                        regs.P.N = ((regs.D) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7C: new opcode_functions(opcode_matrix[0x7C],
            function(regs, pins) { // JMP (a,x)
                switch(regs.TCU) {
                        // JMP (a,x) E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        regs.TA = (regs.X + regs.TA) & 0xFFFF;
                        pins.PDV = 0;
                        break;
                    case 4:
                        pins.PDV = 1;
                        pins.Addr = regs.TA; pins.BA = regs.PBR;
                        break;
                    case 5:
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7D: new opcode_functions(opcode_matrix[0x7D],
            function(regs, pins) { // ADC a,x
                switch(regs.TCU) {
                        // ADC a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7E: new opcode_functions(opcode_matrix[0x7E],
            function(regs, pins) { // ROR a,x
                switch(regs.TCU) {
                        // ROR a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7F: new opcode_functions(opcode_matrix[0x7F],
            function(regs, pins) { // ADC al,x
                switch(regs.TCU) {
                        // ADC al,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x80: new opcode_functions(opcode_matrix[0x80],
            function(regs, pins) { // BRA r
                switch(regs.TCU) {
                        // BRA r E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = true;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x81: new opcode_functions(opcode_matrix[0x81],
            function(regs, pins) { // STA (d,x)
                switch(regs.TCU) {
                        // STA (d,x) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x82: new opcode_functions(opcode_matrix[0x82],
            function(regs, pins) { // BRL rl
                switch(regs.TCU) {
                        // BRL rl E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TA = mksigned16(regs.TA + (pins.D << 8));
                        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x83: new opcode_functions(opcode_matrix[0x83],
            function(regs, pins) { // STA d,s
                switch(regs.TCU) {
                        // STA d,s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x84: new opcode_functions(opcode_matrix[0x84],
            function(regs, pins) { // STY d
                switch(regs.TCU) {
                        // STY d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x85: new opcode_functions(opcode_matrix[0x85],
            function(regs, pins) { // STA d
                switch(regs.TCU) {
                        // STA d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x86: new opcode_functions(opcode_matrix[0x86],
            function(regs, pins) { // STX d
                switch(regs.TCU) {
                        // STX d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x87: new opcode_functions(opcode_matrix[0x87],
            function(regs, pins) { // STA [d]
                switch(regs.TCU) {
                        // STA [d] E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x88: new opcode_functions(opcode_matrix[0x88],
            function(regs, pins) { // DEY i
                switch(regs.TCU) {
                        // DEY i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x89: new opcode_functions(opcode_matrix[0x89],
            function(regs, pins) { // BIT #
                switch(regs.TCU) {
                        // BIT # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8A: new opcode_functions(opcode_matrix[0x8A],
            function(regs, pins) { // TXA i
                switch(regs.TCU) {
                        // TXA i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.X) & 0xFF);
                        regs.P.Z = +((regs.X & 0xFF) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8B: new opcode_functions(opcode_matrix[0x8B],
            function(regs, pins) { // PHB s
                switch(regs.TCU) {
                        // PHB s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.DBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8C: new opcode_functions(opcode_matrix[0x8C],
            function(regs, pins) { // STY a
                switch(regs.TCU) {
                        // STY a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.Y;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8D: new opcode_functions(opcode_matrix[0x8D],
            function(regs, pins) { // STA a
                switch(regs.TCU) {
                        // STA a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8E: new opcode_functions(opcode_matrix[0x8E],
            function(regs, pins) { // STX a
                switch(regs.TCU) {
                        // STX a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.X;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // finish_RW8or16p W16H
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8F: new opcode_functions(opcode_matrix[0x8F],
            function(regs, pins) { // STA al
                switch(regs.TCU) {
                        // STA al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x90: new opcode_functions(opcode_matrix[0x90],
            function(regs, pins) { // BCC r
                switch(regs.TCU) {
                        // BCC r E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x91: new opcode_functions(opcode_matrix[0x91],
            function(regs, pins) { // STA (d),y
                switch(regs.TCU) {
                        // STA (d),y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x92: new opcode_functions(opcode_matrix[0x92],
            function(regs, pins) { // STA (d)
                switch(regs.TCU) {
                        // STA (d) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x93: new opcode_functions(opcode_matrix[0x93],
            function(regs, pins) { // STA (d,s),y
                switch(regs.TCU) {
                        // STA (d,s),y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x94: new opcode_functions(opcode_matrix[0x94],
            function(regs, pins) { // STY d,x
                switch(regs.TCU) {
                        // STY d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x95: new opcode_functions(opcode_matrix[0x95],
            function(regs, pins) { // STA d,x
                switch(regs.TCU) {
                        // STA d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x96: new opcode_functions(opcode_matrix[0x96],
            function(regs, pins) { // STX d,y
                switch(regs.TCU) {
                        // STX d,y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // finish_RW8or16p W16H
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x97: new opcode_functions(opcode_matrix[0x97],
            function(regs, pins) { // STA [d],y
                switch(regs.TCU) {
                        // STA [d],y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x98: new opcode_functions(opcode_matrix[0x98],
            function(regs, pins) { // TYA i
                switch(regs.TCU) {
                        // TYA i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.Y) & 0xFF);
                        regs.P.Z = +((regs.Y & 0xFF) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x99: new opcode_functions(opcode_matrix[0x99],
            function(regs, pins) { // STA a,y
                switch(regs.TCU) {
                        // STA a,y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9A: new opcode_functions(opcode_matrix[0x9A],
            function(regs, pins) { // TXS i
                switch(regs.TCU) {
                        // TXS i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.X
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9B: new opcode_functions(opcode_matrix[0x9B],
            function(regs, pins) { // TXY i
                switch(regs.TCU) {
                        // TXY i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = (regs.X);
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9C: new opcode_functions(opcode_matrix[0x9C],
            function(regs, pins) { // STZ a
                switch(regs.TCU) {
                        // STZ a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9D: new opcode_functions(opcode_matrix[0x9D],
            function(regs, pins) { // STA a,x
                switch(regs.TCU) {
                        // STA a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9E: new opcode_functions(opcode_matrix[0x9E],
            function(regs, pins) { // STZ a,x
                switch(regs.TCU) {
                        // STZ a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9F: new opcode_functions(opcode_matrix[0x9F],
            function(regs, pins) { // STA al,x
                switch(regs.TCU) {
                        // STA al,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA0: new opcode_functions(opcode_matrix[0xA0],
            function(regs, pins) { // LDY #
                switch(regs.TCU) {
                        // LDY # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA1: new opcode_functions(opcode_matrix[0xA1],
            function(regs, pins) { // LDA (d,x)
                switch(regs.TCU) {
                        // LDA (d,x) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA2: new opcode_functions(opcode_matrix[0xA2],
            function(regs, pins) { // LDX #
                switch(regs.TCU) {
                        // LDX # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA3: new opcode_functions(opcode_matrix[0xA3],
            function(regs, pins) { // LDA d,s
                switch(regs.TCU) {
                        // LDA d,s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA4: new opcode_functions(opcode_matrix[0xA4],
            function(regs, pins) { // LDY d
                switch(regs.TCU) {
                        // LDY d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA5: new opcode_functions(opcode_matrix[0xA5],
            function(regs, pins) { // LDA d
                switch(regs.TCU) {
                        // LDA d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA6: new opcode_functions(opcode_matrix[0xA6],
            function(regs, pins) { // LDX d
                switch(regs.TCU) {
                        // LDX d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA7: new opcode_functions(opcode_matrix[0xA7],
            function(regs, pins) { // LDA [d]
                switch(regs.TCU) {
                        // LDA [d] E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA8: new opcode_functions(opcode_matrix[0xA8],
            function(regs, pins) { // TAY i
                switch(regs.TCU) {
                        // TAY i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = (regs.C);
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xA9: new opcode_functions(opcode_matrix[0xA9],
            function(regs, pins) { // LDA #
                switch(regs.TCU) {
                        // LDA # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAA: new opcode_functions(opcode_matrix[0xAA],
            function(regs, pins) { // TAX i
                switch(regs.TCU) {
                        // TAX i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = (regs.C);
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAB: new opcode_functions(opcode_matrix[0xAB],
            function(regs, pins) { // PLB s
                switch(regs.TCU) {
                        // PLB s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAC: new opcode_functions(opcode_matrix[0xAC],
            function(regs, pins) { // LDY a
                switch(regs.TCU) {
                        // LDY a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAD: new opcode_functions(opcode_matrix[0xAD],
            function(regs, pins) { // LDA a
                switch(regs.TCU) {
                        // LDA a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAE: new opcode_functions(opcode_matrix[0xAE],
            function(regs, pins) { // LDX a
                switch(regs.TCU) {
                        // LDX a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAF: new opcode_functions(opcode_matrix[0xAF],
            function(regs, pins) { // LDA al
                switch(regs.TCU) {
                        // LDA al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB0: new opcode_functions(opcode_matrix[0xB0],
            function(regs, pins) { // BCS r
                switch(regs.TCU) {
                        // BCS r E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB1: new opcode_functions(opcode_matrix[0xB1],
            function(regs, pins) { // LDA (d),y
                switch(regs.TCU) {
                        // LDA (d),y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB2: new opcode_functions(opcode_matrix[0xB2],
            function(regs, pins) { // LDA (d)
                switch(regs.TCU) {
                        // LDA (d) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB3: new opcode_functions(opcode_matrix[0xB3],
            function(regs, pins) { // LDA (d,s),y
                switch(regs.TCU) {
                        // LDA (d,s),y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB4: new opcode_functions(opcode_matrix[0xB4],
            function(regs, pins) { // LDY d,x
                switch(regs.TCU) {
                        // LDY d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB5: new opcode_functions(opcode_matrix[0xB5],
            function(regs, pins) { // LDA d,x
                switch(regs.TCU) {
                        // LDA d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB6: new opcode_functions(opcode_matrix[0xB6],
            function(regs, pins) { // LDX d,y
                switch(regs.TCU) {
                        // LDX d,y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB7: new opcode_functions(opcode_matrix[0xB7],
            function(regs, pins) { // LDA [d],y
                switch(regs.TCU) {
                        // LDA [d],y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB8: new opcode_functions(opcode_matrix[0xB8],
            function(regs, pins) { // CLV i
                switch(regs.TCU) {
                        // CLV i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.V = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB9: new opcode_functions(opcode_matrix[0xB9],
            function(regs, pins) { // LDA a,y
                switch(regs.TCU) {
                        // LDA a,y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBA: new opcode_functions(opcode_matrix[0xBA],
            function(regs, pins) { // TSX i
                switch(regs.TCU) {
                        // TSX i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = (regs.S);
                        regs.P.Z = +((regs.S) === 0);
                        regs.P.N = ((regs.S) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBB: new opcode_functions(opcode_matrix[0xBB],
            function(regs, pins) { // TYX i
                switch(regs.TCU) {
                        // TYX i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = (regs.Y);
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBC: new opcode_functions(opcode_matrix[0xBC],
            function(regs, pins) { // LDY a,x
                switch(regs.TCU) {
                        // LDY a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.Y = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBD: new opcode_functions(opcode_matrix[0xBD],
            function(regs, pins) { // LDA a,x
                switch(regs.TCU) {
                        // LDA a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBE: new opcode_functions(opcode_matrix[0xBE],
            function(regs, pins) { // LDX a,y
                switch(regs.TCU) {
                        // LDX a,y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBF: new opcode_functions(opcode_matrix[0xBF],
            function(regs, pins) { // LDA al,x
                switch(regs.TCU) {
                        // LDA al,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC0: new opcode_functions(opcode_matrix[0xC0],
            function(regs, pins) { // CPY #
                switch(regs.TCU) {
                        // CPY # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.Y) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC1: new opcode_functions(opcode_matrix[0xC1],
            function(regs, pins) { // CMP (d,x)
                switch(regs.TCU) {
                        // CMP (d,x) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC2: new opcode_functions(opcode_matrix[0xC2],
            function(regs, pins) { // REP #
                switch(regs.TCU) {
                        // REP # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_native(regs.P.getbyte_native() & (~regs.TR & 0xFF));
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC3: new opcode_functions(opcode_matrix[0xC3],
            function(regs, pins) { // CMP d,s
                switch(regs.TCU) {
                        // CMP d,s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC4: new opcode_functions(opcode_matrix[0xC4],
            function(regs, pins) { // CPY d
                switch(regs.TCU) {
                        // CPY d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.Y) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC5: new opcode_functions(opcode_matrix[0xC5],
            function(regs, pins) { // CMP d
                switch(regs.TCU) {
                        // CMP d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC6: new opcode_functions(opcode_matrix[0xC6],
            function(regs, pins) { // DEC d
                switch(regs.TCU) {
                        // DEC d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC7: new opcode_functions(opcode_matrix[0xC7],
            function(regs, pins) { // CMP [d]
                switch(regs.TCU) {
                        // CMP [d] E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC8: new opcode_functions(opcode_matrix[0xC8],
            function(regs, pins) { // INY i
                switch(regs.TCU) {
                        // INY i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC9: new opcode_functions(opcode_matrix[0xC9],
            function(regs, pins) { // CMP #
                switch(regs.TCU) {
                        // CMP # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCA: new opcode_functions(opcode_matrix[0xCA],
            function(regs, pins) { // DEX i
                switch(regs.TCU) {
                        // DEX i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) - 1) & 0xFFFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCB: new opcode_functions(opcode_matrix[0xCB],
            function(regs, pins) { // WAI i
                switch(regs.TCU) {
                        // WAI i E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.WAI = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCC: new opcode_functions(opcode_matrix[0xCC],
            function(regs, pins) { // CPY a
                switch(regs.TCU) {
                        // CPY a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.Y) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xCD: new opcode_functions(opcode_matrix[0xCD],
            function(regs, pins) { // CMP a
                switch(regs.TCU) {
                        // CMP a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCE: new opcode_functions(opcode_matrix[0xCE],
            function(regs, pins) { // DEC a
                switch(regs.TCU) {
                        // DEC a E=0 M=1 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCF: new opcode_functions(opcode_matrix[0xCF],
            function(regs, pins) { // CMP al
                switch(regs.TCU) {
                        // CMP al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD0: new opcode_functions(opcode_matrix[0xD0],
            function(regs, pins) { // BNE r
                switch(regs.TCU) {
                        // BNE r E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD1: new opcode_functions(opcode_matrix[0xD1],
            function(regs, pins) { // CMP (d),y
                switch(regs.TCU) {
                        // CMP (d),y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD2: new opcode_functions(opcode_matrix[0xD2],
            function(regs, pins) { // CMP (d)
                switch(regs.TCU) {
                        // CMP (d) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD3: new opcode_functions(opcode_matrix[0xD3],
            function(regs, pins) { // CMP (d,s),y
                switch(regs.TCU) {
                        // CMP (d,s),y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD4: new opcode_functions(opcode_matrix[0xD4],
            function(regs, pins) { // PEI s
                switch(regs.TCU) {
                        // PEI s E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.D = regs.TR
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xD5: new opcode_functions(opcode_matrix[0xD5],
            function(regs, pins) { // CMP d,x
                switch(regs.TCU) {
                        // CMP d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD6: new opcode_functions(opcode_matrix[0xD6],
            function(regs, pins) { // DEC d,x
                switch(regs.TCU) {
                        // DEC d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD7: new opcode_functions(opcode_matrix[0xD7],
            function(regs, pins) { // CMP [d],y
                switch(regs.TCU) {
                        // CMP [d],y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD8: new opcode_functions(opcode_matrix[0xD8],
            function(regs, pins) { // CLD i
                switch(regs.TCU) {
                        // CLD i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD9: new opcode_functions(opcode_matrix[0xD9],
            function(regs, pins) { // CMP a,y
                switch(regs.TCU) {
                        // CMP a,y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDA: new opcode_functions(opcode_matrix[0xDA],
            function(regs, pins) { // PHX s
                switch(regs.TCU) {
                        // PHX s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.X);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xDB: new opcode_functions(opcode_matrix[0xDB],
            function(regs, pins) { // STP i
                switch(regs.TCU) {
                        // STP i E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.STP = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDC: new opcode_functions(opcode_matrix[0xDC],
            function(regs, pins) { // JML (a)
                switch(regs.TCU) {
                        // JML (a) E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.PC = regs.TR + (pins.D << 8);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDD: new opcode_functions(opcode_matrix[0xDD],
            function(regs, pins) { // CMP a,x
                switch(regs.TCU) {
                        // CMP a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDE: new opcode_functions(opcode_matrix[0xDE],
            function(regs, pins) { // DEC a,x
                switch(regs.TCU) {
                        // DEC a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDF: new opcode_functions(opcode_matrix[0xDF],
            function(regs, pins) { // CMP al,x
                switch(regs.TCU) {
                        // CMP al,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE0: new opcode_functions(opcode_matrix[0xE0],
            function(regs, pins) { // CPX #
                switch(regs.TCU) {
                        // CPX # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.X) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE1: new opcode_functions(opcode_matrix[0xE1],
            function(regs, pins) { // SBC (d,x)
                switch(regs.TCU) {
                        // SBC (d,x) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE2: new opcode_functions(opcode_matrix[0xE2],
            function(regs, pins) { // SEP #
                switch(regs.TCU) {
                        // SEP # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_native(regs.P.getbyte_native() | regs.TR);
                        if (regs.P.X) { regs.X &= 0xFF, regs.Y &= 0xFF; }
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE3: new opcode_functions(opcode_matrix[0xE3],
            function(regs, pins) { // SBC d,s
                switch(regs.TCU) {
                        // SBC d,s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE4: new opcode_functions(opcode_matrix[0xE4],
            function(regs, pins) { // CPX d
                switch(regs.TCU) {
                        // CPX d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.X) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE5: new opcode_functions(opcode_matrix[0xE5],
            function(regs, pins) { // SBC d
                switch(regs.TCU) {
                        // SBC d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE6: new opcode_functions(opcode_matrix[0xE6],
            function(regs, pins) { // INC d
                switch(regs.TCU) {
                        // INC d E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE7: new opcode_functions(opcode_matrix[0xE7],
            function(regs, pins) { // SBC [d]
                switch(regs.TCU) {
                        // SBC [d] E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE8: new opcode_functions(opcode_matrix[0xE8],
            function(regs, pins) { // INX i
                switch(regs.TCU) {
                        // INX i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) + 1) & 0xFFFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE9: new opcode_functions(opcode_matrix[0xE9],
            function(regs, pins) { // SBC #
                switch(regs.TCU) {
                        // SBC # E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEA: new opcode_functions(opcode_matrix[0xEA],
            function(regs, pins) { // NOP i
                switch(regs.TCU) {
                        // NOP i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEB: new opcode_functions(opcode_matrix[0xEB],
            function(regs, pins) { // XBA i
                switch(regs.TCU) {
                        // XBA i E=0 M=1 X=0
                    case 1:
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2:
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >>> 8) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEC: new opcode_functions(opcode_matrix[0xEC],
            function(regs, pins) { // CPX a
                switch(regs.TCU) {
                        // CPX a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // finish_R16p
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += pins.D << 8;
                        // instruction code follows
                        regs.TR = (regs.X) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xED: new opcode_functions(opcode_matrix[0xED],
            function(regs, pins) { // SBC a
                switch(regs.TCU) {
                        // SBC a E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEE: new opcode_functions(opcode_matrix[0xEE],
            function(regs, pins) { // INC a
                switch(regs.TCU) {
                        // INC a E=0 M=1 X=0
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEF: new opcode_functions(opcode_matrix[0xEF],
            function(regs, pins) { // SBC al
                switch(regs.TCU) {
                        // SBC al E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF0: new opcode_functions(opcode_matrix[0xF0],
            function(regs, pins) { // BEQ r
                switch(regs.TCU) {
                        // BEQ r E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF1: new opcode_functions(opcode_matrix[0xF1],
            function(regs, pins) { // SBC (d),y
                switch(regs.TCU) {
                        // SBC (d),y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF2: new opcode_functions(opcode_matrix[0xF2],
            function(regs, pins) { // SBC (d)
                switch(regs.TCU) {
                        // SBC (d) E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF3: new opcode_functions(opcode_matrix[0xF3],
            function(regs, pins) { // SBC (d,s),y
                switch(regs.TCU) {
                        // SBC (d,s),y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF4: new opcode_functions(opcode_matrix[0xF4],
            function(regs, pins) { // PEA s
                switch(regs.TCU) {
                        // PEA s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xF5: new opcode_functions(opcode_matrix[0xF5],
            function(regs, pins) { // SBC d,x
                switch(regs.TCU) {
                        // SBC d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF6: new opcode_functions(opcode_matrix[0xF6],
            function(regs, pins) { // INC d,x
                switch(regs.TCU) {
                        // INC d,x E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF7: new opcode_functions(opcode_matrix[0xF7],
            function(regs, pins) { // SBC [d],y
                switch(regs.TCU) {
                        // SBC [d],y E=0 M=1 X=0
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF8: new opcode_functions(opcode_matrix[0xF8],
            function(regs, pins) { // SED i
                switch(regs.TCU) {
                        // SED i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF9: new opcode_functions(opcode_matrix[0xF9],
            function(regs, pins) { // SBC a,y
                switch(regs.TCU) {
                        // SBC a,y E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFA: new opcode_functions(opcode_matrix[0xFA],
            function(regs, pins) { // PLX s
                switch(regs.TCU) {
                        // PLX s E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.X = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xFB: new opcode_functions(opcode_matrix[0xFB],
            function(regs, pins) { // XCE i
                switch(regs.TCU) {
                        // XCE i E=0 M=1 X=0
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        let TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
                        if (regs.E) {
                            regs.P.X = regs.P.M = 1;
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                            regs.S = (regs.S & 0xFF) | 0x100;
                        }
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xFC: new opcode_functions(opcode_matrix[0xFC],
            function(regs, pins) { // JSR (a,x)
                switch(regs.TCU) {
                        // JSR (a,x) E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.RW = 1;
                        regs.TA = pins.D;
                        pins.D = ((regs.PC) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 4
                        pins.D = (regs.PC) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 6: // 7
                        pins.PDV = 1;
                        pins.Addr = regs.TA;
                        break;
                    case 7: // 8
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.PC = pins.D;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xFD: new opcode_functions(opcode_matrix[0xFD],
            function(regs, pins) { // SBC a,x
                switch(regs.TCU) {
                        // SBC a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFE: new opcode_functions(opcode_matrix[0xFE],
            function(regs, pins) { // INC a,x
                switch(regs.TCU) {
                        // INC a,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFF: new opcode_functions(opcode_matrix[0xFF],
            function(regs, pins) { // SBC al,x
                switch(regs.TCU) {
                        // SBC al,x E=0 M=1 X=0
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x100: new opcode_functions(opcode_matrix[0x100],
            function(regs, pins) { // S_RESET s
                switch(regs.TCU) {
                        // S_RESET s E=0 M=1 X=0
                    case 1: // 3
                        pins.RW = 0; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFFC); pins.BA = (0);
                        regs.DBR = 0;
                        regs.D = 0;
                        regs.PBR = 0;
                        regs.X &= 0xFF;
                        regs.Y &= 0xFF;
                        regs.S = (regs.S & 0xFF) | 0x100;
                        regs.E = 1;
                        regs.P.M = regs.P.X = regs.P.I = regs.P.C = 1;
                        regs.P.D = 0;
                        regs.STP = regs.WAI = false;
                        break;
                    case 6: // 8
                        regs.PC = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        pins.PDV = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x101: new opcode_functions(opcode_matrix[0x101],
            function(regs, pins) { // S_ABORT s
                switch(regs.TCU) {
                        // S_ABORT s E=0 M=1 X=0
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFE8); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFE9); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x102: new opcode_functions(opcode_matrix[0x102],
            function(regs, pins) { // S_IRQ s
                switch(regs.TCU) {
                        // S_IRQ s E=0 M=1 X=0
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFEE); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFEF); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x103: new opcode_functions(opcode_matrix[0x103],
            function(regs, pins) { // S_NMI s
                switch(regs.TCU) {
                        // S_NMI s E=0 M=1 X=0
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFEA); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFEB); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false)
},
    // E0 M1 X1
    6: {
        0x00: new opcode_functions(opcode_matrix[0x00],
            function(regs, pins) { // BRK s
                switch(regs.TCU) {
                        // BRK s E=0 M=1 X=1
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 3: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 6: // 7
                        pins.Addr = (0xFFE6); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 7: // 8
                        pins.Addr = (0xFFE7); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x01: new opcode_functions(opcode_matrix[0x01],
            function(regs, pins) { // ORA (d,x)
                switch(regs.TCU) {
                        // ORA (d,x) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x02: new opcode_functions(opcode_matrix[0x02],
            function(regs, pins) { // COP s
                switch(regs.TCU) {
                        // COP s E=0 M=1 X=1
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 3: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 6: // 7
                        pins.Addr = (0xFFE4); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 7: // 8
                        pins.Addr = (0xFFE5); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x03: new opcode_functions(opcode_matrix[0x03],
            function(regs, pins) { // ORA d,s
                switch(regs.TCU) {
                        // ORA d,s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x04: new opcode_functions(opcode_matrix[0x04],
            function(regs, pins) { // TSB d
                switch(regs.TCU) {
                        // TSB d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x05: new opcode_functions(opcode_matrix[0x05],
            function(regs, pins) { // ORA d
                switch(regs.TCU) {
                        // ORA d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x06: new opcode_functions(opcode_matrix[0x06],
            function(regs, pins) { // ASL d
                switch(regs.TCU) {
                        // ASL d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x07: new opcode_functions(opcode_matrix[0x07],
            function(regs, pins) { // ORA [d]
                switch(regs.TCU) {
                        // ORA [d] E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x08: new opcode_functions(opcode_matrix[0x08],
            function(regs, pins) { // PHP s
                switch(regs.TCU) {
                        // PHP s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.P.getbyte_native();
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x09: new opcode_functions(opcode_matrix[0x09],
            function(regs, pins) { // ORA #
                switch(regs.TCU) {
                        // ORA # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0A: new opcode_functions(opcode_matrix[0x0A],
            function(regs, pins) { // ASL A
                switch(regs.TCU) {
                        // ASL A E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0B: new opcode_functions(opcode_matrix[0x0B],
            function(regs, pins) { // PHD s
                switch(regs.TCU) {
                        // PHD s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.D);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x0C: new opcode_functions(opcode_matrix[0x0C],
            function(regs, pins) { // TSB a
                switch(regs.TCU) {
                        // TSB a E=0 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0D: new opcode_functions(opcode_matrix[0x0D],
            function(regs, pins) { // ORA a
                switch(regs.TCU) {
                        // ORA a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0E: new opcode_functions(opcode_matrix[0x0E],
            function(regs, pins) { // ASL a
                switch(regs.TCU) {
                        // ASL a E=0 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0F: new opcode_functions(opcode_matrix[0x0F],
            function(regs, pins) { // ORA al
                switch(regs.TCU) {
                        // ORA al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x10: new opcode_functions(opcode_matrix[0x10],
            function(regs, pins) { // BPL r
                switch(regs.TCU) {
                        // BPL r E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x11: new opcode_functions(opcode_matrix[0x11],
            function(regs, pins) { // ORA (d),y
                switch(regs.TCU) {
                        // ORA (d),y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x12: new opcode_functions(opcode_matrix[0x12],
            function(regs, pins) { // ORA (d)
                switch(regs.TCU) {
                        // ORA (d) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x13: new opcode_functions(opcode_matrix[0x13],
            function(regs, pins) { // ORA (d,s),y
                switch(regs.TCU) {
                        // ORA (d,s),y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x14: new opcode_functions(opcode_matrix[0x14],
            function(regs, pins) { // TRB d
                switch(regs.TCU) {
                        // TRB d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x15: new opcode_functions(opcode_matrix[0x15],
            function(regs, pins) { // ORA d,x
                switch(regs.TCU) {
                        // ORA d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x16: new opcode_functions(opcode_matrix[0x16],
            function(regs, pins) { // ASL d,x
                switch(regs.TCU) {
                        // ASL d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x17: new opcode_functions(opcode_matrix[0x17],
            function(regs, pins) { // ORA [d],y
                switch(regs.TCU) {
                        // ORA [d],y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x18: new opcode_functions(opcode_matrix[0x18],
            function(regs, pins) { // CLC i
                switch(regs.TCU) {
                        // CLC i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x19: new opcode_functions(opcode_matrix[0x19],
            function(regs, pins) { // ORA a,y
                switch(regs.TCU) {
                        // ORA a,y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1A: new opcode_functions(opcode_matrix[0x1A],
            function(regs, pins) { // INC A
                switch(regs.TCU) {
                        // INC A E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1B: new opcode_functions(opcode_matrix[0x1B],
            function(regs, pins) { // TCS i
                switch(regs.TCU) {
                        // TCS i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.C;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x1C: new opcode_functions(opcode_matrix[0x1C],
            function(regs, pins) { // TRB a
                switch(regs.TCU) {
                        // TRB a E=0 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1D: new opcode_functions(opcode_matrix[0x1D],
            function(regs, pins) { // ORA a,x
                switch(regs.TCU) {
                        // ORA a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1E: new opcode_functions(opcode_matrix[0x1E],
            function(regs, pins) { // ASL a,x
                switch(regs.TCU) {
                        // ASL a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1F: new opcode_functions(opcode_matrix[0x1F],
            function(regs, pins) { // ORA al,x
                switch(regs.TCU) {
                        // ORA al,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x20: new opcode_functions(opcode_matrix[0x20],
            function(regs, pins) { // JSR a
                switch(regs.TCU) {
                        // JSR a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.PDV = 0;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 6
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x21: new opcode_functions(opcode_matrix[0x21],
            function(regs, pins) { // AND (d,x)
                switch(regs.TCU) {
                        // AND (d,x) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x22: new opcode_functions(opcode_matrix[0x22],
            function(regs, pins) { // JSL al
                switch(regs.TCU) {
                        // JSL al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        regs.TA += pins.D << 8;
                        pins.D = (regs.PBR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 1;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 6: // 7
                        regs.PBR = pins.D;
                        pins.RW = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF;
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 7: // 8
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x23: new opcode_functions(opcode_matrix[0x23],
            function(regs, pins) { // AND d,s
                switch(regs.TCU) {
                        // AND d,s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x24: new opcode_functions(opcode_matrix[0x24],
            function(regs, pins) { // BIT d
                switch(regs.TCU) {
                        // BIT d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x25: new opcode_functions(opcode_matrix[0x25],
            function(regs, pins) { // AND d
                switch(regs.TCU) {
                        // AND d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x26: new opcode_functions(opcode_matrix[0x26],
            function(regs, pins) { // ROL d
                switch(regs.TCU) {
                        // ROL d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x27: new opcode_functions(opcode_matrix[0x27],
            function(regs, pins) { // AND [d]
                switch(regs.TCU) {
                        // AND [d] E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x28: new opcode_functions(opcode_matrix[0x28],
            function(regs, pins) { // PLP s
                switch(regs.TCU) {
                        // PLP s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.setbyte_native(regs.TR);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x29: new opcode_functions(opcode_matrix[0x29],
            function(regs, pins) { // AND #
                switch(regs.TCU) {
                        // AND # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2A: new opcode_functions(opcode_matrix[0x2A],
            function(regs, pins) { // ROL A
                switch(regs.TCU) {
                        // ROL A E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2B: new opcode_functions(opcode_matrix[0x2B],
            function(regs, pins) { // PLD s
                switch(regs.TCU) {
                        // PLD s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        // instruction code follows
                        regs.D = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x2C: new opcode_functions(opcode_matrix[0x2C],
            function(regs, pins) { // BIT a
                switch(regs.TCU) {
                        // BIT a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2D: new opcode_functions(opcode_matrix[0x2D],
            function(regs, pins) { // AND a
                switch(regs.TCU) {
                        // AND a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2E: new opcode_functions(opcode_matrix[0x2E],
            function(regs, pins) { // ROL a
                switch(regs.TCU) {
                        // ROL a E=0 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2F: new opcode_functions(opcode_matrix[0x2F],
            function(regs, pins) { // AND al
                switch(regs.TCU) {
                        // AND al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x30: new opcode_functions(opcode_matrix[0x30],
            function(regs, pins) { // BMI r
                switch(regs.TCU) {
                        // BMI r E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x31: new opcode_functions(opcode_matrix[0x31],
            function(regs, pins) { // AND (d),y
                switch(regs.TCU) {
                        // AND (d),y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x32: new opcode_functions(opcode_matrix[0x32],
            function(regs, pins) { // AND (d)
                switch(regs.TCU) {
                        // AND (d) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x33: new opcode_functions(opcode_matrix[0x33],
            function(regs, pins) { // AND (d,s),y
                switch(regs.TCU) {
                        // AND (d,s),y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x34: new opcode_functions(opcode_matrix[0x34],
            function(regs, pins) { // BIT d,x
                switch(regs.TCU) {
                        // BIT d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x35: new opcode_functions(opcode_matrix[0x35],
            function(regs, pins) { // AND d,x
                switch(regs.TCU) {
                        // AND d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x36: new opcode_functions(opcode_matrix[0x36],
            function(regs, pins) { // ROL d,x
                switch(regs.TCU) {
                        // ROL d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x37: new opcode_functions(opcode_matrix[0x37],
            function(regs, pins) { // AND [d],y
                switch(regs.TCU) {
                        // AND [d],y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x38: new opcode_functions(opcode_matrix[0x38],
            function(regs, pins) { // SEC i
                switch(regs.TCU) {
                        // SEC i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x39: new opcode_functions(opcode_matrix[0x39],
            function(regs, pins) { // AND a,y
                switch(regs.TCU) {
                        // AND a,y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3A: new opcode_functions(opcode_matrix[0x3A],
            function(regs, pins) { // DEC A
                switch(regs.TCU) {
                        // DEC A E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3B: new opcode_functions(opcode_matrix[0x3B],
            function(regs, pins) { // TSC i
                switch(regs.TCU) {
                        // TSC i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.S);
                        regs.P.Z = +((regs.S) === 0);
                        regs.P.N = ((regs.S) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x3C: new opcode_functions(opcode_matrix[0x3C],
            function(regs, pins) { // BIT a,x
                switch(regs.TCU) {
                        // BIT a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3D: new opcode_functions(opcode_matrix[0x3D],
            function(regs, pins) { // AND a,x
                switch(regs.TCU) {
                        // AND a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3E: new opcode_functions(opcode_matrix[0x3E],
            function(regs, pins) { // ROL a,x
                switch(regs.TCU) {
                        // ROL a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3F: new opcode_functions(opcode_matrix[0x3F],
            function(regs, pins) { // AND al,x
                switch(regs.TCU) {
                        // AND al,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x40: new opcode_functions(opcode_matrix[0x40],
            function(regs, pins) { // RTI s
                switch(regs.TCU) {
                        // RTI s E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        pins.PDV = 1;
                        break;
                    case 4: // 5
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.P.setbyte_native(pins.D);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        if (regs.P.E) regs.S = (regs.S & 0xFF) | 0x100;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.TA = pins.D;
                        break;
                    case 6: // 7
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.TA += pins.D << 8;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TA;
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x41: new opcode_functions(opcode_matrix[0x41],
            function(regs, pins) { // EOR (d,x)
                switch(regs.TCU) {
                        // EOR (d,x) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x42: new opcode_functions(opcode_matrix[0x42],
            function(regs, pins) { // WDM i
                switch(regs.TCU) {
                        // WDM i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x43: new opcode_functions(opcode_matrix[0x43],
            function(regs, pins) { // EOR d,s
                switch(regs.TCU) {
                        // EOR d,s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x44: new opcode_functions(opcode_matrix[0x44],
            function(regs, pins) { // MVP xyc
                switch(regs.TCU) {
                        // MVP xyc E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D
                        pins.Addr = (regs.X); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X - 1) & 0xFF;
                        regs.Y = (regs.Y - 1) & 0xFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x45: new opcode_functions(opcode_matrix[0x45],
            function(regs, pins) { // EOR d
                switch(regs.TCU) {
                        // EOR d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x46: new opcode_functions(opcode_matrix[0x46],
            function(regs, pins) { // LSR d
                switch(regs.TCU) {
                        // LSR d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x47: new opcode_functions(opcode_matrix[0x47],
            function(regs, pins) { // EOR [d]
                switch(regs.TCU) {
                        // EOR [d] E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x48: new opcode_functions(opcode_matrix[0x48],
            function(regs, pins) { // PHA s
                switch(regs.TCU) {
                        // PHA s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.C) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x49: new opcode_functions(opcode_matrix[0x49],
            function(regs, pins) { // EOR #
                switch(regs.TCU) {
                        // EOR # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4A: new opcode_functions(opcode_matrix[0x4A],
            function(regs, pins) { // LSR A
                switch(regs.TCU) {
                        // LSR A E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4B: new opcode_functions(opcode_matrix[0x4B],
            function(regs, pins) { // PHK s
                switch(regs.TCU) {
                        // PHK s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.PBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4C: new opcode_functions(opcode_matrix[0x4C],
            function(regs, pins) { // JMP a
                switch(regs.TCU) {
                        // JMP a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4D: new opcode_functions(opcode_matrix[0x4D],
            function(regs, pins) { // EOR a
                switch(regs.TCU) {
                        // EOR a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4E: new opcode_functions(opcode_matrix[0x4E],
            function(regs, pins) { // LSR a
                switch(regs.TCU) {
                        // LSR a E=0 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4F: new opcode_functions(opcode_matrix[0x4F],
            function(regs, pins) { // EOR al
                switch(regs.TCU) {
                        // EOR al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x50: new opcode_functions(opcode_matrix[0x50],
            function(regs, pins) { // BVC r
                switch(regs.TCU) {
                        // BVC r E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x51: new opcode_functions(opcode_matrix[0x51],
            function(regs, pins) { // EOR (d),y
                switch(regs.TCU) {
                        // EOR (d),y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x52: new opcode_functions(opcode_matrix[0x52],
            function(regs, pins) { // EOR (d)
                switch(regs.TCU) {
                        // EOR (d) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x53: new opcode_functions(opcode_matrix[0x53],
            function(regs, pins) { // EOR (d,s),y
                switch(regs.TCU) {
                        // EOR (d,s),y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x54: new opcode_functions(opcode_matrix[0x54],
            function(regs, pins) { // MVN xyc
                switch(regs.TCU) {
                        // MVN xyc E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D;
                        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X + 1) & 0xFF;
                        regs.Y = (regs.Y + 1) & 0xFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x55: new opcode_functions(opcode_matrix[0x55],
            function(regs, pins) { // EOR d,x
                switch(regs.TCU) {
                        // EOR d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x56: new opcode_functions(opcode_matrix[0x56],
            function(regs, pins) { // LSR d,x
                switch(regs.TCU) {
                        // LSR d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x57: new opcode_functions(opcode_matrix[0x57],
            function(regs, pins) { // EOR [d],y
                switch(regs.TCU) {
                        // EOR [d],y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x58: new opcode_functions(opcode_matrix[0x58],
            function(regs, pins) { // CLI i
                switch(regs.TCU) {
                        // CLI i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 0;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x59: new opcode_functions(opcode_matrix[0x59],
            function(regs, pins) { // EOR a,y
                switch(regs.TCU) {
                        // EOR a,y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5A: new opcode_functions(opcode_matrix[0x5A],
            function(regs, pins) { // PHY s
                switch(regs.TCU) {
                        // PHY s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.Y) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x5B: new opcode_functions(opcode_matrix[0x5B],
            function(regs, pins) { // TCD i
                switch(regs.TCU) {
                        // TCD i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.D = (regs.C);
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5C: new opcode_functions(opcode_matrix[0x5C],
            function(regs, pins) { // JMP al
                switch(regs.TCU) {
                        // JMP al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = regs.TA + (pins.D << 8);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5D: new opcode_functions(opcode_matrix[0x5D],
            function(regs, pins) { // EOR a,x
                switch(regs.TCU) {
                        // EOR a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5E: new opcode_functions(opcode_matrix[0x5E],
            function(regs, pins) { // LSR a,x
                switch(regs.TCU) {
                        // LSR a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5F: new opcode_functions(opcode_matrix[0x5F],
            function(regs, pins) { // EOR al,x
                switch(regs.TCU) {
                        // EOR al,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x60: new opcode_functions(opcode_matrix[0x60],
            function(regs, pins) { // RTS s
                switch(regs.TCU) {
                        // RTS s E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x61: new opcode_functions(opcode_matrix[0x61],
            function(regs, pins) { // ADC (d,x)
                switch(regs.TCU) {
                        // ADC (d,x) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x62: new opcode_functions(opcode_matrix[0x62],
            function(regs, pins) { // PER s
                switch(regs.TCU) {
                        // PER s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x63: new opcode_functions(opcode_matrix[0x63],
            function(regs, pins) { // ADC d,s
                switch(regs.TCU) {
                        // ADC d,s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x64: new opcode_functions(opcode_matrix[0x64],
            function(regs, pins) { // STZ d
                switch(regs.TCU) {
                        // STZ d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x65: new opcode_functions(opcode_matrix[0x65],
            function(regs, pins) { // ADC d
                switch(regs.TCU) {
                        // ADC d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x66: new opcode_functions(opcode_matrix[0x66],
            function(regs, pins) { // ROR d
                switch(regs.TCU) {
                        // ROR d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x67: new opcode_functions(opcode_matrix[0x67],
            function(regs, pins) { // ADC [d]
                switch(regs.TCU) {
                        // ADC [d] E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x68: new opcode_functions(opcode_matrix[0x68],
            function(regs, pins) { // PLA s
                switch(regs.TCU) {
                        // PLA s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x69: new opcode_functions(opcode_matrix[0x69],
            function(regs, pins) { // ADC #
                switch(regs.TCU) {
                        // ADC # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6A: new opcode_functions(opcode_matrix[0x6A],
            function(regs, pins) { // ROR A
                switch(regs.TCU) {
                        // ROR A E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6B: new opcode_functions(opcode_matrix[0x6B],
            function(regs, pins) { // RTL s
                switch(regs.TCU) {
                        // RTL s E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x6C: new opcode_functions(opcode_matrix[0x6C],
            function(regs, pins) { // JMP (a)
                switch(regs.TCU) {
                        // JMP (a) E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x6D: new opcode_functions(opcode_matrix[0x6D],
            function(regs, pins) { // ADC a
                switch(regs.TCU) {
                        // ADC a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6E: new opcode_functions(opcode_matrix[0x6E],
            function(regs, pins) { // ROR a
                switch(regs.TCU) {
                        // ROR a E=0 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6F: new opcode_functions(opcode_matrix[0x6F],
            function(regs, pins) { // ADC al
                switch(regs.TCU) {
                        // ADC al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x70: new opcode_functions(opcode_matrix[0x70],
            function(regs, pins) { // BVS r
                switch(regs.TCU) {
                        // BVS r E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x71: new opcode_functions(opcode_matrix[0x71],
            function(regs, pins) { // ADC (d),y
                switch(regs.TCU) {
                        // ADC (d),y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x72: new opcode_functions(opcode_matrix[0x72],
            function(regs, pins) { // ADC (d)
                switch(regs.TCU) {
                        // ADC (d) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x73: new opcode_functions(opcode_matrix[0x73],
            function(regs, pins) { // ADC (d,s),y
                switch(regs.TCU) {
                        // ADC (d,s),y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x74: new opcode_functions(opcode_matrix[0x74],
            function(regs, pins) { // STZ d,x
                switch(regs.TCU) {
                        // STZ d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x75: new opcode_functions(opcode_matrix[0x75],
            function(regs, pins) { // ADC d,x
                switch(regs.TCU) {
                        // ADC d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x76: new opcode_functions(opcode_matrix[0x76],
            function(regs, pins) { // ROR d,x
                switch(regs.TCU) {
                        // ROR d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x77: new opcode_functions(opcode_matrix[0x77],
            function(regs, pins) { // ADC [d],y
                switch(regs.TCU) {
                        // ADC [d],y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x78: new opcode_functions(opcode_matrix[0x78],
            function(regs, pins) { // SEI i
                switch(regs.TCU) {
                        // SEI i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 1;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x79: new opcode_functions(opcode_matrix[0x79],
            function(regs, pins) { // ADC a,y
                switch(regs.TCU) {
                        // ADC a,y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7A: new opcode_functions(opcode_matrix[0x7A],
            function(regs, pins) { // PLY s
                switch(regs.TCU) {
                        // PLY s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x7B: new opcode_functions(opcode_matrix[0x7B],
            function(regs, pins) { // TDC i
                switch(regs.TCU) {
                        // TDC i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.D);
                        regs.P.Z = +((regs.D) === 0);
                        regs.P.N = ((regs.D) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7C: new opcode_functions(opcode_matrix[0x7C],
            function(regs, pins) { // JMP (a,x)
                switch(regs.TCU) {
                        // JMP (a,x) E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        regs.TA = (regs.X + regs.TA) & 0xFFFF;
                        pins.PDV = 0;
                        break;
                    case 4:
                        pins.PDV = 1;
                        pins.Addr = regs.TA; pins.BA = regs.PBR;
                        break;
                    case 5:
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7D: new opcode_functions(opcode_matrix[0x7D],
            function(regs, pins) { // ADC a,x
                switch(regs.TCU) {
                        // ADC a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7E: new opcode_functions(opcode_matrix[0x7E],
            function(regs, pins) { // ROR a,x
                switch(regs.TCU) {
                        // ROR a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7F: new opcode_functions(opcode_matrix[0x7F],
            function(regs, pins) { // ADC al,x
                switch(regs.TCU) {
                        // ADC al,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x80: new opcode_functions(opcode_matrix[0x80],
            function(regs, pins) { // BRA r
                switch(regs.TCU) {
                        // BRA r E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = true;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x81: new opcode_functions(opcode_matrix[0x81],
            function(regs, pins) { // STA (d,x)
                switch(regs.TCU) {
                        // STA (d,x) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x82: new opcode_functions(opcode_matrix[0x82],
            function(regs, pins) { // BRL rl
                switch(regs.TCU) {
                        // BRL rl E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TA = mksigned16(regs.TA + (pins.D << 8));
                        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x83: new opcode_functions(opcode_matrix[0x83],
            function(regs, pins) { // STA d,s
                switch(regs.TCU) {
                        // STA d,s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x84: new opcode_functions(opcode_matrix[0x84],
            function(regs, pins) { // STY d
                switch(regs.TCU) {
                        // STY d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x85: new opcode_functions(opcode_matrix[0x85],
            function(regs, pins) { // STA d
                switch(regs.TCU) {
                        // STA d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x86: new opcode_functions(opcode_matrix[0x86],
            function(regs, pins) { // STX d
                switch(regs.TCU) {
                        // STX d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x87: new opcode_functions(opcode_matrix[0x87],
            function(regs, pins) { // STA [d]
                switch(regs.TCU) {
                        // STA [d] E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x88: new opcode_functions(opcode_matrix[0x88],
            function(regs, pins) { // DEY i
                switch(regs.TCU) {
                        // DEY i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) - 1) & 0xFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x89: new opcode_functions(opcode_matrix[0x89],
            function(regs, pins) { // BIT #
                switch(regs.TCU) {
                        // BIT # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8A: new opcode_functions(opcode_matrix[0x8A],
            function(regs, pins) { // TXA i
                switch(regs.TCU) {
                        // TXA i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.X) & 0xFF);
                        regs.P.Z = +((regs.X & 0xFF) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8B: new opcode_functions(opcode_matrix[0x8B],
            function(regs, pins) { // PHB s
                switch(regs.TCU) {
                        // PHB s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.DBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8C: new opcode_functions(opcode_matrix[0x8C],
            function(regs, pins) { // STY a
                switch(regs.TCU) {
                        // STY a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.Y & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8D: new opcode_functions(opcode_matrix[0x8D],
            function(regs, pins) { // STA a
                switch(regs.TCU) {
                        // STA a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8E: new opcode_functions(opcode_matrix[0x8E],
            function(regs, pins) { // STX a
                switch(regs.TCU) {
                        // STX a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.X & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8F: new opcode_functions(opcode_matrix[0x8F],
            function(regs, pins) { // STA al
                switch(regs.TCU) {
                        // STA al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x90: new opcode_functions(opcode_matrix[0x90],
            function(regs, pins) { // BCC r
                switch(regs.TCU) {
                        // BCC r E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x91: new opcode_functions(opcode_matrix[0x91],
            function(regs, pins) { // STA (d),y
                switch(regs.TCU) {
                        // STA (d),y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x92: new opcode_functions(opcode_matrix[0x92],
            function(regs, pins) { // STA (d)
                switch(regs.TCU) {
                        // STA (d) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x93: new opcode_functions(opcode_matrix[0x93],
            function(regs, pins) { // STA (d,s),y
                switch(regs.TCU) {
                        // STA (d,s),y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x94: new opcode_functions(opcode_matrix[0x94],
            function(regs, pins) { // STY d,x
                switch(regs.TCU) {
                        // STY d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x95: new opcode_functions(opcode_matrix[0x95],
            function(regs, pins) { // STA d,x
                switch(regs.TCU) {
                        // STA d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x96: new opcode_functions(opcode_matrix[0x96],
            function(regs, pins) { // STX d,y
                switch(regs.TCU) {
                        // STX d,y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x97: new opcode_functions(opcode_matrix[0x97],
            function(regs, pins) { // STA [d],y
                switch(regs.TCU) {
                        // STA [d],y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x98: new opcode_functions(opcode_matrix[0x98],
            function(regs, pins) { // TYA i
                switch(regs.TCU) {
                        // TYA i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.Y) & 0xFF);
                        regs.P.Z = +((regs.Y & 0xFF) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x99: new opcode_functions(opcode_matrix[0x99],
            function(regs, pins) { // STA a,y
                switch(regs.TCU) {
                        // STA a,y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9A: new opcode_functions(opcode_matrix[0x9A],
            function(regs, pins) { // TXS i
                switch(regs.TCU) {
                        // TXS i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.X
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9B: new opcode_functions(opcode_matrix[0x9B],
            function(regs, pins) { // TXY i
                switch(regs.TCU) {
                        // TXY i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.X) & 0xFF);
                        regs.P.Z = +((regs.X & 0xFF) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9C: new opcode_functions(opcode_matrix[0x9C],
            function(regs, pins) { // STZ a
                switch(regs.TCU) {
                        // STZ a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9D: new opcode_functions(opcode_matrix[0x9D],
            function(regs, pins) { // STA a,x
                switch(regs.TCU) {
                        // STA a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9E: new opcode_functions(opcode_matrix[0x9E],
            function(regs, pins) { // STZ a,x
                switch(regs.TCU) {
                        // STZ a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9F: new opcode_functions(opcode_matrix[0x9F],
            function(regs, pins) { // STA al,x
                switch(regs.TCU) {
                        // STA al,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA0: new opcode_functions(opcode_matrix[0xA0],
            function(regs, pins) { // LDY #
                switch(regs.TCU) {
                        // LDY # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA1: new opcode_functions(opcode_matrix[0xA1],
            function(regs, pins) { // LDA (d,x)
                switch(regs.TCU) {
                        // LDA (d,x) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA2: new opcode_functions(opcode_matrix[0xA2],
            function(regs, pins) { // LDX #
                switch(regs.TCU) {
                        // LDX # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA3: new opcode_functions(opcode_matrix[0xA3],
            function(regs, pins) { // LDA d,s
                switch(regs.TCU) {
                        // LDA d,s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA4: new opcode_functions(opcode_matrix[0xA4],
            function(regs, pins) { // LDY d
                switch(regs.TCU) {
                        // LDY d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA5: new opcode_functions(opcode_matrix[0xA5],
            function(regs, pins) { // LDA d
                switch(regs.TCU) {
                        // LDA d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA6: new opcode_functions(opcode_matrix[0xA6],
            function(regs, pins) { // LDX d
                switch(regs.TCU) {
                        // LDX d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA7: new opcode_functions(opcode_matrix[0xA7],
            function(regs, pins) { // LDA [d]
                switch(regs.TCU) {
                        // LDA [d] E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA8: new opcode_functions(opcode_matrix[0xA8],
            function(regs, pins) { // TAY i
                switch(regs.TCU) {
                        // TAY i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.C) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xA9: new opcode_functions(opcode_matrix[0xA9],
            function(regs, pins) { // LDA #
                switch(regs.TCU) {
                        // LDA # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAA: new opcode_functions(opcode_matrix[0xAA],
            function(regs, pins) { // TAX i
                switch(regs.TCU) {
                        // TAX i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.C) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAB: new opcode_functions(opcode_matrix[0xAB],
            function(regs, pins) { // PLB s
                switch(regs.TCU) {
                        // PLB s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAC: new opcode_functions(opcode_matrix[0xAC],
            function(regs, pins) { // LDY a
                switch(regs.TCU) {
                        // LDY a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAD: new opcode_functions(opcode_matrix[0xAD],
            function(regs, pins) { // LDA a
                switch(regs.TCU) {
                        // LDA a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAE: new opcode_functions(opcode_matrix[0xAE],
            function(regs, pins) { // LDX a
                switch(regs.TCU) {
                        // LDX a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAF: new opcode_functions(opcode_matrix[0xAF],
            function(regs, pins) { // LDA al
                switch(regs.TCU) {
                        // LDA al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB0: new opcode_functions(opcode_matrix[0xB0],
            function(regs, pins) { // BCS r
                switch(regs.TCU) {
                        // BCS r E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB1: new opcode_functions(opcode_matrix[0xB1],
            function(regs, pins) { // LDA (d),y
                switch(regs.TCU) {
                        // LDA (d),y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB2: new opcode_functions(opcode_matrix[0xB2],
            function(regs, pins) { // LDA (d)
                switch(regs.TCU) {
                        // LDA (d) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB3: new opcode_functions(opcode_matrix[0xB3],
            function(regs, pins) { // LDA (d,s),y
                switch(regs.TCU) {
                        // LDA (d,s),y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB4: new opcode_functions(opcode_matrix[0xB4],
            function(regs, pins) { // LDY d,x
                switch(regs.TCU) {
                        // LDY d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB5: new opcode_functions(opcode_matrix[0xB5],
            function(regs, pins) { // LDA d,x
                switch(regs.TCU) {
                        // LDA d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB6: new opcode_functions(opcode_matrix[0xB6],
            function(regs, pins) { // LDX d,y
                switch(regs.TCU) {
                        // LDX d,y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB7: new opcode_functions(opcode_matrix[0xB7],
            function(regs, pins) { // LDA [d],y
                switch(regs.TCU) {
                        // LDA [d],y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB8: new opcode_functions(opcode_matrix[0xB8],
            function(regs, pins) { // CLV i
                switch(regs.TCU) {
                        // CLV i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.V = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB9: new opcode_functions(opcode_matrix[0xB9],
            function(regs, pins) { // LDA a,y
                switch(regs.TCU) {
                        // LDA a,y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBA: new opcode_functions(opcode_matrix[0xBA],
            function(regs, pins) { // TSX i
                switch(regs.TCU) {
                        // TSX i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X  = regs.S & 0xFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBB: new opcode_functions(opcode_matrix[0xBB],
            function(regs, pins) { // TYX i
                switch(regs.TCU) {
                        // TYX i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.Y) & 0xFF);
                        regs.P.Z = +((regs.Y & 0xFF) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBC: new opcode_functions(opcode_matrix[0xBC],
            function(regs, pins) { // LDY a,x
                switch(regs.TCU) {
                        // LDY a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBD: new opcode_functions(opcode_matrix[0xBD],
            function(regs, pins) { // LDA a,x
                switch(regs.TCU) {
                        // LDA a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBE: new opcode_functions(opcode_matrix[0xBE],
            function(regs, pins) { // LDX a,y
                switch(regs.TCU) {
                        // LDX a,y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBF: new opcode_functions(opcode_matrix[0xBF],
            function(regs, pins) { // LDA al,x
                switch(regs.TCU) {
                        // LDA al,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC0: new opcode_functions(opcode_matrix[0xC0],
            function(regs, pins) { // CPY #
                switch(regs.TCU) {
                        // CPY # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.Y & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC1: new opcode_functions(opcode_matrix[0xC1],
            function(regs, pins) { // CMP (d,x)
                switch(regs.TCU) {
                        // CMP (d,x) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC2: new opcode_functions(opcode_matrix[0xC2],
            function(regs, pins) { // REP #
                switch(regs.TCU) {
                        // REP # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_native(regs.P.getbyte_native() & (~regs.TR & 0xFF));
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC3: new opcode_functions(opcode_matrix[0xC3],
            function(regs, pins) { // CMP d,s
                switch(regs.TCU) {
                        // CMP d,s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC4: new opcode_functions(opcode_matrix[0xC4],
            function(regs, pins) { // CPY d
                switch(regs.TCU) {
                        // CPY d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.Y & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC5: new opcode_functions(opcode_matrix[0xC5],
            function(regs, pins) { // CMP d
                switch(regs.TCU) {
                        // CMP d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC6: new opcode_functions(opcode_matrix[0xC6],
            function(regs, pins) { // DEC d
                switch(regs.TCU) {
                        // DEC d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC7: new opcode_functions(opcode_matrix[0xC7],
            function(regs, pins) { // CMP [d]
                switch(regs.TCU) {
                        // CMP [d] E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC8: new opcode_functions(opcode_matrix[0xC8],
            function(regs, pins) { // INY i
                switch(regs.TCU) {
                        // INY i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) + 1) & 0xFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC9: new opcode_functions(opcode_matrix[0xC9],
            function(regs, pins) { // CMP #
                switch(regs.TCU) {
                        // CMP # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCA: new opcode_functions(opcode_matrix[0xCA],
            function(regs, pins) { // DEX i
                switch(regs.TCU) {
                        // DEX i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) - 1) & 0xFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCB: new opcode_functions(opcode_matrix[0xCB],
            function(regs, pins) { // WAI i
                switch(regs.TCU) {
                        // WAI i E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.WAI = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCC: new opcode_functions(opcode_matrix[0xCC],
            function(regs, pins) { // CPY a
                switch(regs.TCU) {
                        // CPY a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.Y & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xCD: new opcode_functions(opcode_matrix[0xCD],
            function(regs, pins) { // CMP a
                switch(regs.TCU) {
                        // CMP a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCE: new opcode_functions(opcode_matrix[0xCE],
            function(regs, pins) { // DEC a
                switch(regs.TCU) {
                        // DEC a E=0 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCF: new opcode_functions(opcode_matrix[0xCF],
            function(regs, pins) { // CMP al
                switch(regs.TCU) {
                        // CMP al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD0: new opcode_functions(opcode_matrix[0xD0],
            function(regs, pins) { // BNE r
                switch(regs.TCU) {
                        // BNE r E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 0;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD1: new opcode_functions(opcode_matrix[0xD1],
            function(regs, pins) { // CMP (d),y
                switch(regs.TCU) {
                        // CMP (d),y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD2: new opcode_functions(opcode_matrix[0xD2],
            function(regs, pins) { // CMP (d)
                switch(regs.TCU) {
                        // CMP (d) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD3: new opcode_functions(opcode_matrix[0xD3],
            function(regs, pins) { // CMP (d,s),y
                switch(regs.TCU) {
                        // CMP (d,s),y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD4: new opcode_functions(opcode_matrix[0xD4],
            function(regs, pins) { // PEI s
                switch(regs.TCU) {
                        // PEI s E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.D = regs.TR
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xD5: new opcode_functions(opcode_matrix[0xD5],
            function(regs, pins) { // CMP d,x
                switch(regs.TCU) {
                        // CMP d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD6: new opcode_functions(opcode_matrix[0xD6],
            function(regs, pins) { // DEC d,x
                switch(regs.TCU) {
                        // DEC d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD7: new opcode_functions(opcode_matrix[0xD7],
            function(regs, pins) { // CMP [d],y
                switch(regs.TCU) {
                        // CMP [d],y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD8: new opcode_functions(opcode_matrix[0xD8],
            function(regs, pins) { // CLD i
                switch(regs.TCU) {
                        // CLD i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD9: new opcode_functions(opcode_matrix[0xD9],
            function(regs, pins) { // CMP a,y
                switch(regs.TCU) {
                        // CMP a,y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDA: new opcode_functions(opcode_matrix[0xDA],
            function(regs, pins) { // PHX s
                switch(regs.TCU) {
                        // PHX s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.X) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xDB: new opcode_functions(opcode_matrix[0xDB],
            function(regs, pins) { // STP i
                switch(regs.TCU) {
                        // STP i E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.STP = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDC: new opcode_functions(opcode_matrix[0xDC],
            function(regs, pins) { // JML (a)
                switch(regs.TCU) {
                        // JML (a) E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.PC = regs.TR + (pins.D << 8);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDD: new opcode_functions(opcode_matrix[0xDD],
            function(regs, pins) { // CMP a,x
                switch(regs.TCU) {
                        // CMP a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDE: new opcode_functions(opcode_matrix[0xDE],
            function(regs, pins) { // DEC a,x
                switch(regs.TCU) {
                        // DEC a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDF: new opcode_functions(opcode_matrix[0xDF],
            function(regs, pins) { // CMP al,x
                switch(regs.TCU) {
                        // CMP al,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE0: new opcode_functions(opcode_matrix[0xE0],
            function(regs, pins) { // CPX #
                switch(regs.TCU) {
                        // CPX # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.X & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE1: new opcode_functions(opcode_matrix[0xE1],
            function(regs, pins) { // SBC (d,x)
                switch(regs.TCU) {
                        // SBC (d,x) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE2: new opcode_functions(opcode_matrix[0xE2],
            function(regs, pins) { // SEP #
                switch(regs.TCU) {
                        // SEP # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_native(regs.P.getbyte_native() | regs.TR);
                        if (regs.P.X) { regs.X &= 0xFF, regs.Y &= 0xFF; }
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE3: new opcode_functions(opcode_matrix[0xE3],
            function(regs, pins) { // SBC d,s
                switch(regs.TCU) {
                        // SBC d,s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE4: new opcode_functions(opcode_matrix[0xE4],
            function(regs, pins) { // CPX d
                switch(regs.TCU) {
                        // CPX d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.X & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE5: new opcode_functions(opcode_matrix[0xE5],
            function(regs, pins) { // SBC d
                switch(regs.TCU) {
                        // SBC d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE6: new opcode_functions(opcode_matrix[0xE6],
            function(regs, pins) { // INC d
                switch(regs.TCU) {
                        // INC d E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE7: new opcode_functions(opcode_matrix[0xE7],
            function(regs, pins) { // SBC [d]
                switch(regs.TCU) {
                        // SBC [d] E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE8: new opcode_functions(opcode_matrix[0xE8],
            function(regs, pins) { // INX i
                switch(regs.TCU) {
                        // INX i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) + 1) & 0xFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE9: new opcode_functions(opcode_matrix[0xE9],
            function(regs, pins) { // SBC #
                switch(regs.TCU) {
                        // SBC # E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEA: new opcode_functions(opcode_matrix[0xEA],
            function(regs, pins) { // NOP i
                switch(regs.TCU) {
                        // NOP i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEB: new opcode_functions(opcode_matrix[0xEB],
            function(regs, pins) { // XBA i
                switch(regs.TCU) {
                        // XBA i E=0 M=1 X=1
                    case 1:
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2:
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >>> 8) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEC: new opcode_functions(opcode_matrix[0xEC],
            function(regs, pins) { // CPX a
                switch(regs.TCU) {
                        // CPX a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.X & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xED: new opcode_functions(opcode_matrix[0xED],
            function(regs, pins) { // SBC a
                switch(regs.TCU) {
                        // SBC a E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEE: new opcode_functions(opcode_matrix[0xEE],
            function(regs, pins) { // INC a
                switch(regs.TCU) {
                        // INC a E=0 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEF: new opcode_functions(opcode_matrix[0xEF],
            function(regs, pins) { // SBC al
                switch(regs.TCU) {
                        // SBC al E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF0: new opcode_functions(opcode_matrix[0xF0],
            function(regs, pins) { // BEQ r
                switch(regs.TCU) {
                        // BEQ r E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 1;
                        regs.skipped_cycle = 0;
                        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF1: new opcode_functions(opcode_matrix[0xF1],
            function(regs, pins) { // SBC (d),y
                switch(regs.TCU) {
                        // SBC (d),y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF2: new opcode_functions(opcode_matrix[0xF2],
            function(regs, pins) { // SBC (d)
                switch(regs.TCU) {
                        // SBC (d) E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF3: new opcode_functions(opcode_matrix[0xF3],
            function(regs, pins) { // SBC (d,s),y
                switch(regs.TCU) {
                        // SBC (d,s),y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF4: new opcode_functions(opcode_matrix[0xF4],
            function(regs, pins) { // PEA s
                switch(regs.TCU) {
                        // PEA s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xF5: new opcode_functions(opcode_matrix[0xF5],
            function(regs, pins) { // SBC d,x
                switch(regs.TCU) {
                        // SBC d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF6: new opcode_functions(opcode_matrix[0xF6],
            function(regs, pins) { // INC d,x
                switch(regs.TCU) {
                        // INC d,x E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF7: new opcode_functions(opcode_matrix[0xF7],
            function(regs, pins) { // SBC [d],y
                switch(regs.TCU) {
                        // SBC [d],y E=0 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF8: new opcode_functions(opcode_matrix[0xF8],
            function(regs, pins) { // SED i
                switch(regs.TCU) {
                        // SED i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF9: new opcode_functions(opcode_matrix[0xF9],
            function(regs, pins) { // SBC a,y
                switch(regs.TCU) {
                        // SBC a,y E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFA: new opcode_functions(opcode_matrix[0xFA],
            function(regs, pins) { // PLX s
                switch(regs.TCU) {
                        // PLX s E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xFB: new opcode_functions(opcode_matrix[0xFB],
            function(regs, pins) { // XCE i
                switch(regs.TCU) {
                        // XCE i E=0 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        let TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
                        if (regs.E) {
                            regs.P.X = regs.P.M = 1;
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                            regs.S = (regs.S & 0xFF) | 0x100;
                        }
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xFC: new opcode_functions(opcode_matrix[0xFC],
            function(regs, pins) { // JSR (a,x)
                switch(regs.TCU) {
                        // JSR (a,x) E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.RW = 1;
                        regs.TA = pins.D;
                        pins.D = ((regs.PC) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 4
                        pins.D = (regs.PC) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 6: // 7
                        pins.PDV = 1;
                        pins.Addr = regs.TA;
                        break;
                    case 7: // 8
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.PC = pins.D;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xFD: new opcode_functions(opcode_matrix[0xFD],
            function(regs, pins) { // SBC a,x
                switch(regs.TCU) {
                        // SBC a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFE: new opcode_functions(opcode_matrix[0xFE],
            function(regs, pins) { // INC a,x
                switch(regs.TCU) {
                        // INC a,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.RW = 1; pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFF: new opcode_functions(opcode_matrix[0xFF],
            function(regs, pins) { // SBC al,x
                switch(regs.TCU) {
                        // SBC al,x E=0 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x100: new opcode_functions(opcode_matrix[0x100],
            function(regs, pins) { // S_RESET s
                switch(regs.TCU) {
                        // S_RESET s E=0 M=1 X=1
                    case 1: // 3
                        pins.RW = 0; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFFC); pins.BA = (0);
                        regs.DBR = 0;
                        regs.D = 0;
                        regs.PBR = 0;
                        regs.X &= 0xFF;
                        regs.Y &= 0xFF;
                        regs.S = (regs.S & 0xFF) | 0x100;
                        regs.E = 1;
                        regs.P.M = regs.P.X = regs.P.I = regs.P.C = 1;
                        regs.P.D = 0;
                        regs.STP = regs.WAI = false;
                        break;
                    case 6: // 8
                        regs.PC = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        pins.PDV = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x101: new opcode_functions(opcode_matrix[0x101],
            function(regs, pins) { // S_ABORT s
                switch(regs.TCU) {
                        // S_ABORT s E=0 M=1 X=1
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFE8); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFE9); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x102: new opcode_functions(opcode_matrix[0x102],
            function(regs, pins) { // S_IRQ s
                switch(regs.TCU) {
                        // S_IRQ s E=0 M=1 X=1
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFEE); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFEF); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x103: new opcode_functions(opcode_matrix[0x103],
            function(regs, pins) { // S_NMI s
                switch(regs.TCU) {
                        // S_NMI s E=0 M=1 X=1
                    case 1: // 3
                        regs.TR = regs.PC;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.RW = 1;
                        pins.D = regs.PBR;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_native();
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFEA); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFEB); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false)
},
    // E1 M1 X1
    7: {
        0x00: new opcode_functions(opcode_matrix[0x00],
            function(regs, pins) { // BRK s
                switch(regs.TCU) {
                        // BRK s E=1 M=1 X=1
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 4
                        regs.TR = regs.PC;
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_emulated() | 8;
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFFE); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFFF); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x01: new opcode_functions(opcode_matrix[0x01],
            function(regs, pins) { // ORA (d,x)
                switch(regs.TCU) {
                        // ORA (d,x) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x02: new opcode_functions(opcode_matrix[0x02],
            function(regs, pins) { // COP s
                switch(regs.TCU) {
                        // COP s E=1 M=1 X=1
                        // instruction code follows
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 4
                        regs.TR = regs.PC;
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_emulated() & 0xF7;
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFF4); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 6: // 8
                        pins.Addr = (0xFFF5); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // instruction code ends
                        regs.P.D = 0;
                        regs.P.I = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x03: new opcode_functions(opcode_matrix[0x03],
            function(regs, pins) { // ORA d,s
                switch(regs.TCU) {
                        // ORA d,s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x04: new opcode_functions(opcode_matrix[0x04],
            function(regs, pins) { // TSB d
                switch(regs.TCU) {
                        // TSB d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x05: new opcode_functions(opcode_matrix[0x05],
            function(regs, pins) { // ORA d
                switch(regs.TCU) {
                        // ORA d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x06: new opcode_functions(opcode_matrix[0x06],
            function(regs, pins) { // ASL d
                switch(regs.TCU) {
                        // ASL d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x07: new opcode_functions(opcode_matrix[0x07],
            function(regs, pins) { // ORA [d]
                switch(regs.TCU) {
                        // ORA [d] E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x08: new opcode_functions(opcode_matrix[0x08],
            function(regs, pins) { // PHP s
                switch(regs.TCU) {
                        // PHP s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.P.getbyte_emulated();
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x09: new opcode_functions(opcode_matrix[0x09],
            function(regs, pins) { // ORA #
                switch(regs.TCU) {
                        // ORA # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0A: new opcode_functions(opcode_matrix[0x0A],
            function(regs, pins) { // ASL A
                switch(regs.TCU) {
                        // ASL A E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0B: new opcode_functions(opcode_matrix[0x0B],
            function(regs, pins) { // PHD s
                switch(regs.TCU) {
                        // PHD s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.D);
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR & 0xFF00) >>> 8;
                        break;
                    case 3:
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        regs.S = (regs.S & 0xFF) + 0x100;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x0C: new opcode_functions(opcode_matrix[0x0C],
            function(regs, pins) { // TSB a
                switch(regs.TCU) {
                        // TSB a E=1 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (regs.C | regs.TR) & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0D: new opcode_functions(opcode_matrix[0x0D],
            function(regs, pins) { // ORA a
                switch(regs.TCU) {
                        // ORA a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0E: new opcode_functions(opcode_matrix[0x0E],
            function(regs, pins) { // ASL a
                switch(regs.TCU) {
                        // ASL a E=1 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x0F: new opcode_functions(opcode_matrix[0x0F],
            function(regs, pins) { // ORA al
                switch(regs.TCU) {
                        // ORA al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x10: new opcode_functions(opcode_matrix[0x10],
            function(regs, pins) { // BPL r
                switch(regs.TCU) {
                        // BPL r E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 0;
                        regs.skipped_cycle = 0;
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x11: new opcode_functions(opcode_matrix[0x11],
            function(regs, pins) { // ORA (d),y
                switch(regs.TCU) {
                        // ORA (d),y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x12: new opcode_functions(opcode_matrix[0x12],
            function(regs, pins) { // ORA (d)
                switch(regs.TCU) {
                        // ORA (d) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x13: new opcode_functions(opcode_matrix[0x13],
            function(regs, pins) { // ORA (d,s),y
                switch(regs.TCU) {
                        // ORA (d,s),y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x14: new opcode_functions(opcode_matrix[0x14],
            function(regs, pins) { // TRB d
                switch(regs.TCU) {
                        // TRB d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x15: new opcode_functions(opcode_matrix[0x15],
            function(regs, pins) { // ORA d,x
                switch(regs.TCU) {
                        // ORA d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x16: new opcode_functions(opcode_matrix[0x16],
            function(regs, pins) { // ASL d,x
                switch(regs.TCU) {
                        // ASL d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x17: new opcode_functions(opcode_matrix[0x17],
            function(regs, pins) { // ORA [d],y
                switch(regs.TCU) {
                        // ORA [d],y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x18: new opcode_functions(opcode_matrix[0x18],
            function(regs, pins) { // CLC i
                switch(regs.TCU) {
                        // CLC i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x19: new opcode_functions(opcode_matrix[0x19],
            function(regs, pins) { // ORA a,y
                switch(regs.TCU) {
                        // ORA a,y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1A: new opcode_functions(opcode_matrix[0x1A],
            function(regs, pins) { // INC A
                switch(regs.TCU) {
                        // INC A E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1B: new opcode_functions(opcode_matrix[0x1B],
            function(regs, pins) { // TCS i
                switch(regs.TCU) {
                        // TCS i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.C;
                        regs.S = (regs.S & 0xFF) + 0x100;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x1C: new opcode_functions(opcode_matrix[0x1C],
            function(regs, pins) { // TRB a
                switch(regs.TCU) {
                        // TRB a E=1 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.Z = +((regs.TR & regs.C & 0xFF) === 0);
                        regs.TR = (~regs.C) & regs.TR & 0xFF;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1D: new opcode_functions(opcode_matrix[0x1D],
            function(regs, pins) { // ORA a,x
                switch(regs.TCU) {
                        // ORA a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1E: new opcode_functions(opcode_matrix[0x1E],
            function(regs, pins) { // ASL a,x
                switch(regs.TCU) {
                        // ASL a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.RW = 1; pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = (regs.TR & 0x7F) << 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x1F: new opcode_functions(opcode_matrix[0x1F],
            function(regs, pins) { // ORA al,x
                switch(regs.TCU) {
                        // ORA al,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.TR | regs.C) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x20: new opcode_functions(opcode_matrix[0x20],
            function(regs, pins) { // JSR a
                switch(regs.TCU) {
                        // JSR a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.PDV = 0;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 6
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x21: new opcode_functions(opcode_matrix[0x21],
            function(regs, pins) { // AND (d,x)
                switch(regs.TCU) {
                        // AND (d,x) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x22: new opcode_functions(opcode_matrix[0x22],
            function(regs, pins) { // JSL al
                switch(regs.TCU) {
                        // JSL al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        regs.TA += pins.D << 8;
                        pins.D = (regs.PBR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 1;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 6: // 7
                        regs.PBR = pins.D;
                        pins.RW = 1;
                        regs.TR = (regs.PC - 1) & 0xFFFF;
                        pins.D = ((regs.TR) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 7: // 8
                        pins.D = (regs.TR) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        regs.PC = regs.TA;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 8: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x23: new opcode_functions(opcode_matrix[0x23],
            function(regs, pins) { // AND d,s
                switch(regs.TCU) {
                        // AND d,s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x24: new opcode_functions(opcode_matrix[0x24],
            function(regs, pins) { // BIT d
                switch(regs.TCU) {
                        // BIT d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x25: new opcode_functions(opcode_matrix[0x25],
            function(regs, pins) { // AND d
                switch(regs.TCU) {
                        // AND d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x26: new opcode_functions(opcode_matrix[0x26],
            function(regs, pins) { // ROL d
                switch(regs.TCU) {
                        // ROL d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x27: new opcode_functions(opcode_matrix[0x27],
            function(regs, pins) { // AND [d]
                switch(regs.TCU) {
                        // AND [d] E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x28: new opcode_functions(opcode_matrix[0x28],
            function(regs, pins) { // PLP s
                switch(regs.TCU) {
                        // PLP s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.setbyte_emulated(regs.TR);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x29: new opcode_functions(opcode_matrix[0x29],
            function(regs, pins) { // AND #
                switch(regs.TCU) {
                        // AND # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2A: new opcode_functions(opcode_matrix[0x2A],
            function(regs, pins) { // ROL A
                switch(regs.TCU) {
                        // ROL A E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2B: new opcode_functions(opcode_matrix[0x2B],
            function(regs, pins) { // PLD s
                switch(regs.TCU) {
                        // PLD s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 4a
                        regs.TR = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR += (pins.D << 8);
                        regs.S = (regs.S & 0xFF) + 0x100;
                        // instruction code follows
                        regs.D = regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x8000) >>> 15;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x2C: new opcode_functions(opcode_matrix[0x2C],
            function(regs, pins) { // BIT a
                switch(regs.TCU) {
                        // BIT a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2D: new opcode_functions(opcode_matrix[0x2D],
            function(regs, pins) { // AND a
                switch(regs.TCU) {
                        // AND a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2E: new opcode_functions(opcode_matrix[0x2E],
            function(regs, pins) { // ROL a
                switch(regs.TCU) {
                        // ROL a E=1 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x2F: new opcode_functions(opcode_matrix[0x2F],
            function(regs, pins) { // AND al
                switch(regs.TCU) {
                        // AND al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x30: new opcode_functions(opcode_matrix[0x30],
            function(regs, pins) { // BMI r
                switch(regs.TCU) {
                        // BMI r E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.N === 1;
                        regs.skipped_cycle = 0;
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x31: new opcode_functions(opcode_matrix[0x31],
            function(regs, pins) { // AND (d),y
                switch(regs.TCU) {
                        // AND (d),y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x32: new opcode_functions(opcode_matrix[0x32],
            function(regs, pins) { // AND (d)
                switch(regs.TCU) {
                        // AND (d) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x33: new opcode_functions(opcode_matrix[0x33],
            function(regs, pins) { // AND (d,s),y
                switch(regs.TCU) {
                        // AND (d,s),y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x34: new opcode_functions(opcode_matrix[0x34],
            function(regs, pins) { // BIT d,x
                switch(regs.TCU) {
                        // BIT d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x35: new opcode_functions(opcode_matrix[0x35],
            function(regs, pins) { // AND d,x
                switch(regs.TCU) {
                        // AND d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x36: new opcode_functions(opcode_matrix[0x36],
            function(regs, pins) { // ROL d,x
                switch(regs.TCU) {
                        // ROL d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x37: new opcode_functions(opcode_matrix[0x37],
            function(regs, pins) { // AND [d],y
                switch(regs.TCU) {
                        // AND [d],y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x38: new opcode_functions(opcode_matrix[0x38],
            function(regs, pins) { // SEC i
                switch(regs.TCU) {
                        // SEC i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.C = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x39: new opcode_functions(opcode_matrix[0x39],
            function(regs, pins) { // AND a,y
                switch(regs.TCU) {
                        // AND a,y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3A: new opcode_functions(opcode_matrix[0x3A],
            function(regs, pins) { // DEC A
                switch(regs.TCU) {
                        // DEC A E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3B: new opcode_functions(opcode_matrix[0x3B],
            function(regs, pins) { // TSC i
                switch(regs.TCU) {
                        // TSC i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.S);
                        regs.P.Z = +((regs.S) === 0);
                        regs.P.N = ((regs.S) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x3C: new opcode_functions(opcode_matrix[0x3C],
            function(regs, pins) { // BIT a,x
                switch(regs.TCU) {
                        // BIT a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        regs.P.V = (regs.TR & 0x40) >>> 6;
                        regs.P.N = (regs.TR & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3D: new opcode_functions(opcode_matrix[0x3D],
            function(regs, pins) { // AND a,x
                switch(regs.TCU) {
                        // AND a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3E: new opcode_functions(opcode_matrix[0x3E],
            function(regs, pins) { // ROL a,x
                switch(regs.TCU) {
                        // ROL a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.RW = 1; pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        let carry = regs.P.C;
                        regs.P.C = (regs.TR & 0x80) >>> 7;
                        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x3F: new opcode_functions(opcode_matrix[0x3F],
            function(regs, pins) { // AND al,x
                switch(regs.TCU) {
                        // AND al,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & regs.TR & 0xFF;
                        regs.P.Z = +((A) === 0);
                        regs.P.N = ((A) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) + A;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x40: new opcode_functions(opcode_matrix[0x40],
            function(regs, pins) { // RTI s
                switch(regs.TCU) {
                        // RTI s E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        pins.PDV = 1;
                        break;
                    case 4: // 5
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.P.setbyte_emulated(pins.D);
                        if (regs.P.X) {
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                        }
                        if (regs.P.E) regs.S = (regs.S & 0xFF) | 0x100;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.TA = pins.D;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TA + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x41: new opcode_functions(opcode_matrix[0x41],
            function(regs, pins) { // EOR (d,x)
                switch(regs.TCU) {
                        // EOR (d,x) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x42: new opcode_functions(opcode_matrix[0x42],
            function(regs, pins) { // WDM i
                switch(regs.TCU) {
                        // WDM i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x43: new opcode_functions(opcode_matrix[0x43],
            function(regs, pins) { // EOR d,s
                switch(regs.TCU) {
                        // EOR d,s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x44: new opcode_functions(opcode_matrix[0x44],
            function(regs, pins) { // MVP xyc
                switch(regs.TCU) {
                        // MVP xyc E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D
                        pins.Addr = (regs.X); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X - 1) & 0xFF;
                        regs.Y = (regs.Y - 1) & 0xFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x45: new opcode_functions(opcode_matrix[0x45],
            function(regs, pins) { // EOR d
                switch(regs.TCU) {
                        // EOR d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x46: new opcode_functions(opcode_matrix[0x46],
            function(regs, pins) { // LSR d
                switch(regs.TCU) {
                        // LSR d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x47: new opcode_functions(opcode_matrix[0x47],
            function(regs, pins) { // EOR [d]
                switch(regs.TCU) {
                        // EOR [d] E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x48: new opcode_functions(opcode_matrix[0x48],
            function(regs, pins) { // PHA s
                switch(regs.TCU) {
                        // PHA s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.C) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x49: new opcode_functions(opcode_matrix[0x49],
            function(regs, pins) { // EOR #
                switch(regs.TCU) {
                        // EOR # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4A: new opcode_functions(opcode_matrix[0x4A],
            function(regs, pins) { // LSR A
                switch(regs.TCU) {
                        // LSR A E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4B: new opcode_functions(opcode_matrix[0x4B],
            function(regs, pins) { // PHK s
                switch(regs.TCU) {
                        // PHK s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.PBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4C: new opcode_functions(opcode_matrix[0x4C],
            function(regs, pins) { // JMP a
                switch(regs.TCU) {
                        // JMP a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x4D: new opcode_functions(opcode_matrix[0x4D],
            function(regs, pins) { // EOR a
                switch(regs.TCU) {
                        // EOR a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4E: new opcode_functions(opcode_matrix[0x4E],
            function(regs, pins) { // LSR a
                switch(regs.TCU) {
                        // LSR a E=1 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x4F: new opcode_functions(opcode_matrix[0x4F],
            function(regs, pins) { // EOR al
                switch(regs.TCU) {
                        // EOR al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x50: new opcode_functions(opcode_matrix[0x50],
            function(regs, pins) { // BVC r
                switch(regs.TCU) {
                        // BVC r E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 0;
                        regs.skipped_cycle = 0;
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x51: new opcode_functions(opcode_matrix[0x51],
            function(regs, pins) { // EOR (d),y
                switch(regs.TCU) {
                        // EOR (d),y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x52: new opcode_functions(opcode_matrix[0x52],
            function(regs, pins) { // EOR (d)
                switch(regs.TCU) {
                        // EOR (d) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x53: new opcode_functions(opcode_matrix[0x53],
            function(regs, pins) { // EOR (d,s),y
                switch(regs.TCU) {
                        // EOR (d,s),y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x54: new opcode_functions(opcode_matrix[0x54],
            function(regs, pins) { // MVN xyc
                switch(regs.TCU) {
                        // MVN xyc E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.DBR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA = pins.D;
                        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                        break;
                    case 4: // 5
                        pins.RW = 1;
                        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                        break;
                    case 5: // 6
                        pins.RW = 0; pins.PDV = 0;
                        break;
                    case 6: // 7
                        regs.C = (regs.C - 1) & 0xFFFF;
                        regs.X = (regs.X + 1) & 0xFF;
                        regs.Y = (regs.Y + 1) & 0xFF;
                        if (regs.C !== 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x55: new opcode_functions(opcode_matrix[0x55],
            function(regs, pins) { // EOR d,x
                switch(regs.TCU) {
                        // EOR d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x56: new opcode_functions(opcode_matrix[0x56],
            function(regs, pins) { // LSR d,x
                switch(regs.TCU) {
                        // LSR d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x57: new opcode_functions(opcode_matrix[0x57],
            function(regs, pins) { // EOR [d],y
                switch(regs.TCU) {
                        // EOR [d],y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x58: new opcode_functions(opcode_matrix[0x58],
            function(regs, pins) { // CLI i
                switch(regs.TCU) {
                        // CLI i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 0;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x59: new opcode_functions(opcode_matrix[0x59],
            function(regs, pins) { // EOR a,y
                switch(regs.TCU) {
                        // EOR a,y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5A: new opcode_functions(opcode_matrix[0x5A],
            function(regs, pins) { // PHY s
                switch(regs.TCU) {
                        // PHY s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.Y) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x5B: new opcode_functions(opcode_matrix[0x5B],
            function(regs, pins) { // TCD i
                switch(regs.TCU) {
                        // TCD i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.D = (regs.C);
                        regs.P.Z = +((regs.C) === 0);
                        regs.P.N = ((regs.C) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5C: new opcode_functions(opcode_matrix[0x5C],
            function(regs, pins) { // JMP al
                switch(regs.TCU) {
                        // JMP al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = regs.TA + (pins.D << 8);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x5D: new opcode_functions(opcode_matrix[0x5D],
            function(regs, pins) { // EOR a,x
                switch(regs.TCU) {
                        // EOR a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5E: new opcode_functions(opcode_matrix[0x5E],
            function(regs, pins) { // LSR a,x
                switch(regs.TCU) {
                        // LSR a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.RW = 1; pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.C = regs.TR & 1;
                        regs.TR >>>= 1;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x5F: new opcode_functions(opcode_matrix[0x5F],
            function(regs, pins) { // EOR al,x
                switch(regs.TCU) {
                        // EOR al,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) ^ regs.TR;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x60: new opcode_functions(opcode_matrix[0x60],
            function(regs, pins) { // RTS s
                switch(regs.TCU) {
                        // RTS s E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x61: new opcode_functions(opcode_matrix[0x61],
            function(regs, pins) { // ADC (d,x)
                switch(regs.TCU) {
                        // ADC (d,x) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x62: new opcode_functions(opcode_matrix[0x62],
            function(regs, pins) { // PER s
                switch(regs.TCU) {
                        // PER s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.RW = 1; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 5: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.S = (regs.S & 0xFF) + 0x100;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x63: new opcode_functions(opcode_matrix[0x63],
            function(regs, pins) { // ADC d,s
                switch(regs.TCU) {
                        // ADC d,s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x64: new opcode_functions(opcode_matrix[0x64],
            function(regs, pins) { // STZ d
                switch(regs.TCU) {
                        // STZ d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x65: new opcode_functions(opcode_matrix[0x65],
            function(regs, pins) { // ADC d
                switch(regs.TCU) {
                        // ADC d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x66: new opcode_functions(opcode_matrix[0x66],
            function(regs, pins) { // ROR d
                switch(regs.TCU) {
                        // ROR d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x67: new opcode_functions(opcode_matrix[0x67],
            function(regs, pins) { // ADC [d]
                switch(regs.TCU) {
                        // ADC [d] E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x68: new opcode_functions(opcode_matrix[0x68],
            function(regs, pins) { // PLA s
                switch(regs.TCU) {
                        // PLA s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, true, false),
        0x69: new opcode_functions(opcode_matrix[0x69],
            function(regs, pins) { // ADC #
                switch(regs.TCU) {
                        // ADC # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6A: new opcode_functions(opcode_matrix[0x6A],
            function(regs, pins) { // ROR A
                switch(regs.TCU) {
                        // ROR A E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        regs.TR = regs.C & 0xFF;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
                        // Following is auto-generated code for instruction finish
                        break;
                    case 2: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6B: new opcode_functions(opcode_matrix[0x6B],
            function(regs, pins) { // RTL s
                switch(regs.TCU) {
                        // RTL s E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TA = pins.D;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 5: // 6
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        regs.S = (regs.S & 0xFF) + 0x100;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0x6C: new opcode_functions(opcode_matrix[0x6C],
            function(regs, pins) { // JMP (a)
                switch(regs.TCU) {
                        // JMP (a) E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x6D: new opcode_functions(opcode_matrix[0x6D],
            function(regs, pins) { // ADC a
                switch(regs.TCU) {
                        // ADC a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6E: new opcode_functions(opcode_matrix[0x6E],
            function(regs, pins) { // ROR a
                switch(regs.TCU) {
                        // ROR a E=1 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x6F: new opcode_functions(opcode_matrix[0x6F],
            function(regs, pins) { // ADC al
                switch(regs.TCU) {
                        // ADC al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x70: new opcode_functions(opcode_matrix[0x70],
            function(regs, pins) { // BVS r
                switch(regs.TCU) {
                        // BVS r E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.V === 1;
                        regs.skipped_cycle = 0;
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x71: new opcode_functions(opcode_matrix[0x71],
            function(regs, pins) { // ADC (d),y
                switch(regs.TCU) {
                        // ADC (d),y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x72: new opcode_functions(opcode_matrix[0x72],
            function(regs, pins) { // ADC (d)
                switch(regs.TCU) {
                        // ADC (d) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x73: new opcode_functions(opcode_matrix[0x73],
            function(regs, pins) { // ADC (d,s),y
                switch(regs.TCU) {
                        // ADC (d,s),y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x74: new opcode_functions(opcode_matrix[0x74],
            function(regs, pins) { // STZ d,x
                switch(regs.TCU) {
                        // STZ d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x75: new opcode_functions(opcode_matrix[0x75],
            function(regs, pins) { // ADC d,x
                switch(regs.TCU) {
                        // ADC d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x76: new opcode_functions(opcode_matrix[0x76],
            function(regs, pins) { // ROR d,x
                switch(regs.TCU) {
                        // ROR d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x77: new opcode_functions(opcode_matrix[0x77],
            function(regs, pins) { // ADC [d],y
                switch(regs.TCU) {
                        // ADC [d],y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x78: new opcode_functions(opcode_matrix[0x78],
            function(regs, pins) { // SEI i
                switch(regs.TCU) {
                        // SEI i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.I = 1;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x79: new opcode_functions(opcode_matrix[0x79],
            function(regs, pins) { // ADC a,y
                switch(regs.TCU) {
                        // ADC a,y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7A: new opcode_functions(opcode_matrix[0x7A],
            function(regs, pins) { // PLY s
                switch(regs.TCU) {
                        // PLY s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0x7B: new opcode_functions(opcode_matrix[0x7B],
            function(regs, pins) { // TDC i
                switch(regs.TCU) {
                        // TDC i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = (regs.D);
                        regs.P.Z = +((regs.D) === 0);
                        regs.P.N = ((regs.D) & 0x8000) >>> 15;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7C: new opcode_functions(opcode_matrix[0x7C],
            function(regs, pins) { // JMP (a,x)
                switch(regs.TCU) {
                        // JMP (a,x) E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        regs.TA = (regs.X + regs.TA) & 0xFFFF;
                        pins.PDV = 0;
                        break;
                    case 4:
                        pins.PDV = 1;
                        pins.Addr = regs.TA; pins.BA = regs.PBR;
                        break;
                    case 5:
                        regs.TR = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = regs.TR + (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x7D: new opcode_functions(opcode_matrix[0x7D],
            function(regs, pins) { // ADC a,x
                switch(regs.TCU) {
                        // ADC a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7E: new opcode_functions(opcode_matrix[0x7E],
            function(regs, pins) { // ROR a,x
                switch(regs.TCU) {
                        // ROR a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.RW = 1; pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        let carry = regs.P.C << 7;
                        regs.P.C = regs.TR & 0x1;
                        regs.TR = ((regs.TR & 0xFF) >>> 1) | carry;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x7F: new opcode_functions(opcode_matrix[0x7F],
            function(regs, pins) { // ADC al,x
                switch(regs.TCU) {
                        // ADC al,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; regs.TR &= 0xFF;
                        let result;
                        if (!regs.P.D) result = A + regs.TR + regs.P.C;
                        else {
                            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
                            if (result > 0x09) result += 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result > 0x9F) result += 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +(((result & 0xFF)) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x80: new opcode_functions(opcode_matrix[0x80],
            function(regs, pins) { // BRA r
                switch(regs.TCU) {
                        // BRA r E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = true;
                        regs.skipped_cycle = 0;
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x81: new opcode_functions(opcode_matrix[0x81],
            function(regs, pins) { // STA (d,x)
                switch(regs.TCU) {
                        // STA (d,x) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x82: new opcode_functions(opcode_matrix[0x82],
            function(regs, pins) { // BRL rl
                switch(regs.TCU) {
                        // BRL rl E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TA = mksigned16(regs.TA + (pins.D << 8));
                        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x83: new opcode_functions(opcode_matrix[0x83],
            function(regs, pins) { // STA d,s
                switch(regs.TCU) {
                        // STA d,s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x84: new opcode_functions(opcode_matrix[0x84],
            function(regs, pins) { // STY d
                switch(regs.TCU) {
                        // STY d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x85: new opcode_functions(opcode_matrix[0x85],
            function(regs, pins) { // STA d
                switch(regs.TCU) {
                        // STA d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x86: new opcode_functions(opcode_matrix[0x86],
            function(regs, pins) { // STX d
                switch(regs.TCU) {
                        // STX d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x87: new opcode_functions(opcode_matrix[0x87],
            function(regs, pins) { // STA [d]
                switch(regs.TCU) {
                        // STA [d] E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x88: new opcode_functions(opcode_matrix[0x88],
            function(regs, pins) { // DEY i
                switch(regs.TCU) {
                        // DEY i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) - 1) & 0xFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x89: new opcode_functions(opcode_matrix[0x89],
            function(regs, pins) { // BIT #
                switch(regs.TCU) {
                        // BIT # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.P.Z = +((regs.C & regs.TR & 0xFF) === 0);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8A: new opcode_functions(opcode_matrix[0x8A],
            function(regs, pins) { // TXA i
                switch(regs.TCU) {
                        // TXA i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.X) & 0xFF);
                        regs.P.Z = +((regs.X & 0xFF) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8B: new opcode_functions(opcode_matrix[0x8B],
            function(regs, pins) { // PHB s
                switch(regs.TCU) {
                        // PHB s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.DBR) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x8C: new opcode_functions(opcode_matrix[0x8C],
            function(regs, pins) { // STY a
                switch(regs.TCU) {
                        // STY a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.Y & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8D: new opcode_functions(opcode_matrix[0x8D],
            function(regs, pins) { // STA a
                switch(regs.TCU) {
                        // STA a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x8E: new opcode_functions(opcode_matrix[0x8E],
            function(regs, pins) { // STX a
                switch(regs.TCU) {
                        // STX a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = regs.X & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x8F: new opcode_functions(opcode_matrix[0x8F],
            function(regs, pins) { // STA al
                switch(regs.TCU) {
                        // STA al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x90: new opcode_functions(opcode_matrix[0x90],
            function(regs, pins) { // BCC r
                switch(regs.TCU) {
                        // BCC r E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 0;
                        regs.skipped_cycle = 0;
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x91: new opcode_functions(opcode_matrix[0x91],
            function(regs, pins) { // STA (d),y
                switch(regs.TCU) {
                        // STA (d),y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x92: new opcode_functions(opcode_matrix[0x92],
            function(regs, pins) { // STA (d)
                switch(regs.TCU) {
                        // STA (d) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x93: new opcode_functions(opcode_matrix[0x93],
            function(regs, pins) { // STA (d,s),y
                switch(regs.TCU) {
                        // STA (d,s),y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x94: new opcode_functions(opcode_matrix[0x94],
            function(regs, pins) { // STY d,x
                switch(regs.TCU) {
                        // STY d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.Y & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x95: new opcode_functions(opcode_matrix[0x95],
            function(regs, pins) { // STA d,x
                switch(regs.TCU) {
                        // STA d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x96: new opcode_functions(opcode_matrix[0x96],
            function(regs, pins) { // STX d,y
                switch(regs.TCU) {
                        // STX d,y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFF); pins.BA = (0);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = regs.X & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0x97: new opcode_functions(opcode_matrix[0x97],
            function(regs, pins) { // STA [d],y
                switch(regs.TCU) {
                        // STA [d],y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x98: new opcode_functions(opcode_matrix[0x98],
            function(regs, pins) { // TYA i
                switch(regs.TCU) {
                        // TYA i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.Y) & 0xFF);
                        regs.P.Z = +((regs.Y & 0xFF) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x99: new opcode_functions(opcode_matrix[0x99],
            function(regs, pins) { // STA a,y
                switch(regs.TCU) {
                        // STA a,y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9A: new opcode_functions(opcode_matrix[0x9A],
            function(regs, pins) { // TXS i
                switch(regs.TCU) {
                        // TXS i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.S = regs.X
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9B: new opcode_functions(opcode_matrix[0x9B],
            function(regs, pins) { // TXY i
                switch(regs.TCU) {
                        // TXY i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.X) & 0xFF);
                        regs.P.Z = +((regs.X & 0xFF) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x9C: new opcode_functions(opcode_matrix[0x9C],
            function(regs, pins) { // STZ a
                switch(regs.TCU) {
                        // STZ a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        pins.RW = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 4: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9D: new opcode_functions(opcode_matrix[0x9D],
            function(regs, pins) { // STA a,x
                switch(regs.TCU) {
                        // STA a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9E: new opcode_functions(opcode_matrix[0x9E],
            function(regs, pins) { // STZ a,x
                switch(regs.TCU) {
                        // STZ a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = 0;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x9F: new opcode_functions(opcode_matrix[0x9F],
            function(regs, pins) { // STA al,x
                switch(regs.TCU) {
                        // STA al,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        pins.RW = 1;
                        // instruction code follows
                        // #STA
                        regs.TR = regs.C & 0xFF;
                        // instruction code ends
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 5: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA0: new opcode_functions(opcode_matrix[0xA0],
            function(regs, pins) { // LDY #
                switch(regs.TCU) {
                        // LDY # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA1: new opcode_functions(opcode_matrix[0xA1],
            function(regs, pins) { // LDA (d,x)
                switch(regs.TCU) {
                        // LDA (d,x) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA2: new opcode_functions(opcode_matrix[0xA2],
            function(regs, pins) { // LDX #
                switch(regs.TCU) {
                        // LDX # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA3: new opcode_functions(opcode_matrix[0xA3],
            function(regs, pins) { // LDA d,s
                switch(regs.TCU) {
                        // LDA d,s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA4: new opcode_functions(opcode_matrix[0xA4],
            function(regs, pins) { // LDY d
                switch(regs.TCU) {
                        // LDY d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA5: new opcode_functions(opcode_matrix[0xA5],
            function(regs, pins) { // LDA d
                switch(regs.TCU) {
                        // LDA d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA6: new opcode_functions(opcode_matrix[0xA6],
            function(regs, pins) { // LDX d
                switch(regs.TCU) {
                        // LDX d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xA7: new opcode_functions(opcode_matrix[0xA7],
            function(regs, pins) { // LDA [d]
                switch(regs.TCU) {
                        // LDA [d] E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xA8: new opcode_functions(opcode_matrix[0xA8],
            function(regs, pins) { // TAY i
                switch(regs.TCU) {
                        // TAY i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.C) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xA9: new opcode_functions(opcode_matrix[0xA9],
            function(regs, pins) { // LDA #
                switch(regs.TCU) {
                        // LDA # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAA: new opcode_functions(opcode_matrix[0xAA],
            function(regs, pins) { // TAX i
                switch(regs.TCU) {
                        // TAX i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.C) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAB: new opcode_functions(opcode_matrix[0xAB],
            function(regs, pins) { // PLB s
                switch(regs.TCU) {
                        // PLB s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xAC: new opcode_functions(opcode_matrix[0xAC],
            function(regs, pins) { // LDY a
                switch(regs.TCU) {
                        // LDY a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAD: new opcode_functions(opcode_matrix[0xAD],
            function(regs, pins) { // LDA a
                switch(regs.TCU) {
                        // LDA a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xAE: new opcode_functions(opcode_matrix[0xAE],
            function(regs, pins) { // LDX a
                switch(regs.TCU) {
                        // LDX a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xAF: new opcode_functions(opcode_matrix[0xAF],
            function(regs, pins) { // LDA al
                switch(regs.TCU) {
                        // LDA al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB0: new opcode_functions(opcode_matrix[0xB0],
            function(regs, pins) { // BCS r
                switch(regs.TCU) {
                        // BCS r E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.C === 1;
                        regs.skipped_cycle = 0;
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB1: new opcode_functions(opcode_matrix[0xB1],
            function(regs, pins) { // LDA (d),y
                switch(regs.TCU) {
                        // LDA (d),y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB2: new opcode_functions(opcode_matrix[0xB2],
            function(regs, pins) { // LDA (d)
                switch(regs.TCU) {
                        // LDA (d) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB3: new opcode_functions(opcode_matrix[0xB3],
            function(regs, pins) { // LDA (d,s),y
                switch(regs.TCU) {
                        // LDA (d,s),y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB4: new opcode_functions(opcode_matrix[0xB4],
            function(regs, pins) { // LDY d,x
                switch(regs.TCU) {
                        // LDY d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB5: new opcode_functions(opcode_matrix[0xB5],
            function(regs, pins) { // LDA d,x
                switch(regs.TCU) {
                        // LDA d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB6: new opcode_functions(opcode_matrix[0xB6],
            function(regs, pins) { // LDX d,y
                switch(regs.TCU) {
                        // LDX d,y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xB7: new opcode_functions(opcode_matrix[0xB7],
            function(regs, pins) { // LDA [d],y
                switch(regs.TCU) {
                        // LDA [d],y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xB8: new opcode_functions(opcode_matrix[0xB8],
            function(regs, pins) { // CLV i
                switch(regs.TCU) {
                        // CLV i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.V = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xB9: new opcode_functions(opcode_matrix[0xB9],
            function(regs, pins) { // LDA a,y
                switch(regs.TCU) {
                        // LDA a,y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBA: new opcode_functions(opcode_matrix[0xBA],
            function(regs, pins) { // TSX i
                switch(regs.TCU) {
                        // TSX i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X  = regs.S & 0xFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBB: new opcode_functions(opcode_matrix[0xBB],
            function(regs, pins) { // TYX i
                switch(regs.TCU) {
                        // TYX i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.Y) & 0xFF);
                        regs.P.Z = +((regs.Y & 0xFF) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xBC: new opcode_functions(opcode_matrix[0xBC],
            function(regs, pins) { // LDY a,x
                switch(regs.TCU) {
                        // LDY a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBD: new opcode_functions(opcode_matrix[0xBD],
            function(regs, pins) { // LDA a,x
                switch(regs.TCU) {
                        // LDA a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xBE: new opcode_functions(opcode_matrix[0xBE],
            function(regs, pins) { // LDX a,y
                switch(regs.TCU) {
                        // LDX a,y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xBF: new opcode_functions(opcode_matrix[0xBF],
            function(regs, pins) { // LDA al,x
                switch(regs.TCU) {
                        // LDA al,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC0: new opcode_functions(opcode_matrix[0xC0],
            function(regs, pins) { // CPY #
                switch(regs.TCU) {
                        // CPY # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.Y & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC1: new opcode_functions(opcode_matrix[0xC1],
            function(regs, pins) { // CMP (d,x)
                switch(regs.TCU) {
                        // CMP (d,x) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC2: new opcode_functions(opcode_matrix[0xC2],
            function(regs, pins) { // REP #
                switch(regs.TCU) {
                        // REP # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_emulated(regs.P.getbyte_emulated() & (~(regs.TR | 0x30) & 0xFF));
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC3: new opcode_functions(opcode_matrix[0xC3],
            function(regs, pins) { // CMP d,s
                switch(regs.TCU) {
                        // CMP d,s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC4: new opcode_functions(opcode_matrix[0xC4],
            function(regs, pins) { // CPY d
                switch(regs.TCU) {
                        // CPY d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.Y & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xC5: new opcode_functions(opcode_matrix[0xC5],
            function(regs, pins) { // CMP d
                switch(regs.TCU) {
                        // CMP d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC6: new opcode_functions(opcode_matrix[0xC6],
            function(regs, pins) { // DEC d
                switch(regs.TCU) {
                        // DEC d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC7: new opcode_functions(opcode_matrix[0xC7],
            function(regs, pins) { // CMP [d]
                switch(regs.TCU) {
                        // CMP [d] E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xC8: new opcode_functions(opcode_matrix[0xC8],
            function(regs, pins) { // INY i
                switch(regs.TCU) {
                        // INY i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.Y = ((regs.Y) + 1) & 0xFF;
                        regs.P.Z = +((regs.Y) === 0);
                        regs.P.N = ((regs.Y) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xC9: new opcode_functions(opcode_matrix[0xC9],
            function(regs, pins) { // CMP #
                switch(regs.TCU) {
                        // CMP # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCA: new opcode_functions(opcode_matrix[0xCA],
            function(regs, pins) { // DEX i
                switch(regs.TCU) {
                        // DEX i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) - 1) & 0xFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCB: new opcode_functions(opcode_matrix[0xCB],
            function(regs, pins) { // WAI i
                switch(regs.TCU) {
                        // WAI i E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.WAI = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xCC: new opcode_functions(opcode_matrix[0xCC],
            function(regs, pins) { // CPY a
                switch(regs.TCU) {
                        // CPY a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.Y & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xCD: new opcode_functions(opcode_matrix[0xCD],
            function(regs, pins) { // CMP a
                switch(regs.TCU) {
                        // CMP a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCE: new opcode_functions(opcode_matrix[0xCE],
            function(regs, pins) { // DEC a
                switch(regs.TCU) {
                        // DEC a E=1 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xCF: new opcode_functions(opcode_matrix[0xCF],
            function(regs, pins) { // CMP al
                switch(regs.TCU) {
                        // CMP al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD0: new opcode_functions(opcode_matrix[0xD0],
            function(regs, pins) { // BNE r
                switch(regs.TCU) {
                        // BNE r E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 0;
                        regs.skipped_cycle = 0;
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD1: new opcode_functions(opcode_matrix[0xD1],
            function(regs, pins) { // CMP (d),y
                switch(regs.TCU) {
                        // CMP (d),y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD2: new opcode_functions(opcode_matrix[0xD2],
            function(regs, pins) { // CMP (d)
                switch(regs.TCU) {
                        // CMP (d) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD3: new opcode_functions(opcode_matrix[0xD3],
            function(regs, pins) { // CMP (d,s),y
                switch(regs.TCU) {
                        // CMP (d,s),y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD4: new opcode_functions(opcode_matrix[0xD4],
            function(regs, pins) { // PEI s
                switch(regs.TCU) {
                        // PEI s E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.D = regs.TR
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.S = (regs.S & 0xFF) + 0x100;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xD5: new opcode_functions(opcode_matrix[0xD5],
            function(regs, pins) { // CMP d,x
                switch(regs.TCU) {
                        // CMP d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD6: new opcode_functions(opcode_matrix[0xD6],
            function(regs, pins) { // DEC d,x
                switch(regs.TCU) {
                        // DEC d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD7: new opcode_functions(opcode_matrix[0xD7],
            function(regs, pins) { // CMP [d],y
                switch(regs.TCU) {
                        // CMP [d],y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xD8: new opcode_functions(opcode_matrix[0xD8],
            function(regs, pins) { // CLD i
                switch(regs.TCU) {
                        // CLD i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 0;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xD9: new opcode_functions(opcode_matrix[0xD9],
            function(regs, pins) { // CMP a,y
                switch(regs.TCU) {
                        // CMP a,y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDA: new opcode_functions(opcode_matrix[0xDA],
            function(regs, pins) { // PHX s
                switch(regs.TCU) {
                        // PHX s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        pins.RW = 1; pins.PDV = 1;
                        // instruction code follows
                        regs.TR = (regs.X) & 0xFF;
                        // instruction code ends
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 3: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xDB: new opcode_functions(opcode_matrix[0xDB],
            function(regs, pins) { // STP i
                switch(regs.TCU) {
                        // STP i E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.STP = true;
                        // Following is auto-generated code for instruction finish
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDC: new opcode_functions(opcode_matrix[0xDC],
            function(regs, pins) { // JML (a)
                switch(regs.TCU) {
                        // JML (a) E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.PC = regs.TR + (pins.D << 8);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PBR = pins.D;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xDD: new opcode_functions(opcode_matrix[0xDD],
            function(regs, pins) { // CMP a,x
                switch(regs.TCU) {
                        // CMP a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDE: new opcode_functions(opcode_matrix[0xDE],
            function(regs, pins) { // DEC a,x
                switch(regs.TCU) {
                        // DEC a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.RW = 1; pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = ((regs.TR) - 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xDF: new opcode_functions(opcode_matrix[0xDF],
            function(regs, pins) { // CMP al,x
                switch(regs.TCU) {
                        // CMP al,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.C & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE0: new opcode_functions(opcode_matrix[0xE0],
            function(regs, pins) { // CPX #
                switch(regs.TCU) {
                        // CPX # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.X & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE1: new opcode_functions(opcode_matrix[0xE1],
            function(regs, pins) { // SBC (d,x)
                switch(regs.TCU) {
                        // SBC (d,x) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                        break;
                    case 4: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // 5
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE2: new opcode_functions(opcode_matrix[0xE2],
            function(regs, pins) { // SEP #
                switch(regs.TCU) {
                        // SEP # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 2a for REP/SEP
                        regs.TR = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.P.setbyte_emulated(regs.P.getbyte_emulated() | regs.TR);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE3: new opcode_functions(opcode_matrix[0xE3],
            function(regs, pins) { // SBC d,s
                switch(regs.TCU) {
                        // SBC d,s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE4: new opcode_functions(opcode_matrix[0xE4],
            function(regs, pins) { // CPX d
                switch(regs.TCU) {
                        // CPX d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.X & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xE5: new opcode_functions(opcode_matrix[0xE5],
            function(regs, pins) { // SBC d
                switch(regs.TCU) {
                        // SBC d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE6: new opcode_functions(opcode_matrix[0xE6],
            function(regs, pins) { // INC d
                switch(regs.TCU) {
                        // INC d E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE7: new opcode_functions(opcode_matrix[0xE7],
            function(regs, pins) { // SBC [d]
                switch(regs.TCU) {
                        // SBC [d] E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 5: // 5
                        regs.TA += pins.D << 8;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xE8: new opcode_functions(opcode_matrix[0xE8],
            function(regs, pins) { // INX i
                switch(regs.TCU) {
                        // INX i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.X = ((regs.X) + 1) & 0xFF;
                        regs.P.Z = +((regs.X) === 0);
                        regs.P.N = ((regs.X) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xE9: new opcode_functions(opcode_matrix[0xE9],
            function(regs, pins) { // SBC #
                switch(regs.TCU) {
                        // SBC # E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEA: new opcode_functions(opcode_matrix[0xEA],
            function(regs, pins) { // NOP i
                switch(regs.TCU) {
                        // NOP i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEB: new opcode_functions(opcode_matrix[0xEB],
            function(regs, pins) { // XBA i
                switch(regs.TCU) {
                        // XBA i E=1 M=1 X=1
                    case 1:
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        break;
                    case 2:
                        break;
                    case 3: // cleanup_custom
                        // In the future we will check IRQs here
                        // instruction code follows
                        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >>> 8) & 0xFF);
                        regs.P.Z = +((regs.C & 0xFF) === 0);
                        regs.P.N = ((regs.C & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xEC: new opcode_functions(opcode_matrix[0xEC],
            function(regs, pins) { // CPX a
                switch(regs.TCU) {
                        // CPX a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = (regs.X & 0xFF) - regs.TR;
                        regs.P.C = +(regs.TR >= 0);
                        regs.P.Z = +((regs.TR & 0xFF) === 0);
                        regs.P.N = ((regs.TR & 0xFF) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, true),
        0xED: new opcode_functions(opcode_matrix[0xED],
            function(regs, pins) { // SBC a
                switch(regs.TCU) {
                        // SBC a E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEE: new opcode_functions(opcode_matrix[0xEE],
            function(regs, pins) { // INC a
                switch(regs.TCU) {
                        // INC a E=1 M=1 X=1
                        //case AM.Ad
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                        break;
                    case 4: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 5: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 6: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xEF: new opcode_functions(opcode_matrix[0xEF],
            function(regs, pins) { // SBC al
                switch(regs.TCU) {
                        // SBC al E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = (regs.TA); pins.BA = (pins.D);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF0: new opcode_functions(opcode_matrix[0xF0],
            function(regs, pins) { // BEQ r
                switch(regs.TCU) {
                        // BEQ r E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TR = regs.P.Z === 1;
                        regs.skipped_cycle = 0;
                        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                        break;
                    case 2: // 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // 2b
                        if (regs.skipped_cycle === 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        if (regs.skipped_cycle === 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                        if (regs.TR) regs.PC = (regs.PC + mksigned8(regs.TA)) & 0xFFFF;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF1: new opcode_functions(opcode_matrix[0xF1],
            function(regs, pins) { // SBC (d),y
                switch(regs.TCU) {
                        // SBC (d),y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + (regs.Y & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 5: // 4a
                        regs.TA += pins.D << 8;
                        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
                        pins.PDV = 0;
                        break;
                    case 6: // 5
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TR = regs.DBR;
                        regs.TA += regs.Y;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF2: new opcode_functions(opcode_matrix[0xF2],
            function(regs, pins) { // SBC (d)
                switch(regs.TCU) {
                        // SBC (d) E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF3: new opcode_functions(opcode_matrix[0xF3],
            function(regs, pins) { // SBC (d,s),y
                switch(regs.TCU) {
                        // SBC (d,s),y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.PDV = 0;
                        regs.TA = (pins.D + regs.S) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (0);
                        break;
                    case 4: // 5
                        regs.TR = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
                        regs.TR = regs.DBR;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.PDV = 0;
                        break;
                    case 6: // 7
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF4: new opcode_functions(opcode_matrix[0xF4],
            function(regs, pins) { // PEA s
                switch(regs.TCU) {
                        // PEA s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TR = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        pins.D = regs.TR;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.S = (regs.S & 0xFF) + 0x100;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xF5: new opcode_functions(opcode_matrix[0xF5],
            function(regs, pins) { // SBC d,x
                switch(regs.TCU) {
                        // SBC d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF6: new opcode_functions(opcode_matrix[0xF6],
            function(regs, pins) { // INC d,x
                switch(regs.TCU) {
                        // INC d,x E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        break;
                    case 4: // 4
                        pins.PDV = 1;
                        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                        break;
                    case 5: // fetch_rmw_8or16 8
                        regs.TR = pins.D;
                        pins.RW = 1; pins.PDV = 0;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF7: new opcode_functions(opcode_matrix[0xF7],
            function(regs, pins) { // SBC [d],y
                switch(regs.TCU) {
                        // SBC [d],y E=1 M=1 X=1
                    case 1: // fetch_D0_and_skip_cycle 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        if ((regs.D & 0xFF) === 0) { regs.skipped_cycle = true; regs.TCU++; }
                        break;
                    case 2: // fetch_D0_and_skip_cycle 2a
                        regs.TA = pins.D;
                        pins.PDV = 0;
                        break;
                    case 3: // fetch_D0_and_skip_cycle 3
                        if (regs.skipped_cycle) {
                            regs.TA = pins.D;
                            pins.PDV = 0;
                        }
                        pins.PDV = 1;
                        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                        break;
                    case 4: // 4
                        regs.TA = pins.D;
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 5: // 5
                        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        break;
                    case 6: // 6
                        regs.TR = pins.D;
                        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xF8: new opcode_functions(opcode_matrix[0xF8],
            function(regs, pins) { // SED i
                switch(regs.TCU) {
                        // SED i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        regs.P.D = 1;
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xF9: new opcode_functions(opcode_matrix[0xF9],
            function(regs, pins) { // SBC a,y
                switch(regs.TCU) {
                        // SBC a,y E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.Y) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.Y)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFA: new opcode_functions(opcode_matrix[0xFA],
            function(regs, pins) { // PLX s
                switch(regs.TCU) {
                        // PLX s E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        pins.PDV = 0;
                        break;
                    case 2: // 3
                        break;
                    case 3: // 4
                        pins.PDV = 1;
                        regs.S = (regs.S + 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.Addr = regs.S; pins.BA = 0;
                        break;
                    case 4: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.X = ((regs.X) & 0xFF00) + (regs.TR & 0xFF);
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, true),
        0xFB: new opcode_functions(opcode_matrix[0xFB],
            function(regs, pins) { // XCE i
                switch(regs.TCU) {
                        // XCE i E=1 M=1 X=1
                    case 1: // 2
                        pins.PDV = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        // instruction code follows
                        let TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
                        if (regs.E) {
                            regs.P.X = regs.P.M = 1;
                            regs.X &= 0xFF;
                            regs.Y &= 0xFF;
                            regs.S = (regs.S & 0xFF) | 0x100;
                        }
                        // instruction code ends
                        break;
                    case 2: // cleanup_custom
                        // In the future we will check IRQs here
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.PDV = 1;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0xFC: new opcode_functions(opcode_matrix[0xFC],
            function(regs, pins) { // JSR (a,x)
                switch(regs.TCU) {
                        // JSR (a,x) E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        pins.RW = 1;
                        regs.TA = pins.D;
                        pins.D = ((regs.PC) & 0xFF00) >>> 8;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 4
                        pins.D = (regs.PC) & 0xFF;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 5
                        pins.RW = 0;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 5: // 6
                        pins.PDV = 0;
                        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                        break;
                    case 6: // 7
                        pins.PDV = 1;
                        pins.Addr = regs.TA;
                        break;
                    case 7: // 8
                        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                        regs.PC = pins.D;
                        break;
                    case 8: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, false, false),
        0xFD: new opcode_functions(opcode_matrix[0xFD],
            function(regs, pins) { // SBC a,x
                switch(regs.TCU) {
                        // SBC a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.skipped_cycle = false;
                        regs.TR = regs.TA + ((regs.X) & 0xFF);
                        if (regs.TR < 0x100) { regs.skipped_cycle = true; regs.TCU++; } 
                        break;
                    case 3: // 3a
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += pins.D << 8
                        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 4
                        if (regs.skipped_cycle) regs.TA += pins.D << 8;
                        regs.TA += (regs.X)
                        regs.TR = regs.DBR;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        pins.PDV = 1;
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFE: new opcode_functions(opcode_matrix[0xFE],
            function(regs, pins) { // INC a,x
                switch(regs.TCU) {
                        // INC a,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        pins.PDV = 0;
                        regs.TR = regs.DBR;
                        regs.TA += (pins.D << 8) + regs.X;
                        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
                        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                        break;
                    case 4: // 5
                        pins.PDV = 1;
                        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                        break;
                    case 5: // 6
                        pins.RW = 1; pins.PDV = 0;
                        regs.TR = pins.D;
                        // instruction code follows
                        regs.TR = ((regs.TR) + 1) & 0xFF;
                        regs.P.Z = +((regs.TR) === 0);
                        regs.P.N = ((regs.TR) & 0x80) >>> 7;
                        // instruction code ends
                        break;
                    case 6: // finish_rmw mem8
                        pins.PDV = 1;
                        pins.D = regs.TR & 0xFF;
                        // Following is auto-generated code for instruction finish
                        break;
                    case 7: // cleanup
                        // In the future we will check IRQs here
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        pins.RW = 0;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0xFF: new opcode_functions(opcode_matrix[0xFF],
            function(regs, pins) { // SBC al,x
                switch(regs.TCU) {
                        // SBC al,x E=1 M=1 X=1
                    case 1: // 2
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 2: // 3
                        regs.TA = pins.D
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 3: // 4
                        regs.TA += pins.D << 8;
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        break;
                    case 4: // 5
                        regs.TA += (pins.D << 16) + regs.X;
                        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >>> 16) & 0xFF);
                        break;
                    case 5: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.TR = pins.D;
                        // instruction code follows
                        let A = regs.C & 0xFF; let data = (~regs.TR) & 0xFF;
                        let result;
                        if (!regs.P.D) result = data + A + regs.P.C;
                        else {
                            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
                            if (result <= 0x0F) result -= 0x06;
                            regs.P.C = +(result > 0x0F);
                            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
                        }
                        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >>> 7;
                        if (regs.P.D && result <= 0xFF) result -= 0x60;
                        regs.P.C = +(result > 0xFF);
                        regs.P.Z = +((result & 0xFF) === 0);
                        regs.P.N = ((result) & 0x80) >>> 7;
                        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
                        // instruction code ends
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            true, true, false),
        0x100: new opcode_functions(opcode_matrix[0x100],
            function(regs, pins) { // S_RESET s
                switch(regs.TCU) {
                        // S_RESET s E=1 M=1 X=1
                    case 1: // 3
                        pins.RW = 0; pins.PDV = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 2: // 4
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 3: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 4: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        break;
                    case 5: // 7
                        pins.Addr = (0xFFFC); pins.BA = (0);
                        regs.DBR = 0;
                        regs.D = 0;
                        regs.PBR = 0;
                        regs.X &= 0xFF;
                        regs.Y &= 0xFF;
                        regs.S = (regs.S & 0xFF) | 0x100;
                        regs.E = 1;
                        regs.P.M = regs.P.X = regs.P.I = regs.P.C = 1;
                        regs.P.D = 0;
                        regs.STP = regs.WAI = false;
                        break;
                    case 6: // 8
                        regs.PC = pins.D;
                        pins.Addr++; if (pins.Addr === 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                        break;
                    case 7: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC += (pins.D << 8);
                        pins.PDV = 1;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x101: new opcode_functions(opcode_matrix[0x101],
            function(regs, pins) { // S_ABORT s
                switch(regs.TCU) {
                        // S_ABORT s E=1 M=1 X=1
                    case 1: // 4
                        regs.TR = regs.PC;
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 2: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 3: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_emulated() & 0xF7;
                        break;
                    case 4: // 7
                        pins.Addr = (0xFFF8); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 5: // 8
                        pins.Addr = (0xFFF9); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x102: new opcode_functions(opcode_matrix[0x102],
            function(regs, pins) { // S_IRQ s
                switch(regs.TCU) {
                        // S_IRQ s E=1 M=1 X=1
                    case 1: // 4
                        regs.TR = regs.PC;
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 2: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 3: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_emulated() & 0xF7;
                        break;
                    case 4: // 7
                        pins.Addr = (0xFFFE); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 5: // 8
                        pins.Addr = (0xFFFF); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false),
        0x103: new opcode_functions(opcode_matrix[0x103],
            function(regs, pins) { // S_NMI s
                switch(regs.TCU) {
                        // S_NMI s E=1 M=1 X=1
                    case 1: // 4
                        regs.TR = regs.PC;
                        pins.RW = 1;
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = (regs.TR >>> 8) & 0xFF;
                        break;
                    case 2: // 5
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.TR & 0xFF;
                        break;
                    case 3: // 6
                        pins.Addr = regs.S; pins.BA = 0;
                        regs.S = (regs.S - 1) & 0xFFFF;
                        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                        pins.D = regs.P.getbyte_emulated() & 0xF7;
                        break;
                    case 4: // 7
                        pins.Addr = (0xFFFA); pins.BA = (0);
                        pins.RW = 0;
                        break;
                    case 5: // 8
                        pins.Addr = (0xFFFB); pins.BA = (0);
                        regs.TA = pins.D;
                        regs.PBR = 0;
                        break;
                    case 6: // cleanup_custom
                        // In the future we will check IRQs here
                        regs.PC = (pins.D << 8) + regs.TA;
                        regs.P.I = 1;
                        regs.P.D = 0;
                        // Following is auto-generated code for instruction finish
                        pins.Addr = regs.PC; pins.BA = regs.PBR;
                        regs.PC = (regs.PC + 1) & 0xFFFF;
                        regs.TCU = 0;
                        break;
                }
            },
            false, false, false)
},

});