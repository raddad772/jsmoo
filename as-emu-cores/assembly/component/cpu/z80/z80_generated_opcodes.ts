import {Z80_opcode_functions, Z80_opcode_matrix, Z80_CB_opcode_matrix, Z80_CBd_opcode_matrix, Z80_ED_opcode_matrix, Z80_MAX_OPCODE, Z80_S_DECODE, Z80_parity} from "./z80_opcodes"
import {z80_pins, z80_regs, Z80P} from "./z80"
import {mksigned8} from "../../../helpers/helpers"

export var z80_decoded_opcodes: Array<Z80_opcode_functions> = new Array<Z80_opcode_functions>(((Z80_MAX_OPCODE+1)*7));

function z80_get_opcode_function(opcode: u32): Z80_opcode_functions {
    switch(opcode) {
        case 0x00: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // NOP
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x01: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x01), // 01
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.B = ((regs.TR) & 0xFF00) >>> 8;
                    regs.C = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x02: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x02), // 02
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_a BC
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.WZ = (regs.B << 8) | regs.C
                    pins.Addr = (regs.WZ);
                    break;
                case 2:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.A << 8);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x03: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x03), // 03
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr BC
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = (((regs.B << 8) | regs.C ) + 1) & 0xFFFF;
                    regs.B = ((regs.TR) & 0xFF00) >>> 8;
                    regs.C = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x04: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x04), // 04
            function(regs: z80_regs, pins: z80_pins): void { // INC_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.B) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x05: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x05), // 05
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.B) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x06: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x06), // 06
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n B
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x07: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x07), // 07
            function(regs: z80_regs, pins: z80_pins): void { // RLCA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = (regs.A & 0x80) >>> 7;
                    regs.A = ((regs.A << 1) | c) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x08: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x08), // 08
            function(regs: z80_regs, pins: z80_pins): void { // EX_rr_rr AF AF_
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.exchange_shadow_af();
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x09: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x09), // 09
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr BC
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was HL
                    regs.Q = 1;
                    regs.WZ = (((regs.H << 8) | regs.L) + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = regs.L;
                    y = regs.C;
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = regs.H;
                    y = regs.B;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.H = regs.t[5];
                    regs.L = regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x0A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0A), // 0A
            function(regs: z80_regs, pins: z80_pins): void { // LD_a_irr BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.WZ = (regs.B << 8) | regs.C;
                    pins.Addr = (regs.WZ);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.A = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x0B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0B), // 0B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr BC
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = (regs.B << 8) | regs.C
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.B = ((regs.TA) & 0xFF00) >>> 8;
                    regs.C = (regs.TA) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x0C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0C), // 0C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.C) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x0D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0D), // 0D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.C) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x0E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0E), // 0E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n C
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x0F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0F), // 0F
            function(regs: z80_regs, pins: z80_pins): void { // RRCA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = regs.A & 1;
                    regs.A = (c << 7) | (regs.A >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x10: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x10), // 10
            function(regs: z80_regs, pins: z80_pins): void { // DJNZ_e
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    break;
                case 2: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    regs.B = (regs.B - 1) & 0xFF;
                    if (regs.B == 0) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 5: // Adding 5 cycles
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    break;
                case 9:
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x11: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x11), // 11
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.D = ((regs.TR) & 0xFF00) >>> 8;
                    regs.E = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x12: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x12), // 12
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_a DE
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.WZ = (regs.D << 8) | regs.E
                    pins.Addr = (regs.WZ);
                    break;
                case 2:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.A << 8);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x13: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x13), // 13
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr DE
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = (((regs.D << 8) | regs.E ) + 1) & 0xFFFF;
                    regs.D = ((regs.TR) & 0xFF00) >>> 8;
                    regs.E = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x14: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x14), // 14
            function(regs: z80_regs, pins: z80_pins): void { // INC_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.D) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x15: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x15), // 15
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.D) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x16: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x16), // 16
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n D
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x17: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x17), // 17
            function(regs: z80_regs, pins: z80_pins): void { // RLA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = (regs.A & 0x80) >>> 7;
                    regs.A = ((regs.A << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x18: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x18), // 18
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(1)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x19: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x19), // 19
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr DE
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was HL
                    regs.Q = 1;
                    regs.WZ = (((regs.H << 8) | regs.L) + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = regs.L;
                    y = regs.E;
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = regs.H;
                    y = regs.D;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.H = regs.t[5];
                    regs.L = regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1A), // 1A
            function(regs: z80_regs, pins: z80_pins): void { // LD_a_irr DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.WZ = (regs.D << 8) | regs.E;
                    pins.Addr = (regs.WZ);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.A = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1B), // 1B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr DE
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = (regs.D << 8) | regs.E
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.D = ((regs.TA) & 0xFF00) >>> 8;
                    regs.E = (regs.TA) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1C), // 1C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.E) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1D), // 1D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.E) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1E), // 1E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n E
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1F), // 1F
            function(regs: z80_regs, pins: z80_pins): void { // RRA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = regs.A & 1;
                    regs.A = (regs.F.C << 7) | (regs.A >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x20: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x20), // 20
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.Z === 0)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x21: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x21), // 21
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.H = ((regs.TR) & 0xFF00) >>> 8;
                    regs.L = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x22: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x22), // 22
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_rr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.L);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    break;
                case 10: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 11:
                    pins.D = (regs.H);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 12: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x23: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x23), // 23
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr HL
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = (((regs.H << 8) | regs.L ) + 1) & 0xFFFF;
                    regs.H = ((regs.TR) & 0xFF00) >>> 8;
                    regs.L = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x24: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x24), // 24
            function(regs: z80_regs, pins: z80_pins): void { // INC_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.H) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x25: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x25), // 25
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.H) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x26: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x26), // 26
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n H
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x27: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x27), // 27
            function(regs: z80_regs, pins: z80_pins): void { // DAA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let a = regs.A;
                    if (regs.F.C || (regs.A > 0x99)) { regs.A = (regs.A + (regs.F.N ? -0x60: 0x60)) & 0xFF; regs.F.C = 1; }
                    if (regs.F.H || ((regs.A & 0x0F) > 0x09)) { regs.A = (regs.A + (regs.F.N ? -6 : 6)) & 0xFF; }
                    regs.F.PV = Z80_parity(regs.A);
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.H = ((a ^ regs.A) & 0x10) >>> 4;
                    regs.F.Z = +(regs.A == 0);
                    regs.F.S = ((regs.A) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x28: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x28), // 28
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.Z === 1)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x29: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x29), // 29
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr HL
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was HL
                    regs.Q = 1;
                    regs.WZ = (((regs.H << 8) | regs.L) + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = regs.L;
                    y = regs.L;
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = regs.H;
                    y = regs.H;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.H = regs.t[5];
                    regs.L = regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2A), // 2A
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_inn HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TA = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TA |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.L = (regs.TR);
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.WZ = regs.TA;
                    break;
                case 10: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 11: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 12: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.H = (regs.TR);
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2B), // 2B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr HL
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = (regs.H << 8) | regs.L
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2C), // 2C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.L) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2D), // 2D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.L) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2E), // 2E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n L
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2F), // 2F
            function(regs: z80_regs, pins: z80_pins): void { // CPL
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A ^= 0xFF;
                    regs.F.N = regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x30: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x30), // 30
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.C === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.C === 0)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x31: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x31), // 31
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn SP
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.SP = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x32: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x32), // 32
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_a
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.A << 8);
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x33: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x33), // 33
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr SP
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = ((regs.SP ) + 1) & 0xFFFF;
                    regs.SP = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x34: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x34), // 34
            function(regs: z80_regs, pins: z80_pins): void { // INC_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4:
                    regs.TR = ((regs.TR) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x35: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x35), // 35
            function(regs: z80_regs, pins: z80_pins): void { // DEC_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4:
                    regs.TR = ((regs.TR) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x36: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x36), // 36
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_n HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 5:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 6: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x37: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x37), // 37
            function(regs: z80_regs, pins: z80_pins): void { // SCF
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    if (regs.Q) { regs.F.X = 0; regs.F.Y = 0; }
                    regs.F.C = regs.Q = 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X |= ((regs.A & 8) >>> 3);
                    regs.F.Y |= ((regs.A & 0x20) >>> 5);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x38: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x38), // 38
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.C === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.C === 1)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x39: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x39), // 39
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr SP
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was HL
                    regs.Q = 1;
                    regs.WZ = (((regs.H << 8) | regs.L) + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = regs.L;
                    y = (regs.SP & 0xFF);
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = regs.H;
                    y = ((regs.SP & 0xFF00) >>> 8);
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.H = regs.t[5];
                    regs.L = regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3A), // 3A
            function(regs: z80_regs, pins: z80_pins): void { // LD_a_inn
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.A = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3B), // 3B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr SP
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = regs.SP
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.SP = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3C), // 3C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.A) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3D), // 3D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.A) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3E), // 3E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n A
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3F), // 3F
            function(regs: z80_regs, pins: z80_pins): void { // CCF
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    if (regs.Q) { regs.F.X = regs.F.Y = 0; } 
                    regs.F.H = regs.F.C;
                    regs.F.C = +(!regs.F.C);
                    regs.F.N = 0;
                    regs.F.X |= (regs.A & 8) >>> 3;
                    regs.F.Y |= (regs.A & 0x20) >>> 5;
                    regs.Q = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x40: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x40), // 40
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x41: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x41), // 41
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x42: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x42), // 42
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x43: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x43), // 43
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x44: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x44), // 44
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.H;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x45: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x45), // 45
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.L;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x46: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x46), // 46
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr B HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x47: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x47), // 47
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x48: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x48), // 48
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x49: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x49), // 49
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4A), // 4A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4B), // 4B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4C), // 4C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.H;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4D), // 4D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.L;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4E), // 4E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr C HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4F), // 4F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x50: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x50), // 50
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x51: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x51), // 51
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x52: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x52), // 52
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x53: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x53), // 53
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x54: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x54), // 54
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.H;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x55: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x55), // 55
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.L;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x56: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x56), // 56
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr D HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x57: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x57), // 57
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x58: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x58), // 58
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x59: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x59), // 59
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5A), // 5A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5B), // 5B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5C), // 5C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.H;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5D), // 5D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.L;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5E), // 5E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr E HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5F), // 5F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x60: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x60), // 60
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.H = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x61: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x61), // 61
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.H = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x62: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x62), // 62
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.H = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x63: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x63), // 63
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.H = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x64: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x64), // 64
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.H = regs.H;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x65: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x65), // 65
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.H = regs.L;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x66: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x66), // 66
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr _H HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x67: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x67), // 67
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.H = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x68: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x68), // 68
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.L = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x69: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x69), // 69
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.L = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6A), // 6A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.L = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6B), // 6B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.L = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6C), // 6C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.L = regs.H;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6D), // 6D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.L = regs.L;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6E), // 6E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr _L HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6F), // 6F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.L = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x70: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x70), // 70
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL B
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2:
                    pins.D = (regs.B);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x71: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x71), // 71
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL C
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2:
                    pins.D = (regs.C);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x72: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x72), // 72
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL D
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2:
                    pins.D = (regs.D);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x73: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x73), // 73
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL E
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2:
                    pins.D = (regs.E);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x74: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x74), // 74
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL _H
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2:
                    pins.D = (regs.H);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x75: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x75), // 75
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL _L
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2:
                    pins.D = (regs.L);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x76: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x76), // 76
            function(regs: z80_regs, pins: z80_pins): void { // HALT
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.HALT = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x77: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x77), // 77
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL A
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x78: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x78), // 78
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x79: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x79), // 79
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x7A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7A), // 7A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x7B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7B), // 7B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x7C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7C), // 7C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.H;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x7D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7D), // 7D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.L;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x7E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7E), // 7E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr A HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x7F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7F), // 7F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x80: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x80), // 80
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.B;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x81: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x81), // 81
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.C;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x82: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x82), // 82
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.D;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x83: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x83), // 83
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.E;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x84: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x84), // 84
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.H;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x85: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x85), // 85
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.L;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x86: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x86), // 86
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x87: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x87), // 87
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.A;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x88: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x88), // 88
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.B;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x89: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x89), // 89
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.C;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x8A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8A), // 8A
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.D;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x8B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8B), // 8B
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.E;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x8C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8C), // 8C
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.H;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x8D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8D), // 8D
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.L;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x8E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8E), // 8E
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x8F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8F), // 8F
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.A;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x90: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x90), // 90
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.B);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x91: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x91), // 91
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.C);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x92: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x92), // 92
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.D);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x93: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x93), // 93
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.E);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x94: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x94), // 94
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.H);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x95: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x95), // 95
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.L);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x96: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x96), // 96
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x97: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x97), // 97
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x98: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x98), // 98
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.B);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x99: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x99), // 99
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.C);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x9A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9A), // 9A
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.D);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x9B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9B), // 9B
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.E);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x9C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9C), // 9C
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.H);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x9D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9D), // 9D
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.L);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x9E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9E), // 9E
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x9F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9F), // 9F
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA0), // A0
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.B);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA1), // A1
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.C);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA2), // A2
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.D);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA3), // A3
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.E);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA4), // A4
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.H);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA5), // A5
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.L);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA6), // A6
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.A) & (regs.TR);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA7), // A7
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.A);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA8), // A8
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.B);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xA9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA9), // A9
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.C);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xAA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAA), // AA
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.D);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xAB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAB), // AB
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.E);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xAC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAC), // AC
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.H);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xAD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAD), // AD
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.L);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xAE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAE), // AE
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.A) ^ (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xAF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAF), // AF
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.A);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB0), // B0
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.B);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB1), // B1
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.C);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB2), // B2
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.D);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB3), // B3
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.E);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB4), // B4
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.H);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB5), // B5
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.L);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB6), // B6
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.A) | (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB7), // B7
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.A);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB8), // B8
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.B;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xB9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB9), // B9
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.C;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xBA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBA), // BA
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.D;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xBB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBB), // BB
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.E;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xBC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBC), // BC
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.H;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xBD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBD), // BD
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.L;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xBE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBE), // BE
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.TR;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xBF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBF), // BF
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.A;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC0), // C0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.Z === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC1), // C1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.B = ((regs.TR) & 0xFF00) >>> 8;
                    regs.C = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC2), // C2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.Z === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC3), // C3
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC4), // C4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.Z === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC5), // C5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr BC
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.B);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.C);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC6), // C6
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC7), // C7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 0
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x00;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC8), // C8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.Z === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xC9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC9), // C9
            function(regs: z80_regs, pins: z80_pins): void { // RET
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xCA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCA), // CA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.Z === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xCB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0xCC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCC), // CC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.Z === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xCD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCD), // CD
            function(regs: z80_regs, pins: z80_pins): void { // CALL_nn
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    break;
                case 14: // cleanup_custom
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xCE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCE), // CE
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xCF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCF), // CF
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 1
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x08;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD0), // D0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.C === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.C === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD1), // D1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.D = ((regs.TR) & 0xFF00) >>> 8;
                    regs.E = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD2), // D2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.C === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.C === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD3), // D3
            function(regs: z80_regs, pins: z80_pins): void { // OUT_in_a
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.A << 8);
                    break;
                case 4: // OUT start
                    pins.Addr = regs.WZ;
                    pins.D = regs.A;
                    regs.data = pins.D;
                    break;
                case 5: // OUT continues
                    break;
                case 6: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 7: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.WZ & 0xFF00);
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD4), // D4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.C === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.C === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD5), // D5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr DE
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.D);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.E);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD6), // D6
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD7), // D7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 2
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x10;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD8), // D8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.C === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.C === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xD9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD9), // D9
            function(regs: z80_regs, pins: z80_pins): void { // EXX
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.exchange_shadow();
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xDA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDA), // DA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.C === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.C === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xDB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDB), // DB
            function(regs: z80_regs, pins: z80_pins): void { // IN_a_in
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.A << 8);
                    break;
                case 4: // IN start
                    pins.Addr = regs.WZ;
                    break;
                case 5: // IN actual read
                    break;
                case 6: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 7: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.A = pins.D;
                    regs.data = pins.D;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xDC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDC), // DC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.C === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.C === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xDD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0xDE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDE), // DE
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xDF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDF), // DF
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 3
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x18;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE0), // E0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.PV === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.PV === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE1), // E1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.H = ((regs.TR) & 0xFF00) >>> 8;
                    regs.L = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE2), // E2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.PV === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.PV === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE3), // E3
            function(regs: z80_regs, pins: z80_pins): void { // EX_irr_rr SP HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = regs.SP;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ |= (regs.TR << 8);
                    break;
                case 7: // wait
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (regs.L);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 12:
                    pins.D = (regs.H);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    break;
                case 14: // wait
                    break;
                case 15: // wait
                    regs.H = ((regs.WZ) & 0xFF00) >>> 8;
                    regs.L = (regs.WZ) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 16: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE4), // E4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.PV === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.PV === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE5), // E5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr HL
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.H);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.L);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE6), // E6
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let z = (regs.A) & (regs.TR);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE7), // E7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 4
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x20;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE8), // E8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.PV === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.PV === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xE9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE9), // E9
            function(regs: z80_regs, pins: z80_pins): void { // JP_rr HL
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.PC = (regs.H << 8) | regs.L;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xEA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEA), // EA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.PV === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.PV === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xEB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEB), // EB
            function(regs: z80_regs, pins: z80_pins): void { // EX_rr_rr DE _HL
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.exchange_de_hl();
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xEC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEC), // EC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.PV === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.PV === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xED: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0xEE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEE), // EE
            function(regs: z80_regs, pins: z80_pins): void { // undefined
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let z = (regs.A) ^ (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xEF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEF), // EF
            function(regs: z80_regs, pins: z80_pins): void { // RST 5
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x28;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF0), // F0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.S === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.S === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF1), // F1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr AF
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.A = ((regs.TR) & 0xFF00) >>> 8;
                    regs.F.setbyte((regs.TR) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF2), // F2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.S === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.S === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF3), // F3
            function(regs: z80_regs, pins: z80_pins): void { // DI
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IFF1 = regs.IFF2 = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF4), // F4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.S === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.S === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF5), // F5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr AF
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.F.getbyte());
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF6), // F6
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let z = (regs.A) | (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF7), // F7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 6
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x30;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF8), // F8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.S === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.S === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xF9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF9), // F9
            function(regs: z80_regs, pins: z80_pins): void { // LD_sp_rr HL
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.SP = (regs.H << 8) | regs.L
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xFA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFA), // FA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.S === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.S === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xFB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFB), // FB
            function(regs: z80_regs, pins: z80_pins): void { // EI
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IFF1 = regs.IFF2 = regs.EI = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xFC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFC), // FC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.S === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.S === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xFD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0xFE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFE), // FE
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.TR;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0xFF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFF), // FF
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 7
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x38;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x100: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x100), // 100
            function(regs: z80_regs, pins: z80_pins): void { // IRQ
            switch(regs.TCU) {
                case 1:
                    regs.R = (regs.R + 1) & 0x7F;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    let wait: u32;
                    switch(pins.IRQ_maskable ? regs.IM : 1) {
                    case 0:
                        regs.t[0] = 0;
                        regs.WZ = pins.D;
                        wait = 12 - (((pins.D | 0x38) == 0xFF) ? 6 : 7);
                        regs.TCU += wait;
                        break;
                    case 1:
                        regs.t[0] = 0;
                        regs.WZ = regs.IRQ_vec;
                        wait = 12 - (pins.IRQ_maskable ? 7 : 5);
                        regs.TCU += wait;
                        break;
                    case 2:
                        regs.t[0] = 1;
                        regs.TA = (regs.I << 8) | pins.D;
                        regs.WZ = 0;
                        break;
                    }
                    break;
                case 8: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 9: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 10: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    break;
                case 11: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 12: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 13: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    if (regs.t[0] == 1) { regs.WZ |= regs.TR << 8; }
                    break;
                case 14: // Adding 6 cycles
                    break;
                case 15:
                    break;
                case 16:
                    break;
                case 17:
                    break;
                case 18:
                    break;
                case 19:
                    regs.PC = regs.WZ;
                    regs.IFF1 = 0;
                    if (pins.IRQ_maskable) regs.IFF2 = 0;
                    regs.HALT = 0;
                    if (regs.P) regs.F.PV = 0;
                    regs.P = 0;
                    regs.Q = 0;
                    regs.IRQ_vec = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 20: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x101: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x101), // 101
            function(regs: z80_regs, pins: z80_pins): void { // RESET
            switch(regs.TCU) {
                case 1:
                    regs.IFF1 = regs.IFF2 = 0; // disable interrupt
                    regs.IM = 0;
                    regs.I = 0;
                    regs.R = 0;
                    regs.PC = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 2: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x102: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x00), // CB 00
            function(regs: z80_regs, pins: z80_pins): void { // RLC_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.B;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x103: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x01), // CB 01
            function(regs: z80_regs, pins: z80_pins): void { // RLC_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.C;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x104: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x02), // CB 02
            function(regs: z80_regs, pins: z80_pins): void { // RLC_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.D;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x105: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x03), // CB 03
            function(regs: z80_regs, pins: z80_pins): void { // RLC_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.E;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x106: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x04), // CB 04
            function(regs: z80_regs, pins: z80_pins): void { // RLC_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.H;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x107: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x05), // CB 05
            function(regs: z80_regs, pins: z80_pins): void { // RLC_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.L;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x108: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x06), // CB 06
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x109: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x07), // CB 07
            function(regs: z80_regs, pins: z80_pins): void { // RLC_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x10A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x08), // CB 08
            function(regs: z80_regs, pins: z80_pins): void { // RRC_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.B;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x10B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x09), // CB 09
            function(regs: z80_regs, pins: z80_pins): void { // RRC_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.C;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x10C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x0A), // CB 0A
            function(regs: z80_regs, pins: z80_pins): void { // RRC_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.D;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x10D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x0B), // CB 0B
            function(regs: z80_regs, pins: z80_pins): void { // RRC_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.E;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x10E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x0C), // CB 0C
            function(regs: z80_regs, pins: z80_pins): void { // RRC_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.H;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x10F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x0D), // CB 0D
            function(regs: z80_regs, pins: z80_pins): void { // RRC_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.L;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x110: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x0E), // CB 0E
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x111: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x0F), // CB 0F
            function(regs: z80_regs, pins: z80_pins): void { // RRC_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x112: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x10), // CB 10
            function(regs: z80_regs, pins: z80_pins): void { // RL_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.B;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x113: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x11), // CB 11
            function(regs: z80_regs, pins: z80_pins): void { // RL_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.C;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x114: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x12), // CB 12
            function(regs: z80_regs, pins: z80_pins): void { // RL_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.D;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x115: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x13), // CB 13
            function(regs: z80_regs, pins: z80_pins): void { // RL_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.E;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x116: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x14), // CB 14
            function(regs: z80_regs, pins: z80_pins): void { // RL_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.H;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x117: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x15), // CB 15
            function(regs: z80_regs, pins: z80_pins): void { // RL_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.L;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x118: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x16), // CB 16
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x119: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x17), // CB 17
            function(regs: z80_regs, pins: z80_pins): void { // RL_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x11A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x18), // CB 18
            function(regs: z80_regs, pins: z80_pins): void { // RR_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.B;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x11B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x19), // CB 19
            function(regs: z80_regs, pins: z80_pins): void { // RR_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.C;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x11C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x1A), // CB 1A
            function(regs: z80_regs, pins: z80_pins): void { // RR_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.D;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x11D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x1B), // CB 1B
            function(regs: z80_regs, pins: z80_pins): void { // RR_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.E;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x11E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x1C), // CB 1C
            function(regs: z80_regs, pins: z80_pins): void { // RR_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.H;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x11F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x1D), // CB 1D
            function(regs: z80_regs, pins: z80_pins): void { // RR_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.L;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x120: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x1E), // CB 1E
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x121: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x1F), // CB 1F
            function(regs: z80_regs, pins: z80_pins): void { // RR_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x122: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x20), // CB 20
            function(regs: z80_regs, pins: z80_pins): void { // SLA_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.B;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x123: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x21), // CB 21
            function(regs: z80_regs, pins: z80_pins): void { // SLA_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.C;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x124: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x22), // CB 22
            function(regs: z80_regs, pins: z80_pins): void { // SLA_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.D;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x125: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x23), // CB 23
            function(regs: z80_regs, pins: z80_pins): void { // SLA_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.E;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x126: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x24), // CB 24
            function(regs: z80_regs, pins: z80_pins): void { // SLA_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.H;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x127: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x25), // CB 25
            function(regs: z80_regs, pins: z80_pins): void { // SLA_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.L;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x128: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x26), // CB 26
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x129: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x27), // CB 27
            function(regs: z80_regs, pins: z80_pins): void { // SLA_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x12A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x28), // CB 28
            function(regs: z80_regs, pins: z80_pins): void { // SRA_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.B;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x12B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x29), // CB 29
            function(regs: z80_regs, pins: z80_pins): void { // SRA_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.C;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x12C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x2A), // CB 2A
            function(regs: z80_regs, pins: z80_pins): void { // SRA_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.D;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x12D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x2B), // CB 2B
            function(regs: z80_regs, pins: z80_pins): void { // SRA_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.E;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x12E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x2C), // CB 2C
            function(regs: z80_regs, pins: z80_pins): void { // SRA_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.H;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x12F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x2D), // CB 2D
            function(regs: z80_regs, pins: z80_pins): void { // SRA_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.L;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x130: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x2E), // CB 2E
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x131: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x2F), // CB 2F
            function(regs: z80_regs, pins: z80_pins): void { // SRA_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x132: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x30), // CB 30
            function(regs: z80_regs, pins: z80_pins): void { // SLL_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.B;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x133: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x31), // CB 31
            function(regs: z80_regs, pins: z80_pins): void { // SLL_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.C;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x134: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x32), // CB 32
            function(regs: z80_regs, pins: z80_pins): void { // SLL_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.D;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x135: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x33), // CB 33
            function(regs: z80_regs, pins: z80_pins): void { // SLL_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.E;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x136: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x34), // CB 34
            function(regs: z80_regs, pins: z80_pins): void { // SLL_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.H;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x137: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x35), // CB 35
            function(regs: z80_regs, pins: z80_pins): void { // SLL_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.L;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x138: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x36), // CB 36
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4: // wait
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x139: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x37), // CB 37
            function(regs: z80_regs, pins: z80_pins): void { // SLL_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x13A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x38), // CB 38
            function(regs: z80_regs, pins: z80_pins): void { // SRL_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.B;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x13B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x39), // CB 39
            function(regs: z80_regs, pins: z80_pins): void { // SRL_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.C;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x13C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x3A), // CB 3A
            function(regs: z80_regs, pins: z80_pins): void { // SRL_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.D;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x13D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x3B), // CB 3B
            function(regs: z80_regs, pins: z80_pins): void { // SRL_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.E;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x13E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x3C), // CB 3C
            function(regs: z80_regs, pins: z80_pins): void { // SRL_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.H;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x13F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x3D), // CB 3D
            function(regs: z80_regs, pins: z80_pins): void { // SRL_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.L;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x140: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x3E), // CB 3E
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x141: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x3F), // CB 3F
            function(regs: z80_regs, pins: z80_pins): void { // SRL_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x142: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x40), // CB 40
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 0 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.B) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x143: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x41), // CB 41
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 0 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.C) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.C) & 8) >>> 3;
                    regs.F.Y = ((regs.C) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x144: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x42), // CB 42
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 0 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.D) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.D) & 8) >>> 3;
                    regs.F.Y = ((regs.D) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x145: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x43), // CB 43
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 0 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.E) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.E) & 8) >>> 3;
                    regs.F.Y = ((regs.E) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x146: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x44), // CB 44
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 0 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.H) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.H) & 8) >>> 3;
                    regs.F.Y = ((regs.H) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x147: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x45), // CB 45
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 0 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.L) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.L) & 8) >>> 3;
                    regs.F.Y = ((regs.L) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x148: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x46), // CB 46
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr 0 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x149: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x47), // CB 47
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 0 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x14A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x48), // CB 48
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 1 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.B) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x14B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x49), // CB 49
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 1 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.C) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.C) & 8) >>> 3;
                    regs.F.Y = ((regs.C) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x14C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x4A), // CB 4A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 1 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.D) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.D) & 8) >>> 3;
                    regs.F.Y = ((regs.D) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x14D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x4B), // CB 4B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 1 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.E) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.E) & 8) >>> 3;
                    regs.F.Y = ((regs.E) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x14E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x4C), // CB 4C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 1 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.H) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.H) & 8) >>> 3;
                    regs.F.Y = ((regs.H) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x14F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x4D), // CB 4D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 1 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.L) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.L) & 8) >>> 3;
                    regs.F.Y = ((regs.L) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x150: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x4E), // CB 4E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr 1 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x151: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x4F), // CB 4F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 1 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x152: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x50), // CB 50
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 2 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.B) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x153: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x51), // CB 51
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 2 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.C) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.C) & 8) >>> 3;
                    regs.F.Y = ((regs.C) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x154: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x52), // CB 52
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 2 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.D) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.D) & 8) >>> 3;
                    regs.F.Y = ((regs.D) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x155: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x53), // CB 53
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 2 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.E) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.E) & 8) >>> 3;
                    regs.F.Y = ((regs.E) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x156: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x54), // CB 54
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 2 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.H) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.H) & 8) >>> 3;
                    regs.F.Y = ((regs.H) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x157: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x55), // CB 55
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 2 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.L) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.L) & 8) >>> 3;
                    regs.F.Y = ((regs.L) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x158: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x56), // CB 56
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr 2 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x159: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x57), // CB 57
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 2 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x15A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x58), // CB 58
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 3 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.B) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x15B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x59), // CB 59
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 3 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.C) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.C) & 8) >>> 3;
                    regs.F.Y = ((regs.C) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x15C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x5A), // CB 5A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 3 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.D) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.D) & 8) >>> 3;
                    regs.F.Y = ((regs.D) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x15D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x5B), // CB 5B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 3 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.E) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.E) & 8) >>> 3;
                    regs.F.Y = ((regs.E) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x15E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x5C), // CB 5C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 3 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.H) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.H) & 8) >>> 3;
                    regs.F.Y = ((regs.H) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x15F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x5D), // CB 5D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 3 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.L) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.L) & 8) >>> 3;
                    regs.F.Y = ((regs.L) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x160: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x5E), // CB 5E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr 3 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x161: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x5F), // CB 5F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 3 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x162: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x60), // CB 60
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 4 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.B) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x163: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x61), // CB 61
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 4 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.C) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.C) & 8) >>> 3;
                    regs.F.Y = ((regs.C) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x164: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x62), // CB 62
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 4 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.D) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.D) & 8) >>> 3;
                    regs.F.Y = ((regs.D) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x165: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x63), // CB 63
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 4 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.E) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.E) & 8) >>> 3;
                    regs.F.Y = ((regs.E) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x166: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x64), // CB 64
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 4 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.H) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.H) & 8) >>> 3;
                    regs.F.Y = ((regs.H) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x167: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x65), // CB 65
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 4 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.L) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.L) & 8) >>> 3;
                    regs.F.Y = ((regs.L) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x168: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x66), // CB 66
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr 4 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x169: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x67), // CB 67
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 4 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x16A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x68), // CB 68
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 5 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.B) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x16B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x69), // CB 69
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 5 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.C) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.C) & 8) >>> 3;
                    regs.F.Y = ((regs.C) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x16C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x6A), // CB 6A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 5 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.D) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.D) & 8) >>> 3;
                    regs.F.Y = ((regs.D) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x16D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x6B), // CB 6B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 5 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.E) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.E) & 8) >>> 3;
                    regs.F.Y = ((regs.E) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x16E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x6C), // CB 6C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 5 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.H) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.H) & 8) >>> 3;
                    regs.F.Y = ((regs.H) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x16F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x6D), // CB 6D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 5 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.L) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.L) & 8) >>> 3;
                    regs.F.Y = ((regs.L) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x170: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x6E), // CB 6E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr 5 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x171: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x6F), // CB 6F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 5 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x172: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x70), // CB 70
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 6 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.B) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x173: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x71), // CB 71
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 6 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.C) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.C) & 8) >>> 3;
                    regs.F.Y = ((regs.C) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x174: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x72), // CB 72
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 6 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.D) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.D) & 8) >>> 3;
                    regs.F.Y = ((regs.D) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x175: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x73), // CB 73
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 6 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.E) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.E) & 8) >>> 3;
                    regs.F.Y = ((regs.E) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x176: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x74), // CB 74
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 6 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.H) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.H) & 8) >>> 3;
                    regs.F.Y = ((regs.H) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x177: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x75), // CB 75
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 6 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.L) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.L) & 8) >>> 3;
                    regs.F.Y = ((regs.L) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x178: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x76), // CB 76
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr 6 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x179: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x77), // CB 77
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 6 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x17A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x78), // CB 78
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 7 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.B) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x17B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x79), // CB 79
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 7 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.C) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.C) & 8) >>> 3;
                    regs.F.Y = ((regs.C) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x17C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x7A), // CB 7A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 7 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.D) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.D) & 8) >>> 3;
                    regs.F.Y = ((regs.D) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x17D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x7B), // CB 7B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 7 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.E) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.E) & 8) >>> 3;
                    regs.F.Y = ((regs.E) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x17E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x7C), // CB 7C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 7 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.H) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.H) & 8) >>> 3;
                    regs.F.Y = ((regs.H) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x17F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x7D), // CB 7D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 7 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.L) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.L) & 8) >>> 3;
                    regs.F.Y = ((regs.L) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x180: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x7E), // CB 7E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr 7 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x181: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x7F), // CB 7F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_r 7 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x182: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x80), // CB 80
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 0 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.B = regs.B & ((1 << 0) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x183: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x81), // CB 81
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 0 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.C = regs.C & ((1 << 0) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x184: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x82), // CB 82
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 0 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.D = regs.D & ((1 << 0) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x185: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x83), // CB 83
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 0 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.E = regs.E & ((1 << 0) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x186: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x84), // CB 84
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 0 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.H = regs.H & ((1 << 0) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x187: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x85), // CB 85
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 0 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.L = regs.L & ((1 << 0) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x188: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x86), // CB 86
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr 0 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x189: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x87), // CB 87
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 0 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A = regs.A & ((1 << 0) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x18A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x88), // CB 88
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 1 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.B = regs.B & ((1 << 1) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x18B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x89), // CB 89
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 1 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.C = regs.C & ((1 << 1) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x18C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x8A), // CB 8A
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 1 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.D = regs.D & ((1 << 1) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x18D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x8B), // CB 8B
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 1 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.E = regs.E & ((1 << 1) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x18E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x8C), // CB 8C
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 1 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.H = regs.H & ((1 << 1) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x18F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x8D), // CB 8D
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 1 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.L = regs.L & ((1 << 1) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x190: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x8E), // CB 8E
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr 1 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x191: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x8F), // CB 8F
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 1 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A = regs.A & ((1 << 1) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x192: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x90), // CB 90
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 2 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.B = regs.B & ((1 << 2) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x193: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x91), // CB 91
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 2 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.C = regs.C & ((1 << 2) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x194: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x92), // CB 92
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 2 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.D = regs.D & ((1 << 2) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x195: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x93), // CB 93
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 2 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.E = regs.E & ((1 << 2) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x196: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x94), // CB 94
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 2 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.H = regs.H & ((1 << 2) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x197: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x95), // CB 95
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 2 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.L = regs.L & ((1 << 2) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x198: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x96), // CB 96
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr 2 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x199: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x97), // CB 97
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 2 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A = regs.A & ((1 << 2) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x19A: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x98), // CB 98
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 3 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.B = regs.B & ((1 << 3) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x19B: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x99), // CB 99
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 3 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.C = regs.C & ((1 << 3) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x19C: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x9A), // CB 9A
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 3 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.D = regs.D & ((1 << 3) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x19D: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x9B), // CB 9B
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 3 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.E = regs.E & ((1 << 3) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x19E: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x9C), // CB 9C
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 3 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.H = regs.H & ((1 << 3) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x19F: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x9D), // CB 9D
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 3 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.L = regs.L & ((1 << 3) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A0: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x9E), // CB 9E
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr 3 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A1: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0x9F), // CB 9F
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 3 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A = regs.A & ((1 << 3) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A2: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA0), // CB A0
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 4 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.B = regs.B & ((1 << 4) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A3: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA1), // CB A1
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 4 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.C = regs.C & ((1 << 4) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A4: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA2), // CB A2
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 4 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.D = regs.D & ((1 << 4) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A5: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA3), // CB A3
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 4 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.E = regs.E & ((1 << 4) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A6: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA4), // CB A4
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 4 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.H = regs.H & ((1 << 4) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A7: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA5), // CB A5
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 4 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.L = regs.L & ((1 << 4) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A8: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA6), // CB A6
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr 4 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1A9: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA7), // CB A7
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 4 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A = regs.A & ((1 << 4) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1AA: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA8), // CB A8
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 5 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.B = regs.B & ((1 << 5) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1AB: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xA9), // CB A9
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 5 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.C = regs.C & ((1 << 5) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1AC: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xAA), // CB AA
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 5 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.D = regs.D & ((1 << 5) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1AD: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xAB), // CB AB
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 5 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.E = regs.E & ((1 << 5) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1AE: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xAC), // CB AC
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 5 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.H = regs.H & ((1 << 5) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1AF: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xAD), // CB AD
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 5 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.L = regs.L & ((1 << 5) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B0: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xAE), // CB AE
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr 5 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B1: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xAF), // CB AF
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 5 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A = regs.A & ((1 << 5) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B2: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB0), // CB B0
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 6 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.B = regs.B & ((1 << 6) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B3: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB1), // CB B1
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 6 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.C = regs.C & ((1 << 6) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B4: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB2), // CB B2
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 6 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.D = regs.D & ((1 << 6) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B5: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB3), // CB B3
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 6 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.E = regs.E & ((1 << 6) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B6: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB4), // CB B4
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 6 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.H = regs.H & ((1 << 6) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B7: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB5), // CB B5
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 6 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.L = regs.L & ((1 << 6) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B8: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB6), // CB B6
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr 6 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1B9: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB7), // CB B7
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 6 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A = regs.A & ((1 << 6) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1BA: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB8), // CB B8
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 7 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.B = regs.B & ((1 << 7) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1BB: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xB9), // CB B9
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 7 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.C = regs.C & ((1 << 7) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1BC: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xBA), // CB BA
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 7 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.D = regs.D & ((1 << 7) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1BD: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xBB), // CB BB
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 7 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.E = regs.E & ((1 << 7) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1BE: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xBC), // CB BC
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 7 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.H = regs.H & ((1 << 7) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1BF: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xBD), // CB BD
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 7 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.L = regs.L & ((1 << 7) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C0: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xBE), // CB BE
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr 7 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C1: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xBF), // CB BF
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_r 7 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A = regs.A & ((1 << 7) ^ 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C2: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC0), // CB C0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 0 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.B | (1 << 0);
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C3: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC1), // CB C1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 0 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.C | (1 << 0);
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C4: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC2), // CB C2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 0 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.D | (1 << 0);
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C5: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC3), // CB C3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 0 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.E | (1 << 0);
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C6: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC4), // CB C4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 0 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.H | (1 << 0);
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C7: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC5), // CB C5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 0 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.L | (1 << 0);
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C8: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC6), // CB C6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr 0 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1C9: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC7), // CB C7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 0 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.A | (1 << 0);
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1CA: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC8), // CB C8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 1 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.B | (1 << 1);
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1CB: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xC9), // CB C9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 1 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.C | (1 << 1);
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1CC: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xCA), // CB CA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 1 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.D | (1 << 1);
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1CD: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xCB), // CB CB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 1 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.E | (1 << 1);
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1CE: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xCC), // CB CC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 1 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.H | (1 << 1);
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1CF: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xCD), // CB CD
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 1 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.L | (1 << 1);
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D0: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xCE), // CB CE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr 1 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D1: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xCF), // CB CF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 1 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.A | (1 << 1);
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D2: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD0), // CB D0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 2 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.B | (1 << 2);
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D3: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD1), // CB D1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 2 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.C | (1 << 2);
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D4: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD2), // CB D2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 2 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.D | (1 << 2);
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D5: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD3), // CB D3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 2 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.E | (1 << 2);
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D6: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD4), // CB D4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 2 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.H | (1 << 2);
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D7: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD5), // CB D5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 2 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.L | (1 << 2);
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D8: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD6), // CB D6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr 2 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1D9: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD7), // CB D7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 2 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.A | (1 << 2);
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1DA: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD8), // CB D8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 3 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.B | (1 << 3);
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1DB: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xD9), // CB D9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 3 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.C | (1 << 3);
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1DC: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xDA), // CB DA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 3 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.D | (1 << 3);
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1DD: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xDB), // CB DB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 3 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.E | (1 << 3);
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1DE: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xDC), // CB DC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 3 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.H | (1 << 3);
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1DF: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xDD), // CB DD
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 3 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.L | (1 << 3);
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E0: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xDE), // CB DE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr 3 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E1: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xDF), // CB DF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 3 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.A | (1 << 3);
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E2: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE0), // CB E0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 4 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.B | (1 << 4);
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E3: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE1), // CB E1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 4 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.C | (1 << 4);
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E4: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE2), // CB E2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 4 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.D | (1 << 4);
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E5: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE3), // CB E3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 4 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.E | (1 << 4);
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E6: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE4), // CB E4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 4 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.H | (1 << 4);
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E7: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE5), // CB E5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 4 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.L | (1 << 4);
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E8: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE6), // CB E6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr 4 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1E9: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE7), // CB E7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 4 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.A | (1 << 4);
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1EA: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE8), // CB E8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 5 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.B | (1 << 5);
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1EB: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xE9), // CB E9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 5 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.C | (1 << 5);
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1EC: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xEA), // CB EA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 5 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.D | (1 << 5);
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1ED: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xEB), // CB EB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 5 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.E | (1 << 5);
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1EE: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xEC), // CB EC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 5 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.H | (1 << 5);
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1EF: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xED), // CB ED
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 5 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.L | (1 << 5);
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F0: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xEE), // CB EE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr 5 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F1: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xEF), // CB EF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 5 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.A | (1 << 5);
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F2: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF0), // CB F0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 6 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.B | (1 << 6);
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F3: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF1), // CB F1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 6 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.C | (1 << 6);
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F4: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF2), // CB F2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 6 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.D | (1 << 6);
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F5: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF3), // CB F3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 6 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.E | (1 << 6);
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F6: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF4), // CB F4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 6 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.H | (1 << 6);
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F7: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF5), // CB F5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 6 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.L | (1 << 6);
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F8: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF6), // CB F6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr 6 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1F9: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF7), // CB F7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 6 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.A | (1 << 6);
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1FA: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF8), // CB F8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 7 B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.B | (1 << 7);
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1FB: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xF9), // CB F9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 7 C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.C | (1 << 7);
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1FC: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xFA), // CB FA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 7 D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.D | (1 << 7);
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1FD: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xFB), // CB FB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 7 E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.E | (1 << 7);
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1FE: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xFC), // CB FC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 7 H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.H | (1 << 7);
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x1FF: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xFD), // CB FD
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 7 L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.L | (1 << 7);
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x200: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xFE), // CB FE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr 7 _HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 4: // wait
                    break;
                case 5: // write begin
                    pins.Addr = ((regs.H << 8) | regs.L);
                    break;
                case 6:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x201: return new Z80_opcode_functions(Z80_CB_opcode_matrix.get(0xFF), // CB FF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_r 7 A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = regs.A | (1 << 7);
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x202: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x203: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x204: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // DD 00
            function(regs: z80_regs, pins: z80_pins): void { // NOP
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x205: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x01), // DD 01
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.B = ((regs.TR) & 0xFF00) >>> 8;
                    regs.C = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x206: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x02), // DD 02
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_a BC
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.WZ = (regs.B << 8) | regs.C
                    pins.Addr = (regs.WZ);
                    break;
                case 2:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.A << 8);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x207: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x03), // DD 03
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr BC
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = (((regs.B << 8) | regs.C ) + 1) & 0xFFFF;
                    regs.B = ((regs.TR) & 0xFF00) >>> 8;
                    regs.C = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x208: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x04), // DD 04
            function(regs: z80_regs, pins: z80_pins): void { // INC_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.B) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x209: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x05), // DD 05
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.B) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x20A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x06), // DD 06
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n B
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x20B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x07), // DD 07
            function(regs: z80_regs, pins: z80_pins): void { // RLCA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = (regs.A & 0x80) >>> 7;
                    regs.A = ((regs.A << 1) | c) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x20C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x08), // DD 08
            function(regs: z80_regs, pins: z80_pins): void { // EX_rr_rr AF AF_
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.exchange_shadow_af();
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x20D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x09), // DD 09
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr BC
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was IX
                    regs.Q = 1;
                    regs.WZ = (regs.IX + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.IX & 0xFF);
                    y = regs.C;
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = ((regs.IX & 0xFF00) >>> 8);
                    y = regs.B;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.IX = (regs.t[5] << 8) | regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x20E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0A), // DD 0A
            function(regs: z80_regs, pins: z80_pins): void { // LD_a_irr BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.WZ = (regs.B << 8) | regs.C;
                    pins.Addr = (regs.WZ);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.A = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x20F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0B), // DD 0B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr BC
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = (regs.B << 8) | regs.C
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.B = ((regs.TA) & 0xFF00) >>> 8;
                    regs.C = (regs.TA) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x210: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0C), // DD 0C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.C) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x211: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0D), // DD 0D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.C) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x212: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0E), // DD 0E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n C
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x213: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0F), // DD 0F
            function(regs: z80_regs, pins: z80_pins): void { // RRCA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = regs.A & 1;
                    regs.A = (c << 7) | (regs.A >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x214: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x10), // DD 10
            function(regs: z80_regs, pins: z80_pins): void { // DJNZ_e
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    break;
                case 2: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    regs.B = (regs.B - 1) & 0xFF;
                    if (regs.B == 0) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 5: // Adding 5 cycles
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    break;
                case 9:
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x215: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x11), // DD 11
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.D = ((regs.TR) & 0xFF00) >>> 8;
                    regs.E = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x216: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x12), // DD 12
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_a DE
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.WZ = (regs.D << 8) | regs.E
                    pins.Addr = (regs.WZ);
                    break;
                case 2:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.A << 8);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x217: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x13), // DD 13
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr DE
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = (((regs.D << 8) | regs.E ) + 1) & 0xFFFF;
                    regs.D = ((regs.TR) & 0xFF00) >>> 8;
                    regs.E = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x218: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x14), // DD 14
            function(regs: z80_regs, pins: z80_pins): void { // INC_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.D) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x219: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x15), // DD 15
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.D) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x21A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x16), // DD 16
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n D
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x21B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x17), // DD 17
            function(regs: z80_regs, pins: z80_pins): void { // RLA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = (regs.A & 0x80) >>> 7;
                    regs.A = ((regs.A << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x21C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x18), // DD 18
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(1)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x21D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x19), // DD 19
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr DE
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was IX
                    regs.Q = 1;
                    regs.WZ = (regs.IX + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.IX & 0xFF);
                    y = regs.E;
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = ((regs.IX & 0xFF00) >>> 8);
                    y = regs.D;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.IX = (regs.t[5] << 8) | regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x21E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1A), // DD 1A
            function(regs: z80_regs, pins: z80_pins): void { // LD_a_irr DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.WZ = (regs.D << 8) | regs.E;
                    pins.Addr = (regs.WZ);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.A = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x21F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1B), // DD 1B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr DE
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = (regs.D << 8) | regs.E
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.D = ((regs.TA) & 0xFF00) >>> 8;
                    regs.E = (regs.TA) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x220: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1C), // DD 1C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.E) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x221: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1D), // DD 1D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.E) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x222: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1E), // DD 1E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n E
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x223: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1F), // DD 1F
            function(regs: z80_regs, pins: z80_pins): void { // RRA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = regs.A & 1;
                    regs.A = (regs.F.C << 7) | (regs.A >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x224: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x20), // DD 20
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.Z === 0)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x225: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x21), // DD 21
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.IX = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x226: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x22), // DD 22
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_rr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = ((regs.IX & 0xFF));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    break;
                case 10: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 11:
                    pins.D = (((regs.IX & 0xFF00) >>> 8));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 12: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x227: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x23), // DD 23
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr HL
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = ((regs.IX ) + 1) & 0xFFFF;
                    regs.IX = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x228: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x24), // DD 24
            function(regs: z80_regs, pins: z80_pins): void { // INC_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = (((regs.IX & 0xFF00) >>> 8) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.IX = (regs.TR << 8) | (regs.IX & 0xFF)
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x229: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x25), // DD 25
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = (((regs.IX & 0xFF00) >>> 8) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.IX = (regs.TR << 8) | (regs.IX & 0xFF)
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x22A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x26), // DD 26
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n H
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.IX = ((regs.TR) << 8) | (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x22B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x27), // DD 27
            function(regs: z80_regs, pins: z80_pins): void { // DAA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let a = regs.A;
                    if (regs.F.C || (regs.A > 0x99)) { regs.A = (regs.A + (regs.F.N ? -0x60: 0x60)) & 0xFF; regs.F.C = 1; }
                    if (regs.F.H || ((regs.A & 0x0F) > 0x09)) { regs.A = (regs.A + (regs.F.N ? -6 : 6)) & 0xFF; }
                    regs.F.PV = Z80_parity(regs.A);
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.H = ((a ^ regs.A) & 0x10) >>> 4;
                    regs.F.Z = +(regs.A == 0);
                    regs.F.S = ((regs.A) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x22C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x28), // DD 28
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.Z === 1)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x22D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x29), // DD 29
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr HL
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was IX
                    regs.Q = 1;
                    regs.WZ = (regs.IX + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.IX & 0xFF);
                    y = (regs.IX & 0xFF);
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = ((regs.IX & 0xFF00) >>> 8);
                    y = ((regs.IX & 0xFF00) >>> 8);
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.IX = (regs.t[5] << 8) | regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x22E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2A), // DD 2A
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_inn HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TA = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TA |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.IX = (regs.IX & 0xFF00) | (regs.TR);
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.WZ = regs.TA;
                    break;
                case 10: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 11: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 12: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.IX = (regs.TR << 8) | (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x22F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2B), // DD 2B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr HL
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = regs.IX
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.IX = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x230: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2C), // DD 2C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.IX & 0xFF) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.IX = (regs.IX & 0xFF00) | regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x231: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2D), // DD 2D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.IX & 0xFF) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.IX = (regs.IX & 0xFF00) | regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x232: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2E), // DD 2E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n L
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.IX = (regs.IX & 0xFF00) | ((regs.TR) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x233: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2F), // DD 2F
            function(regs: z80_regs, pins: z80_pins): void { // CPL
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A ^= 0xFF;
                    regs.F.N = regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x234: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x30), // DD 30
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.C === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.C === 0)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x235: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x31), // DD 31
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn SP
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.SP = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x236: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x32), // DD 32
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_a
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.A << 8);
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x237: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x33), // DD 33
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr SP
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = ((regs.SP ) + 1) & 0xFFFF;
                    regs.SP = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x238: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x34), // DD 34
            function(regs: z80_regs, pins: z80_pins): void { // INC_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 12:
                    regs.TR = ((regs.TR) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    break;
                case 13: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 14:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 15: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 16: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x239: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x35), // DD 35
            function(regs: z80_regs, pins: z80_pins): void { // DEC_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 12:
                    regs.TR = ((regs.TR) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    break;
                case 13: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 14:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 15: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 16: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x23A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x36), // DD 36
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_n HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 2 cycles
                    break;
                case 5:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 6: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 7: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 8: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x23B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x37), // DD 37
            function(regs: z80_regs, pins: z80_pins): void { // SCF
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    if (regs.Q) { regs.F.X = 0; regs.F.Y = 0; }
                    regs.F.C = regs.Q = 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X |= ((regs.A & 8) >>> 3);
                    regs.F.Y |= ((regs.A & 0x20) >>> 5);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x23C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x38), // DD 38
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.C === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.C === 1)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x23D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x39), // DD 39
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr SP
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was IX
                    regs.Q = 1;
                    regs.WZ = (regs.IX + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.IX & 0xFF);
                    y = (regs.SP & 0xFF);
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = ((regs.IX & 0xFF00) >>> 8);
                    y = ((regs.SP & 0xFF00) >>> 8);
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.IX = (regs.t[5] << 8) | regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x23E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3A), // DD 3A
            function(regs: z80_regs, pins: z80_pins): void { // LD_a_inn
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.A = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x23F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3B), // DD 3B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr SP
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = regs.SP
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.SP = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x240: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3C), // DD 3C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.A) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x241: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3D), // DD 3D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.A) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x242: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3E), // DD 3E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n A
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x243: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3F), // DD 3F
            function(regs: z80_regs, pins: z80_pins): void { // CCF
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    if (regs.Q) { regs.F.X = regs.F.Y = 0; } 
                    regs.F.H = regs.F.C;
                    regs.F.C = +(!regs.F.C);
                    regs.F.N = 0;
                    regs.F.X |= (regs.A & 8) >>> 3;
                    regs.F.Y |= (regs.A & 0x20) >>> 5;
                    regs.Q = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x244: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x40), // DD 40
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x245: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x41), // DD 41
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x246: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x42), // DD 42
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x247: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x43), // DD 43
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x248: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x44), // DD 44
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = ((regs.IX & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x249: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x45), // DD 45
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x24A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x46), // DD 46
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr B HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x24B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x47), // DD 47
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x24C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x48), // DD 48
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x24D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x49), // DD 49
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x24E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4A), // DD 4A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x24F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4B), // DD 4B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x250: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4C), // DD 4C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = ((regs.IX & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x251: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4D), // DD 4D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x252: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4E), // DD 4E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr C HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x253: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4F), // DD 4F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x254: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x50), // DD 50
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x255: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x51), // DD 51
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x256: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x52), // DD 52
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x257: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x53), // DD 53
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x258: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x54), // DD 54
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = ((regs.IX & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x259: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x55), // DD 55
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x25A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x56), // DD 56
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr D HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x25B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x57), // DD 57
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x25C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x58), // DD 58
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x25D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x59), // DD 59
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x25E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5A), // DD 5A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x25F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5B), // DD 5B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x260: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5C), // DD 5C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = ((regs.IX & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x261: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5D), // DD 5D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x262: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5E), // DD 5E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr E HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x263: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5F), // DD 5F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x264: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x60), // DD 60
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = ((regs.B) << 8) | (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x265: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x61), // DD 61
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = ((regs.C) << 8) | (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x266: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x62), // DD 62
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = ((regs.D) << 8) | (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x267: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x63), // DD 63
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = ((regs.E) << 8) | (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x268: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x64), // DD 64
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = ((((regs.IX & 0xFF00) >>> 8)) << 8) | (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x269: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x65), // DD 65
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = (((regs.IX & 0xFF)) << 8) | (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x26A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x66), // DD 66
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr _H HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x26B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x67), // DD 67
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = ((regs.A) << 8) | (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x26C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x68), // DD 68
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = (regs.IX & 0xFF00) | ((regs.B) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x26D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x69), // DD 69
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = (regs.IX & 0xFF00) | ((regs.C) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x26E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6A), // DD 6A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = (regs.IX & 0xFF00) | ((regs.D) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x26F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6B), // DD 6B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = (regs.IX & 0xFF00) | ((regs.E) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x270: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6C), // DD 6C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = (regs.IX & 0xFF00) | ((((regs.IX & 0xFF00) >>> 8)) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x271: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6D), // DD 6D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = (regs.IX & 0xFF00) | (((regs.IX & 0xFF)) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x272: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6E), // DD 6E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr _L HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x273: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6F), // DD 6F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IX = (regs.IX & 0xFF00) | ((regs.A) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x274: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x70), // DD 70
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL B
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.B);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x275: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x71), // DD 71
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL C
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.C);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x276: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x72), // DD 72
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL D
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.D);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x277: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x73), // DD 73
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL E
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.E);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x278: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x74), // DD 74
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL _H
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.H);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x279: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x75), // DD 75
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL _L
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.L);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x27A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x76), // DD 76
            function(regs: z80_regs, pins: z80_pins): void { // HALT
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.HALT = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x27B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x77), // DD 77
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL A
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x27C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x78), // DD 78
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x27D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x79), // DD 79
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x27E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7A), // DD 7A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x27F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7B), // DD 7B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x280: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7C), // DD 7C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = ((regs.IX & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x281: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7D), // DD 7D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = (regs.IX & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x282: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7E), // DD 7E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr A HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x283: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7F), // DD 7F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x284: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x80), // DD 80
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.B;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x285: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x81), // DD 81
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.C;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x286: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x82), // DD 82
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.D;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x287: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x83), // DD 83
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.E;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x288: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x84), // DD 84
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = ((regs.IX & 0xFF00) >>> 8);
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x289: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x85), // DD 85
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = (regs.IX & 0xFF);
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x28A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x86), // DD 86
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x28B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x87), // DD 87
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.A;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x28C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x88), // DD 88
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.B;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x28D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x89), // DD 89
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.C;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x28E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8A), // DD 8A
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.D;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x28F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8B), // DD 8B
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.E;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x290: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8C), // DD 8C
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = ((regs.IX & 0xFF00) >>> 8);
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x291: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8D), // DD 8D
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = (regs.IX & 0xFF);
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x292: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8E), // DD 8E
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x293: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8F), // DD 8F
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.A;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x294: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x90), // DD 90
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.B);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x295: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x91), // DD 91
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.C);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x296: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x92), // DD 92
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.D);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x297: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x93), // DD 93
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.E);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x298: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x94), // DD 94
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>((regs.IX & 0xFF00) >>> 8));
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x299: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x95), // DD 95
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>(regs.IX & 0xFF));
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x29A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x96), // DD 96
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x29B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x97), // DD 97
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x29C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x98), // DD 98
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.B);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x29D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x99), // DD 99
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.C);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x29E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9A), // DD 9A
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.D);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x29F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9B), // DD 9B
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.E);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9C), // DD 9C
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>((regs.IX & 0xFF00) >>> 8));
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9D), // DD 9D
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>(regs.IX & 0xFF));
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9E), // DD 9E
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9F), // DD 9F
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA0), // DD A0
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.B);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA1), // DD A1
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.C);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA2), // DD A2
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.D);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA3), // DD A3
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.E);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA4), // DD A4
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (((regs.IX & 0xFF00) >>> 8));
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2A9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA5), // DD A5
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & ((regs.IX & 0xFF));
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2AA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA6), // DD A6
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.A) & (regs.TR);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2AB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA7), // DD A7
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.A);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2AC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA8), // DD A8
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.B);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2AD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA9), // DD A9
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.C);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2AE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAA), // DD AA
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.D);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2AF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAB), // DD AB
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.E);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAC), // DD AC
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (((regs.IX & 0xFF00) >>> 8));
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAD), // DD AD
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ ((regs.IX & 0xFF));
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAE), // DD AE
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.A) ^ (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAF), // DD AF
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.A);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB0), // DD B0
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.B);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB1), // DD B1
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.C);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB2), // DD B2
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.D);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB3), // DD B3
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.E);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB4), // DD B4
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (((regs.IX & 0xFF00) >>> 8));
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2B9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB5), // DD B5
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | ((regs.IX & 0xFF));
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2BA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB6), // DD B6
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.A) | (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2BB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB7), // DD B7
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.A);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2BC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB8), // DD B8
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.B;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2BD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB9), // DD B9
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.C;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2BE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBA), // DD BA
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.D;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2BF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBB), // DD BB
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.E;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBC), // DD BC
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>((regs.IX & 0xFF00) >>> 8);
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBD), // DD BD
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>(regs.IX & 0xFF);
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBE), // DD BE
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IX + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.TR;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBF), // DD BF
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.A;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC0), // DD C0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.Z === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC1), // DD C1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.B = ((regs.TR) & 0xFF00) >>> 8;
                    regs.C = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC2), // DD C2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.Z === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC3), // DD C3
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC4), // DD C4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.Z === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2C9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC5), // DD C5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr BC
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.B);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.C);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2CA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC6), // DD C6
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2CB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC7), // DD C7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 0
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x00;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2CC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC8), // DD C8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.Z === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2CD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC9), // DD C9
            function(regs: z80_regs, pins: z80_pins): void { // RET
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2CE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCA), // DD CA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.Z === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2CF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x2D0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCC), // DD CC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.Z === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCD), // DD CD
            function(regs: z80_regs, pins: z80_pins): void { // CALL_nn
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    break;
                case 14: // cleanup_custom
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCE), // DD CE
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCF), // DD CF
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 1
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x08;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD0), // DD D0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.C === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.C === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD1), // DD D1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.D = ((regs.TR) & 0xFF00) >>> 8;
                    regs.E = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD2), // DD D2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.C === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.C === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD3), // DD D3
            function(regs: z80_regs, pins: z80_pins): void { // OUT_in_a
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.A << 8);
                    break;
                case 4: // OUT start
                    pins.Addr = regs.WZ;
                    pins.D = regs.A;
                    regs.data = pins.D;
                    break;
                case 5: // OUT continues
                    break;
                case 6: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 7: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.WZ & 0xFF00);
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD4), // DD D4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.C === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.C === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2D9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD5), // DD D5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr DE
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.D);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.E);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2DA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD6), // DD D6
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2DB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD7), // DD D7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 2
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x10;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2DC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD8), // DD D8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.C === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.C === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2DD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD9), // DD D9
            function(regs: z80_regs, pins: z80_pins): void { // EXX
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.exchange_shadow();
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2DE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDA), // DD DA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.C === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.C === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2DF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDB), // DD DB
            function(regs: z80_regs, pins: z80_pins): void { // IN_a_in
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.A << 8);
                    break;
                case 4: // IN start
                    pins.Addr = regs.WZ;
                    break;
                case 5: // IN actual read
                    break;
                case 6: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 7: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.A = pins.D;
                    regs.data = pins.D;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDC), // DD DC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.C === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.C === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x2E2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDE), // DD DE
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDF), // DD DF
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 3
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x18;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE0), // DD E0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.PV === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.PV === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE1), // DD E1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.IX = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE2), // DD E2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.PV === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.PV === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE3), // DD E3
            function(regs: z80_regs, pins: z80_pins): void { // EX_irr_rr SP HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = regs.SP;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ |= (regs.TR << 8);
                    break;
                case 7: // wait
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = ((regs.IX & 0xFF));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 12:
                    pins.D = (((regs.IX & 0xFF00) >>> 8));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    break;
                case 14: // wait
                    break;
                case 15: // wait
                    regs.IX = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 16: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE4), // DD E4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.PV === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.PV === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2E9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE5), // DD E5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr HL
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.IX & 0xFF00) >>> 8));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.IX & 0xFF));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2EA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE6), // DD E6
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let z = (regs.A) & (regs.TR);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2EB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE7), // DD E7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 4
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x20;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2EC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE8), // DD E8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.PV === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.PV === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2ED: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE9), // DD E9
            function(regs: z80_regs, pins: z80_pins): void { // JP_rr HL
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.PC = regs.IX;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2EE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEA), // DD EA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.PV === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.PV === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2EF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEB), // DD EB
            function(regs: z80_regs, pins: z80_pins): void { // EX_rr_rr DE _HL
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.exchange_de_hl();
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEC), // DD EC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.PV === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.PV === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x2F2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEE), // DD EE
            function(regs: z80_regs, pins: z80_pins): void { // undefined
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let z = (regs.A) ^ (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEF), // DD EF
            function(regs: z80_regs, pins: z80_pins): void { // RST 5
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x28;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF0), // DD F0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.S === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.S === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF1), // DD F1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr AF
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.A = ((regs.TR) & 0xFF00) >>> 8;
                    regs.F.setbyte((regs.TR) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF2), // DD F2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.S === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.S === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF3), // DD F3
            function(regs: z80_regs, pins: z80_pins): void { // DI
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IFF1 = regs.IFF2 = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF4), // DD F4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.S === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.S === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2F9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF5), // DD F5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr AF
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.F.getbyte());
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2FA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF6), // DD F6
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let z = (regs.A) | (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2FB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF7), // DD F7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 6
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x30;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2FC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF8), // DD F8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.S === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.S === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2FD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF9), // DD F9
            function(regs: z80_regs, pins: z80_pins): void { // LD_sp_rr HL
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.SP = regs.IX
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2FE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFA), // DD FA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.S === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.S === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x2FF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFB), // DD FB
            function(regs: z80_regs, pins: z80_pins): void { // EI
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IFF1 = regs.IFF2 = regs.EI = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x300: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFC), // DD FC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.S === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.S === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x301: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x302: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFE), // DD FE
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.TR;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x303: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFF), // DD FF
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 7
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x38;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x304: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x100), // DD 100
            function(regs: z80_regs, pins: z80_pins): void { // IRQ
            switch(regs.TCU) {
                case 1:
                    regs.R = (regs.R + 1) & 0x7F;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    let wait: u32;
                    switch(pins.IRQ_maskable ? regs.IM : 1) {
                    case 0:
                        regs.t[0] = 0;
                        regs.WZ = pins.D;
                        wait = 12 - (((pins.D | 0x38) == 0xFF) ? 6 : 7);
                        regs.TCU += wait;
                        break;
                    case 1:
                        regs.t[0] = 0;
                        regs.WZ = regs.IRQ_vec;
                        wait = 12 - (pins.IRQ_maskable ? 7 : 5);
                        regs.TCU += wait;
                        break;
                    case 2:
                        regs.t[0] = 1;
                        regs.TA = (regs.I << 8) | pins.D;
                        regs.WZ = 0;
                        break;
                    }
                    break;
                case 8: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 9: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 10: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    break;
                case 11: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 12: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 13: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    if (regs.t[0] == 1) { regs.WZ |= regs.TR << 8; }
                    break;
                case 14: // Adding 6 cycles
                    break;
                case 15:
                    break;
                case 16:
                    break;
                case 17:
                    break;
                case 18:
                    break;
                case 19:
                    regs.PC = regs.WZ;
                    regs.IFF1 = 0;
                    if (pins.IRQ_maskable) regs.IFF2 = 0;
                    regs.HALT = 0;
                    if (regs.P) regs.F.PV = 0;
                    regs.P = 0;
                    regs.Q = 0;
                    regs.IRQ_vec = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 20: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x305: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x101), // DD 101
            function(regs: z80_regs, pins: z80_pins): void { // RESET
            switch(regs.TCU) {
                case 1:
                    regs.IFF1 = regs.IFF2 = 0; // disable interrupt
                    regs.IM = 0;
                    regs.I = 0;
                    regs.R = 0;
                    regs.PC = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 2: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x306: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x307: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x308: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x309: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x30A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x30B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x30C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x30D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x30E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x30F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x310: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x311: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x312: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x313: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x314: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x315: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x316: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x317: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x318: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x319: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x31A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x31B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x31C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x31D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x31E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x31F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x320: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x321: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x322: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x323: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x324: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x325: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x326: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x327: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x328: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x329: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x32A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x32B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x32C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x32D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x32E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x32F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x330: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x331: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x332: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x333: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x334: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x335: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x336: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x337: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x338: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x339: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x33A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x33B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x33C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x33D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x33E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x33F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x340: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x341: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x342: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x343: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x344: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x345: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x346: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x40), // ED 40
            function(regs: z80_regs, pins: z80_pins): void { // IN_r_ic B
            switch(regs.TCU) {
                case 1: // IN start
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    break;
                case 2: // IN actual read
                    break;
                case 3: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 4: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.B = regs.TR;
                    regs.TA = (regs.B << 8) | regs.C;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x347: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x41), // ED 41
            function(regs: z80_regs, pins: z80_pins): void { // OUT_ic_r B
            switch(regs.TCU) {
                case 1: // OUT start
                    regs.Q = 0;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    pins.D = regs.B;
                    regs.data = pins.D;
                    break;
                case 2: // OUT continues
                    break;
                case 3: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 4: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x348: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x42), // ED 42
            function(regs: z80_regs, pins: z80_pins): void { // SBC_hl_rr BC
            let x: i32, y: i32, z: i32, c: i32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.L);
                    y = (regs.C);
                    c = +(regs.F.C);
                    z = (x - y - c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[0] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = (regs.H);
                    y = (regs.B);
                    c = +(regs.F.C);
                    z = (x - y - c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[1] = z & 0xFF;
                    regs.H = regs.t[1];
                    regs.L = regs.t[0];
                    regs.F.Z = +((regs.H == 0) && (regs.L == 0));
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x349: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x43), // ED 43
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_rr BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.C);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    break;
                case 10: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 11:
                    pins.D = (regs.B);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 12: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x34A: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x44), // ED 44
            function(regs: z80_regs, pins: z80_pins): void { // NEG
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>0);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x34B: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x45), // ED 45
            function(regs: z80_regs, pins: z80_pins): void { // RETN
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    regs.IFF1 = regs.IFF2;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x34C: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x46), // ED 46
            function(regs: z80_regs, pins: z80_pins): void { // IM_o 0
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IM = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x34D: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x47), // ED 47
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r1 I A
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.I = (regs.A);
                    // Following is auto-generated code for instruction finish
                    break;
                case 2: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x34E: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x48), // ED 48
            function(regs: z80_regs, pins: z80_pins): void { // IN_r_ic C
            switch(regs.TCU) {
                case 1: // IN start
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    break;
                case 2: // IN actual read
                    break;
                case 3: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 4: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.C = regs.TR;
                    regs.TA = (regs.B << 8) | regs.C;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x34F: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x49), // ED 49
            function(regs: z80_regs, pins: z80_pins): void { // OUT_ic_r C
            switch(regs.TCU) {
                case 1: // OUT start
                    regs.Q = 0;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    pins.D = regs.C;
                    regs.data = pins.D;
                    break;
                case 2: // OUT continues
                    break;
                case 3: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 4: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x350: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x4A), // ED 4A
            function(regs: z80_regs, pins: z80_pins): void { // ADC_hl_rr BC
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    regs.Q = 1;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    regs.WZ = (((regs.H << 8) | regs.L) + 1) & 0xFFFF;
                    x = regs.L;
                    y = regs.C;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.L = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = regs.H;
                    y = regs.B;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.H = z & 0xFF;
                    regs.F.Z = +((regs.H == 0) && (regs.L == 0));
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x351: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x4B), // ED 4B
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_inn BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TA = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TA |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.C = (regs.TR);
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.WZ = regs.TA;
                    break;
                case 10: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 11: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 12: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.B = (regs.TR);
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x352: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x4C), // ED 4C
            function(regs: z80_regs, pins: z80_pins): void { // NEG
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>0);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x353: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x4D), // ED 4D
            function(regs: z80_regs, pins: z80_pins): void { // RETI
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    regs.IFF1 = regs.IFF2;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x354: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x4E), // ED 4E
            function(regs: z80_regs, pins: z80_pins): void { // IM_o 0
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IM = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x355: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x4F), // ED 4F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r1 R A
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.R = (regs.A);
                    // Following is auto-generated code for instruction finish
                    break;
                case 2: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x356: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x50), // ED 50
            function(regs: z80_regs, pins: z80_pins): void { // IN_r_ic D
            switch(regs.TCU) {
                case 1: // IN start
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    break;
                case 2: // IN actual read
                    break;
                case 3: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 4: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.D = regs.TR;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x357: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x51), // ED 51
            function(regs: z80_regs, pins: z80_pins): void { // OUT_ic_r D
            switch(regs.TCU) {
                case 1: // OUT start
                    regs.Q = 0;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    pins.D = regs.D;
                    regs.data = pins.D;
                    break;
                case 2: // OUT continues
                    break;
                case 3: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 4: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x358: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x52), // ED 52
            function(regs: z80_regs, pins: z80_pins): void { // SBC_hl_rr DE
            let x: i32, y: i32, z: i32, c: i32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.L);
                    y = (regs.E);
                    c = +(regs.F.C);
                    z = (x - y - c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[0] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = (regs.H);
                    y = (regs.D);
                    c = +(regs.F.C);
                    z = (x - y - c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[1] = z & 0xFF;
                    regs.H = regs.t[1];
                    regs.L = regs.t[0];
                    regs.F.Z = +((regs.H == 0) && (regs.L == 0));
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x359: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x53), // ED 53
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_rr DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.E);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    break;
                case 10: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 11:
                    pins.D = (regs.D);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 12: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x35A: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x54), // ED 54
            function(regs: z80_regs, pins: z80_pins): void { // NEG
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>0);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x35B: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x55), // ED 55
            function(regs: z80_regs, pins: z80_pins): void { // RETN
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    regs.IFF1 = regs.IFF2;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x35C: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x56), // ED 56
            function(regs: z80_regs, pins: z80_pins): void { // IM_o 1
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IM = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x35D: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x57), // ED 57
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r2 A I
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    let x = regs.I;
                    regs.A = regs.I;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.PV = regs.IFF2;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.P = 1;
                    // Following is auto-generated code for instruction finish
                    break;
                case 2: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x35E: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x58), // ED 58
            function(regs: z80_regs, pins: z80_pins): void { // IN_r_ic E
            switch(regs.TCU) {
                case 1: // IN start
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    break;
                case 2: // IN actual read
                    break;
                case 3: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 4: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.E = regs.TR;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x35F: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x59), // ED 59
            function(regs: z80_regs, pins: z80_pins): void { // OUT_ic_r E
            switch(regs.TCU) {
                case 1: // OUT start
                    regs.Q = 0;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    pins.D = regs.E;
                    regs.data = pins.D;
                    break;
                case 2: // OUT continues
                    break;
                case 3: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 4: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x360: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x5A), // ED 5A
            function(regs: z80_regs, pins: z80_pins): void { // ADC_hl_rr DE
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    regs.Q = 1;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    regs.WZ = (((regs.H << 8) | regs.L) + 1) & 0xFFFF;
                    x = regs.L;
                    y = regs.E;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.L = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = regs.H;
                    y = regs.D;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.H = z & 0xFF;
                    regs.F.Z = +((regs.H == 0) && (regs.L == 0));
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x361: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x5B), // ED 5B
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_inn DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TA = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TA |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.E = (regs.TR);
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.WZ = regs.TA;
                    break;
                case 10: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 11: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 12: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.D = (regs.TR);
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x362: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x5C), // ED 5C
            function(regs: z80_regs, pins: z80_pins): void { // NEG
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>0);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x363: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x5D), // ED 5D
            function(regs: z80_regs, pins: z80_pins): void { // RETI
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    regs.IFF1 = regs.IFF2;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x364: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x5E), // ED 5E
            function(regs: z80_regs, pins: z80_pins): void { // IM_o 2
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IM = 2;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x365: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x5F), // ED 5F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r2 A R
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    let x = regs.R;
                    regs.A = regs.R;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.PV = regs.IFF2;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.P = 1;
                    // Following is auto-generated code for instruction finish
                    break;
                case 2: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x366: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x60), // ED 60
            function(regs: z80_regs, pins: z80_pins): void { // IN_r_ic H
            switch(regs.TCU) {
                case 1: // IN start
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    break;
                case 2: // IN actual read
                    break;
                case 3: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 4: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.H = regs.TR;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x367: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x61), // ED 61
            function(regs: z80_regs, pins: z80_pins): void { // OUT_ic_r H
            switch(regs.TCU) {
                case 1: // OUT start
                    regs.Q = 0;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    pins.D = regs.H;
                    regs.data = pins.D;
                    break;
                case 2: // OUT continues
                    break;
                case 3: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 4: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x368: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x62), // ED 62
            function(regs: z80_regs, pins: z80_pins): void { // SBC_hl_rr HL
            let x: i32, y: i32, z: i32, c: i32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.L);
                    y = (regs.L);
                    c = +(regs.F.C);
                    z = (x - y - c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[0] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = (regs.H);
                    y = (regs.H);
                    c = +(regs.F.C);
                    z = (x - y - c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[1] = z & 0xFF;
                    regs.H = regs.t[1];
                    regs.L = regs.t[0];
                    regs.F.Z = +((regs.H == 0) && (regs.L == 0));
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x369: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x63), // ED 63
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_rr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.L);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    break;
                case 10: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 11:
                    pins.D = (regs.H);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 12: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x36A: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x64), // ED 64
            function(regs: z80_regs, pins: z80_pins): void { // NEG
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>0);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x36B: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x65), // ED 65
            function(regs: z80_regs, pins: z80_pins): void { // RETN
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    regs.IFF1 = regs.IFF2;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x36C: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x66), // ED 66
            function(regs: z80_regs, pins: z80_pins): void { // IM_o 0
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IM = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x36D: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x67), // ED 67
            function(regs: z80_regs, pins: z80_pins): void { // RRD
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.WZ = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.WZ);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4:
                    break;
                case 5: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 6:
                    pins.D = (((regs.TR >>> 4) | (regs.A << 4)) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    break;
                case 8: // Adding 3 cycles
                    break;
                case 9:
                    break;
                case 10:
                    regs.A = (regs.A & 0xF0) | (regs.TR & 0x0F);
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(regs.A);
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((regs.A) == 0);
                    regs.F.S = ((regs.A) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 11: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x36E: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x68), // ED 68
            function(regs: z80_regs, pins: z80_pins): void { // IN_r_ic L
            switch(regs.TCU) {
                case 1: // IN start
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    break;
                case 2: // IN actual read
                    break;
                case 3: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 4: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.L = regs.TR;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x36F: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x69), // ED 69
            function(regs: z80_regs, pins: z80_pins): void { // OUT_ic_r L
            switch(regs.TCU) {
                case 1: // OUT start
                    regs.Q = 0;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    pins.D = regs.L;
                    regs.data = pins.D;
                    break;
                case 2: // OUT continues
                    break;
                case 3: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 4: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x370: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x6A), // ED 6A
            function(regs: z80_regs, pins: z80_pins): void { // ADC_hl_rr HL
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    regs.Q = 1;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    regs.WZ = (((regs.H << 8) | regs.L) + 1) & 0xFFFF;
                    x = regs.L;
                    y = regs.L;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.L = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = regs.H;
                    y = regs.H;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.H = z & 0xFF;
                    regs.F.Z = +((regs.H == 0) && (regs.L == 0));
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x371: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x6B), // ED 6B
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_inn HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TA = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TA |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.L = (regs.TR);
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.WZ = regs.TA;
                    break;
                case 10: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 11: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 12: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.H = (regs.TR);
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x372: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x6C), // ED 6C
            function(regs: z80_regs, pins: z80_pins): void { // NEG
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>0);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x373: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x6D), // ED 6D
            function(regs: z80_regs, pins: z80_pins): void { // RETI
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    regs.IFF1 = regs.IFF2;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x374: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x6E), // ED 6E
            function(regs: z80_regs, pins: z80_pins): void { // IM_o 0
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IM = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x375: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x6F), // ED 6F
            function(regs: z80_regs, pins: z80_pins): void { // RLD
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.WZ = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.WZ);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 4:
                    break;
                case 5: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 6:
                    pins.D = (((regs.TR << 4) & 0xF0) | (regs.A & 0x0F));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    break;
                case 8: // Adding 3 cycles
                    break;
                case 9:
                    break;
                case 10:
                    regs.A = (regs.A & 0xF0) | (regs.TR >>> 4);
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(regs.A);
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.Z = +((regs.A) == 0);
                    regs.F.S = ((regs.A) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 11: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x376: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x70), // ED 70
            function(regs: z80_regs, pins: z80_pins): void { // IN_ic
            switch(regs.TCU) {
                case 1: // IN start
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    break;
                case 2: // IN actual read
                    break;
                case 3: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 4: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x377: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x71), // ED 71
            function(regs: z80_regs, pins: z80_pins): void { // OUT_ic
            switch(regs.TCU) {
                case 1: // OUT start
                    regs.Q = 0;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    pins.D = 0x00;
                    regs.data = pins.D;
                    break;
                case 2: // OUT continues
                    break;
                case 3: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 4: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x378: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x72), // ED 72
            function(regs: z80_regs, pins: z80_pins): void { // SBC_hl_rr SP
            let x: i32, y: i32, z: i32, c: i32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.L);
                    y = ((regs.SP & 0xFF));
                    c = +(regs.F.C);
                    z = (x - y - c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[0] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = (regs.H);
                    y = (((regs.SP & 0xFF00) >>> 8));
                    c = +(regs.F.C);
                    z = (x - y - c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[1] = z & 0xFF;
                    regs.H = regs.t[1];
                    regs.L = regs.t[0];
                    regs.F.Z = +((regs.H == 0) && (regs.L == 0));
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x379: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x73), // ED 73
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_rr SP
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = ((regs.SP & 0xFF));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    break;
                case 10: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 11:
                    pins.D = (((regs.SP & 0xFF00) >>> 8));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 12: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x37A: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x74), // ED 74
            function(regs: z80_regs, pins: z80_pins): void { // NEG
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>0);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x37B: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x75), // ED 75
            function(regs: z80_regs, pins: z80_pins): void { // RETN
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    regs.IFF1 = regs.IFF2;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x37C: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x76), // ED 76
            function(regs: z80_regs, pins: z80_pins): void { // IM_o 1
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IM = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x37D: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x77), // ED 77
            function(regs: z80_regs, pins: z80_pins): void { // NOP
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x37E: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x78), // ED 78
            function(regs: z80_regs, pins: z80_pins): void { // IN_r_ic A
            switch(regs.TCU) {
                case 1: // IN start
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    break;
                case 2: // IN actual read
                    break;
                case 3: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 4: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.A = regs.TR;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x37F: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x79), // ED 79
            function(regs: z80_regs, pins: z80_pins): void { // OUT_ic_r A
            switch(regs.TCU) {
                case 1: // OUT start
                    regs.Q = 0;
                    regs.TA = (regs.B << 8) | regs.C;
                    pins.Addr = regs.TA;
                    pins.D = regs.A;
                    regs.data = pins.D;
                    break;
                case 2: // OUT continues
                    break;
                case 3: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 4: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 5: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x380: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x7A), // ED 7A
            function(regs: z80_regs, pins: z80_pins): void { // ADC_hl_rr SP
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    regs.Q = 1;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    regs.WZ = (((regs.H << 8) | regs.L) + 1) & 0xFFFF;
                    x = regs.L;
                    y = (regs.SP & 0xFF);
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.L = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = regs.H;
                    y = ((regs.SP & 0xFF00) >>> 8);
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.H = z & 0xFF;
                    regs.F.Z = +((regs.H == 0) && (regs.L == 0));
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x381: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x7B), // ED 7B
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_inn SP
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TA = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TA |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP & 0xFF00) | (regs.TR);
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.WZ = regs.TA;
                    break;
                case 10: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 11: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 12: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.TR << 8) | (regs.SP & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x382: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x7C), // ED 7C
            function(regs: z80_regs, pins: z80_pins): void { // NEG
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>0);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x383: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x7D), // ED 7D
            function(regs: z80_regs, pins: z80_pins): void { // RETI
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    regs.IFF1 = regs.IFF2;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x384: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x7E), // ED 7E
            function(regs: z80_regs, pins: z80_pins): void { // IM_o 2
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IM = 2;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x385: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0x7F), // ED 7F
            function(regs: z80_regs, pins: z80_pins): void { // NOP
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x386: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x387: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x388: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x389: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x38A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x38B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x38C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x38D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x38E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x38F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x390: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x391: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x392: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x393: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x394: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x395: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x396: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x397: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x398: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x399: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x39A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x39B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x39C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x39D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x39E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x39F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3A0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3A1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3A2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3A3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3A4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3A5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3A6: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xA0), // ED A0
            function(regs: z80_regs, pins: z80_pins): void { // LDI
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    regs.TA = (regs.D << 8) | regs.E;
                    break;
                case 4: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 5:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 6: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.D = ((regs.TA) & 0xFF00) >>> 8;
                    regs.E = (regs.TA) & 0xFF;
                    break;
                case 7: // Adding 2 cycles
                    break;
                case 8:
                    regs.F.N = regs.F.H = 0;
                    regs.TA = (regs.A + regs.TR) & 0xFF
                    regs.F.X = (regs.TA & 8) >>> 3;
                    regs.F.Y = (regs.TA & 2) >>> 1;
                    regs.TA = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.B = ((regs.TA) & 0xFF00) >>> 8;
                    regs.C = (regs.TA) & 0xFF;
                    regs.F.PV = +(regs.TA !== 0);
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3A7: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xA1), // ED A1
            function(regs: z80_regs, pins: z80_pins): void { // CPI
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    regs.TA = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    let n = (regs.A - regs.TR) & 0xFF;
                    regs.F.N = 1;
                    regs.TA = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.F.PV = +(regs.TA !== 0)
                    regs.F.H = ((regs.A ^ regs.TR ^ n) & 0x10) >>> 4;
                    regs.B = (regs.TA & 0xFF00) >>> 8;
                    regs.C = regs.TA & 0xFF;
                    regs.TR = (n - regs.F.H) & 0xFF;
                    regs.F.X = (regs.TR & 8) >>> 3;
                    regs.F.Y = (regs.TR & 2) >>> 1;
                    regs.F.Z = +(n == 0);
                    regs.F.S = ((n) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3A8: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xA2), // ED A2
            function(regs: z80_regs, pins: z80_pins): void { // INI
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    break;
                case 2: // IN start
                    pins.Addr = regs.TA;
                    break;
                case 3: // IN actual read
                    break;
                case 4: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 5: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.B = (regs.B - 1) & 0xFF;
                    regs.TA = (regs.H << 8) | regs.L;
                    break;
                case 6: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 7:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 8: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.H = (regs.TA & 0xFF00) >>> 8;
                    regs.L = regs.TA & 0xFF;
                    regs.F.C = ((regs.C + 1 + regs.TR) & 0x100) >>> 8;
                    regs.F.N = (regs.TR & 0x80) >>> 7;
                    regs.TA = ((regs.C + 1) & 0xFF) + regs.TR & 7 ^ regs.B;
                    regs.F.PV = Z80_parity(regs.TA);
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.H = regs.F.C;
                    regs.F.Z = +((regs.B) == 0);
                    regs.F.S = ((regs.B) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3A9: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xA3), // ED A3
            function(regs: z80_regs, pins: z80_pins): void { // OUTI
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    break;
                case 2: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    regs.B = (regs.B - 1) & 0xFF;
                    regs.TA = (regs.B << 8) | regs.C;
                    break;
                case 5: // OUT start
                    pins.Addr = regs.TA;
                    pins.D = regs.TR;
                    regs.data = pins.D;
                    break;
                case 6: // OUT continues
                    break;
                case 7: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 8: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    regs.F.C = ((regs.L + regs.TR) & 0x100) >>> 8;
                    regs.F.N = (regs.TR & 0x80) >>> 7;
                    regs.TR = (regs.L + regs.TR & 7 ^ regs.B) & 0xFF;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.H = regs.F.C;
                    regs.F.Z = +((regs.B) == 0);
                    regs.F.S = ((regs.B) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3AA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3AB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3AC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3AD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3AE: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xA8), // ED A8
            function(regs: z80_regs, pins: z80_pins): void { // LDD
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.H = (regs.TA & 0xFF00) >>> 8;
                    regs.L = regs.TA & 0xFF;
                    regs.TA = (regs.D << 8) | regs.E;
                    break;
                case 4: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 5:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 6: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.D = (regs.TA & 0xFF00) >>> 8;
                    regs.E = regs.TA & 0xFF;
                    break;
                case 7: // Adding 2 cycles
                    break;
                case 8:
                    regs.F.N = regs.F.H = 0;
                    regs.TA = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.B = ((regs.TA) & 0xFF00) >>> 8;
                    regs.C = (regs.TA) & 0xFF;
                    regs.F.PV = +(regs.TA !== 0);
                    regs.TA = (regs.A + regs.TR) & 0xFF;
                    regs.F.X = (regs.TA & 8) >>> 3;
                    regs.F.Y = (regs.TA & 2) >>> 1;
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3AF: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xA9), // ED A9
            function(regs: z80_regs, pins: z80_pins): void { // CPD
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.WZ = (regs.WZ - 1) & 0xFFFF;
                    regs.TA = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.TA = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.B = (regs.TA & 0xFF00) >>> 8;
                    regs.C = regs.TA & 0xFF;
                    let n = regs.A - regs.TR;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TA !== 0);
                    regs.F.H = ((regs.A ^ regs.TR ^ n) & 0x10) >>> 4;
                    regs.F.X = ((n - regs.F.H) & 8) >>> 3;
                    regs.F.Y = ((n - regs.F.H) & 2) >>> 1;
                    regs.F.Z = +(n == 0);
                    regs.F.S = ((n) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3B0: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xAA), // ED AA
            function(regs: z80_regs, pins: z80_pins): void { // IND
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    regs.WZ = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.TA = (regs.B << 8) | regs.C;
                    break;
                case 2: // IN start
                    pins.Addr = regs.TA;
                    break;
                case 3: // IN actual read
                    break;
                case 4: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 5: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.B = (regs.B - 1) & 0xFF;
                    regs.TA = (regs.H << 8) | regs.L;
                    break;
                case 6: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 7:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 8: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    regs.F.C = ((((regs.C - 1) & 0xFF) + regs.TR) & 0x100) >>> 8;
                    regs.F.N = (regs.TR & 0x80) >>> 7;
                    regs.TA = ((regs.C - 1) & 0xFF) + regs.TR & 7 ^ regs.B;
                    regs.F.PV = Z80_parity(regs.TA);
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.H = regs.F.C;
                    regs.F.Z = +((regs.B) == 0);
                    regs.F.S = ((regs.B) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3B1: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xAB), // ED AB
            function(regs: z80_regs, pins: z80_pins): void { // OUTD
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    break;
                case 2: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    regs.B = (regs.B - 1) & 0xFF;
                    regs.TA = (regs.B << 8) | regs.C;
                    break;
                case 5: // OUT start
                    pins.Addr = regs.TA;
                    pins.D = regs.TR;
                    regs.data = pins.D;
                    break;
                case 6: // OUT continues
                    break;
                case 7: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 8: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA - 1) & 0xFFFF;
                    regs.F.C = ((regs.L + regs.TR) & 0x100) >>> 8;
                    regs.F.N = (regs.TR & 0x80) >>> 7;
                    regs.TR = (regs.L + regs.TR & 7 ^ regs.B) & 0xFF;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.H = regs.F.C;
                    regs.F.Z = +((regs.B) == 0);
                    regs.F.S = ((regs.B) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3B2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3B3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3B4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3B5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3B6: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xB0), // ED B0
            function(regs: z80_regs, pins: z80_pins): void { // LDIR
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    regs.TA = (regs.D << 8) | regs.E;
                    break;
                case 4: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 5:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 6: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.D = ((regs.TA) & 0xFF00) >>> 8;
                    regs.E = (regs.TA) & 0xFF;
                    break;
                case 7: // Adding 2 cycles
                    break;
                case 8:
                    regs.F.N = regs.F.H = 0;
                    regs.TA = (regs.A + regs.TR) & 0xFF
                    regs.F.X = (regs.TA & 8) >>> 3;
                    regs.F.Y = (regs.TA & 2) >>> 1;
                    regs.TA = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.B = ((regs.TA) & 0xFF00) >>> 8;
                    regs.C = (regs.TA) & 0xFF;
                    regs.F.PV = +(regs.TA !== 0);
                    if ((regs.B == 0) && (regs.C == 0)) { regs.TCU += 5; break; }
                    break;
                case 9:
                    regs.PC = (regs.PC - 2) & 0xFFFF;
                    regs.WZ = (regs.PC + 1) & 0xFFFF;
                    regs.F.X = (regs.PC >>> 11) & 1;
                    regs.F.Y = (regs.PC >>> 13) & 1;
                    break;
                case 10: // Adding 4 cycles
                    break;
                case 11:
                    break;
                case 12:
                    break;
                case 13:
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3B7: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xB1), // ED B1
            function(regs: z80_regs, pins: z80_pins): void { // CPIR
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    regs.TA = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    let n = (regs.A - regs.TR) & 0xFF;
                    regs.F.N = 1;
                    regs.TA = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.F.PV = +(regs.TA !== 0)
                    regs.F.H = ((regs.A ^ regs.TR ^ n) & 0x10) >>> 4;
                    regs.B = (regs.TA & 0xFF00) >>> 8;
                    regs.C = regs.TA & 0xFF;
                    regs.TR = (n - regs.F.H) & 0xFF;
                    regs.F.X = (regs.TR & 8) >>> 3;
                    regs.F.Y = (regs.TR & 2) >>> 1;
                    regs.F.Z = +(n == 0);
                    regs.F.S = ((n) & 0x80) >>> 7;
                    if (((regs.B == 0) && (regs.C == 0)) || (regs.F.Z)) {regs.TCU += 5; break; }
                    break;
                case 9:
                    regs.PC = (regs.PC - 2) & 0xFFFF;
                    regs.WZ = (regs.PC + 1) & 0xFFFF;
                    regs.F.X = (regs.PC >>> 11) & 1;
                    regs.F.Y = (regs.PC >>> 13) & 1;
                    break;
                case 10: // Adding 4 cycles
                    break;
                case 11:
                    break;
                case 12:
                    break;
                case 13:
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3B8: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xB2), // ED B2
            function(regs: z80_regs, pins: z80_pins): void { // INIR
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    regs.TA = (regs.B << 8) | regs.C;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    break;
                case 2: // IN start
                    pins.Addr = regs.TA;
                    break;
                case 3: // IN actual read
                    break;
                case 4: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 5: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.B = (regs.B - 1) & 0xFF;
                    regs.TA = (regs.H << 8) | regs.L;
                    break;
                case 6: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 7:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 8: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.H = (regs.TA & 0xFF00) >>> 8;
                    regs.L = regs.TA & 0xFF;
                    regs.F.C = ((regs.C + 1 + regs.TR) & 0x100) >>> 8;
                    regs.F.N = (regs.TR & 0x80) >>> 7;
                    regs.TA = ((regs.C + 1) & 0xFF) + regs.TR & 7 ^ regs.B;
                    regs.F.PV = Z80_parity(regs.TA);
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.H = regs.F.C;
                    regs.F.Z = +((regs.B) == 0);
                    regs.F.S = ((regs.B) & 0x80) >>> 7;
                    if (regs.B == 0) { regs.TCU += 5; break; }
                    break;
                case 9:
                    regs.PC = (regs.PC - 2) & 0xFFFF;
                    regs.F.X = (regs.PC >>> 11) & 1;
                    regs.F.Y = (regs.PC >>> 13) & 1;
                    if (regs.F.C) {
                        if (regs.data & 0x80) {
                            regs.F.PV ^= Z80_parity((regs.B - 1) & 7) ^ 1;
                            regs.F.H = +((regs.B & 0x0F) == 0);
                        }
                        else {
                            regs.F.PV ^= Z80_parity((regs.B + 1) & 7) ^ 1;
                            regs.F.H = +((regs.B & 0x0F) == 0x0F);
                        }
                    }
                    else {
                        regs.F.PV ^= Z80_parity(regs.B & 7) ^ 1;
                    }
                    break;
                case 10: // Adding 4 cycles
                    break;
                case 11:
                    break;
                case 12:
                    break;
                case 13:
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3B9: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xB3), // ED B3
            function(regs: z80_regs, pins: z80_pins): void { // OTIR
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    break;
                case 2: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    regs.B = (regs.B - 1) & 0xFF;
                    regs.TA = (regs.B << 8) | regs.C;
                    break;
                case 5: // OUT start
                    pins.Addr = regs.TA;
                    pins.D = regs.TR;
                    regs.data = pins.D;
                    break;
                case 6: // OUT continues
                    break;
                case 7: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 8: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA + 1) & 0xFFFF;
                    regs.F.C = ((regs.L + regs.TR) & 0x100) >>> 8;
                    regs.F.N = (regs.TR & 0x80) >>> 7;
                    regs.TR = (regs.L + regs.TR & 7 ^ regs.B) & 0xFF;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.H = regs.F.C;
                    regs.F.Z = +((regs.B) == 0);
                    regs.F.S = ((regs.B) & 0x80) >>> 7;
                    if (regs.B == 0) { regs.TCU += 5; break; }
                    break;
                case 9:
                    regs.PC = (regs.PC - 2) & 0xFFFF;
                    regs.F.X = (regs.PC >>> 11) & 1;
                    regs.F.Y = (regs.PC >>> 13) & 1;
                    if (regs.F.C) {
                        if (regs.data & 0x80) {
                            regs.F.PV ^= Z80_parity((regs.B - 1) & 7) ^ 1;
                            regs.F.H = +((regs.B & 0x0F) == 0);
                        }
                        else {
                            regs.F.PV ^= Z80_parity((regs.B + 1) & 7) ^ 1;
                            regs.F.H = +((regs.B & 0x0F) == 0x0F);
                        }
                    }
                    else {
                        regs.F.PV ^= Z80_parity(regs.B & 7) ^ 1;
                    }
                    break;
                case 10: // Adding 4 cycles
                    break;
                case 11:
                    break;
                case 12:
                    break;
                case 13:
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3BA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3BB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3BC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3BD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3BE: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xB8), // ED B8
            function(regs: z80_regs, pins: z80_pins): void { // LDDR
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.H = (regs.TA & 0xFF00) >>> 8;
                    regs.L = regs.TA & 0xFF;
                    regs.TA = (regs.D << 8) | regs.E;
                    break;
                case 4: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 5:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 6: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.D = (regs.TA & 0xFF00) >>> 8;
                    regs.E = regs.TA & 0xFF;
                    break;
                case 7: // Adding 2 cycles
                    break;
                case 8:
                    regs.F.N = regs.F.H = 0;
                    regs.TA = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.B = ((regs.TA) & 0xFF00) >>> 8;
                    regs.C = (regs.TA) & 0xFF;
                    regs.F.PV = +(regs.TA !== 0);
                    regs.TA = (regs.A + regs.TR) & 0xFF;
                    regs.F.X = (regs.TA & 8) >>> 3;
                    regs.F.Y = (regs.TA & 2) >>> 1;
                    if ((regs.B == 0) && (regs.C == 0)) { regs.TCU += 5; break; }
                    break;
                case 9:
                    regs.PC = (regs.PC - 2) & 0xFFFF;
                    regs.WZ = (regs.PC + 1) & 0xFFFF;
                    regs.F.X = (regs.PC >>> 11) & 1;
                    regs.F.Y = (regs.PC >>> 13) & 1;
                    break;
                case 10: // Adding 4 cycles
                    break;
                case 11:
                    break;
                case 12:
                    break;
                case 13:
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3BF: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xB9), // ED B9
            function(regs: z80_regs, pins: z80_pins): void { // CPDR
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    regs.WZ = (regs.WZ - 1) & 0xFFFF;
                    regs.TA = (regs.H << 8) | regs.L;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.TA = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.B = (regs.TA & 0xFF00) >>> 8;
                    regs.C = regs.TA & 0xFF;
                    let n = regs.A - regs.TR;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TA !== 0);
                    regs.F.H = ((regs.A ^ regs.TR ^ n) & 0x10) >>> 4;
                    regs.F.X = ((n - regs.F.H) & 8) >>> 3;
                    regs.F.Y = ((n - regs.F.H) & 2) >>> 1;
                    regs.F.Z = +(n == 0);
                    regs.F.S = ((n) & 0x80) >>> 7;
                    if (((regs.B == 0) && (regs.C == 0)) || (regs.F.Z)) {regs.TCU += 5; break; }
                    break;
                case 9:
                    regs.PC = (regs.PC - 2) & 0xFFFF;
                    regs.WZ = (regs.PC + 1) & 0xFFFF;
                    regs.F.X = (regs.PC >>> 11) & 1;
                    regs.F.Y = (regs.PC >>> 13) & 1;
                    break;
                case 10: // Adding 4 cycles
                    break;
                case 11:
                    break;
                case 12:
                    break;
                case 13:
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3C0: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xBA), // ED BA
            function(regs: z80_regs, pins: z80_pins): void { // INDR
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    regs.WZ = (((regs.B << 8) | regs.C) - 1) & 0xFFFF;
                    regs.TA = (regs.B << 8) | regs.C;
                    break;
                case 2: // IN start
                    pins.Addr = regs.TA;
                    break;
                case 3: // IN actual read
                    break;
                case 4: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 5: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.TR = pins.D;
                    regs.data = pins.D;
                    regs.B = (regs.B - 1) & 0xFF;
                    regs.TA = (regs.H << 8) | regs.L;
                    break;
                case 6: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 7:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 8: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    regs.F.C = ((((regs.C - 1) & 0xFF) + regs.TR) & 0x100) >>> 8;
                    regs.F.N = (regs.TR & 0x80) >>> 7;
                    regs.TA = ((regs.C - 1) & 0xFF) + regs.TR & 7 ^ regs.B;
                    regs.F.PV = Z80_parity(regs.TA);
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.H = regs.F.C;
                    regs.F.Z = +((regs.B) == 0);
                    regs.F.S = ((regs.B) & 0x80) >>> 7;
                    if (regs.B == 0) { regs.TCU += 5; break; }
                    break;
                case 9:
                    regs.PC = (regs.PC - 2) & 0xFFFF;
                    regs.F.X = (regs.PC >>> 11) & 1;
                    regs.F.Y = (regs.PC >>> 13) & 1;
                    if (regs.F.C) {
                        if (regs.data & 0x80) {
                            regs.F.PV ^= Z80_parity((regs.B - 1) & 7) ^ 1;
                            regs.F.H = +((regs.B & 0x0F) == 0);
                        }
                        else {
                            regs.F.PV ^= Z80_parity((regs.B + 1) & 7) ^ 1;
                            regs.F.H = +((regs.B & 0x0F) == 0x0F);
                        }
                    }
                    else {
                        regs.F.PV ^= Z80_parity(regs.B & 7) ^ 1;
                    }
                    break;
                case 10: // Adding 4 cycles
                    break;
                case 11:
                    break;
                case 12:
                    break;
                case 13:
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3C1: return new Z80_opcode_functions(Z80_ED_opcode_matrix.get(0xBB), // ED BB
            function(regs: z80_regs, pins: z80_pins): void { // OTDR
            switch(regs.TCU) {
                case 1:
                    regs.Q = 1;
                    regs.TA = (regs.H << 8) | regs.L;
                    break;
                case 2: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.H = ((regs.TA) & 0xFF00) >>> 8;
                    regs.L = (regs.TA) & 0xFF;
                    regs.B = (regs.B - 1) & 0xFF;
                    regs.TA = (regs.B << 8) | regs.C;
                    break;
                case 5: // OUT start
                    pins.Addr = regs.TA;
                    pins.D = regs.TR;
                    regs.data = pins.D;
                    break;
                case 6: // OUT continues
                    break;
                case 7: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 8: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = (regs.TA - 1) & 0xFFFF;
                    regs.F.C = ((regs.L + regs.TR) & 0x100) >>> 8;
                    regs.F.N = (regs.TR & 0x80) >>> 7;
                    regs.TR = (regs.L + regs.TR & 7 ^ regs.B) & 0xFF;
                    regs.F.PV = Z80_parity(regs.TR);
                    regs.F.X = ((regs.B) & 8) >>> 3;
                    regs.F.Y = ((regs.B) & 0x20) >>> 5;
                    regs.F.H = regs.F.C;
                    regs.F.Z = +((regs.B) == 0);
                    regs.F.S = ((regs.B) & 0x80) >>> 7;
                    if (regs.B == 0) { regs.TCU += 5; break; }
                    break;
                case 9:
                    regs.PC = (regs.PC - 2) & 0xFFFF;
                    regs.F.X = (regs.PC >>> 11) & 1;
                    regs.F.Y = (regs.PC >>> 13) & 1;
                    if (regs.F.C) {
                        if (regs.data & 0x80) {
                            regs.F.PV ^= Z80_parity((regs.B - 1) & 7) ^ 1;
                            regs.F.H = +((regs.B & 0x0F) == 0);
                        }
                        else {
                            regs.F.PV ^= Z80_parity((regs.B + 1) & 7) ^ 1;
                            regs.F.H = +((regs.B & 0x0F) == 0x0F);
                        }
                    }
                    else {
                        regs.F.PV ^= Z80_parity(regs.B & 7) ^ 1;
                    }
                    break;
                case 10: // Adding 4 cycles
                    break;
                case 11:
                    break;
                case 12:
                    break;
                case 13:
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x3C2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3C3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3C4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3C5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3C6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3C7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3C8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3C9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3CA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3CB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3CC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3CD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3CE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3CF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3D9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3DA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3DB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3DC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3DD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3DE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3DF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3E9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3EA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3EB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3EC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3ED: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3EE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3EF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3F9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3FA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3FB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3FC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3FD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3FE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x3FF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x400: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x401: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x402: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x403: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x404: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x405: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x406: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x407: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x408: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // FD 00
            function(regs: z80_regs, pins: z80_pins): void { // NOP
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x409: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x01), // FD 01
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.B = ((regs.TR) & 0xFF00) >>> 8;
                    regs.C = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x40A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x02), // FD 02
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_a BC
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.WZ = (regs.B << 8) | regs.C
                    pins.Addr = (regs.WZ);
                    break;
                case 2:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.A << 8);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x40B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x03), // FD 03
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr BC
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = (((regs.B << 8) | regs.C ) + 1) & 0xFFFF;
                    regs.B = ((regs.TR) & 0xFF00) >>> 8;
                    regs.C = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x40C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x04), // FD 04
            function(regs: z80_regs, pins: z80_pins): void { // INC_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.B) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x40D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x05), // FD 05
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.B) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x40E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x06), // FD 06
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n B
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x40F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x07), // FD 07
            function(regs: z80_regs, pins: z80_pins): void { // RLCA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = (regs.A & 0x80) >>> 7;
                    regs.A = ((regs.A << 1) | c) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x410: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x08), // FD 08
            function(regs: z80_regs, pins: z80_pins): void { // EX_rr_rr AF AF_
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.exchange_shadow_af();
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x411: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x09), // FD 09
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr BC
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was IY
                    regs.Q = 1;
                    regs.WZ = (regs.IY + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.IY & 0xFF);
                    y = regs.C;
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = ((regs.IY & 0xFF00) >>> 8);
                    y = regs.B;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.IY = (regs.t[5] << 8) | regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x412: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0A), // FD 0A
            function(regs: z80_regs, pins: z80_pins): void { // LD_a_irr BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.WZ = (regs.B << 8) | regs.C;
                    pins.Addr = (regs.WZ);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.A = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x413: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0B), // FD 0B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr BC
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = (regs.B << 8) | regs.C
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.B = ((regs.TA) & 0xFF00) >>> 8;
                    regs.C = (regs.TA) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x414: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0C), // FD 0C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.C) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x415: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0D), // FD 0D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.C) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x416: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0E), // FD 0E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n C
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x417: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x0F), // FD 0F
            function(regs: z80_regs, pins: z80_pins): void { // RRCA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = regs.A & 1;
                    regs.A = (c << 7) | (regs.A >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x418: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x10), // FD 10
            function(regs: z80_regs, pins: z80_pins): void { // DJNZ_e
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    break;
                case 2: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    regs.B = (regs.B - 1) & 0xFF;
                    if (regs.B == 0) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 5: // Adding 5 cycles
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    break;
                case 9:
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x419: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x11), // FD 11
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.D = ((regs.TR) & 0xFF00) >>> 8;
                    regs.E = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x41A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x12), // FD 12
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_a DE
            switch(regs.TCU) {
                case 1: // write begin
                    regs.Q = 0;
                    regs.WZ = (regs.D << 8) | regs.E
                    pins.Addr = (regs.WZ);
                    break;
                case 2:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 3: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.A << 8);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x41B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x13), // FD 13
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr DE
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = (((regs.D << 8) | regs.E ) + 1) & 0xFFFF;
                    regs.D = ((regs.TR) & 0xFF00) >>> 8;
                    regs.E = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x41C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x14), // FD 14
            function(regs: z80_regs, pins: z80_pins): void { // INC_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.D) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x41D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x15), // FD 15
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.D) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x41E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x16), // FD 16
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n D
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x41F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x17), // FD 17
            function(regs: z80_regs, pins: z80_pins): void { // RLA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = (regs.A & 0x80) >>> 7;
                    regs.A = ((regs.A << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x420: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x18), // FD 18
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(1)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x421: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x19), // FD 19
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr DE
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was IY
                    regs.Q = 1;
                    regs.WZ = (regs.IY + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.IY & 0xFF);
                    y = regs.E;
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = ((regs.IY & 0xFF00) >>> 8);
                    y = regs.D;
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.IY = (regs.t[5] << 8) | regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x422: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1A), // FD 1A
            function(regs: z80_regs, pins: z80_pins): void { // LD_a_irr DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.WZ = (regs.D << 8) | regs.E;
                    pins.Addr = (regs.WZ);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.A = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x423: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1B), // FD 1B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr DE
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = (regs.D << 8) | regs.E
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.D = ((regs.TA) & 0xFF00) >>> 8;
                    regs.E = (regs.TA) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x424: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1C), // FD 1C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.E) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x425: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1D), // FD 1D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.E) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x426: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1E), // FD 1E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n E
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x427: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x1F), // FD 1F
            function(regs: z80_regs, pins: z80_pins): void { // RRA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let c = regs.A & 1;
                    regs.A = (regs.F.C << 7) | (regs.A >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x428: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x20), // FD 20
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.Z === 0)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x429: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x21), // FD 21
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.IY = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x42A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x22), // FD 22
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_rr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = ((regs.IY & 0xFF));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    break;
                case 10: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 11:
                    pins.D = (((regs.IY & 0xFF00) >>> 8));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 12: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x42B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x23), // FD 23
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr HL
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = ((regs.IY ) + 1) & 0xFFFF;
                    regs.IY = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x42C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x24), // FD 24
            function(regs: z80_regs, pins: z80_pins): void { // INC_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = (((regs.IY & 0xFF00) >>> 8) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.IY = (regs.TR << 8) | (regs.IY & 0xFF)
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x42D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x25), // FD 25
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = (((regs.IY & 0xFF00) >>> 8) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.IY = (regs.TR << 8) | (regs.IY & 0xFF)
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x42E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x26), // FD 26
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n H
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.IY = ((regs.TR) << 8) | (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x42F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x27), // FD 27
            function(regs: z80_regs, pins: z80_pins): void { // DAA
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let a = regs.A;
                    if (regs.F.C || (regs.A > 0x99)) { regs.A = (regs.A + (regs.F.N ? -0x60: 0x60)) & 0xFF; regs.F.C = 1; }
                    if (regs.F.H || ((regs.A & 0x0F) > 0x09)) { regs.A = (regs.A + (regs.F.N ? -6 : 6)) & 0xFF; }
                    regs.F.PV = Z80_parity(regs.A);
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    regs.F.H = ((a ^ regs.A) & 0x10) >>> 4;
                    regs.F.Z = +(regs.A == 0);
                    regs.F.S = ((regs.A) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x430: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x28), // FD 28
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.Z === 1)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x431: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x29), // FD 29
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr HL
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was IY
                    regs.Q = 1;
                    regs.WZ = (regs.IY + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.IY & 0xFF);
                    y = (regs.IY & 0xFF);
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = ((regs.IY & 0xFF00) >>> 8);
                    y = ((regs.IY & 0xFF00) >>> 8);
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.IY = (regs.t[5] << 8) | regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x432: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2A), // FD 2A
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_inn HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TA = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TA |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.IY = (regs.IY & 0xFF00) | (regs.TR);
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    regs.WZ = regs.TA;
                    break;
                case 10: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 11: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 12: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.IY = (regs.TR << 8) | (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 13: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x433: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2B), // FD 2B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr HL
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = regs.IY
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.IY = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x434: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2C), // FD 2C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.IY & 0xFF) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.IY = (regs.IY & 0xFF00) | regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x435: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2D), // FD 2D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.IY & 0xFF) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.IY = (regs.IY & 0xFF00) | regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x436: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2E), // FD 2E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n L
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.IY = (regs.IY & 0xFF00) | ((regs.TR) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x437: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x2F), // FD 2F
            function(regs: z80_regs, pins: z80_pins): void { // CPL
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.A ^= 0xFF;
                    regs.F.N = regs.F.H = 1;
                    regs.F.X = ((regs.A) & 8) >>> 3;
                    regs.F.Y = ((regs.A) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x438: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x30), // FD 30
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.C === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.C === 0)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x439: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x31), // FD 31
            function(regs: z80_regs, pins: z80_pins): void { // LD_rr_nn SP
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR |= (regs.t[4] << 8);
                    regs.SP = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x43A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x32), // FD 32
            function(regs: z80_regs, pins: z80_pins): void { // LD_inn_a
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.A << 8);
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x43B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x33), // FD 33
            function(regs: z80_regs, pins: z80_pins): void { // INC_rr SP
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TR = ((regs.SP ) + 1) & 0xFFFF;
                    regs.SP = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x43C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x34), // FD 34
            function(regs: z80_regs, pins: z80_pins): void { // INC_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 12:
                    regs.TR = ((regs.TR) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    break;
                case 13: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 14:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 15: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 16: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x43D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x35), // FD 35
            function(regs: z80_regs, pins: z80_pins): void { // DEC_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 12:
                    regs.TR = ((regs.TR) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    break;
                case 13: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 14:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 15: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 16: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x43E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x36), // FD 36
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_n HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 2 cycles
                    break;
                case 5:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 6: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 7: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 8: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x43F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x37), // FD 37
            function(regs: z80_regs, pins: z80_pins): void { // SCF
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    if (regs.Q) { regs.F.X = 0; regs.F.Y = 0; }
                    regs.F.C = regs.Q = 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.X |= ((regs.A & 8) >>> 3);
                    regs.F.Y |= ((regs.A & 0x20) >>> 5);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x440: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x38), // FD 38
            function(regs: z80_regs, pins: z80_pins): void { // JR_c_e regs.F.C === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TR = mksigned8(regs.TR);
                    if (!(regs.F.C === 1)) { regs.TCU += 5; break; }
                    regs.WZ = (regs.PC + regs.TR) & 0xFFFF;
                    regs.PC = regs.WZ;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    // Following is auto-generated code for instruction finish
                    break;
                case 9: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x441: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x39), // FD 39
            function(regs: z80_regs, pins: z80_pins): void { // ADD_hl_rr SP
            let x: u32, y: u32, z: u32;
            switch(regs.TCU) {
                case 1: // Adding 4 cycles
                    // SUB was IY
                    regs.Q = 1;
                    regs.WZ = (regs.IY + 1) & 0xFFFF;
                    regs.t[0] = regs.F.PV; regs.t[1] = regs.F.Z; regs.t[2] = regs.F.S;
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    x = (regs.IY & 0xFF);
                    y = (regs.SP & 0xFF);
                    z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[4] = z & 0xFF;
                    break;
                case 5: // Adding 3 cycles
                    break;
                case 6:
                    break;
                case 7:
                    x = ((regs.IY & 0xFF00) >>> 8);
                    y = ((regs.SP & 0xFF00) >>> 8);
                    z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.t[5] = z & 0xFF;
                    regs.F.PV = regs.t[0]; regs.F.Z = regs.t[1]; regs.F.S = regs.t[2];
                    regs.IY = (regs.t[5] << 8) | regs.t[4];
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x442: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3A), // FD 3A
            function(regs: z80_regs, pins: z80_pins): void { // LD_a_inn
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 8: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 9: // Read end/latch
                    regs.A = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x443: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3B), // FD 3B
            function(regs: z80_regs, pins: z80_pins): void { // DEC_rr SP
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.TA = regs.SP
                    regs.TA = (regs.TA - 1) & 0xFFFF;
                    regs.SP = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x444: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3C), // FD 3C
            function(regs: z80_regs, pins: z80_pins): void { // INC_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.A) + 1) & 0xFF;
                    regs.F.N = 0;
                    regs.F.PV = +(regs.TR == 0x80);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0);
                    regs.F.Z = +(regs.TR == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x445: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3D), // FD 3D
            function(regs: z80_regs, pins: z80_pins): void { // DEC_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    regs.TR = ((regs.A) - 1) & 0xFF;
                    regs.F.N = 1;
                    regs.F.PV = +(regs.TR == 0x7F);
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.H = +((regs.TR & 0x0F) == 0x0F);
                    regs.F.Z = +((regs.TR) == 0);
                    regs.F.S = ((regs.TR) & 0x80) >>> 7;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x446: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3E), // FD 3E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_n A
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x447: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x3F), // FD 3F
            function(regs: z80_regs, pins: z80_pins): void { // CCF
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    if (regs.Q) { regs.F.X = regs.F.Y = 0; } 
                    regs.F.H = regs.F.C;
                    regs.F.C = +(!regs.F.C);
                    regs.F.N = 0;
                    regs.F.X |= (regs.A & 8) >>> 3;
                    regs.F.Y |= (regs.A & 0x20) >>> 5;
                    regs.Q = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x448: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x40), // FD 40
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x449: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x41), // FD 41
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x44A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x42), // FD 42
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x44B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x43), // FD 43
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x44C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x44), // FD 44
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = ((regs.IY & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x44D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x45), // FD 45
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x44E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x46), // FD 46
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr B HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.B = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x44F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x47), // FD 47
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r B A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.B = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x450: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x48), // FD 48
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x451: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x49), // FD 49
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x452: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4A), // FD 4A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x453: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4B), // FD 4B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x454: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4C), // FD 4C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = ((regs.IY & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x455: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4D), // FD 4D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x456: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4E), // FD 4E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr C HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.C = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x457: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x4F), // FD 4F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r C A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.C = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x458: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x50), // FD 50
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x459: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x51), // FD 51
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x45A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x52), // FD 52
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x45B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x53), // FD 53
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x45C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x54), // FD 54
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = ((regs.IY & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x45D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x55), // FD 55
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x45E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x56), // FD 56
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr D HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.D = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x45F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x57), // FD 57
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r D A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.D = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x460: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x58), // FD 58
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x461: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x59), // FD 59
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x462: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5A), // FD 5A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x463: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5B), // FD 5B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x464: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5C), // FD 5C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = ((regs.IY & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x465: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5D), // FD 5D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x466: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5E), // FD 5E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr E HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.E = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x467: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x5F), // FD 5F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r E A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.E = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x468: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x60), // FD 60
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = ((regs.B) << 8) | (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x469: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x61), // FD 61
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = ((regs.C) << 8) | (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x46A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x62), // FD 62
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = ((regs.D) << 8) | (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x46B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x63), // FD 63
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = ((regs.E) << 8) | (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x46C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x64), // FD 64
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = ((((regs.IY & 0xFF00) >>> 8)) << 8) | (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x46D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x65), // FD 65
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = (((regs.IY & 0xFF)) << 8) | (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x46E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x66), // FD 66
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr _H HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.H = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x46F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x67), // FD 67
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r H A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = ((regs.A) << 8) | (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x470: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x68), // FD 68
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = (regs.IY & 0xFF00) | ((regs.B) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x471: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x69), // FD 69
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = (regs.IY & 0xFF00) | ((regs.C) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x472: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6A), // FD 6A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = (regs.IY & 0xFF00) | ((regs.D) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x473: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6B), // FD 6B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = (regs.IY & 0xFF00) | ((regs.E) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x474: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6C), // FD 6C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = (regs.IY & 0xFF00) | ((((regs.IY & 0xFF00) >>> 8)) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x475: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6D), // FD 6D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = (regs.IY & 0xFF00) | (((regs.IY & 0xFF)) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x476: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6E), // FD 6E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr _L HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.L = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x477: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x6F), // FD 6F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r L A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IY = (regs.IY & 0xFF00) | ((regs.A) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x478: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x70), // FD 70
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL B
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.B);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x479: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x71), // FD 71
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL C
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.C);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x47A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x72), // FD 72
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL D
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.D);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x47B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x73), // FD 73
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL E
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.E);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x47C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x74), // FD 74
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL _H
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.H);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x47D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x75), // FD 75
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL _L
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.L);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x47E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x76), // FD 76
            function(regs: z80_regs, pins: z80_pins): void { // HALT
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.HALT = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x47F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x77), // FD 77
            function(regs: z80_regs, pins: z80_pins): void { // LD_irr_r HL A
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 10:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 11: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x480: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x78), // FD 78
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.B;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x481: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x79), // FD 79
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.C;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x482: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7A), // FD 7A
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.D;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x483: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7B), // FD 7B
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.E;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x484: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7C), // FD 7C
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = ((regs.IY & 0xFF00) >>> 8);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x485: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7D), // FD 7D
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = (regs.IY & 0xFF);
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x486: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7E), // FD 7E
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_irr A HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.A = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x487: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x7F), // FD 7F
            function(regs: z80_regs, pins: z80_pins): void { // LD_r_r A A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.A = regs.A;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x488: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x80), // FD 80
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.B;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x489: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x81), // FD 81
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.C;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x48A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x82), // FD 82
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.D;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x48B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x83), // FD 83
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.E;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x48C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x84), // FD 84
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = ((regs.IY & 0xFF00) >>> 8);
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x48D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x85), // FD 85
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = (regs.IY & 0xFF);
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x48E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x86), // FD 86
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x48F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x87), // FD 87
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.A;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x490: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x88), // FD 88
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.B;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x491: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x89), // FD 89
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.C;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x492: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8A), // FD 8A
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.D;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x493: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8B), // FD 8B
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.E;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x494: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8C), // FD 8C
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = ((regs.IY & 0xFF00) >>> 8);
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x495: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8D), // FD 8D
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = (regs.IY & 0xFF);
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x496: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8E), // FD 8E
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x497: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x8F), // FD 8F
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x = regs.A;
                    let y = regs.A;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x498: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x90), // FD 90
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.B);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x499: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x91), // FD 91
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.C);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x49A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x92), // FD 92
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.D);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x49B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x93), // FD 93
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.E);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x49C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x94), // FD 94
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>((regs.IY & 0xFF00) >>> 8));
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x49D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x95), // FD 95
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>(regs.IY & 0xFF));
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x49E: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x96), // FD 96
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x49F: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x97), // FD 97
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x98), // FD 98
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.B);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x99), // FD 99
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.C);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9A), // FD 9A
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.D);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9B), // FD 9B
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.E);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9C), // FD 9C
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>((regs.IY & 0xFF00) >>> 8));
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9D), // FD 9D
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>(regs.IY & 0xFF));
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9E), // FD 9E
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x9F), // FD 9F
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.A);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA0), // FD A0
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.B);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4A9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA1), // FD A1
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.C);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4AA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA2), // FD A2
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.D);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4AB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA3), // FD A3
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.E);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4AC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA4), // FD A4
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (((regs.IY & 0xFF00) >>> 8));
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4AD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA5), // FD A5
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & ((regs.IY & 0xFF));
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4AE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA6), // FD A6
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.A) & (regs.TR);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4AF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA7), // FD A7
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) & (regs.A);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA8), // FD A8
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.B);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xA9), // FD A9
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.C);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAA), // FD AA
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.D);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAB), // FD AB
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.E);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAC), // FD AC
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (((regs.IY & 0xFF00) >>> 8));
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAD), // FD AD
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ ((regs.IY & 0xFF));
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAE), // FD AE
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.A) ^ (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xAF), // FD AF
            function(regs: z80_regs, pins: z80_pins): void { // XOR_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) ^ (regs.A);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB0), // FD B0
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.B);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4B9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB1), // FD B1
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.C);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4BA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB2), // FD B2
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.D);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4BB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB3), // FD B3
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.E);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4BC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB4), // FD B4
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (((regs.IY & 0xFF00) >>> 8));
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4BD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB5), // FD B5
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | ((regs.IY & 0xFF));
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4BE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB6), // FD B6
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.A) | (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4BF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB7), // FD B7
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let z = (regs.A) | (regs.A);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB8), // FD B8
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r B
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.B;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xB9), // FD B9
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r C
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.C;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBA), // FD BA
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r D
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.D;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBB), // FD BB
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r E
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.E;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBC), // FD BC
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r H
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>((regs.IY & 0xFF00) >>> 8);
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBD), // FD BD
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r L
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>(regs.IY & 0xFF);
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBE), // FD BE
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_irr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Adding 5 cycles
                    break;
                case 5:
                    break;
                case 6:
                    break;
                case 7:
                    break;
                case 8:
                    regs.WZ = (regs.IY + mksigned8(regs.TR)) & 0xFFFF;
                    regs.TA = regs.WZ;
                    break;
                case 9: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 10: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 11: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.TR;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 12: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xBF), // FD BF
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_r A
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 1;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.A;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC0), // FD C0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.Z === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4C9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC1), // FD C1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr BC
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.B = ((regs.TR) & 0xFF00) >>> 8;
                    regs.C = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4CA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC2), // FD C2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.Z === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4CB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC3), // FD C3
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4CC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC4), // FD C4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.Z === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.Z === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4CD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC5), // FD C5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr BC
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.B);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.C);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4CE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC6), // FD C6
            function(regs: z80_regs, pins: z80_pins): void { // ADD_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + 0;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4CF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC7), // FD C7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 0
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x00;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC8), // FD C8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.Z === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xC9), // FD C9
            function(regs: z80_regs, pins: z80_pins): void { // RET
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCA), // FD CA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.Z === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x4D4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCC), // FD CC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.Z === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.Z === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCD), // FD CD
            function(regs: z80_regs, pins: z80_pins): void { // CALL_nn
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    break;
                case 14: // cleanup_custom
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCE), // FD CE
            function(regs: z80_regs, pins: z80_pins): void { // ADC_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x = regs.A;
                    let y = regs.TR;
                    let z = x + y + regs.F.C;
                    regs.F.C = +(z > 0xFF);
                    regs.F.N = 0;
                    regs.F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xCF), // FD CF
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 1
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x08;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD0), // FD D0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.C === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.C === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4D9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD1), // FD D1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr DE
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.D = ((regs.TR) & 0xFF00) >>> 8;
                    regs.E = (regs.TR) & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4DA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD2), // FD D2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.C === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.C === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4DB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD3), // FD D3
            function(regs: z80_regs, pins: z80_pins): void { // OUT_in_a
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.A << 8);
                    break;
                case 4: // OUT start
                    pins.Addr = regs.WZ;
                    pins.D = regs.A;
                    regs.data = pins.D;
                    break;
                case 5: // OUT continues
                    break;
                case 6: // WAIT STATE
                    pins.WR = 1; pins.IO = 1;
                    break;
                case 7: // OUT end
                    pins.WR = 0; pins.IO = 0;
                    regs.WZ = ((regs.WZ + 1) & 0xFF) | (regs.WZ & 0xFF00);
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4DC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD4), // FD D4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.C === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.C === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4DD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD5), // FD D5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr DE
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.D);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.E);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4DE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD6), // FD D6
            function(regs: z80_regs, pins: z80_pins): void { // SUB_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(0));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4DF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD7), // FD D7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 2
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x10;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD8), // FD D8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.C === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.C === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xD9), // FD D9
            function(regs: z80_regs, pins: z80_pins): void { // EXX
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.exchange_shadow();
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDA), // FD DA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.C === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.C === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDB), // FD DB
            function(regs: z80_regs, pins: z80_pins): void { // IN_a_in
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.A << 8);
                    break;
                case 4: // IN start
                    pins.Addr = regs.WZ;
                    break;
                case 5: // IN actual read
                    break;
                case 6: // IN wait state
                    pins.RD = 1; pins.IO = 1;
                    break;
                case 7: // IN end/latch
                    pins.RD = 0; pins.IO = 0;
                    regs.A = pins.D;
                    regs.data = pins.D;
                    regs.WZ = (regs.WZ + 1) & 0xFFFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDC), // FD DC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.C === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.C === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x4E6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDE), // FD DE
            function(regs: z80_regs, pins: z80_pins): void { // SBC_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x: i32 = (<i32>regs.A);
                    let y: i32 = (<i32>regs.TR);
                    let c = <i32>(+(regs.F.C));
                    let z = <i32>(<i32>x - <i32>y - <i32>c) & 0x1FF;
                    regs.F.C = (z & 0x100) >>> 8;
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z & 0xFF;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xDF), // FD DF
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 3
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x18;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE0), // FD E0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.PV === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.PV === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4E9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE1), // FD E1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.IY = regs.TR;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4EA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE2), // FD E2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.PV === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.PV === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4EB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE3), // FD E3
            function(regs: z80_regs, pins: z80_pins): void { // EX_irr_rr SP HL
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    regs.TA = regs.SP;
                    pins.Addr = (regs.TA);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.WZ |= (regs.TR << 8);
                    break;
                case 7: // wait
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = ((regs.IY & 0xFF));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.TA);
                    break;
                case 12:
                    pins.D = (((regs.IY & 0xFF00) >>> 8));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    break;
                case 14: // wait
                    break;
                case 15: // wait
                    regs.IY = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 16: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4EC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE4), // FD E4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.PV === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.PV === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4ED: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE5), // FD E5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr HL
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.IY & 0xFF00) >>> 8));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.IY & 0xFF));
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4EE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE6), // FD E6
            function(regs: z80_regs, pins: z80_pins): void { // AND_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let z = (regs.A) & (regs.TR);
                    regs.F.C = regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.H = 1;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4EF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE7), // FD E7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 4
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x20;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F0: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE8), // FD E8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.PV === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.PV === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F1: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xE9), // FD E9
            function(regs: z80_regs, pins: z80_pins): void { // JP_rr HL
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.PC = regs.IY;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F2: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEA), // FD EA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.PV === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.PV === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F3: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEB), // FD EB
            function(regs: z80_regs, pins: z80_pins): void { // EX_rr_rr DE _HL
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.exchange_de_hl();
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F4: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEC), // FD EC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.PV === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.PV === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F5: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x4F6: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEE), // FD EE
            function(regs: z80_regs, pins: z80_pins): void { // undefined
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let z = (regs.A) ^ (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F7: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xEF), // FD EF
            function(regs: z80_regs, pins: z80_pins): void { // RST 5
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x28;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F8: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF0), // FD F0
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.S === 0
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.S === 0)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4F9: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF1), // FD F1
            function(regs: z80_regs, pins: z80_pins): void { // POP_rr AF
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.SP);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.A = ((regs.TR) & 0xFF00) >>> 8;
                    regs.F.setbyte((regs.TR) & 0xFF);
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4FA: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF2), // FD F2
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.S === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.S === 0) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4FB: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF3), // FD F3
            function(regs: z80_regs, pins: z80_pins): void { // DI
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IFF1 = regs.IFF2 = 0;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4FC: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF4), // FD F4
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.S === 0
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.S === 0)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4FD: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF5), // FD F5
            function(regs: z80_regs, pins: z80_pins): void { // PUSH_rr AF
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (regs.A);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = (regs.F.getbyte());
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4FE: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF6), // FD F6
            function(regs: z80_regs, pins: z80_pins): void { // OR_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let z = (regs.A) | (regs.TR);
                    regs.F.C = regs.F.N = regs.F.H = 0;
                    regs.F.X = ((z) & 8) >>> 3;
                    regs.F.Y = ((z) & 0x20) >>> 5;
                    regs.F.PV = Z80_parity(z);
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    regs.A = z;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x4FF: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF7), // FD F7
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 6
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x30;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x500: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF8), // FD F8
            function(regs: z80_regs, pins: z80_pins): void { // RET_c regs.F.S === 1
            switch(regs.TCU) {
                case 1: // 0
                    regs.Q = 0;
                    if (!(regs.F.S === 1)) { regs.TCU += 6; break; }
                    break;
                case 2: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 3: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 4: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    break;
                case 5: // Start read
                    pins.Addr = (regs.SP);
                    break;
                case 6: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 7: // Read end/latch
                    regs.t[0] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP + 1) & 0xFFFF;
                    regs.TR |= regs.t[0] << 8;
                    regs.WZ = (regs.TR);
                    regs.PC = regs.WZ
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x501: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xF9), // FD F9
            function(regs: z80_regs, pins: z80_pins): void { // LD_sp_rr HL
            switch(regs.TCU) {
                case 1: // Adding 2 cycles
                    regs.Q = 0;
                    break;
                case 2:
                    regs.SP = regs.IY
                    // Following is auto-generated code for instruction finish
                    break;
                case 3: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x502: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFA), // FD FA
            function(regs: z80_regs, pins: z80_pins): void { // JP_c_nn regs.F.S === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    if (regs.F.S === 1) regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x503: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFB), // FD FB
            function(regs: z80_regs, pins: z80_pins): void { // EI
            switch(regs.TCU) {
                case 1: // cleanup_custom
                    regs.Q = 0;
                    regs.IFF1 = regs.IFF2 = regs.EI = 1;
                    // Following is auto-generated code for instruction finish
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x504: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFC), // FD FC
            function(regs: z80_regs, pins: z80_pins): void { // CALL_c_nn regs.F.S === 1
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 0;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    break;
                case 4: // Start read
                    pins.Addr = (regs.PC);
                    break;
                case 5: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 6: // Read end/latch
                    regs.t[4] = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.WZ |= (regs.t[4] << 8);
                    regs.TA = regs.WZ;
                    regs.TR = +(regs.F.S === 1)
                    if (!regs.TR) { regs.TA = regs.PC; regs.TCU+=7; break; }
                    break;
                case 7:
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 8: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 9:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 10: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 11: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 12:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 13: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.PC = regs.TA;
                    // Following is auto-generated code for instruction finish
                    break;
                case 14: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x505: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x506: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFE), // FD FE
            function(regs: z80_regs, pins: z80_pins): void { // CP_a_n
            switch(regs.TCU) {
                case 1: // Start read
                    regs.Q = 1;
                    pins.Addr = (regs.PC);
                    break;
                case 2: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 3: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    let x: i32 = <i32>regs.A;
                    let y: i32 = <i32>regs.TR;
                    let z: i32 = x - y;
                    regs.F.C = +(z < 0);
                    regs.F.N = 1;
                    regs.F.PV = (((x ^ y) & (x ^ z)) & 0x80) >>> 7;
                    regs.F.X = ((y) & 8) >>> 3;
                    regs.F.Y = ((y) & 0x20) >>> 5;
                    regs.F.H = ((x ^ y ^ z) & 0x10) >>> 4;
                    regs.F.Z = +((z & 0xFF) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    // Following is auto-generated code for instruction finish
                    break;
                case 4: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x507: return new Z80_opcode_functions(Z80_opcode_matrix.get(0xFF), // FD FF
            function(regs: z80_regs, pins: z80_pins): void { // RST_o 7
            switch(regs.TCU) {
                case 1:
                    regs.Q = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.WZ = 0x38;
                    regs.PC = regs.WZ;
                    // Following is auto-generated code for instruction finish
                    break;
                case 8: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x508: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x100), // FD 100
            function(regs: z80_regs, pins: z80_pins): void { // IRQ
            switch(regs.TCU) {
                case 1:
                    regs.R = (regs.R + 1) & 0x7F;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 2: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 3:
                    pins.D = (((regs.PC) >>> 8) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 4: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    regs.SP = (regs.SP - 1) & 0xFFFF;
                    break;
                case 5: // write begin
                    pins.Addr = (regs.SP);
                    break;
                case 6:
                    pins.D = ((regs.PC) & 0xFF);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 7: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    let wait: u32;
                    switch(pins.IRQ_maskable ? regs.IM : 1) {
                    case 0:
                        regs.t[0] = 0;
                        regs.WZ = pins.D;
                        wait = 12 - (((pins.D | 0x38) == 0xFF) ? 6 : 7);
                        regs.TCU += wait;
                        break;
                    case 1:
                        regs.t[0] = 0;
                        regs.WZ = regs.IRQ_vec;
                        wait = 12 - (pins.IRQ_maskable ? 7 : 5);
                        regs.TCU += wait;
                        break;
                    case 2:
                        regs.t[0] = 1;
                        regs.TA = (regs.I << 8) | pins.D;
                        regs.WZ = 0;
                        break;
                    }
                    break;
                case 8: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 9: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 10: // Read end/latch
                    regs.WZ = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TA = (regs.TA + 1) & 0xFFFF;
                    break;
                case 11: // Start read
                    pins.Addr = (regs.TA);
                    break;
                case 12: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 13: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    if (regs.t[0] == 1) { regs.WZ |= regs.TR << 8; }
                    break;
                case 14: // Adding 6 cycles
                    break;
                case 15:
                    break;
                case 16:
                    break;
                case 17:
                    break;
                case 18:
                    break;
                case 19:
                    regs.PC = regs.WZ;
                    regs.IFF1 = 0;
                    if (pins.IRQ_maskable) regs.IFF2 = 0;
                    regs.HALT = 0;
                    if (regs.P) regs.F.PV = 0;
                    regs.P = 0;
                    regs.Q = 0;
                    regs.IRQ_vec = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 20: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x509: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x101), // FD 101
            function(regs: z80_regs, pins: z80_pins): void { // RESET
            switch(regs.TCU) {
                case 1:
                    regs.IFF1 = regs.IFF2 = 0; // disable interrupt
                    regs.IM = 0;
                    regs.I = 0;
                    regs.R = 0;
                    regs.PC = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 2: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x50A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x00), // CB DD 00
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x50B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x01), // CB DD 01
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x50C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x02), // CB DD 02
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x50D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x03), // CB DD 03
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x50E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x04), // CB DD 04
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x50F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x05), // CB DD 05
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x510: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x06), // CB DD 06
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x511: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x07), // CB DD 07
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x512: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x08), // CB DD 08
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x513: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x09), // CB DD 09
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x514: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0A), // CB DD 0A
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x515: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0B), // CB DD 0B
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x516: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0C), // CB DD 0C
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x517: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0D), // CB DD 0D
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x518: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0E), // CB DD 0E
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x519: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0F), // CB DD 0F
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x51A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x10), // CB DD 10
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x51B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x11), // CB DD 11
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x51C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x12), // CB DD 12
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x51D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x13), // CB DD 13
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x51E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x14), // CB DD 14
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x51F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x15), // CB DD 15
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x520: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x16), // CB DD 16
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x521: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x17), // CB DD 17
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x522: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x18), // CB DD 18
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x523: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x19), // CB DD 19
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x524: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1A), // CB DD 1A
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x525: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1B), // CB DD 1B
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x526: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1C), // CB DD 1C
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x527: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1D), // CB DD 1D
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x528: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1E), // CB DD 1E
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x529: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1F), // CB DD 1F
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x52A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x20), // CB DD 20
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x52B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x21), // CB DD 21
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x52C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x22), // CB DD 22
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x52D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x23), // CB DD 23
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x52E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x24), // CB DD 24
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x52F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x25), // CB DD 25
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x530: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x26), // CB DD 26
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x531: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x27), // CB DD 27
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x532: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x28), // CB DD 28
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x533: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x29), // CB DD 29
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x534: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2A), // CB DD 2A
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x535: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2B), // CB DD 2B
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x536: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2C), // CB DD 2C
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x537: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2D), // CB DD 2D
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x538: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2E), // CB DD 2E
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x539: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2F), // CB DD 2F
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x53A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x30), // CB DD 30
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x53B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x31), // CB DD 31
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x53C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x32), // CB DD 32
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x53D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x33), // CB DD 33
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x53E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x34), // CB DD 34
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x53F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x35), // CB DD 35
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x540: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x36), // CB DD 36
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x541: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x37), // CB DD 37
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x542: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x38), // CB DD 38
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x543: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x39), // CB DD 39
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x544: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3A), // CB DD 3A
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x545: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3B), // CB DD 3B
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x546: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3C), // CB DD 3C
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x547: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3D), // CB DD 3D
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x548: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3E), // CB DD 3E
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x549: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3F), // CB DD 3F
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x54A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x40), // CB DD 40
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x54B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x41), // CB DD 41
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x54C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x42), // CB DD 42
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x54D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x43), // CB DD 43
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x54E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x44), // CB DD 44
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x54F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x45), // CB DD 45
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x550: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x46), // CB DD 46
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x551: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x47), // CB DD 47
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x552: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x48), // CB DD 48
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x553: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x49), // CB DD 49
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x554: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4A), // CB DD 4A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x555: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4B), // CB DD 4B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x556: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4C), // CB DD 4C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x557: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4D), // CB DD 4D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x558: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4E), // CB DD 4E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x559: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4F), // CB DD 4F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x55A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x50), // CB DD 50
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x55B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x51), // CB DD 51
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x55C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x52), // CB DD 52
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x55D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x53), // CB DD 53
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x55E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x54), // CB DD 54
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x55F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x55), // CB DD 55
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x560: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x56), // CB DD 56
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x561: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x57), // CB DD 57
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x562: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x58), // CB DD 58
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x563: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x59), // CB DD 59
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x564: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5A), // CB DD 5A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x565: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5B), // CB DD 5B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x566: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5C), // CB DD 5C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x567: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5D), // CB DD 5D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x568: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5E), // CB DD 5E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x569: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5F), // CB DD 5F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x56A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x60), // CB DD 60
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x56B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x61), // CB DD 61
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x56C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x62), // CB DD 62
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x56D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x63), // CB DD 63
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x56E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x64), // CB DD 64
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x56F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x65), // CB DD 65
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x570: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x66), // CB DD 66
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x571: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x67), // CB DD 67
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x572: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x68), // CB DD 68
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x573: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x69), // CB DD 69
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x574: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6A), // CB DD 6A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x575: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6B), // CB DD 6B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x576: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6C), // CB DD 6C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x577: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6D), // CB DD 6D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x578: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6E), // CB DD 6E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x579: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6F), // CB DD 6F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x57A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x70), // CB DD 70
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x57B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x71), // CB DD 71
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x57C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x72), // CB DD 72
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x57D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x73), // CB DD 73
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x57E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x74), // CB DD 74
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x57F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x75), // CB DD 75
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x580: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x76), // CB DD 76
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x581: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x77), // CB DD 77
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x582: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x78), // CB DD 78
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x583: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x79), // CB DD 79
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x584: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7A), // CB DD 7A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x585: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7B), // CB DD 7B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x586: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7C), // CB DD 7C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x587: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7D), // CB DD 7D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x588: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7E), // CB DD 7E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x589: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7F), // CB DD 7F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x58A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x80), // CB DD 80
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x58B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x81), // CB DD 81
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x58C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x82), // CB DD 82
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x58D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x83), // CB DD 83
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x58E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x84), // CB DD 84
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x58F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x85), // CB DD 85
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x590: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x86), // CB DD 86
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x591: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x87), // CB DD 87
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x592: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x88), // CB DD 88
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x593: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x89), // CB DD 89
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x594: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8A), // CB DD 8A
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x595: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8B), // CB DD 8B
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x596: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8C), // CB DD 8C
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x597: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8D), // CB DD 8D
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x598: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8E), // CB DD 8E
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x599: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8F), // CB DD 8F
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x59A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x90), // CB DD 90
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x59B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x91), // CB DD 91
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x59C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x92), // CB DD 92
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x59D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x93), // CB DD 93
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x59E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x94), // CB DD 94
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x59F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x95), // CB DD 95
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x96), // CB DD 96
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x97), // CB DD 97
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x98), // CB DD 98
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x99), // CB DD 99
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9A), // CB DD 9A
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9B), // CB DD 9B
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9C), // CB DD 9C
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9D), // CB DD 9D
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9E), // CB DD 9E
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5A9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9F), // CB DD 9F
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5AA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA0), // CB DD A0
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5AB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA1), // CB DD A1
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5AC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA2), // CB DD A2
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5AD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA3), // CB DD A3
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5AE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA4), // CB DD A4
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5AF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA5), // CB DD A5
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA6), // CB DD A6
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA7), // CB DD A7
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA8), // CB DD A8
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA9), // CB DD A9
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAA), // CB DD AA
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAB), // CB DD AB
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAC), // CB DD AC
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAD), // CB DD AD
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAE), // CB DD AE
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5B9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAF), // CB DD AF
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5BA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB0), // CB DD B0
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5BB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB1), // CB DD B1
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5BC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB2), // CB DD B2
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5BD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB3), // CB DD B3
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5BE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB4), // CB DD B4
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5BF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB5), // CB DD B5
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB6), // CB DD B6
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB7), // CB DD B7
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB8), // CB DD B8
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB9), // CB DD B9
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBA), // CB DD BA
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBB), // CB DD BB
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBC), // CB DD BC
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBD), // CB DD BD
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBE), // CB DD BE
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5C9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBF), // CB DD BF
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5CA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC0), // CB DD C0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5CB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC1), // CB DD C1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5CC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC2), // CB DD C2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5CD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC3), // CB DD C3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5CE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC4), // CB DD C4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5CF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC5), // CB DD C5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC6), // CB DD C6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC7), // CB DD C7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC8), // CB DD C8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC9), // CB DD C9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCA), // CB DD CA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCB), // CB DD CB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCC), // CB DD CC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCD), // CB DD CD
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCE), // CB DD CE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5D9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCF), // CB DD CF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5DA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD0), // CB DD D0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5DB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD1), // CB DD D1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5DC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD2), // CB DD D2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5DD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD3), // CB DD D3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5DE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD4), // CB DD D4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5DF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD5), // CB DD D5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD6), // CB DD D6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD7), // CB DD D7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD8), // CB DD D8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD9), // CB DD D9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDA), // CB DD DA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDB), // CB DD DB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDC), // CB DD DC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDD), // CB DD DD
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDE), // CB DD DE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5E9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDF), // CB DD DF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5EA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE0), // CB DD E0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5EB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE1), // CB DD E1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5EC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE2), // CB DD E2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5ED: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE3), // CB DD E3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5EE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE4), // CB DD E4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5EF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE5), // CB DD E5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE6), // CB DD E6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE7), // CB DD E7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE8), // CB DD E8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE9), // CB DD E9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEA), // CB DD EA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEB), // CB DD EB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEC), // CB DD EC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xED), // CB DD ED
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEE), // CB DD EE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5F9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEF), // CB DD EF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5FA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF0), // CB DD F0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5FB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF1), // CB DD F1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5FC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF2), // CB DD F2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5FD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF3), // CB DD F3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5FE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF4), // CB DD F4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x5FF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF5), // CB DD F5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x600: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF6), // CB DD F6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x601: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF7), // CB DD F7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x602: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF8), // CB DD F8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x603: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF9), // CB DD F9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x604: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFA), // CB DD FA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x605: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFB), // CB DD FB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x606: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFC), // CB DD FC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x607: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFD), // CB DD FD
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x608: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFE), // CB DD FE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x609: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFF), // CB DD FF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x60A: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x60B: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x60C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x00), // CB FD 00
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x60D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x01), // CB FD 01
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x60E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x02), // CB FD 02
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x60F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x03), // CB FD 03
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x610: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x04), // CB FD 04
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x611: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x05), // CB FD 05
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x612: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x06), // CB FD 06
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x613: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x07), // CB FD 07
            function(regs: z80_regs, pins: z80_pins): void { // RLC_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x << 1) | (x >>> 7)) & 0xFF;
                    regs.F.C = x & 1;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x614: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x08), // CB FD 08
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x615: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x09), // CB FD 09
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x616: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0A), // CB FD 0A
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x617: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0B), // CB FD 0B
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x618: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0C), // CB FD 0C
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x619: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0D), // CB FD 0D
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x61A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0E), // CB FD 0E
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x61B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x0F), // CB FD 0F
            function(regs: z80_regs, pins: z80_pins): void { // RRC_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    x = ((x >>> 1) | (x << 7)) & 0xFF;
                    regs.F.C = (x & 0x80) >>> 7;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x61C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x10), // CB FD 10
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x61D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x11), // CB FD 11
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x61E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x12), // CB FD 12
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x61F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x13), // CB FD 13
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x620: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x14), // CB FD 14
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x621: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x15), // CB FD 15
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x622: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x16), // CB FD 16
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x623: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x17), // CB FD 17
            function(regs: z80_regs, pins: z80_pins): void { // RL_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | regs.F.C) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x624: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x18), // CB FD 18
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x625: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x19), // CB FD 19
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x626: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1A), // CB FD 1A
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x627: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1B), // CB FD 1B
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x628: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1C), // CB FD 1C
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x629: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1D), // CB FD 1D
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x62A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1E), // CB FD 1E
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x62B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x1F), // CB FD 1F
            function(regs: z80_regs, pins: z80_pins): void { // RR_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) | (regs.F.C << 7);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x62C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x20), // CB FD 20
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x62D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x21), // CB FD 21
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x62E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x22), // CB FD 22
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x62F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x23), // CB FD 23
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x630: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x24), // CB FD 24
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x631: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x25), // CB FD 25
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x632: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x26), // CB FD 26
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x633: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x27), // CB FD 27
            function(regs: z80_regs, pins: z80_pins): void { // SLA_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = (x << 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x634: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x28), // CB FD 28
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x635: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x29), // CB FD 29
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x636: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2A), // CB FD 2A
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x637: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2B), // CB FD 2B
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x638: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2C), // CB FD 2C
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x639: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2D), // CB FD 2D
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x63A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2E), // CB FD 2E
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x63B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x2F), // CB FD 2F
            function(regs: z80_regs, pins: z80_pins): void { // SRA_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x & 0x80) | (x >>> 1);
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x63C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x30), // CB FD 30
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x63D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x31), // CB FD 31
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x63E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x32), // CB FD 32
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x63F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x33), // CB FD 33
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x640: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x34), // CB FD 34
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x641: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x35), // CB FD 35
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x642: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x36), // CB FD 36
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x643: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x37), // CB FD 37
            function(regs: z80_regs, pins: z80_pins): void { // SLL_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = (x & 0x80) >>> 7;
                    x = ((x << 1) | 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x644: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x38), // CB FD 38
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.B = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x645: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x39), // CB FD 39
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.C = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x646: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3A), // CB FD 3A
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.D = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x647: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3B), // CB FD 3B
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.E = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x648: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3C), // CB FD 3C
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.H = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x649: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3D), // CB FD 3D
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.L = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x64A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3E), // CB FD 3E
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    // JUNKVAR set here to regs.TR
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x64B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x3F), // CB FD 3F
            function(regs: z80_regs, pins: z80_pins): void { // SRL_irr_r addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let x = regs.TR;
                    let c = x & 1;
                    x = (x >>> 1) & 0xFF;
                    regs.F.C = c;
                    regs.F.N = regs.F.H = 0;
                    regs.F.PV = Z80_parity(x);
                    regs.F.X = ((x) & 8) >>> 3;
                    regs.F.Y = ((x) & 0x20) >>> 5;
                    regs.F.Z = +((x) == 0);
                    regs.F.S = ((x) & 0x80) >>> 7;
                    regs.TR = x;
                    regs.A = regs.TR;
                    break;
                case 6: // wait
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x64C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x40), // CB FD 40
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x64D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x41), // CB FD 41
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x64E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x42), // CB FD 42
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x64F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x43), // CB FD 43
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x650: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x44), // CB FD 44
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x651: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x45), // CB FD 45
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x652: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x46), // CB FD 46
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x653: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x47), // CB FD 47
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 0 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 0);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x654: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x48), // CB FD 48
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x655: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x49), // CB FD 49
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x656: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4A), // CB FD 4A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x657: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4B), // CB FD 4B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x658: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4C), // CB FD 4C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x659: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4D), // CB FD 4D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x65A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4E), // CB FD 4E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x65B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x4F), // CB FD 4F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 1 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 1);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x65C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x50), // CB FD 50
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x65D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x51), // CB FD 51
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x65E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x52), // CB FD 52
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x65F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x53), // CB FD 53
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x660: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x54), // CB FD 54
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x661: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x55), // CB FD 55
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x662: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x56), // CB FD 56
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x663: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x57), // CB FD 57
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 2 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 2);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x664: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x58), // CB FD 58
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x665: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x59), // CB FD 59
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x666: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5A), // CB FD 5A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x667: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5B), // CB FD 5B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x668: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5C), // CB FD 5C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x669: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5D), // CB FD 5D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x66A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5E), // CB FD 5E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x66B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x5F), // CB FD 5F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 3 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 3);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x66C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x60), // CB FD 60
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x66D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x61), // CB FD 61
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x66E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x62), // CB FD 62
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x66F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x63), // CB FD 63
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x670: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x64), // CB FD 64
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x671: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x65), // CB FD 65
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x672: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x66), // CB FD 66
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x673: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x67), // CB FD 67
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 4 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 4);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x674: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x68), // CB FD 68
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x675: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x69), // CB FD 69
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x676: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6A), // CB FD 6A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x677: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6B), // CB FD 6B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x678: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6C), // CB FD 6C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x679: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6D), // CB FD 6D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x67A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6E), // CB FD 6E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x67B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x6F), // CB FD 6F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 5 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 5);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x67C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x70), // CB FD 70
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x67D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x71), // CB FD 71
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x67E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x72), // CB FD 72
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x67F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x73), // CB FD 73
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x680: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x74), // CB FD 74
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x681: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x75), // CB FD 75
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x682: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x76), // CB FD 76
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x683: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x77), // CB FD 77
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 6 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 6);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x684: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x78), // CB FD 78
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x685: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x79), // CB FD 79
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x686: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7A), // CB FD 7A
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x687: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7B), // CB FD 7B
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x688: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7C), // CB FD 7C
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x689: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7D), // CB FD 7D
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x68A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7E), // CB FD 7E
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x68B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x7F), // CB FD 7F
            function(regs: z80_regs, pins: z80_pins): void { // BIT_o_irr_r 7 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    let z = (regs.TR) & (1 << 7);
                    regs.F.N = 0;
                    regs.F.PV = Z80_parity(z);
                    regs.F.H = 1;
                    regs.F.X = ((regs.TR) & 8) >>> 3;
                    regs.F.Y = ((regs.TR) & 0x20) >>> 5;
                    regs.F.Z = +((z) == 0);
                    regs.F.S = ((z) & 0x80) >>> 7;
                    break;
                case 6: // wait
                    regs.F.X = (((regs.WZ >>> 8)) & 8) >>> 3;
                    regs.F.Y = (((regs.WZ >>> 8)) & 0x20) >>> 5;
                    // Following is auto-generated code for instruction finish
                    break;
                case 7: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x68C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x80), // CB FD 80
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x68D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x81), // CB FD 81
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x68E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x82), // CB FD 82
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x68F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x83), // CB FD 83
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x690: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x84), // CB FD 84
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x691: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x85), // CB FD 85
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x692: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x86), // CB FD 86
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x693: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x87), // CB FD 87
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 0 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 0) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x694: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x88), // CB FD 88
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x695: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x89), // CB FD 89
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x696: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8A), // CB FD 8A
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x697: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8B), // CB FD 8B
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x698: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8C), // CB FD 8C
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x699: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8D), // CB FD 8D
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x69A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8E), // CB FD 8E
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x69B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x8F), // CB FD 8F
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 1 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 1) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x69C: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x90), // CB FD 90
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x69D: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x91), // CB FD 91
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x69E: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x92), // CB FD 92
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x69F: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x93), // CB FD 93
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x94), // CB FD 94
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x95), // CB FD 95
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x96), // CB FD 96
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x97), // CB FD 97
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 2 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 2) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x98), // CB FD 98
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x99), // CB FD 99
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9A), // CB FD 9A
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9B), // CB FD 9B
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9C), // CB FD 9C
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6A9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9D), // CB FD 9D
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6AA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9E), // CB FD 9E
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6AB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0x9F), // CB FD 9F
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 3 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 3) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6AC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA0), // CB FD A0
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6AD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA1), // CB FD A1
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6AE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA2), // CB FD A2
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6AF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA3), // CB FD A3
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA4), // CB FD A4
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA5), // CB FD A5
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA6), // CB FD A6
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA7), // CB FD A7
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 4 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 4) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA8), // CB FD A8
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xA9), // CB FD A9
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAA), // CB FD AA
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAB), // CB FD AB
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAC), // CB FD AC
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6B9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAD), // CB FD AD
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6BA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAE), // CB FD AE
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6BB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xAF), // CB FD AF
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 5 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 5) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6BC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB0), // CB FD B0
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6BD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB1), // CB FD B1
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6BE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB2), // CB FD B2
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6BF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB3), // CB FD B3
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB4), // CB FD B4
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB5), // CB FD B5
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB6), // CB FD B6
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB7), // CB FD B7
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 6 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 6) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB8), // CB FD B8
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xB9), // CB FD B9
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBA), // CB FD BA
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBB), // CB FD BB
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBC), // CB FD BC
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6C9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBD), // CB FD BD
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6CA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBE), // CB FD BE
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6CB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xBF), // CB FD BF
            function(regs: z80_regs, pins: z80_pins): void { // RES_o_irr_r 7 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    break;
                case 6: // wait
                    regs.TR = regs.TR & ((1 << 7) ^ 0xFF);
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6CC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC0), // CB FD C0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6CD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC1), // CB FD C1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6CE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC2), // CB FD C2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6CF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC3), // CB FD C3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC4), // CB FD C4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC5), // CB FD C5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC6), // CB FD C6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC7), // CB FD C7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 0 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 0);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC8), // CB FD C8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xC9), // CB FD C9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCA), // CB FD CA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCB), // CB FD CB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCC), // CB FD CC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6D9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCD), // CB FD CD
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6DA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCE), // CB FD CE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6DB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xCF), // CB FD CF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 1 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 1);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6DC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD0), // CB FD D0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6DD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD1), // CB FD D1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6DE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD2), // CB FD D2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6DF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD3), // CB FD D3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD4), // CB FD D4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD5), // CB FD D5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD6), // CB FD D6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD7), // CB FD D7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 2 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 2);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD8), // CB FD D8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xD9), // CB FD D9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDA), // CB FD DA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDB), // CB FD DB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDC), // CB FD DC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6E9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDD), // CB FD DD
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6EA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDE), // CB FD DE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6EB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xDF), // CB FD DF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 3 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 3);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6EC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE0), // CB FD E0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6ED: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE1), // CB FD E1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6EE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE2), // CB FD E2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6EF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE3), // CB FD E3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F0: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE4), // CB FD E4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F1: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE5), // CB FD E5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F2: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE6), // CB FD E6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F3: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE7), // CB FD E7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 4 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 4);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F4: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE8), // CB FD E8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F5: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xE9), // CB FD E9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F6: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEA), // CB FD EA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F7: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEB), // CB FD EB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F8: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEC), // CB FD EC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6F9: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xED), // CB FD ED
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6FA: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEE), // CB FD EE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6FB: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xEF), // CB FD EF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 5 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 5);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6FC: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF0), // CB FD F0
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6FD: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF1), // CB FD F1
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6FE: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF2), // CB FD F2
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x6FF: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF3), // CB FD F3
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x700: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF4), // CB FD F4
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x701: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF5), // CB FD F5
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x702: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF6), // CB FD F6
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x703: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF7), // CB FD F7
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 6 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 6);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x704: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF8), // CB FD F8
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr B
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.B = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x705: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xF9), // CB FD F9
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr C
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.C = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x706: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFA), // CB FD FA
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr D
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.D = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x707: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFB), // CB FD FB
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr E
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.E = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x708: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFC), // CB FD FC
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr H
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.H = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x709: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFD), // CB FD FD
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr L
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.L = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x70A: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFE), // CB FD FE
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr _
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    // JUNKVAR set here to regs.TR
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x70B: return new Z80_opcode_functions(Z80_CBd_opcode_matrix.get(0xFF), // CB FD FF
            function(regs: z80_regs, pins: z80_pins): void { // SET_o_irr_r 7 addr A
            switch(regs.TCU) {
                case 1: // wait
                    regs.Q = 1;
                    break;
                case 2: // wait
                    break;
                case 3: // Start read
                    pins.Addr = (regs.WZ);
                    break;
                case 4: // signal
                    pins.RD = 1; pins.MRQ = 1;
                    break;
                case 5: // Read end/latch
                    regs.TR = pins.D;
                    pins.RD = 0; pins.MRQ = 0;
                    regs.TR = regs.TR | (1 << 7);
                    break;
                case 6: // wait
                    regs.A = regs.TR;
                    break;
                case 7: // write begin
                    pins.Addr = (regs.WZ);
                    break;
                case 8:
                    pins.D = (regs.TR);
                    pins.WR = 1; pins.MRQ = 1;
                    break;
                case 9: // write end
                    pins.WR = 0; pins.MRQ = 0;
                    // Following is auto-generated code for instruction finish
                    break;
                case 10: // cleanup_custom
                    pins.Addr = regs.PC;
                    regs.PC = (regs.PC + 1) & 0xFFFF;
                    regs.TCU = 0;
                    regs.EI = 0;
                    regs.P = 0;
                    regs.prefix = 0x00;
                    regs.rprefix = Z80P.HL;
                    regs.IR = Z80_S_DECODE;
                    regs.poll_IRQ = true;
                    break;
            }
        });
        case 0x70C: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
        case 0x70D: return new Z80_opcode_functions(Z80_opcode_matrix.get(0x00), // 00
            function(regs: z80_regs, pins: z80_pins): void { // undefined
        });
    }
    return new Z80_opcode_functions(Z80_opcode_matrix.get(0), function(regs: z80_regs, pins: z80_pins): void { console.log('INVALID OPCODE');});
}

for (let i = 0; i <= 1806; i++) {
    z80_decoded_opcodes[i] = z80_get_opcode_function(i);
}
