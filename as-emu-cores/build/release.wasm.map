{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/rt/tcms.ts","assembly/component/cpu/m6502/m6502_opcodes.ts","~lib/util/error.ts","~lib/shared/runtime.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/arraybuffer.ts","~lib/util/hash.ts","~lib/map.ts","assembly/helpers/debug.ts","~lib/util/sort.ts","~lib/array.ts","assembly/system/nes/cpu/nesm6502_generated_opcodes.ts","assembly/component/cpu/m6502/m6502.ts","assembly/helpers/helpers.ts","~lib/console.ts","assembly/system/interface.ts","assembly/system/nes/nes_ppu.ts","assembly/system/nes/mappers/interface.ts","assembly/system/nes/nes.ts","assembly/system/nes/nes_common.ts","assembly/system/gb/gb_cart.ts","assembly/system/gb/mappers/mbc3.ts","assembly/system/gb/gb_cpu.ts","assembly/component/cpu/sm83/sm83_opcodes.ts","assembly/component/cpu/sm83/sm83_generated_opcodes.ts","assembly/component/cpu/sm83/sm83.ts","assembly/system/gb/gb.ts","assembly/glue/global_player.ts","assembly/glue/cpu_tester.ts","~lib/string.ts","assembly/system/nes/cpu/r2a03.ts","assembly/component/controller/nes_joypad.ts","assembly/system/nes/cpu/controller_port.ts","~lib/staticarray.ts","assembly/system/nes/nes_cart.ts","~lib/typedarray.ts","assembly/system/gb/gb_ppu.ts","~lib/memory.ts","~lib/math.ts","~lib/number.ts","assembly/system/nes/mappers/mapper_none.ts","assembly/system/nes/mappers/mmc1.ts","assembly/system/nes/mappers/mmc3b.ts","assembly/system/nes/mappers/uxrom.ts","assembly/system/nes/mappers/cxrom.ts","assembly/system/nes/mappers/axrom.ts","assembly/system/nes/mappers/vrc_2b_4e_4f.ts","assembly/system/nes/mappers/dxrom.ts","~lib/util/casemap.ts","assembly/system/gb/mappers/nomapper.ts","assembly/system/gb/mappers/mbc1.ts","assembly/system/gb/mappers/mbc2.ts","assembly/system/gb/mappers/mbc5.ts","~lib/function.ts"],"names":[],"mappings":"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CpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SAEpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SAEpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SAEpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SAEpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SAEpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAqB,IAAK,SACrD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB,IAAK,SACpD,AAAqB,GAAM,EAAoB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0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAkBc,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAkBc,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAkBc,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAkBc,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAkBc,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAkBc,AAA0B,EAAuB,KAC/D,SAac,AAA0B,EAAuB,KAC/D,SAmBc,AAA0B,EAAuB,KAC/D,SAmBc,AAA0B,EAAuB,KAC/D,SAmBc,AAA0B,EAAuB,KAC/D,SAmBc,AAA0B,EAAuB,KAC/D,SAmBc,AAA0B,EAAuB,KAC/D,S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,SAgBe,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SA2Be,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SA4Be,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SA4Be,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SA4Be,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SA4Be,AAA0B,EAAyB,IAClE,SAiBe,AAA0B,EAAyB,IAClE,SAee,AAA0B,EAAyB,IAClE,SAee,AAA0B,EAAyB,IAClE,SAee,AAA0B,EAAyB,IAClE,SAee,AAA0B,EAAyB,IAClE,SAee,AAA0B,EAAyB,IAClE,SAee,AAA0B,EAAyB,IAClE,SA0Be,AAA0B,EAAyB,IAClE,SAee,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,IAClE,SA2Be,AAA0B,EAAyB,IAClE,SAgBe,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAmBe,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAmBe,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAmBe,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAmBe,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAmBe,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAmBe,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAmBe,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAmBe,AAA0B,EAAyB,KAClE,SAee,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAuBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAuBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAuBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAuBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAuBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAuBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAuBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAuBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAwBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAwBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,KAClE,SAwBe,AAA0B,EAAyB,KAClE,SAae,AAA0B,EAAyB,K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","sourceRoot":"./release","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export let ROOT: Root = changetype<Root>(0); // unsafe initializion below\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  let head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  let prev = block.prev;\n  let next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  let slMap = GETSL(root, fl) & (~0 << sl);\n  let head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  let tail = GETTAIL(root);\n  let tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  let size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\n  let left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  let pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  let pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  let pagesBefore = memory.size();\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  let root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  let memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, block);\n  prepareBlock(root, block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let blockInfo = block.mmInfo;\n  let blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  let newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE } from \"./common\";\nimport { onvisit, oncollect } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === TCMS: A Two-Color Mark & Sweep garbage collector ===\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unreachable                                     │\n// │ BLACK*      │ Reachable                                       │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy let white = 0;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy let total: usize = 0;\n\n// @ts-ignore: decorator\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white);\n  total += obj.size;\n  return changetype<usize>(obj) + TOTAL_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  if (oldPtr < __heap_base) { // move to heap for simplicity\n    let newPtr = __new(size, oldObj.rtId);\n    memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n    return newPtr;\n  }\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  total -= oldObj.size;\n  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size) + OBJECT_OVERHEAD;\n  let newObj = changetype<Object>(newPtr - TOTAL_OVERHEAD);\n  newObj.rtSize = <u32>size;\n\n  // Replace with new object\n  newObj.next.prev = newObj;\n  newObj.prev.next = newObj;\n\n  total += newObj.size;\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.unlink(); // from fromSpace\n    obj.linkTo(toSpace, i32(!white));\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  obj.unlink(); // from pinSpace\n  obj.linkTo(fromSpace, white);\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC at\", 1, total);\n\n  // Mark roots (add to toSpace)\n  __visit_globals(VISIT_SCAN);\n\n  // Mark direct members of pinned objects (add to toSpace)\n  let pn = pinSpace;\n  let iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\n    iter = iter.next;\n  }\n\n  // Mark what's reachable from toSpace\n  let black = i32(!white);\n  let to = toSpace;\n  iter = to.next;\n  while (iter != to) {\n    if (DEBUG) assert(iter.color == black);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\n    iter = iter.next;\n  }\n\n  // Sweep what's left in fromSpace\n  let from = fromSpace;\n  iter = from.next;\n  while (iter != from) {\n    if (DEBUG) assert(iter.color == white);\n    let newNext = iter.next;\n    if (changetype<usize>(iter) < __heap_base) {\n      iter.nextWithColor = 0; // may become linked again\n      iter.prev = changetype<Object>(0);\n    } else {\n      total -= iter.size;\n      if (isDefined(__finalize)) __finalize(changetype<usize>(iter) + TOTAL_OVERHEAD);\n      __free(changetype<usize>(iter) + BLOCK_OVERHEAD);\n    }\n    iter = newNext;\n  }\n  from.nextWithColor = changetype<usize>(from);\n  from.prev = from;\n\n  // Flip spaces and colors\n  fromSpace = to;\n  toSpace = from;\n  white = black;\n\n  if (TRACE) trace(\"GC done at\", 1, total);\n  if (RTRACE) oncollect(total);\n}\n","import {m6502_pins, m6502_regs} from \"./m6502\";\r\n\r\nexport const M6502_OP_RESET = 0x100;\r\nexport const M6502_OP_NMI = 0x101;\r\nexport const M6502_OP_IRQ = 0x102;\r\n\r\nexport const M6502_MAX_OPCODE = 0x102;\r\n\r\nexport enum M6502_VARIANTS {\r\n    STOCK = 0, STOCK_UNDOCUMENTED, CMOS, INVALID\r\n}\r\n\r\nexport enum M6502_MN {\r\n    ADC = 0, AND, ASL, BCC, BCS, BEQ,\r\n    BIT, BMI, BNE, BPL, BRK, BVC,\r\n    BVS, CLC, CLD, CLI, CLV, CMP,\r\n    CPX, CPY, DEC, DEX, DEY, EOR,\r\n    INC, INX, INY, JMP, JSR, LDA,\r\n    LDX, LDY, LSR, NOP, ORA, PHA,\r\n    PHP, PLA, PLP, ROL, ROR, RTI,\r\n    RTS, SBC, SEC, SED, SEI, STA,\r\n    STX, STY, TAX, TAY, TSX, TXA,\r\n    TXS, TYA, NONE, S_RESET, S_NMI, S_IRQ\r\n}\r\n\r\nexport enum M6502_AM {\r\n    ACCUM, ABSr, ABSm, ABSw, ABSjmp, ABSjsr,\r\n    ABS_Xr, ABS_Xm, ABS_Xw, ABS_Xsya,\r\n    ABS_Yr, ABS_Ym, ABS_Yw, ABS_Yxas, ABS_Ysxa,\r\n    IMM, IMPLIED, IND, INDjmp,\r\n    X_INDr, X_INDm, X_INDw,\r\n    IND_Yr, IND_Ym, IND_Yw,\r\n    PC_REL, PC_REL_ZP,\r\n    ZPr, ZPm, ZPw,\r\n    ZP_Xr, ZP_Xm, ZP_Xw,\r\n    ZP_Yr, ZP_Ym, ZP_Yw, NONE,\r\n\r\n    ABS_IND_Xr, ZP_INDr, ZP_INDw\r\n}\r\n\r\nclass M6502_opcode_info {\r\n    opcode: u32 = 0\r\n    ins: u32 = 0\r\n    addr_mode: M6502_AM = M6502_AM.NONE\r\n    mnemonic: string = ''\r\n    variant: M6502_VARIANTS = M6502_VARIANTS.STOCK\r\n\r\n    constructor(opcode: u32, ins: u32, addr_mode: M6502_AM, mnemonic: string, variant: M6502_VARIANTS = M6502_VARIANTS.STOCK) {\r\n        this.opcode = opcode;\r\n        this.ins = ins;\r\n        this.addr_mode = addr_mode;\r\n        this.mnemonic = mnemonic;\r\n        this.variant = variant;\r\n    }\r\n}\r\n\r\nexport class M6502_opcode_functions {\r\n    ins: u32 = 0\r\n    opcode: u32 = 0\r\n    addr_mode: M6502_AM = M6502_AM.NONE\r\n    mnemonic: string = ''\r\n    exec_func: (regs: m6502_regs, pins: m6502_pins) => void;\r\n    constructor(opcode_info: M6502_opcode_info, exec_func: (regs: m6502_regs, pins: m6502_pins) => void) {\r\n        this.opcode = opcode_info.opcode;\r\n        this.ins = opcode_info.ins;\r\n        this.addr_mode = opcode_info.addr_mode;\r\n        this.mnemonic = opcode_info.mnemonic;\r\n        this.exec_func = exec_func;\r\n    }\r\n}\r\n\r\nexport var M6502_stock_matrix: Map<u32, M6502_opcode_info> = new Map<u32, M6502_opcode_info>();\r\nexport var M6502_invalid_matrix: Map<u32, M6502_opcode_info> = new Map<u32, M6502_opcode_info>();\r\n\r\nfor (let i = 0; i < 0x100; i++) {\r\n    M6502_invalid_matrix.set(i, new M6502_opcode_info(i, M6502_MN.NONE, M6502_AM.NONE, '', M6502_VARIANTS.INVALID));\r\n}\r\n\r\nfunction M6502_get_stock_matrix_item(i: u32): M6502_opcode_info {\r\n    let y: M6502_opcode_info;\r\n    switch(i) {\r\n        case 0x00: y = new M6502_opcode_info(0x00, M6502_MN.BRK, M6502_AM.IMPLIED, 'BRK', M6502_VARIANTS.STOCK); break;\r\n        case 0x01: y = new M6502_opcode_info(0x01, M6502_MN.ORA, M6502_AM.X_INDr, 'ORA (d,x)', M6502_VARIANTS.STOCK); break;\r\n        case 0x05: y = new M6502_opcode_info(0x05, M6502_MN.ORA, M6502_AM.ZPr, 'ORA d', M6502_VARIANTS.STOCK); break;\r\n        case 0x06: y = new M6502_opcode_info(0x06, M6502_MN.ASL, M6502_AM.ZPm, 'ASL d', M6502_VARIANTS.STOCK); break;\r\n        case 0x08: y = new M6502_opcode_info(0x08, M6502_MN.PHP, M6502_AM.IMPLIED, 'PHP', M6502_VARIANTS.STOCK); break;\r\n        case 0x09: y = new M6502_opcode_info(0x09, M6502_MN.ORA, M6502_AM.IMM, 'ORA #', M6502_VARIANTS.STOCK); break;\r\n        case 0x0A: y = new M6502_opcode_info(0x0A, M6502_MN.ASL, M6502_AM.ACCUM, 'ASL A', M6502_VARIANTS.STOCK); break;\r\n        case 0x0D: y = new M6502_opcode_info(0x0D, M6502_MN.ORA, M6502_AM.ABSr, 'ORA a', M6502_VARIANTS.STOCK); break;\r\n        case 0x0E: y = new M6502_opcode_info(0x0E, M6502_MN.ASL, M6502_AM.ABSm, 'ASL a', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0x10: y = new M6502_opcode_info(0x10, M6502_MN.BPL, M6502_AM.PC_REL, 'BPL r', M6502_VARIANTS.STOCK); break;\r\n        case 0x11: y = new M6502_opcode_info(0x11, M6502_MN.ORA, M6502_AM.IND_Yr, 'ORA (d),y', M6502_VARIANTS.STOCK); break;\r\n        case 0x15: y = new M6502_opcode_info(0x15, M6502_MN.ORA, M6502_AM.ZP_Xr, 'ORA d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x16: y = new M6502_opcode_info(0x16, M6502_MN.ASL, M6502_AM.ZP_Xm, 'ASL d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x18: y = new M6502_opcode_info(0x18, M6502_MN.CLC, M6502_AM.IMPLIED, 'CLC i', M6502_VARIANTS.STOCK); break;\r\n        case 0x19: y = new M6502_opcode_info(0x19, M6502_MN.ORA, M6502_AM.ABS_Yr, 'ORA a,y', M6502_VARIANTS.STOCK); break;\r\n        case 0x1D: y = new M6502_opcode_info(0x1D, M6502_MN.ORA, M6502_AM.ABS_Xr, 'ORA a,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x1E: y = new M6502_opcode_info(0x1E, M6502_MN.ASL, M6502_AM.ABS_Xm, 'ASL a,x', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0x20: y = new M6502_opcode_info(0x20, M6502_MN.JSR, M6502_AM.ABSjsr, 'JSR a', M6502_VARIANTS.STOCK); break;\r\n        case 0x21: y = new M6502_opcode_info(0x21, M6502_MN.AND, M6502_AM.X_INDr, 'AND (d,x)', M6502_VARIANTS.STOCK); break;\r\n        case 0x24: y = new M6502_opcode_info(0x24, M6502_MN.BIT, M6502_AM.ZPr, 'BIT d', M6502_VARIANTS.STOCK); break;\r\n        case 0x25: y = new M6502_opcode_info(0x25, M6502_MN.AND, M6502_AM.ZPr, 'AND d', M6502_VARIANTS.STOCK); break;\r\n        case 0x26: y = new M6502_opcode_info(0x26, M6502_MN.ROL, M6502_AM.ZPm, 'ROL d', M6502_VARIANTS.STOCK); break;\r\n        case 0x28: y = new M6502_opcode_info(0x28, M6502_MN.PLP, M6502_AM.IMPLIED, 'PLP', M6502_VARIANTS.STOCK); break;\r\n        case 0x29: y = new M6502_opcode_info(0x29, M6502_MN.AND, M6502_AM.IMM, 'AND #', M6502_VARIANTS.STOCK); break;\r\n        case 0x2A: y = new M6502_opcode_info(0x2A, M6502_MN.ROL, M6502_AM.ACCUM, 'ROL A', M6502_VARIANTS.STOCK); break;\r\n        case 0x2C: y = new M6502_opcode_info(0x2C, M6502_MN.BIT, M6502_AM.ABSr, 'BIT a', M6502_VARIANTS.STOCK); break;\r\n        case 0x2D: y = new M6502_opcode_info(0x2D, M6502_MN.AND, M6502_AM.ABSr, 'AND a', M6502_VARIANTS.STOCK); break;\r\n        case 0x2E: y = new M6502_opcode_info(0x2E, M6502_MN.ROL, M6502_AM.ABSm, 'ROL a', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0x30: y = new M6502_opcode_info(0x30, M6502_MN.BMI, M6502_AM.PC_REL, 'BMI r', M6502_VARIANTS.STOCK); break;\r\n        case 0x31: y = new M6502_opcode_info(0x31, M6502_MN.AND, M6502_AM.IND_Yr, 'AND (d),x', M6502_VARIANTS.STOCK); break;\r\n        case 0x35: y = new M6502_opcode_info(0x35, M6502_MN.AND, M6502_AM.ZP_Xr, 'AND d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x36: y = new M6502_opcode_info(0x36, M6502_MN.ROL, M6502_AM.ZP_Xm, 'ROL d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x38: y = new M6502_opcode_info(0x38, M6502_MN.SEC, M6502_AM.IMPLIED, 'SEC', M6502_VARIANTS.STOCK); break;\r\n        case 0x39: y = new M6502_opcode_info(0x39, M6502_MN.AND, M6502_AM.ABS_Yr, 'AND a,y', M6502_VARIANTS.STOCK); break;\r\n        case 0x3D: y = new M6502_opcode_info(0x3D, M6502_MN.AND, M6502_AM.ABS_Xr, 'AND a,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x3E: y = new M6502_opcode_info(0x3E, M6502_MN.ROL, M6502_AM.ABS_Xm, 'ROL a,x', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0x40: y = new M6502_opcode_info(0x40, M6502_MN.RTI, M6502_AM.IMPLIED, 'RTI', M6502_VARIANTS.STOCK); break;\r\n        case 0x41: y = new M6502_opcode_info(0x41, M6502_MN.EOR, M6502_AM.X_INDr, 'EOR (d,x)', M6502_VARIANTS.STOCK); break;\r\n        case 0x45: y = new M6502_opcode_info(0x45, M6502_MN.EOR, M6502_AM.ZPr, 'EOR d', M6502_VARIANTS.STOCK); break;\r\n        case 0x46: y = new M6502_opcode_info(0x46, M6502_MN.LSR, M6502_AM.ZPm, 'LSR d', M6502_VARIANTS.STOCK); break;\r\n        case 0x48: y = new M6502_opcode_info(0x48, M6502_MN.PHA, M6502_AM.IMPLIED, 'PHA', M6502_VARIANTS.STOCK); break;\r\n        case 0x49: y = new M6502_opcode_info(0x49, M6502_MN.EOR, M6502_AM.IMM, 'EOR #', M6502_VARIANTS.STOCK); break;\r\n        case 0x4A: y = new M6502_opcode_info(0x4A, M6502_MN.LSR, M6502_AM.ACCUM, 'LSR A', M6502_VARIANTS.STOCK); break;\r\n        case 0x4C: y = new M6502_opcode_info(0x4C, M6502_MN.JMP, M6502_AM.ABSjmp, 'JMP a', M6502_VARIANTS.STOCK); break;\r\n        case 0x4D: y = new M6502_opcode_info(0x4D, M6502_MN.EOR, M6502_AM.ABSr, 'EOR a', M6502_VARIANTS.STOCK); break;\r\n        case 0x4E: y = new M6502_opcode_info(0x4E, M6502_MN.LSR, M6502_AM.ABSm, 'LSR a', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0x50: y = new M6502_opcode_info(0x50, M6502_MN.BVC, M6502_AM.PC_REL, 'BVC r', M6502_VARIANTS.STOCK); break;\r\n        case 0x51: y = new M6502_opcode_info(0x51, M6502_MN.EOR, M6502_AM.IND_Yr, 'EOR (d),y', M6502_VARIANTS.STOCK); break;\r\n        case 0x55: y = new M6502_opcode_info(0x55, M6502_MN.EOR, M6502_AM.ZP_Xr, 'EOR d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x56: y = new M6502_opcode_info(0x56, M6502_MN.LSR, M6502_AM.ZP_Xm, 'LSR d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x58: y = new M6502_opcode_info(0x58, M6502_MN.CLI, M6502_AM.IMPLIED, 'CLI', M6502_VARIANTS.STOCK); break;\r\n        case 0x59: y = new M6502_opcode_info(0x59, M6502_MN.EOR, M6502_AM.ABS_Yr, 'EOR a,y', M6502_VARIANTS.STOCK); break;\r\n        case 0x5D: y = new M6502_opcode_info(0x5D, M6502_MN.EOR, M6502_AM.ABS_Xr, 'EOR a,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x5E: y = new M6502_opcode_info(0x5E, M6502_MN.LSR, M6502_AM.ABS_Xm, 'LSR a,x', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0x60: y = new M6502_opcode_info(0x60, M6502_MN.RTS, M6502_AM.IMPLIED, 'RTS', M6502_VARIANTS.STOCK); break;\r\n        case 0x61: y = new M6502_opcode_info(0x61, M6502_MN.ADC, M6502_AM.X_INDr, 'ADC (d,x)', M6502_VARIANTS.STOCK); break;\r\n        case 0x65: y = new M6502_opcode_info(0x65, M6502_MN.ADC, M6502_AM.ZPr, 'ADC d', M6502_VARIANTS.STOCK); break;\r\n        case 0x66: y = new M6502_opcode_info(0x66, M6502_MN.ROR, M6502_AM.ZPm, 'ROR d', M6502_VARIANTS.STOCK); break;\r\n        case 0x68: y = new M6502_opcode_info(0x68, M6502_MN.PLA, M6502_AM.IMPLIED, 'PLA', M6502_VARIANTS.STOCK); break;\r\n        case 0x69: y = new M6502_opcode_info(0x69, M6502_MN.ADC, M6502_AM.IMM, 'ADC #', M6502_VARIANTS.STOCK); break;\r\n        case 0x6A: y = new M6502_opcode_info(0x6A, M6502_MN.ROR, M6502_AM.ACCUM, 'ROR A', M6502_VARIANTS.STOCK); break;\r\n        case 0x6C: y = new M6502_opcode_info(0x6C, M6502_MN.JMP, M6502_AM.INDjmp, 'JMP (d)', M6502_VARIANTS.STOCK); break;\r\n        case 0x6D: y = new M6502_opcode_info(0x6D, M6502_MN.ADC, M6502_AM.ABSr, 'ADC a', M6502_VARIANTS.STOCK); break;\r\n        case 0x6E: y = new M6502_opcode_info(0x6E, M6502_MN.ROR, M6502_AM.ABSm, 'ROR a', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0x70: y = new M6502_opcode_info(0x70, M6502_MN.BVS, M6502_AM.PC_REL, 'BVS r', M6502_VARIANTS.STOCK); break;\r\n        case 0x71: y = new M6502_opcode_info(0x71, M6502_MN.ADC, M6502_AM.IND_Yr, 'ADC (d),y', M6502_VARIANTS.STOCK); break;\r\n        case 0x75: y = new M6502_opcode_info(0x75, M6502_MN.ADC, M6502_AM.ZP_Xr, 'ADC d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x76: y = new M6502_opcode_info(0x76, M6502_MN.ROR, M6502_AM.ZP_Xm, 'ROR d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x78: y = new M6502_opcode_info(0x78, M6502_MN.SEI, M6502_AM.IMPLIED, 'SEI', M6502_VARIANTS.STOCK); break;\r\n        case 0x79: y = new M6502_opcode_info(0x79, M6502_MN.ADC, M6502_AM.ABS_Yr, 'ADC a,y', M6502_VARIANTS.STOCK); break;\r\n        case 0x7D: y = new M6502_opcode_info(0x7D, M6502_MN.ADC, M6502_AM.ABS_Xr, 'ADC a,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x7E: y = new M6502_opcode_info(0x7E, M6502_MN.ROR, M6502_AM.ABS_Xm, 'ROR a,x', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0x81: y = new M6502_opcode_info(0x81, M6502_MN.STA, M6502_AM.X_INDw, 'STA (d,x)', M6502_VARIANTS.STOCK); break;\r\n        case 0x84: y = new M6502_opcode_info(0x84, M6502_MN.STY, M6502_AM.ZPw, 'STY d', M6502_VARIANTS.STOCK); break;\r\n        case 0x85: y = new M6502_opcode_info(0x85, M6502_MN.STA, M6502_AM.ZPw, 'STA d', M6502_VARIANTS.STOCK); break;\r\n        case 0x86: y = new M6502_opcode_info(0x86, M6502_MN.STX, M6502_AM.ZPw, 'STX d', M6502_VARIANTS.STOCK); break;\r\n        case 0x88: y = new M6502_opcode_info(0x88, M6502_MN.DEY, M6502_AM.IMPLIED, 'DEY', M6502_VARIANTS.STOCK); break;\r\n        case 0x8A: y = new M6502_opcode_info(0x8A, M6502_MN.TXA, M6502_AM.IMPLIED, 'TXA', M6502_VARIANTS.STOCK); break;\r\n        case 0x8C: y = new M6502_opcode_info(0x8C, M6502_MN.STY, M6502_AM.ABSw, 'STY a', M6502_VARIANTS.STOCK); break;\r\n        case 0x8D: y = new M6502_opcode_info(0x8D, M6502_MN.STA, M6502_AM.ABSw, 'STA a', M6502_VARIANTS.STOCK); break;\r\n        case 0x8E: y = new M6502_opcode_info(0x8E, M6502_MN.STX, M6502_AM.ABSw, 'STX a', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0x90: y = new M6502_opcode_info(0x90, M6502_MN.BCC, M6502_AM.PC_REL, 'BCC', M6502_VARIANTS.STOCK); break;\r\n        case 0x91: y = new M6502_opcode_info(0x91, M6502_MN.STA, M6502_AM.IND_Yw, 'STA (d),y', M6502_VARIANTS.STOCK); break;\r\n        case 0x94: y = new M6502_opcode_info(0x94, M6502_MN.STY, M6502_AM.ZP_Xw, 'STY d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x95: y = new M6502_opcode_info(0x95, M6502_MN.STA, M6502_AM.ZP_Xw, 'STA d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0x96: y = new M6502_opcode_info(0x96, M6502_MN.STX, M6502_AM.ZP_Yw, 'STX d,y', M6502_VARIANTS.STOCK); break;\r\n        case 0x98: y = new M6502_opcode_info(0x98, M6502_MN.TYA, M6502_AM.IMPLIED, 'TYA', M6502_VARIANTS.STOCK); break;\r\n        case 0x99: y = new M6502_opcode_info(0x99, M6502_MN.STA, M6502_AM.ABS_Yw, 'STA a,y', M6502_VARIANTS.STOCK); break;\r\n        case 0x9A: y = new M6502_opcode_info(0x9A, M6502_MN.TXS, M6502_AM.IMPLIED, 'TXS', M6502_VARIANTS.STOCK); break;\r\n        case 0x9D: y = new M6502_opcode_info(0x9D, M6502_MN.STA, M6502_AM.ABS_Xw, 'STA a,x', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0xA0: y = new M6502_opcode_info(0xA0, M6502_MN.LDY, M6502_AM.IMM, 'LDY #', M6502_VARIANTS.STOCK); break;\r\n        case 0xA1: y = new M6502_opcode_info(0xA1, M6502_MN.LDA, M6502_AM.X_INDr, 'LDA (d,x)', M6502_VARIANTS.STOCK); break;\r\n        case 0xA2: y = new M6502_opcode_info(0xA2, M6502_MN.LDX, M6502_AM.IMM, 'LDX #', M6502_VARIANTS.STOCK); break;\r\n        case 0xA4: y = new M6502_opcode_info(0xA4, M6502_MN.LDY, M6502_AM.ZPr, 'LDY d', M6502_VARIANTS.STOCK); break;\r\n        case 0xA5: y = new M6502_opcode_info(0xA5, M6502_MN.LDA, M6502_AM.ZPr, 'LDA d', M6502_VARIANTS.STOCK); break;\r\n        case 0xA6: y = new M6502_opcode_info(0xA6, M6502_MN.LDX, M6502_AM.ZPr, 'LDX d', M6502_VARIANTS.STOCK); break;\r\n        case 0xA8: y = new M6502_opcode_info(0xA8, M6502_MN.TAY, M6502_AM.IMPLIED, 'TAY', M6502_VARIANTS.STOCK); break;\r\n        case 0xA9: y = new M6502_opcode_info(0xA9, M6502_MN.LDA, M6502_AM.IMM, 'LDA #', M6502_VARIANTS.STOCK); break;\r\n        case 0xAA: y = new M6502_opcode_info(0xAA, M6502_MN.TAX, M6502_AM.IMPLIED, 'TAX', M6502_VARIANTS.STOCK); break;\r\n        case 0xAC: y = new M6502_opcode_info(0xAC, M6502_MN.LDY, M6502_AM.ABSr, 'LDY a', M6502_VARIANTS.STOCK); break;\r\n        case 0xAD: y = new M6502_opcode_info(0xAD, M6502_MN.LDA, M6502_AM.ABSr, 'LDA a', M6502_VARIANTS.STOCK); break;\r\n        case 0xAE: y = new M6502_opcode_info(0xAE, M6502_MN.LDX, M6502_AM.ABSr, 'LDX a', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0xB0: y = new M6502_opcode_info(0xB0, M6502_MN.BCS, M6502_AM.PC_REL, 'BCS r', M6502_VARIANTS.STOCK); break;\r\n        case 0xB1: y = new M6502_opcode_info(0xB1, M6502_MN.LDA, M6502_AM.IND_Yr, 'LDA (d),y', M6502_VARIANTS.STOCK); break;\r\n        case 0xB4: y = new M6502_opcode_info(0xB4, M6502_MN.LDY, M6502_AM.ZP_Xr, 'LDY d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0xB5: y = new M6502_opcode_info(0xB5, M6502_MN.LDA, M6502_AM.ZP_Xr, 'LDA d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0xB6: y = new M6502_opcode_info(0xB6, M6502_MN.LDX, M6502_AM.ZP_Yr, 'LDX d,y', M6502_VARIANTS.STOCK); break;\r\n        case 0xB8: y = new M6502_opcode_info(0xB8, M6502_MN.CLV, M6502_AM.IMPLIED, 'CLV', M6502_VARIANTS.STOCK); break;\r\n        case 0xB9: y = new M6502_opcode_info(0xB9, M6502_MN.LDA, M6502_AM.ABS_Yr, 'LDA a,y', M6502_VARIANTS.STOCK); break;\r\n        case 0xBA: y = new M6502_opcode_info(0xBA, M6502_MN.TSX, M6502_AM.IMPLIED, 'TSX', M6502_VARIANTS.STOCK); break;\r\n        case 0xBC: y = new M6502_opcode_info(0xBC, M6502_MN.LDY, M6502_AM.ABS_Xr, 'LDY a,x', M6502_VARIANTS.STOCK); break;\r\n        case 0xBD: y = new M6502_opcode_info(0xBD, M6502_MN.LDA, M6502_AM.ABS_Xr, 'LDA a,x', M6502_VARIANTS.STOCK); break;\r\n        case 0xBE: y = new M6502_opcode_info(0xBE, M6502_MN.LDX, M6502_AM.ABS_Yr, 'LDX a,y', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0xC0: y = new M6502_opcode_info(0xC0, M6502_MN.CPY, M6502_AM.IMM, 'CPY #', M6502_VARIANTS.STOCK); break;\r\n        case 0xC1: y = new M6502_opcode_info(0xC1, M6502_MN.CMP, M6502_AM.X_INDr, 'CMP (d,x)', M6502_VARIANTS.STOCK); break;\r\n        case 0xC4: y = new M6502_opcode_info(0xC4, M6502_MN.CPY, M6502_AM.ZPr, 'CPY d', M6502_VARIANTS.STOCK); break;\r\n        case 0xC5: y = new M6502_opcode_info(0xC5, M6502_MN.CMP, M6502_AM.ZPr, 'CMP d', M6502_VARIANTS.STOCK); break;\r\n        case 0xC6: y = new M6502_opcode_info(0xC6, M6502_MN.DEC, M6502_AM.ZPm, 'DEC d', M6502_VARIANTS.STOCK); break;\r\n        case 0xC8: y = new M6502_opcode_info(0xC8, M6502_MN.INY, M6502_AM.IMPLIED, 'INY', M6502_VARIANTS.STOCK); break;\r\n        case 0xC9: y = new M6502_opcode_info(0xC9, M6502_MN.CMP, M6502_AM.IMM, 'CMP #', M6502_VARIANTS.STOCK); break;\r\n        case 0xCA: y = new M6502_opcode_info(0xCA, M6502_MN.DEX, M6502_AM.IMPLIED, 'DEX', M6502_VARIANTS.STOCK); break;\r\n        case 0xCC: y = new M6502_opcode_info(0xCC, M6502_MN.CPY, M6502_AM.ABSr, 'CPY a', M6502_VARIANTS.STOCK); break;\r\n        case 0xCD: y = new M6502_opcode_info(0xCD, M6502_MN.CMP, M6502_AM.ABSr, 'CMP a', M6502_VARIANTS.STOCK); break;\r\n        case 0xCE: y = new M6502_opcode_info(0xCE, M6502_MN.DEC, M6502_AM.ABSm, 'DEC a', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0xD0: y = new M6502_opcode_info(0xD0, M6502_MN.BNE, M6502_AM.PC_REL, 'BNE r', M6502_VARIANTS.STOCK); break;\r\n        case 0xD1: y = new M6502_opcode_info(0xD1, M6502_MN.CMP, M6502_AM.IND_Yr, 'CMP (d),y', M6502_VARIANTS.STOCK); break;\r\n        case 0xD5: y = new M6502_opcode_info(0xD5, M6502_MN.CMP, M6502_AM.ZP_Xr, 'CMP d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0xD6: y = new M6502_opcode_info(0xD6, M6502_MN.DEC, M6502_AM.ZP_Xm, 'DEC d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0xD8: y = new M6502_opcode_info(0xD8, M6502_MN.CLD, M6502_AM.IMPLIED, 'CLD', M6502_VARIANTS.STOCK); break;\r\n        case 0xD9: y = new M6502_opcode_info(0xD9, M6502_MN.CMP, M6502_AM.ABS_Yr, 'CMP a,y', M6502_VARIANTS.STOCK); break;\r\n        case 0xDD: y = new M6502_opcode_info(0xDD, M6502_MN.CMP, M6502_AM.ABS_Xr, 'CMP a,x', M6502_VARIANTS.STOCK); break;\r\n        case 0xDE: y = new M6502_opcode_info(0xDE, M6502_MN.DEC, M6502_AM.ABS_Xm, 'DEC a,x', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0xE0: y = new M6502_opcode_info(0xE0, M6502_MN.CPX, M6502_AM.IMM, 'CPX #', M6502_VARIANTS.STOCK); break;\r\n        case 0xE1: y = new M6502_opcode_info(0xE1, M6502_MN.SBC, M6502_AM.X_INDr, 'SBC (d,x)', M6502_VARIANTS.STOCK); break;\r\n        case 0xE4: y = new M6502_opcode_info(0xE4, M6502_MN.CPX, M6502_AM.ZPr, 'CPX d', M6502_VARIANTS.STOCK); break;\r\n        case 0xE5: y = new M6502_opcode_info(0xE5, M6502_MN.SBC, M6502_AM.ZPr, 'SBC d', M6502_VARIANTS.STOCK); break;\r\n        case 0xE6: y = new M6502_opcode_info(0xE6, M6502_MN.INC, M6502_AM.ZPm, 'INC d', M6502_VARIANTS.STOCK); break;\r\n        case 0xE8: y = new M6502_opcode_info(0xE8, M6502_MN.INX, M6502_AM.IMPLIED, 'INX', M6502_VARIANTS.STOCK); break;\r\n        case 0xE9: y = new M6502_opcode_info(0xE9, M6502_MN.SBC, M6502_AM.IMM, 'SBC #', M6502_VARIANTS.STOCK); break;\r\n        case 0xEA: y = new M6502_opcode_info(0xEA, M6502_MN.NOP, M6502_AM.IMPLIED, 'NOP', M6502_VARIANTS.STOCK); break;\r\n        case 0xEC: y = new M6502_opcode_info(0xEC, M6502_MN.CPX, M6502_AM.ABSr, 'CPX a', M6502_VARIANTS.STOCK); break;\r\n        case 0xED: y = new M6502_opcode_info(0xED, M6502_MN.SBC, M6502_AM.ABSr, 'SBC a', M6502_VARIANTS.STOCK); break;\r\n        case 0xEE: y = new M6502_opcode_info(0xEE, M6502_MN.INC, M6502_AM.ABSm, 'INC a', M6502_VARIANTS.STOCK); break;\r\n\r\n        case 0xF0: y = new M6502_opcode_info(0xF0, M6502_MN.BEQ, M6502_AM.PC_REL, 'BEQ r', M6502_VARIANTS.STOCK); break;\r\n        case 0xF1: y = new M6502_opcode_info(0xF1, M6502_MN.SBC, M6502_AM.IND_Yr, 'SBC (d),y', M6502_VARIANTS.STOCK); break;\r\n        case 0xF5: y = new M6502_opcode_info(0xF5, M6502_MN.SBC, M6502_AM.ZP_Xr, 'SBC d,x', M6502_VARIANTS.STOCK); break;\r\n        case 0xF6: y = new M6502_opcode_info(0xF6, M6502_MN.INC, M6502_AM.ZP_Xm, 'INC d,X', M6502_VARIANTS.STOCK); break;\r\n        case 0xF8: y = new M6502_opcode_info(0xF8, M6502_MN.SED, M6502_AM.IMPLIED, 'SED', M6502_VARIANTS.STOCK); break;\r\n        case 0xF9: y = new M6502_opcode_info(0xF9, M6502_MN.SBC, M6502_AM.ABS_Yr, 'SBC a,y', M6502_VARIANTS.STOCK); break;\r\n        case 0xFD: y = new M6502_opcode_info(0xFD, M6502_MN.SBC, M6502_AM.ABS_Xr, 'SBC a,x', M6502_VARIANTS.STOCK); break;\r\n        case 0xFE: y = new M6502_opcode_info(0xFE, M6502_MN.INC, M6502_AM.ABS_Xm, 'INC a,x', M6502_VARIANTS.STOCK); break;\r\n        case M6502_OP_RESET: y = new M6502_opcode_info(M6502_OP_RESET, M6502_MN.S_RESET, M6502_AM.IMPLIED, 'RESET', M6502_VARIANTS.STOCK); break;\r\n        case M6502_OP_NMI: y = new M6502_opcode_info(M6502_OP_NMI, M6502_MN.S_NMI, M6502_AM.IMPLIED, 'NMI', M6502_VARIANTS.STOCK); break;\r\n        case M6502_OP_IRQ: y = new M6502_opcode_info(M6502_OP_IRQ, M6502_MN.S_IRQ, M6502_AM.IMPLIED, 'IRQ', M6502_VARIANTS.STOCK); break;\r\n        default:\r\n            y = new M6502_opcode_info(i, M6502_MN.NONE, M6502_AM.NONE, 'NONE', M6502_VARIANTS.STOCK);\r\n            break;\r\n    }\r\n    return y;\r\n}\r\n\r\nfor (let i = 0; i <= M6502_MAX_OPCODE; i++) {\r\n    M6502_stock_matrix.set(i, M6502_get_stock_matrix_item(i));\r\n}\r\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  let uv  = reinterpret<u64>(value);\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  let sid = uv & 0x000FFFFFFFFFFFFF;\n  let frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  let len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  let h: u32 = key.length << 1;\n  let len: usize = h;\n  let pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  let end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    let entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) != null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    let hashCode = HASH<K>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let keys = new Array<K>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(keys[length++] = entry.key);\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<V>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.value);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","export enum D_RESOURCE_TYPES {\r\n    none,\r\n    R5A22,\r\n    SPC700,\r\n    WDC65C816,\r\n    SNESPPU,\r\n    M6502,\r\n    Z80,\r\n    SM83\r\n}\r\n\r\nclass debugger_t {\r\n    do_break: bool = false\r\n    brk_on_NMIRQ: bool = false\r\n    watch_on: bool = false\r\n\r\n    break(who: D_RESOURCE_TYPES = D_RESOURCE_TYPES.none): void {\r\n        console.log('DOING BREAK');\r\n        this.do_break = true;\r\n    }\r\n}\r\n\r\nexport const dbg = new debugger_t();","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","import {M6502_opcode_functions, M6502_stock_matrix, M6502_invalid_matrix, M6502_MAX_OPCODE} from \"../../../component/cpu/m6502/m6502_opcodes\";\r\nimport {m6502_pins, m6502_regs} from \"../../../component/cpu/m6502/m6502\";\r\nimport {mksigned8} from \"../../../helpers/helpers\"\r\n\r\nexport var nesm6502_opcodes_decoded: Array<M6502_opcode_functions> = new Array<M6502_opcode_functions>(M6502_MAX_OPCODE+1);\r\n\r\nfunction nesm6502_get_opcode_function(opcode: u32): M6502_opcode_functions {\r\n    switch(opcode) {\r\n        case 0x00: return new M6502_opcode_functions(M6502_stock_matrix.get(0x00),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BRK\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.P.B = 1;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        regs.TR = regs.PC\r\n                        pins.D = (regs.TR >>> 8) & 0xFF;\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        pins.D = regs.TR & 0xFF;\r\n                        break;\r\n                    case 4:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        pins.D = regs.P.getbyte();\r\n                        break;\r\n                    case 5:\r\n                        regs.P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK\r\n                        regs.P.I = 1;\r\n                        pins.RW = 0;\r\n                        pins.Addr = (0xFFFE);\r\n                        break;\r\n                    case 6:\r\n                        regs.PC = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFFFF;\r\n                        break;\r\n                    case 7: // cleanup_custom\r\n                        regs.PC |= (pins.D << 8);\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x01: return new M6502_opcode_functions(M6502_stock_matrix.get(0x01),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ORA (d,x)\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        break;\r\n                    case 3: // real read ABS L\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // read ABS H\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 5: // Read from addr\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.A |= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x02: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x02),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x03: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x03),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x04: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x04),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x05: return new M6502_opcode_functions(M6502_stock_matrix.get(0x05),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ORA d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        regs.A |= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x06: return new M6502_opcode_functions(M6502_stock_matrix.get(0x06),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ASL d\r\n                switch(regs.TCU) {\r\n                    case 1: // fetch ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // capture data\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // spurious read/write\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 4: // real write\r\n                        regs.P.C = (pins.D & 0x80) >>> 7;\r\n                        pins.D = (pins.D << 1) & 0xFF;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 5: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x07: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x07),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x08: return new M6502_opcode_functions(M6502_stock_matrix.get(0x08),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //PHP\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        pins.D = regs.P.getbyte() | 0x30;\r\n                        pins.RW = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 3: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x09: return new M6502_opcode_functions(M6502_stock_matrix.get(0x09),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ORA #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        regs.A |= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x0A: return new M6502_opcode_functions(M6502_stock_matrix.get(0x0A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ASL A\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.P.C = (regs.A & 0x80) >>> 7;\r\n                        regs.A = (regs.A << 1) & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x0B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x0B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x0C: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x0C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x0D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x0D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ORA a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.A |= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x0E: return new M6502_opcode_functions(M6502_stock_matrix.get(0x0E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ASL a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4:\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 5:\r\n                        regs.P.C = (pins.D & 0x80) >>> 7;\r\n                        pins.D = (pins.D << 1) & 0xFF;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x0F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x0F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x10: return new M6502_opcode_functions(M6502_stock_matrix.get(0x10),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BPL r\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.TR = +(regs.P.N == 0);\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = (regs.PC + mksigned8(pins.D)) & 0xFFFF;\r\n                        pins.Addr = regs.PC;\r\n                        if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page\r\n                        break;\r\n                    case 3: // extra idle on page cross\r\n                        pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.PC = regs.TA;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x11: return new M6502_opcode_functions(M6502_stock_matrix.get(0x11),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ORA (d),y\r\n                switch(regs.TCU) {\r\n                    case 1: // Get ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABS L\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // get ABS H\r\n                        regs.TR = pins.D;\r\n                        regs.TA = pins.D + regs.Y;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 4: // idle if crossed\r\n                        regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;\r\n                        regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;\r\n                        if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 5:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.A |= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x12: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x12),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x13: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x13),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x14: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x14),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x15: return new M6502_opcode_functions(M6502_stock_matrix.get(0x15),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ORA d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.A |= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x16: return new M6502_opcode_functions(M6502_stock_matrix.get(0x16),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ASL d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        regs.P.C = (regs.TR & 0x80) >>> 7;\r\n                        regs.TR = (regs.TR << 1) & 0xFF;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        break;\r\n                    case 5:\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x17: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x17),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x18: return new M6502_opcode_functions(M6502_stock_matrix.get(0x18),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CLC i\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.P.C = 0;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x19: return new M6502_opcode_functions(M6502_stock_matrix.get(0x19),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ORA a,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.Y) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.A |= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x1A: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x1A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x1B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x1B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x1C: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x1C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x1D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x1D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ORA a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.X) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.A |= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x1E: return new M6502_opcode_functions(M6502_stock_matrix.get(0x1E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ASL a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3: // spurious read\r\n                        regs.TA |= pins.D << 8;\r\n                        pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);\r\n                        break;\r\n                    case 4: // real read\r\n                        pins.Addr = (regs.TA + regs.X) & 0xFFFF;\r\n                        break;\r\n                    case 5: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 6:\r\n                        regs.P.C = (regs.TR & 0x80) >>> 7;\r\n                        regs.TR = (regs.TR << 1) & 0xFF;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 7: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x1F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x1F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x20: return new M6502_opcode_functions(M6502_stock_matrix.get(0x20),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //JSR a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious stack read\r\n                        regs.TA = pins.D;\r\n                        regs.TR = regs.PC;\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        break;\r\n                    case 3: // stack write PCH\r\n                        pins.RW = 1;\r\n                        pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                        break;\r\n                    case 4: // stack write PCL\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        pins.D = regs.PC & 0xFF;\r\n                        break;\r\n                    case 5:\r\n                        pins.Addr = regs.TR;\r\n                        pins.RW = 0;\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.PC = regs.TA | (pins.D << 8);\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x21: return new M6502_opcode_functions(M6502_stock_matrix.get(0x21),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //AND (d,x)\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        break;\r\n                    case 3: // real read ABS L\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // read ABS H\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 5: // Read from addr\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.A &= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x22: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x22),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x23: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x23),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x24: return new M6502_opcode_functions(M6502_stock_matrix.get(0x24),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BIT d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        regs.P.Z = +((regs.A & pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        regs.P.V = (pins.D & 0x40) >>> 6;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x25: return new M6502_opcode_functions(M6502_stock_matrix.get(0x25),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //AND d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        regs.A &= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x26: return new M6502_opcode_functions(M6502_stock_matrix.get(0x26),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROL d\r\n                switch(regs.TCU) {\r\n                    case 1: // fetch ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // capture data\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // spurious read/write\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 4: // real write\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = (pins.D & 0x80) >>> 7;\r\n                        pins.D = ((pins.D << 1) | c) & 0xFF;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 5: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x27: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x27),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x28: return new M6502_opcode_functions(M6502_stock_matrix.get(0x28),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //PLP\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        break;\r\n                    case 2: // spurious stack read\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S + 1) & 0xFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.P.setbyte(pins.D);\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x29: return new M6502_opcode_functions(M6502_stock_matrix.get(0x29),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //AND #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        regs.A &= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x2A: return new M6502_opcode_functions(M6502_stock_matrix.get(0x2A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROL A\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = (regs.A & 0x80) >>> 7;\r\n                        regs.A = ((regs.A << 1) | c) & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x2B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x2B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x2C: return new M6502_opcode_functions(M6502_stock_matrix.get(0x2C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BIT a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.P.Z = +((regs.A & pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        regs.P.V = (pins.D & 0x40) >>> 6;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x2D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x2D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //AND a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.A &= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x2E: return new M6502_opcode_functions(M6502_stock_matrix.get(0x2E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROL a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4:\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 5:\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = (pins.D & 0x80) >>> 7;\r\n                        pins.D = ((pins.D << 1) | c) & 0xFF;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x2F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x2F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x30: return new M6502_opcode_functions(M6502_stock_matrix.get(0x30),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BMI r\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.TR = +(regs.P.N == 1);\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = (regs.PC + mksigned8(pins.D)) & 0xFFFF;\r\n                        pins.Addr = regs.PC;\r\n                        if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page\r\n                        break;\r\n                    case 3: // extra idle on page cross\r\n                        pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.PC = regs.TA;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x31: return new M6502_opcode_functions(M6502_stock_matrix.get(0x31),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //AND (d),x\r\n                switch(regs.TCU) {\r\n                    case 1: // Get ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABS L\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // get ABS H\r\n                        regs.TR = pins.D;\r\n                        regs.TA = pins.D + regs.Y;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 4: // idle if crossed\r\n                        regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;\r\n                        regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;\r\n                        if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 5:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.A &= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x32: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x32),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x33: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x33),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x34: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x34),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x35: return new M6502_opcode_functions(M6502_stock_matrix.get(0x35),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //AND d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.A &= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x36: return new M6502_opcode_functions(M6502_stock_matrix.get(0x36),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROL d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = (regs.TR & 0x80) >>> 7;\r\n                        regs.TR = ((regs.TR << 1) | c) & 0xFF;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        break;\r\n                    case 5:\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x37: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x37),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x38: return new M6502_opcode_functions(M6502_stock_matrix.get(0x38),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SEC\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.P.C = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x39: return new M6502_opcode_functions(M6502_stock_matrix.get(0x39),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //AND a,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.Y) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.A &= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x3A: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x3A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x3B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x3B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x3C: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x3C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x3D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x3D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //AND a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.X) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.A &= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x3E: return new M6502_opcode_functions(M6502_stock_matrix.get(0x3E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROL a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3: // spurious read\r\n                        regs.TA |= pins.D << 8;\r\n                        pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);\r\n                        break;\r\n                    case 4: // real read\r\n                        pins.Addr = (regs.TA + regs.X) & 0xFFFF;\r\n                        break;\r\n                    case 5: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 6:\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = (regs.TR & 0x80) >>> 7;\r\n                        regs.TR = ((regs.TR << 1) | c) & 0xFF;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 7: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x3F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x3F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x40: return new M6502_opcode_functions(M6502_stock_matrix.get(0x40),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //RTI\r\n                switch(regs.TCU) {\r\n                    case 1: // spurious read\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious stack read\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 3: // Read P\r\n                        regs.S = (regs.S + 1) & 0xFF;\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 4: // Read PCL\r\n                        regs.P.setbyte(pins.D);\r\n                        regs.S = (regs.S + 1) & 0xFF;\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 5: // read PCH\r\n                        regs.PC = pins.D;\r\n                        regs.S = (regs.S + 1) & 0xFF;\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.PC |= (pins.D << 8);\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x41: return new M6502_opcode_functions(M6502_stock_matrix.get(0x41),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //EOR (d,x)\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        break;\r\n                    case 3: // real read ABS L\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // read ABS H\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 5: // Read from addr\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.A ^= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x42: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x42),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x43: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x43),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x44: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x44),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x45: return new M6502_opcode_functions(M6502_stock_matrix.get(0x45),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //EOR d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        regs.A ^= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x46: return new M6502_opcode_functions(M6502_stock_matrix.get(0x46),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LSR d\r\n                switch(regs.TCU) {\r\n                    case 1: // fetch ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // capture data\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // spurious read/write\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 4: // real write\r\n                        regs.P.C = pins.D & 1;\r\n                        pins.D >>>= 1;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = 0;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 5: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x47: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x47),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x48: return new M6502_opcode_functions(M6502_stock_matrix.get(0x48),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //PHA\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        pins.D = regs.A\r\n                        pins.RW = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 3: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x49: return new M6502_opcode_functions(M6502_stock_matrix.get(0x49),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //EOR #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        regs.A ^= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x4A: return new M6502_opcode_functions(M6502_stock_matrix.get(0x4A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LSR A\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.P.C = regs.A & 1;\r\n                        regs.A >>>= 1;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = 0;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x4B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x4B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x4C: return new M6502_opcode_functions(M6502_stock_matrix.get(0x4C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //JMP a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        regs.PC = regs.TA | (pins.D << 8);\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x4D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x4D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //EOR a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.A ^= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x4E: return new M6502_opcode_functions(M6502_stock_matrix.get(0x4E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LSR a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4:\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 5:\r\n                        regs.P.C = pins.D & 1;\r\n                        pins.D >>>= 1;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = 0;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x4F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x4F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x50: return new M6502_opcode_functions(M6502_stock_matrix.get(0x50),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BVC r\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.TR = +(regs.P.V == 0);\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = (regs.PC + mksigned8(pins.D)) & 0xFFFF;\r\n                        pins.Addr = regs.PC;\r\n                        if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page\r\n                        break;\r\n                    case 3: // extra idle on page cross\r\n                        pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.PC = regs.TA;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x51: return new M6502_opcode_functions(M6502_stock_matrix.get(0x51),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //EOR (d),y\r\n                switch(regs.TCU) {\r\n                    case 1: // Get ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABS L\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // get ABS H\r\n                        regs.TR = pins.D;\r\n                        regs.TA = pins.D + regs.Y;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 4: // idle if crossed\r\n                        regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;\r\n                        regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;\r\n                        if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 5:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.A ^= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x52: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x52),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x53: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x53),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x54: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x54),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x55: return new M6502_opcode_functions(M6502_stock_matrix.get(0x55),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //EOR d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.A ^= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x56: return new M6502_opcode_functions(M6502_stock_matrix.get(0x56),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LSR d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        regs.P.C = regs.TR & 1;\r\n                        regs.TR >>>= 1;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = 0;\r\n                        break;\r\n                    case 5:\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x57: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x57),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x58: return new M6502_opcode_functions(M6502_stock_matrix.get(0x58),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CLI\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.P.I = 0;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x59: return new M6502_opcode_functions(M6502_stock_matrix.get(0x59),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //EOR a,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.Y) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.A ^= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x5A: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x5A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x5B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x5B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x5C: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x5C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x5D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x5D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //EOR a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.X) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.A ^= pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x5E: return new M6502_opcode_functions(M6502_stock_matrix.get(0x5E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LSR a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3: // spurious read\r\n                        regs.TA |= pins.D << 8;\r\n                        pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);\r\n                        break;\r\n                    case 4: // real read\r\n                        pins.Addr = (regs.TA + regs.X) & 0xFFFF;\r\n                        break;\r\n                    case 5: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 6:\r\n                        regs.P.C = regs.TR & 1;\r\n                        regs.TR >>>= 1;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = 0;\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 7: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x5F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x5F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x60: return new M6502_opcode_functions(M6502_stock_matrix.get(0x60),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //RTS\r\n                switch(regs.TCU) {\r\n                    case 1: // spurious read\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious stack read\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 3: // read PCL\r\n                        regs.S = (regs.S + 1) & 0xFF;\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 4: // read PCH\r\n                        regs.PC = pins.D;\r\n                        regs.S = (regs.S + 1) & 0xFF;\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 5: // spurious read\r\n                        regs.PC |= (pins.D << 8);\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x61: return new M6502_opcode_functions(M6502_stock_matrix.get(0x61),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ADC (d,x)\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        break;\r\n                    case 3: // real read ABS L\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // read ABS H\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 5: // Read from addr\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D;\r\n                        o = i + regs.A + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x62: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x62),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x63: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x63),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x64: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x64),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x65: return new M6502_opcode_functions(M6502_stock_matrix.get(0x65),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ADC d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D;\r\n                        o = i + regs.A + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x66: return new M6502_opcode_functions(M6502_stock_matrix.get(0x66),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROR d\r\n                switch(regs.TCU) {\r\n                    case 1: // fetch ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // capture data\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // spurious read/write\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 4: // real write\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = pins.D & 1;\r\n                        pins.D = (c << 7) | (pins.D >>> 1);\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 5: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x67: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x67),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x68: return new M6502_opcode_functions(M6502_stock_matrix.get(0x68),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //PLA\r\n                switch(regs.TCU) {\r\n                    case 1: // spurious read\r\n                        pins.Addr = regs.PC;\r\n                        break;\r\n                    case 2: // spurious stack read\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 3: // good stack read\r\n                        regs.S = (regs.S + 1) & 0xFF;\r\n                        pins.Addr = regs.S | 0x100;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.A = pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x69: return new M6502_opcode_functions(M6502_stock_matrix.get(0x69),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ADC #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D;\r\n                        o = i + regs.A + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x6A: return new M6502_opcode_functions(M6502_stock_matrix.get(0x6A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROR A\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = regs.A & 1;\r\n                        regs.A = (c << 7) | (regs.A >>> 1);\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x6B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x6B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x6C: return new M6502_opcode_functions(M6502_stock_matrix.get(0x6C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //JMP (d)\r\n                switch(regs.TCU) {\r\n                    case 1: // read ABSL\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // read ABSH\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TA = pins.D\r\n                        break;\r\n                    case 3: // read PCL\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // read PCH\r\n                        regs.PC = pins.D;\r\n                        pins.Addr = (pins.Addr & 0xFF00) | ((pins.Addr + 1) & 0xFF);\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.PC |= pins.D << 8;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x6D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x6D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ADC a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D;\r\n                        o = i + regs.A + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x6E: return new M6502_opcode_functions(M6502_stock_matrix.get(0x6E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROR a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4:\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 5:\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = pins.D & 1;\r\n                        pins.D = (c << 7) | (pins.D >>> 1);\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x6F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x6F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x70: return new M6502_opcode_functions(M6502_stock_matrix.get(0x70),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BVS r\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.TR = +(regs.P.V == 1);\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = (regs.PC + mksigned8(pins.D)) & 0xFFFF;\r\n                        pins.Addr = regs.PC;\r\n                        if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page\r\n                        break;\r\n                    case 3: // extra idle on page cross\r\n                        pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.PC = regs.TA;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x71: return new M6502_opcode_functions(M6502_stock_matrix.get(0x71),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ADC (d),y\r\n                switch(regs.TCU) {\r\n                    case 1: // Get ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABS L\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // get ABS H\r\n                        regs.TR = pins.D;\r\n                        regs.TA = pins.D + regs.Y;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 4: // idle if crossed\r\n                        regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;\r\n                        regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;\r\n                        if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 5:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D;\r\n                        o = i + regs.A + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x72: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x72),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x73: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x73),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x74: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x74),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x75: return new M6502_opcode_functions(M6502_stock_matrix.get(0x75),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ADC d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D;\r\n                        o = i + regs.A + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x76: return new M6502_opcode_functions(M6502_stock_matrix.get(0x76),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROR d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = regs.TR & 1;\r\n                        regs.TR = (c << 7) | (regs.TR >>> 1);\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        break;\r\n                    case 5:\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x77: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x77),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x78: return new M6502_opcode_functions(M6502_stock_matrix.get(0x78),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SEI\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.P.I = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x79: return new M6502_opcode_functions(M6502_stock_matrix.get(0x79),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ADC a,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.Y) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D;\r\n                        o = i + regs.A + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x7A: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x7A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x7B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x7B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x7C: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x7C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x7D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x7D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ADC a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.X) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D;\r\n                        o = i + regs.A + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x7E: return new M6502_opcode_functions(M6502_stock_matrix.get(0x7E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //ROR a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3: // spurious read\r\n                        regs.TA |= pins.D << 8;\r\n                        pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);\r\n                        break;\r\n                    case 4: // real read\r\n                        pins.Addr = (regs.TA + regs.X) & 0xFFFF;\r\n                        break;\r\n                    case 5: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 6:\r\n                        let c: u32 = regs.P.C;\r\n                        regs.P.C = regs.TR & 1;\r\n                        regs.TR = (c << 7) | (regs.TR >>> 1);\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 7: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x7F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x7F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x80: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x80),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x81: return new M6502_opcode_functions(M6502_stock_matrix.get(0x81),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STA (d,x)\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        break;\r\n                    case 3: // real read ABS L\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // read ABS H\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 5: // Write result to addr\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        pins.D = regs.A;\r\n                        pins.RW = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x82: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x82),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x83: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x83),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x84: return new M6502_opcode_functions(M6502_stock_matrix.get(0x84),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STY d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        pins.D = regs.Y;\r\n                        pins.RW = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 3: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x85: return new M6502_opcode_functions(M6502_stock_matrix.get(0x85),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STA d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        pins.D = regs.A;\r\n                        pins.RW = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 3: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x86: return new M6502_opcode_functions(M6502_stock_matrix.get(0x86),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STX d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        pins.D = regs.X;\r\n                        pins.RW = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 3: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x87: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x87),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x88: return new M6502_opcode_functions(M6502_stock_matrix.get(0x88),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //DEY\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.Y = (regs.Y - 1) & 0xFF;\r\n                        regs.P.Z = +((regs.Y) == 0);\r\n                        regs.P.N = ((regs.Y) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x89: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x89),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x8A: return new M6502_opcode_functions(M6502_stock_matrix.get(0x8A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //TXA\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.A = regs.X;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x8B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x8B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x8C: return new M6502_opcode_functions(M6502_stock_matrix.get(0x8C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STY a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        pins.D = regs.Y;\r\n                        pins.RW = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 4: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x8D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x8D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STA a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        pins.D = regs.A;\r\n                        pins.RW = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 4: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x8E: return new M6502_opcode_functions(M6502_stock_matrix.get(0x8E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STX a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        pins.D = regs.X;\r\n                        pins.RW = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 4: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x8F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x8F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x90: return new M6502_opcode_functions(M6502_stock_matrix.get(0x90),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BCC\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.TR = +(regs.P.C == 0);\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = (regs.PC + mksigned8(pins.D)) & 0xFFFF;\r\n                        pins.Addr = regs.PC;\r\n                        if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page\r\n                        break;\r\n                    case 3: // extra idle on page cross\r\n                        pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.PC = regs.TA;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x91: return new M6502_opcode_functions(M6502_stock_matrix.get(0x91),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STA (d),y\r\n                switch(regs.TCU) {\r\n                    case 1: // get ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABS L\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // get ABS H\r\n                        regs.TA = pins.D + regs.Y;\r\n                        regs.TR = (pins.D + regs.Y) & 0xFF;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 4: // always idle\r\n                        regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;\r\n                        pins.Addr = (pins.D << 8) | regs.TR;\r\n                        break;\r\n                    case 5: // write data\r\n                        pins.Addr = regs.TA;\r\n                        pins.RW = 1;\r\n                        pins.D = regs.A;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x92: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x92),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x93: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x93),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x94: return new M6502_opcode_functions(M6502_stock_matrix.get(0x94),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STY d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // write data\r\n                        pins.Addr = (pins.Addr + regs.X) & 0xFF;\r\n                        pins.RW = 1;\r\n                        pins.D = regs.Y;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 4: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x95: return new M6502_opcode_functions(M6502_stock_matrix.get(0x95),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STA d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // write data\r\n                        pins.Addr = (pins.Addr + regs.X) & 0xFF;\r\n                        pins.RW = 1;\r\n                        pins.D = regs.A;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 4: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x96: return new M6502_opcode_functions(M6502_stock_matrix.get(0x96),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STX d,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // write data\r\n                        pins.Addr = (pins.Addr + regs.Y) & 0xFF;\r\n                        pins.RW = 1;\r\n                        pins.D = regs.X;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 4: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x97: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x97),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x98: return new M6502_opcode_functions(M6502_stock_matrix.get(0x98),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //TYA\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.A = regs.Y;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x99: return new M6502_opcode_functions(M6502_stock_matrix.get(0x99),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STA a,y\r\n                switch(regs.TCU) {\r\n                    case 1: // get ABSL\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABSH\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3: // idle incorrect\r\n                        regs.TA |= pins.D << 8;\r\n                        pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);\r\n                        break;\r\n                    case 4:\r\n                        pins.Addr = (regs.TA + regs.Y) & 0xFFFF;\r\n                        pins.RW = 1;\r\n                        pins.D = regs.A;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 5: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x9A: return new M6502_opcode_functions(M6502_stock_matrix.get(0x9A),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //TXS\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.S = regs.X;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x9B: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x9B),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x9C: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x9C),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x9D: return new M6502_opcode_functions(M6502_stock_matrix.get(0x9D),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //STA a,x\r\n                switch(regs.TCU) {\r\n                    case 1: // get ABSL\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABSH\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3: // idle incorrect\r\n                        regs.TA |= pins.D << 8;\r\n                        pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);\r\n                        break;\r\n                    case 4:\r\n                        pins.Addr = (regs.TA + regs.X) & 0xFFFF;\r\n                        pins.RW = 1;\r\n                        pins.D = regs.A;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 5: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x9E: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x9E),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x9F: return new M6502_opcode_functions(M6502_invalid_matrix.get(0x9F),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xA0: return new M6502_opcode_functions(M6502_stock_matrix.get(0xA0),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDY #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        regs.Y = pins.D;\r\n                        regs.P.Z = +((regs.Y) == 0);\r\n                        regs.P.N = ((regs.Y) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xA1: return new M6502_opcode_functions(M6502_stock_matrix.get(0xA1),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDA (d,x)\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        break;\r\n                    case 3: // real read ABS L\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // read ABS H\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 5: // Read from addr\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.A = pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xA2: return new M6502_opcode_functions(M6502_stock_matrix.get(0xA2),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDX #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        regs.X = pins.D;\r\n                        regs.P.Z = +((regs.X) == 0);\r\n                        regs.P.N = ((regs.X) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xA3: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xA3),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xA4: return new M6502_opcode_functions(M6502_stock_matrix.get(0xA4),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDY d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        regs.Y = pins.D;\r\n                        regs.P.Z = +((regs.Y) == 0);\r\n                        regs.P.N = ((regs.Y) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xA5: return new M6502_opcode_functions(M6502_stock_matrix.get(0xA5),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDA d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        regs.A = pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xA6: return new M6502_opcode_functions(M6502_stock_matrix.get(0xA6),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDX d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        regs.X = pins.D;\r\n                        regs.P.Z = +((regs.X) == 0);\r\n                        regs.P.N = ((regs.X) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xA7: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xA7),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xA8: return new M6502_opcode_functions(M6502_stock_matrix.get(0xA8),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //TAY\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.Y = regs.A;\r\n                        regs.P.Z = +((regs.Y) == 0);\r\n                        regs.P.N = ((regs.Y) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xA9: return new M6502_opcode_functions(M6502_stock_matrix.get(0xA9),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDA #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        regs.A = pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xAA: return new M6502_opcode_functions(M6502_stock_matrix.get(0xAA),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //TAX\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.X = regs.A;\r\n                        regs.P.Z = +((regs.X) == 0);\r\n                        regs.P.N = ((regs.X) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xAB: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xAB),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xAC: return new M6502_opcode_functions(M6502_stock_matrix.get(0xAC),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDY a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.Y = pins.D;\r\n                        regs.P.Z = +((regs.Y) == 0);\r\n                        regs.P.N = ((regs.Y) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xAD: return new M6502_opcode_functions(M6502_stock_matrix.get(0xAD),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDA a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.A = pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xAE: return new M6502_opcode_functions(M6502_stock_matrix.get(0xAE),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDX a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.X = pins.D;\r\n                        regs.P.Z = +((regs.X) == 0);\r\n                        regs.P.N = ((regs.X) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xAF: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xAF),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xB0: return new M6502_opcode_functions(M6502_stock_matrix.get(0xB0),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BCS r\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.TR = +(regs.P.C == 1);\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = (regs.PC + mksigned8(pins.D)) & 0xFFFF;\r\n                        pins.Addr = regs.PC;\r\n                        if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page\r\n                        break;\r\n                    case 3: // extra idle on page cross\r\n                        pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.PC = regs.TA;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xB1: return new M6502_opcode_functions(M6502_stock_matrix.get(0xB1),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDA (d),y\r\n                switch(regs.TCU) {\r\n                    case 1: // Get ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABS L\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // get ABS H\r\n                        regs.TR = pins.D;\r\n                        regs.TA = pins.D + regs.Y;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 4: // idle if crossed\r\n                        regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;\r\n                        regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;\r\n                        if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 5:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        regs.A = pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xB2: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xB2),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xB3: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xB3),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xB4: return new M6502_opcode_functions(M6502_stock_matrix.get(0xB4),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDY d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.Y = pins.D;\r\n                        regs.P.Z = +((regs.Y) == 0);\r\n                        regs.P.N = ((regs.Y) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xB5: return new M6502_opcode_functions(M6502_stock_matrix.get(0xB5),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDA d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.A = pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xB6: return new M6502_opcode_functions(M6502_stock_matrix.get(0xB6),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDX d,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.Y) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.X = pins.D;\r\n                        regs.P.Z = +((regs.X) == 0);\r\n                        regs.P.N = ((regs.X) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xB7: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xB7),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xB8: return new M6502_opcode_functions(M6502_stock_matrix.get(0xB8),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CLV\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.P.V = 0;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xB9: return new M6502_opcode_functions(M6502_stock_matrix.get(0xB9),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDA a,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.Y) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.A = pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xBA: return new M6502_opcode_functions(M6502_stock_matrix.get(0xBA),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //TSX\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.X = regs.S;\r\n                        regs.P.Z = +((regs.X) == 0);\r\n                        regs.P.N = ((regs.X) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xBB: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xBB),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xBC: return new M6502_opcode_functions(M6502_stock_matrix.get(0xBC),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDY a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.X) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.Y = pins.D;\r\n                        regs.P.Z = +((regs.Y) == 0);\r\n                        regs.P.N = ((regs.Y) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xBD: return new M6502_opcode_functions(M6502_stock_matrix.get(0xBD),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDA a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.X) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.A = pins.D;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xBE: return new M6502_opcode_functions(M6502_stock_matrix.get(0xBE),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //LDX a,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.Y) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        regs.X = pins.D;\r\n                        regs.P.Z = +((regs.X) == 0);\r\n                        regs.P.N = ((regs.X) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xBF: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xBF),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xC0: return new M6502_opcode_functions(M6502_stock_matrix.get(0xC0),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CPY #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        let o: i32 = regs.Y - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xC1: return new M6502_opcode_functions(M6502_stock_matrix.get(0xC1),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CMP (d,x)\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        break;\r\n                    case 3: // real read ABS L\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // read ABS H\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 5: // Read from addr\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        let o: i32 = regs.A - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xC2: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xC2),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xC3: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xC3),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xC4: return new M6502_opcode_functions(M6502_stock_matrix.get(0xC4),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CPY d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        let o: i32 = regs.Y - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xC5: return new M6502_opcode_functions(M6502_stock_matrix.get(0xC5),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CMP d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        let o: i32 = regs.A - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xC6: return new M6502_opcode_functions(M6502_stock_matrix.get(0xC6),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //DEC d\r\n                switch(regs.TCU) {\r\n                    case 1: // fetch ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // capture data\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // spurious read/write\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 4: // real write\r\n                        pins.D = (pins.D - 1) & 0xFF;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 5: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xC7: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xC7),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xC8: return new M6502_opcode_functions(M6502_stock_matrix.get(0xC8),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //INY\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.Y = (regs.Y + 1) & 0xFF;\r\n                        regs.P.Z = +((regs.Y) == 0);\r\n                        regs.P.N = ((regs.Y) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xC9: return new M6502_opcode_functions(M6502_stock_matrix.get(0xC9),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CMP #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        let o: i32 = regs.A - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xCA: return new M6502_opcode_functions(M6502_stock_matrix.get(0xCA),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //DEX\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.X = (regs.X - 1) & 0xFF;\r\n                        regs.P.Z = +((regs.X) == 0);\r\n                        regs.P.N = ((regs.X) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xCB: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xCB),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xCC: return new M6502_opcode_functions(M6502_stock_matrix.get(0xCC),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CPY a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        let o: i32 = regs.Y - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xCD: return new M6502_opcode_functions(M6502_stock_matrix.get(0xCD),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CMP a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        let o: i32 = regs.A - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xCE: return new M6502_opcode_functions(M6502_stock_matrix.get(0xCE),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //DEC a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4:\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 5:\r\n                        pins.D = (pins.D - 1) & 0xFF;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xCF: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xCF),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xD0: return new M6502_opcode_functions(M6502_stock_matrix.get(0xD0),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BNE r\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.TR = +(regs.P.Z == 0);\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = (regs.PC + mksigned8(pins.D)) & 0xFFFF;\r\n                        pins.Addr = regs.PC;\r\n                        if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page\r\n                        break;\r\n                    case 3: // extra idle on page cross\r\n                        pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.PC = regs.TA;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xD1: return new M6502_opcode_functions(M6502_stock_matrix.get(0xD1),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CMP (d),y\r\n                switch(regs.TCU) {\r\n                    case 1: // Get ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABS L\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // get ABS H\r\n                        regs.TR = pins.D;\r\n                        regs.TA = pins.D + regs.Y;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 4: // idle if crossed\r\n                        regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;\r\n                        regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;\r\n                        if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 5:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        let o: i32 = regs.A - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xD2: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xD2),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xD3: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xD3),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xD4: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xD4),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xD5: return new M6502_opcode_functions(M6502_stock_matrix.get(0xD5),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CMP d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        let o: i32 = regs.A - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xD6: return new M6502_opcode_functions(M6502_stock_matrix.get(0xD6),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //DEC d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        regs.TR = (regs.TR - 1) & 0xFF;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        break;\r\n                    case 5:\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xD7: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xD7),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xD8: return new M6502_opcode_functions(M6502_stock_matrix.get(0xD8),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CLD\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.P.D = 0;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xD9: return new M6502_opcode_functions(M6502_stock_matrix.get(0xD9),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CMP a,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.Y) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        let o: i32 = regs.A - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xDA: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xDA),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xDB: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xDB),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xDC: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xDC),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xDD: return new M6502_opcode_functions(M6502_stock_matrix.get(0xDD),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CMP a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.X) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        let o: i32 = regs.A - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xDE: return new M6502_opcode_functions(M6502_stock_matrix.get(0xDE),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //DEC a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3: // spurious read\r\n                        regs.TA |= pins.D << 8;\r\n                        pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);\r\n                        break;\r\n                    case 4: // real read\r\n                        pins.Addr = (regs.TA + regs.X) & 0xFFFF;\r\n                        break;\r\n                    case 5: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 6:\r\n                        regs.TR = (regs.TR - 1) & 0xFF;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 7: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xDF: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xDF),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xE0: return new M6502_opcode_functions(M6502_stock_matrix.get(0xE0),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CPX #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        let o: i32 = regs.X - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xE1: return new M6502_opcode_functions(M6502_stock_matrix.get(0xE1),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SBC (d,x)\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        pins.Addr = pins.D;\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        break;\r\n                    case 3: // real read ABS L\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // read ABS H\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 5: // Read from addr\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D ^ 0xFF;\r\n                        o = regs.A + i + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xE2: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xE2),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xE3: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xE3),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xE4: return new M6502_opcode_functions(M6502_stock_matrix.get(0xE4),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CPX d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        let o: i32 = regs.X - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xE5: return new M6502_opcode_functions(M6502_stock_matrix.get(0xE5),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SBC d\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D ^ 0xFF;\r\n                        o = regs.A + i + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xE6: return new M6502_opcode_functions(M6502_stock_matrix.get(0xE6),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //INC d\r\n                switch(regs.TCU) {\r\n                    case 1: // fetch ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // capture data\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // spurious read/write\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 4: // real write\r\n                        pins.D = (pins.D + 1) & 0xFF;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 5: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xE7: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xE7),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xE8: return new M6502_opcode_functions(M6502_stock_matrix.get(0xE8),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //INX\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.X = (regs.X + 1) & 0xFF;\r\n                        regs.P.Z = +((regs.X) == 0);\r\n                        regs.P.N = ((regs.X) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xE9: return new M6502_opcode_functions(M6502_stock_matrix.get(0xE9),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SBC #\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D ^ 0xFF;\r\n                        o = regs.A + i + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xEA: return new M6502_opcode_functions(M6502_stock_matrix.get(0xEA),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //NOP\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xEB: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xEB),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xEC: return new M6502_opcode_functions(M6502_stock_matrix.get(0xEC),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //CPX a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        let o: i32 = regs.X - pins.D;\r\n                        regs.P.C = +(!((o & 0x100) >>> 8));\r\n                        regs.P.Z = +((o & 0xFF) == 0);\r\n                        regs.P.N = ((o) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xED: return new M6502_opcode_functions(M6502_stock_matrix.get(0xED),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SBC a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D ^ 0xFF;\r\n                        o = regs.A + i + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xEE: return new M6502_opcode_functions(M6502_stock_matrix.get(0xEE),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //INC a\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        break;\r\n                    case 4:\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 5:\r\n                        pins.D = (pins.D + 1) & 0xFF;\r\n                        regs.P.Z = +((pins.D) == 0);\r\n                        regs.P.N = ((pins.D) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xEF: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xEF),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xF0: return new M6502_opcode_functions(M6502_stock_matrix.get(0xF0),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //BEQ r\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.TR = +(regs.P.Z == 1);\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = (regs.PC + mksigned8(pins.D)) & 0xFFFF;\r\n                        pins.Addr = regs.PC;\r\n                        if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page\r\n                        break;\r\n                    case 3: // extra idle on page cross\r\n                        pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        regs.PC = regs.TA;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xF1: return new M6502_opcode_functions(M6502_stock_matrix.get(0xF1),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SBC (d),y\r\n                switch(regs.TCU) {\r\n                    case 1: // Get ZP\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // get ABS L\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3: // get ABS H\r\n                        regs.TR = pins.D;\r\n                        regs.TA = pins.D + regs.Y;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFF;\r\n                        break;\r\n                    case 4: // idle if crossed\r\n                        regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;\r\n                        regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;\r\n                        if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 5:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 6: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D ^ 0xFF;\r\n                        o = regs.A + i + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xF2: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xF2),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xF3: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xF3),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xF4: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xF4),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xF5: return new M6502_opcode_functions(M6502_stock_matrix.get(0xF5),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SBC d,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D ^ 0xFF;\r\n                        o = regs.A + i + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xF6: return new M6502_opcode_functions(M6502_stock_matrix.get(0xF6),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //INC d,X\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2: // spurious read\r\n                        regs.TA = (pins.D + regs.X) & 0xFF;\r\n                        pins.Addr = pins.D;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 4: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        regs.TR = (regs.TR + 1) & 0xFF;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        break;\r\n                    case 5:\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 6: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xF7: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xF7),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xF8: return new M6502_opcode_functions(M6502_stock_matrix.get(0xF8),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SED\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.P.D = 1;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 2: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xF9: return new M6502_opcode_functions(M6502_stock_matrix.get(0xF9),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SBC a,y\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.Y) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D ^ 0xFF;\r\n                        o = regs.A + i + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xFA: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xFA),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xFB: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xFB),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xFC: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xFC),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0xFD: return new M6502_opcode_functions(M6502_stock_matrix.get(0xFD),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //SBC a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.TA | (pins.D << 8);\r\n                        regs.TA = (pins.Addr + regs.X) & 0xFFFF;\r\n                        if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }\r\n                        pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);\r\n                        break;\r\n                    case 4: // optional\r\n                        pins.Addr = regs.TA;\r\n                        break;\r\n                    case 5: // cleanup_custom\r\n                        let o: i32;\r\n                        let i: i32 = pins.D ^ 0xFF;\r\n                        o = regs.A + i + regs.P.C;\r\n                        regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >>> 7;\r\n                        regs.P.C = +(o > 0xFF);\r\n                        regs.A = o & 0xFF;\r\n                        regs.P.Z = +((regs.A) == 0);\r\n                        regs.P.N = ((regs.A) & 0x80) >>> 7;\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xFE: return new M6502_opcode_functions(M6502_stock_matrix.get(0xFE),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //INC a,x\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        regs.TA = pins.D;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 3: // spurious read\r\n                        regs.TA |= pins.D << 8;\r\n                        pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);\r\n                        break;\r\n                    case 4: // real read\r\n                        pins.Addr = (regs.TA + regs.X) & 0xFFFF;\r\n                        break;\r\n                    case 5: // spurious read/write\r\n                        regs.TR = pins.D;\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 6:\r\n                        regs.TR = (regs.TR + 1) & 0xFF;\r\n                        regs.P.Z = +((regs.TR) == 0);\r\n                        regs.P.N = ((regs.TR) & 0x80) >>> 7;\r\n                        pins.D = regs.TR;\r\n                        // Following is auto-generated code for instruction finish\r\n                        break;\r\n                    case 7: // cleanup\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        pins.RW = 0;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0xFF: return new M6502_opcode_functions(M6502_invalid_matrix.get(0xFF),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //\r\n        });\r\n        case 0x100: return new M6502_opcode_functions(M6502_stock_matrix.get(0x100),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //RESET\r\n                switch(regs.TCU) {\r\n                    case 1: // 3\r\n                        pins.RW = 0;\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        break;\r\n                    case 2: // 4\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        break;\r\n                    case 3: // 5\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        break;\r\n                    case 4: // 6\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        break;\r\n                    case 5: // 7\r\n                        pins.Addr = (0xFFFC);\r\n                        break;\r\n                    case 6: // 8\r\n                        regs.PC = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFFFF;\r\n                        break;\r\n                    case 7: // cleanup_custom\r\n                        regs.PC |= (pins.D << 8);\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x101: return new M6502_opcode_functions(M6502_stock_matrix.get(0x101),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //NMI\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.P.B = 0;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        regs.TR = (regs.PC - 2) & 0xFFFF;\r\n                        pins.D = (regs.TR >>> 8) & 0xFF;\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        pins.D = regs.TR & 0xFF;\r\n                        break;\r\n                    case 4:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        pins.D = regs.P.getbyte();\r\n                        break;\r\n                    case 5:\r\n                        regs.P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK\r\n                        regs.P.I = 1;\r\n                        pins.RW = 0;\r\n                        pins.Addr = (0xFFFA);\r\n                        break;\r\n                    case 6:\r\n                        regs.PC = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFFFF;\r\n                        break;\r\n                    case 7: // cleanup_custom\r\n                        regs.PC |= (pins.D << 8);\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n        case 0x102: return new M6502_opcode_functions(M6502_stock_matrix.get(0x102),\r\n            function(regs: m6502_regs, pins: m6502_pins): void { //IRQ\r\n                switch(regs.TCU) {\r\n                    case 1:\r\n                        regs.P.B = 0;\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        break;\r\n                    case 2:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        regs.TR = (regs.PC - 2) & 0xFFFF;\r\n                        pins.D = (regs.TR >>> 8) & 0xFF;\r\n                        pins.RW = 1;\r\n                        break;\r\n                    case 3:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        pins.D = regs.TR & 0xFF;\r\n                        break;\r\n                    case 4:\r\n                        pins.Addr = regs.S | 0x100;\r\n                        regs.S = (regs.S - 1) & 0xFF;\r\n                        pins.D = regs.P.getbyte();\r\n                        break;\r\n                    case 5:\r\n                        regs.P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK\r\n                        regs.P.I = 1;\r\n                        pins.RW = 0;\r\n                        pins.Addr = (0xFFFE);\r\n                        break;\r\n                    case 6:\r\n                        regs.PC = pins.D;\r\n                        pins.Addr = (pins.Addr + 1) & 0xFFFF;\r\n                        break;\r\n                    case 7: // cleanup_custom\r\n                        regs.PC |= (pins.D << 8);\r\n                        // Following is auto-generated code for instruction finish\r\n                        pins.Addr = regs.PC;\r\n                        regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                        regs.TCU = 0;\r\n                        break;\r\n                }\r\n        });\r\n    }\r\n    return new M6502_opcode_functions(M6502_invalid_matrix.get(opcode), function(regs: m6502_regs, pins: m6502_pins): void { console.log('INVALID OPCODE');});\r\n}\r\n\r\nfor (let i = 0; i <= M6502_MAX_OPCODE; i++) {\r\n    nesm6502_opcodes_decoded[i] = nesm6502_get_opcode_function(i);\r\n}\r\n","import {M6502_AM, M6502_OP_IRQ, M6502_OP_NMI, M6502_OP_RESET, M6502_opcode_functions} from \"./m6502_opcodes\";\r\nimport {dbg} from \"../../../helpers/debug\";\r\nimport {hex2, hex4} from \"../../../helpers/helpers\";\r\n\r\nclass m6502_P {\r\n    C: u32\r\n    Z: u32\r\n    I: u32\r\n    D: u32\r\n    B: u32\r\n    V: u32\r\n    N: u32\r\n\r\n    constructor() {\r\n        this.C = this.Z = this.I = this.D = this.B = this.V = this.N = 0;\r\n    }\r\n\r\n    setbyte(val: u32): void {\r\n        this.C = val & 1;\r\n        this.Z = (val & 0x02) >>> 1;\r\n        this.I = (val & 0x04) >>> 2;\r\n        this.D = (val & 0x08) >>> 3;\r\n        this.B = 1; // Confirmed via Visual6502\r\n        this.V = (val & 0x40) >>> 6;\r\n        this.N = (val & 0x80) >>> 7;\r\n    }\r\n\r\n    getbyte(): u32 {\r\n        return this.C | (this.Z << 1) | (this.I << 2) | (this.D << 3) | (this.B << 4) | 0x20 | (this.V << 6) | (this.N << 7);\r\n    }\r\n\r\n    formatbyte(): string {\r\n\t\tlet outstr: string = '';\r\n\t\toutstr += this.N ? 'N' : 'n';\r\n\t\toutstr += this.V ? 'V-' : 'v-';\r\n\t\toutstr += this.B ? 'B' : 'b';\r\n\t\toutstr += this.D ? 'D' : 'd';\r\n\t\toutstr += this.I ? 'I' : 'i';\r\n\t\toutstr += this.Z ? 'Z' : 'z';\r\n\t\toutstr += this.C ? 'C' : 'c';\r\n\t\treturn outstr;\r\n    }\r\n}\r\n\r\nexport class m6502_regs {\r\n    A: u32 = 0\r\n    X: u32 = 0\r\n    Y: u32 = 0\r\n    PC: u32 = 0\r\n    S: u32 = 0\r\n    old_I: u32 = 0\r\n    P: m6502_P = new m6502_P()\r\n    TCU: u32 = 0\r\n    IR: u32 = 0\r\n    TA: i32 = 0\r\n    TR: i32 = 0\r\n    skipped_cycle: u32 = 0\r\n    HLT: u32 = 0\r\n    IRQ_pending: u32 = 0\r\n    NMI_pending: u32 = 0\r\n    WAI: u32 = 0\r\n    STP: u32 = 0\r\n}\r\n\r\nexport class m6502_pins {\r\n    Addr: u32 = 0\r\n    D: u32 = 0\r\n    RW: u32 = 0\r\n\r\n    IRQ: u32 = 0\r\n    NMI: u32 = 0\r\n    RST: u32 = 0\r\n}\r\n\r\nexport class m6502 {\r\n    regs: m6502_regs\r\n    pins: m6502_pins\r\n\r\n    IRQ_ack: bool = false\r\n    NMI_ack: bool = false\r\n    NMI_old: u32 = 0;\r\n    IRQ_count: u64 = 0;\r\n\r\n    PCO: u32 = 0;\r\n\r\n    opcode_set: Array<M6502_opcode_functions>\r\n    first_reset: bool = true\r\n    current_instruction: M6502_opcode_functions\r\n\r\n    constructor(opcode_set: Array<M6502_opcode_functions>) {\r\n        this.regs = new m6502_regs();\r\n        this.pins = new m6502_pins();\r\n        this.opcode_set = opcode_set;\r\n        this.current_instruction = opcode_set[0];\r\n    }\r\n\r\n    trace_peek(addr: u32): u32 {\r\n        console.log('IMPLEMENT TRACEP EEK DOAG')\r\n        return 0;\r\n    }\r\n\r\n    reset(): void {\r\n        this.pins.RST = 0;\r\n        this.regs.TCU = 0;\r\n        this.pins.D = M6502_OP_RESET;\r\n        this.pins.RW = 1;\r\n        this.regs.P.B = 1;\r\n        this.regs.P.D = 0;\r\n        this.regs.P.I = 1;\r\n        this.regs.WAI = 0;\r\n        this.regs.STP = 0;\r\n        if (this.first_reset) this.power_on();\r\n        this.first_reset = false;\r\n    }\r\n\r\n    power_on(): void {\r\n        // Initial values from Visual6502\r\n        this.regs.A = 0xCC;\r\n        this.regs.S = 0xFD;\r\n        this.pins.D = 0x60;\r\n        this.pins.RW = 0;\r\n        this.regs.X = this.regs.Y = 0;\r\n        this.regs.P.I = 1;\r\n        this.regs.P.Z = 1;\r\n        this.regs.PC = 0;\r\n    }\r\n\r\n    cycle(): void {\r\n        if (this.regs.HLT || this.regs.STP) return;\r\n        if (this.pins.IRQ) {\r\n            this.IRQ_count++;\r\n            if (this.IRQ_count >= 1) {\r\n                this.pins.IRQ = 0;\r\n                this.IRQ_count = 0;\r\n                this.regs.IRQ_pending = 1;\r\n                this.IRQ_ack = false;\r\n            }\r\n        }\r\n        else this.IRQ_count = 0;\r\n\r\n        // Edge-sensitive 0->1\r\n        if (this.pins.NMI !== this.NMI_old) {\r\n            if (this.pins.NMI === 0) { // Reset NMI status\r\n                this.NMI_ack = false;\r\n            }\r\n            else { // Make NMI pending\r\n                this.NMI_ack = false;\r\n                this.regs.NMI_pending = 1;\r\n            }\r\n            this.NMI_old = this.pins.NMI;\r\n        }\r\n\r\n        this.regs.TCU++;\r\n        if (this.regs.TCU === 1) {\r\n            this.PCO = this.pins.Addr; // Capture PC before it runs away\r\n            this.regs.IR = this.pins.D;\r\n            if (this.regs.NMI_pending && !this.NMI_ack) {\r\n                this.NMI_ack = true;\r\n                this.regs.NMI_pending = 0;\r\n                this.regs.IR = M6502_OP_NMI;\r\n                if (dbg.brk_on_NMIRQ) dbg.break();\r\n            } else if (this.regs.IRQ_pending && !this.IRQ_ack && !this.regs.old_I) {\r\n                this.IRQ_ack = true;\r\n                this.regs.IRQ_pending = 0;\r\n                this.regs.IR = M6502_OP_IRQ;\r\n            }\r\n            this.regs.old_I = this.regs.P.I;\r\n\t\t\tthis.current_instruction = this.opcode_set[this.regs.IR];\r\n            if (this.current_instruction.addr_mode == M6502_AM.NONE) {\r\n                console.log('INVALID OPCODE');\r\n                dbg.break();\r\n            }\r\n            /*if (this.trace_on) {\r\n                dbg.traces.add(TRACERS.M6502, this.clock.trace_cycles-1, this.trace_format(this.disassemble(), this.PCO));\r\n            }*/\r\n        }\r\n        this.IRQ_ack = false;\r\n        this.NMI_ack = false;\r\n\r\n        this.current_instruction.exec_func(this.regs, this.pins);\r\n    }\r\n}\r\n\r\n","// For relative addressing\r\nexport function mksigned8(what: u32): i32 {\r\n     return what >= 0x80 ? -(0x100 - what) : what;\r\n}\r\n\r\nexport function mksigned13(what: u32): i32 {\r\n    return what >= 0x1000 ? -(0x2000 - what) : what;\r\n}\r\n\r\nexport function mksigned16h4(w: u32): string {\r\n     let what: i32 = w >= 0x8000 ? -(0x10000 - <i32>w) : <i32>w;\r\n     let o = hex5(Math.abs(what * 4));\r\n     return (what < 0 ? '-' : '+') + o + 'h';\r\n}\r\n\r\n\r\nexport function mksigned16h(w: u32): string {\r\n     let what: i32 = w >= 0x8000 ? -(0x10000 - <i32>w) : <i32>w;\r\n     let o: string = hex4(Math.abs(w));\r\n     return (what < 0 ? '-' : '+') + o + 'h';\r\n}\r\n\r\n// @ts-ignore\r\n@inline\r\nexport function mksigned16(what: u32): i32 {\r\n     return what >= 0x8000 ? -(0x10000 - what) : what;\r\n}\r\n\r\nexport function hex2(val: u32): string {\r\n    let outstr = val.toString(16);\r\n    while(outstr.length < 2) outstr = '0' + outstr;\r\n    return outstr.toUpperCase();\r\n}\r\n\r\nexport function hex5(val: u32): string {\r\n    let outstr = val.toString(16);\r\n    while(outstr.length < 5) outstr = '0' + outstr;\r\n    return outstr.toUpperCase();\r\n}\r\n\r\n\r\nexport function hex4(val: u32): string {\r\n    let outstr = val.toString(16);\r\n    while(outstr.length < 4) outstr = '0' + outstr;\r\n    return outstr.toUpperCase();\r\n}\r\n\r\nexport function hex6(val: u32): string {\r\n    let outstr = val.toString(16);\r\n    while(outstr.length < 6) outstr = '0' + outstr;\r\n    return outstr.toUpperCase();\r\n}\r\n\r\nexport function hex8(val: u32): string {\r\n    let outstr = val.toString(16);\r\n    while(outstr.length < 8) outstr = '0' + outstr;\r\n    return outstr.toUpperCase();\r\n}\r\n\r\nexport function hex0x2(val: u32): String {\r\n    return '0x' + hex2(val);\r\n}\r\n\r\nexport function hex0x4(val: u32): String {\r\n    return '0x' + hex4(val);\r\n}\r\n\r\nexport function hex0x6(val: u32): String {\r\n    return '0x' + hex6(val);\r\n}\r\n\r\nclass perf_split_t {\r\n    name: String\r\n    order: u32\r\n    total: f64 = 0\r\n    sample: f64 = 0\r\n    constructor(name: String, order: u32) {\r\n        this.name = name;\r\n        this.order = order;\r\n    }\r\n}\r\n\r\nexport class perf_timer_t {\r\n    name: String\r\n    samples: u32 = 0\r\n    splits: Map<String, perf_split_t> = new Map<String, perf_split_t>();\r\n    splits_order: Map<u32, String> = new Map<u32, String>();\r\n    splits_order_r: Map<String, u32> = new Map<String, u32>();\r\n\r\n    sample_start: f64 = 0\r\n    sample_end: f64 = 0\r\n    sample_time_total: f64 = 0\r\n\r\n    req_breakdowns: u32 = 0\r\n    breakdown_every: u32 = 0\r\n\r\n    num_keys: u32 = 0;\r\n\r\n    constructor(name: String, breakdown_every: u32, splits: Array<String>) {\r\n        this.name = name;\r\n        this.breakdown_every = breakdown_every;\r\n\r\n        for (let i: u32 = 0, k: u32 = <u32>splits.length; i < k; i++) {\r\n            this.add_split(splits[i]);\r\n        }\r\n    }\r\n\r\n    add_split(name: String): void {\r\n        this.splits_order.set(this.num_keys, name);\r\n        this.splits_order_r.set(name, this.num_keys);\r\n        this.splits.set(name, new perf_split_t(name, this.num_keys));\r\n        this.num_keys++;\r\n    }\r\n\r\n    start_sample(): void {\r\n        this.sample_start = performance.now();\r\n    }\r\n\r\n    record_split(name: String): void {\r\n        this.splits.get(name).sample = performance.now();\r\n    }\r\n\r\n    end_sample(): void {\r\n        this.sample_end = performance.now();\r\n        this.samples++;\r\n        //this.sample_time_total += this.sample_end - this.sample_start;\r\n        this.do_samples();\r\n        this.req_breakdowns++;\r\n        if (this.req_breakdowns >= this.breakdown_every) {\r\n            this.req_breakdowns = 0;\r\n            this.analyze();\r\n            this.reset();\r\n        }\r\n    }\r\n\r\n    analyze(): void {\r\n        console.log('----Breakdown of performance for ' + this.name);\r\n        console.log('Sample size: ' + this.samples.toString());\r\n        let e = this.splits.keys()\r\n        for (let sn: u32 = 0; sn < this.num_keys; sn++) {\r\n            let split = this.splits.get(e[sn]);\r\n            console.log(split.name + ': ' + (split.total / this.sample_time_total).toString() + ', avg ' + (split.total / this.samples).toString());\r\n        }\r\n        console.log('TOTAL TIME TAKEN ' + this.sample_time_total.toString());\r\n    }\r\n\r\n    // Reset statistics\r\n    reset(): void {\r\n        let e = this.splits.keys()\r\n        for (let i: u32 = 0; i < this.num_keys; i++) {\r\n            this.splits.get(e[i]).total = 0;\r\n        }\r\n        this.samples = 0;\r\n        this.sample_time_total = 0;\r\n    }\r\n\r\n    // Take reported splits and tally up times\r\n    do_samples(): void {\r\n        let last_val = this.sample_start;\r\n        let e = this.splits.keys();\r\n        for (let i: u32 = 0; i < this.num_keys; i++) {\r\n            const split = this.splits.get(e[i]);\r\n            if (split.sample === 0) { console.log('YO ' + i.toString()); }\r\n            //console.log(split.sample);\r\n            split.total += (split.sample - last_val);\r\n            last_val = split.sample;\r\n        }\r\n        this.sample_time_total += last_val;\r\n    }\r\n}\r\n","import {\n  console as binding\n} from \"./bindings/dom\";\n\nexport namespace console {\n\n  export function assert<T>(condition: T, message: string = \"\"): void {\n    binding.assert(!!condition, message);\n  }\n\n  export function log(message: string = \"\"): void {\n    binding.log(message);\n  }\n\n  export function debug(message: string = \"\"): void {\n    binding.debug(message);\n  }\n\n  export function info(message: string = \"\"): void {\n    binding.info(message);\n  }\n\n  export function warn(message: string = \"\"): void {\n    binding.warn(message);\n  }\n\n  export function error(message: string = \"\"): void {\n    binding.error(message);\n  }\n\n  export function time(label: string = \"default\"): void {\n    binding.time(label);\n  }\n\n  export function timeLog(label: string = \"default\"): void {\n    binding.timeLog(label);\n  }\n\n  export function timeEnd(label: string = \"default\"): void {\n    binding.timeEnd(label);\n  }\n}\n","import {framevars_t} from \"../glue/global_player\";\r\n\r\nexport enum MD_TIMING {\r\n    frame = 0,\r\n    line = 1,\r\n    timestep = 2\r\n}\r\n\r\nexport enum MD_STANDARD {\r\n    NTSC = 0,\r\n    PAL = 1,\r\n    LCD\r\n}\r\n\r\nexport enum SCREENVAR_FIELDS {\r\n    current_frame = 0,\r\n    current_scanline = 1,\r\n    current_x = 2\r\n}\r\n\r\nexport class input_map_keypoint {\r\n    uber: String = ''       // Like player 1, player 2, keyboard, etc.\r\n    name: String = ''       // Name like up down a b\r\n    buf_pos: u32 = 0        // Position in buffer\r\n    internal_code: u32 = 0  // Internal usage\r\n}\r\n\r\nexport class overscan_info {\r\n    top: u32 = 0\r\n    bottom: u32 = 0\r\n    left: u32 = 0\r\n    right: u32 = 0\r\n}\r\n\r\nexport class machine_description {\r\n    name: String = '';\r\n    timing: MD_TIMING = MD_TIMING.frame\r\n    fps: u32 = 60\r\n    standard: MD_STANDARD = MD_STANDARD.NTSC\r\n    x_resolution: u32 = 256\r\n    y_resolution: u32 = 256\r\n    xrw: u32 = 4;\r\n    xrh: u32 = 3;\r\n\r\n    overscan: overscan_info = new overscan_info()\r\n\r\n    out_ptr: usize = 0;\r\n    out_size: u32 = 0;\r\n\r\n    keymap: Array<input_map_keypoint> = new Array<input_map_keypoint>();\r\n}\r\n\r\nexport class console_mt_struct {\r\n    vram_ptr: usize = 0\r\n    gp0_ptr: usize = 0\r\n    gp1_ptr: usize = 0\r\n    mmio_ptr: usize = 0\r\n}\r\n\r\nexport interface systemEmulator {\r\n    //serialize(): funcref,\r\n    //deserialize()\r\n    get_description(): machine_description;\r\n    finish_frame(): u32;\r\n    finish_scanline(): u32;\r\n    step_master(cycles: u32): u32;\r\n    reset(): void;\r\n    load_ROM(name: string, what: usize, sz: u32): void;\r\n    load_BIOS(what: usize, sz: u32): void;\r\n    killall(): void;\r\n    map_inputs(bufptr: usize): void;\r\n    get_framevars(): framevars_t;\r\n\r\n    play(): void;\r\n    pause(): void;\r\n    stop(): void;\r\n\r\n    get_mt_struct(): console_mt_struct;\r\n}\r\n\r\nexport interface systemEmulatorStandardClock {\r\n    frames_since_restart: u64\r\n    trace_cycles: u64\r\n}\r\n","import {NES_VARIANTS, NES_clock, NES_bus} from \"./nes_common\";\r\nimport {perf_timer_t} from \"../../helpers/helpers\";\r\n\r\nclass PPU_effect_buffer {\r\n    length: i32\r\n    items: StaticArray<i64>\r\n    constructor(length: u32) {\r\n        this.length = <i32>length;\r\n        this.items = new StaticArray<i64>(length);\r\n        for (let i: u32 = 0; i < length; i++) {\r\n            this.items[i] = -1;\r\n        }\r\n    }\r\n\r\n    get(cycle: u64): i64 {\r\n        let ci: i32 = <i32>cycle % this.length;\r\n        let r: i64 = this.items[ci];\r\n        this.items[ci] = -1;\r\n        return r;\r\n    }\r\n\r\n    set(cycle: u64, value: u32): void {\r\n        this.items[<i32>(cycle % this.length)] = <i64>value;\r\n    }\r\n}\r\n\r\nclass NES_PPU_io {\r\n    nmi_enable: u32 = 0\r\n    sprite_overflow: u32 = 0\r\n    sprite0_hit: u32 = 0\r\n    vram_increment: u32 = 1\r\n\r\n    sprite_pattern_table: u32 = 0\r\n    bg_pattern_table: u32 = 0\r\n\r\n    v: u32 = 0 // VRAM access address\r\n    t: u32 = 0 // Latch value for VRAM access and PPU scroll\r\n    x: u32 = 0 // Fine X scroll\r\n    w: u32 = 0 // low/high latch\r\n\r\n    greyscale: u32 = 0\r\n    bg_hide_left_8: u32 = 0\r\n    sprite_hide_left_8: u32 = 0\r\n    bg_enable: u32 = 0\r\n    sprite_enable: u32 = 0\r\n    OAM_addr: u32 = 0\r\n\r\n    emph_r: u32 = 0\r\n    emph_g: u32 = 0\r\n    emph_b: u32 = 0\r\n    emph_bits: u16 = 0\r\n\r\n}\r\n\r\nclass NES_PPU_status {\r\n    sprite_height: u32 = 8;\r\n    nmi_out: u32 = 0\r\n}\r\n\r\nclass NES_PPU_latch {\r\n    VRAM_read: u32 = 0\r\n}\r\n\r\nconst scanline_splits: Array<String> = new Array<String>(6);\r\n//['startup', 'startup2', 'maint', 'bgcolor', 'sprite_eval', 'color_out']\r\nscanline_splits[0] = 'startup';\r\nscanline_splits[1] = 'startup2';\r\nscanline_splits[2] = 'maint';\r\nscanline_splits[3] = 'bgcolor';\r\nscanline_splits[4] = 'sprite_eval';\r\nscanline_splits[5] = 'color_out';\r\n\r\nexport class NES_ppu {\r\n    clock: NES_clock\r\n    bus: NES_bus\r\n    variant: NES_VARIANTS\r\n\r\n    line_cycle: i32 = 0;\r\n    OAM: StaticArray<u32> = new StaticArray<u32>(256);\r\n    secondary_OAM: StaticArray<u32> = new StaticArray<u32>(32);\r\n    secondary_OAM_index: u32 = 0;\r\n    secondary_OAM_sprite_index: u32 = 0;\r\n    secondary_OAM_sprite_total: u32 = 0;\r\n    secondary_OAM_lock: bool = false;\r\n\r\n    OAM_transfer_latch: u32 = 0;\r\n    OAM_eval_index: u32 = 0;\r\n    OAM_eval_done: u32 = 0;\r\n\r\n    sprite0_on_next_line: bool = false;\r\n    sprite0_on_this_line: bool = false;\r\n\r\n    CGRAM: StaticArray<u32> = new StaticArray<u32>(32);\r\n    output: StaticArray<u16> = new StaticArray<u16>(256*256);\r\n\r\n    bg_fetches0: u32 = 0\r\n    bg_fetches1: u32 = 0\r\n    bg_fetches2: u32 = 0\r\n    bg_fetches3: u32 = 0\r\n    bg_shifter: u32 = 0;\r\n    bg_palette_shifter: u32 = 0;\r\n    bg_tile_fetch_addr: u32 = 0;\r\n    bg_tile_fetch_buffer: u32 = 0;\r\n    sprite_pattern_shifters: StaticArray<u32> = new StaticArray<u32>(8);\r\n    sprite_attribute_latches: StaticArray<u32> = new StaticArray<u32>(8);\r\n    sprite_x_counters: StaticArray<i32> = new StaticArray<i32>(8);\r\n    sprite_y_lines: StaticArray<i32> = new StaticArray<i32>(8);\r\n    last_sprite_addr: u32 = 0;\r\n\r\n    io: NES_PPU_io = new NES_PPU_io();\r\n    status: NES_PPU_status = new NES_PPU_status();\r\n    latch: NES_PPU_latch = new NES_PPU_latch();\r\n    scanline_timer: perf_timer_t = new perf_timer_t('scanline timer', 60*240, scanline_splits);\r\n    out_buffer: usize\r\n\r\n    w2006_buffer: PPU_effect_buffer\r\n\r\n    constructor(out_buffer: usize, variant: NES_VARIANTS, clock: NES_clock, bus: NES_bus) {\r\n        this.variant = variant;\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n        this.out_buffer = out_buffer;\r\n\r\n        this.w2006_buffer = new PPU_effect_buffer(4*clock.timing.ppu_divisor);\r\n\r\n        bus.ppu = this;\r\n    }\r\n\r\n    reset(): void {\r\n        this.line_cycle = 0;\r\n        this.io.w = 0;\r\n    }\r\n\r\n    write_cgram(addr: u32, val: u32): void {\r\n        this.bus.mapper.a12_watch(addr | 0x3F00)\r\n        if ((addr & 0x13) === 0x10) addr &= 0xEF;\r\n        this.CGRAM[addr & 0x1F] = val & 0x3F;\r\n    }\r\n\r\n    read_cgram(addr: u32): u32 {\r\n      if((addr & 0x13) === 0x10) addr &= 0xEF;\r\n      let data: u32 = this.CGRAM[addr & 0x1F];\r\n      if(this.io.greyscale) data &= 0x30;\r\n      return data;\r\n    }\r\n\r\n    mem_write(addr: u32, val: u32): void {\r\n        if ((addr & 0x3FFF) < 0x3F00) this.bus.PPU_write(addr, val);\r\n        else this.write_cgram(addr, val);\r\n    }\r\n\r\n    @inline rendering_enabled(): bool {\r\n        return this.io.bg_enable || this.io.sprite_enable;\r\n    }\r\n\r\n    new_frame(): void {\r\n        this.clock.ppu_y = 0;\r\n        this.clock.frames_since_restart++;\r\n        this.clock.frame_odd = (this.clock.frame_odd + 1) & 1;\r\n        this.clock.master_frame++;\r\n        this.clock.cpu_frame_cycle = 0;\r\n    }\r\n\r\n    new_scanline(): void {\r\n        if (this.clock.ppu_y === this.clock.timing.ppu_pre_render)\r\n            this.new_frame();\r\n        else {\r\n            this.clock.ppu_y++;\r\n        }\r\n\r\n        if (this.clock.ppu_y == this.clock.timing.vblank_start) {\r\n            this.clock.vblank = 1;\r\n            this.update_nmi();\r\n        }\r\n        else if (this.clock.ppu_y == this.clock.timing.vblank_end) {\r\n            this.clock.vblank = 0;\r\n            this.update_nmi();\r\n        }\r\n        this.line_cycle = 0;\r\n    }\r\n\r\n\r\n    fetch_chr_line(table: u32, tile: u32, line: u32): u32 {\r\n        let r: u32 = (0x1000 * table) + (tile * 16) + line;\r\n        let low: u32 = this.bus.mapper.PPU_read_effect(r);\r\n        let high: u32 = this.bus.mapper.PPU_read_effect(r + 8);\r\n        this.last_sprite_addr = r + 8;\r\n        let output: u32 = 0;\r\n        for (let i = 0; i < 8; i++) {\r\n            output <<= 2;\r\n            output |= (low & 1) | ((high & 1) << 1);\r\n            low >>>= 1;\r\n            high >>>= 1;\r\n        }\r\n        return output;\r\n    }\r\n\r\n    fetch_chr_addr(table: u32, tile: u32, line: u32): u32 {\r\n        return (0x1000 * table) + (tile * 16) + line;\r\n    }\r\n\r\n    fetch_chr_line_low(addr: u32): u32 {\r\n        let low: u32 = this.bus.mapper.PPU_read_effect(addr);\r\n        let output: u32 = 0;\r\n        for (let i: u32 = 0; i < 8; i++) {\r\n            output <<= 2;\r\n            output |= (low & 1);\r\n            low >>>= 1;\r\n        }\r\n        return output;\r\n    }\r\n\r\n    fetch_chr_line_high(addr: u32, o: u32): u32 {\r\n        let high: u32 = this.bus.mapper.PPU_read_effect(addr + 8);\r\n        let output: u32 = 0;\r\n        for (let i: u32 = 0; i < 8; i++) {\r\n            output <<= 2;\r\n            output |= ((high & 1) << 1);\r\n            high >>>= 1;\r\n        }\r\n        return output | o;\r\n    }\r\n\r\n    @inline perform_bg_fetches(): void { // Only called from prerender and visible scanlines\r\n        const lc = this.line_cycle;\r\n\r\n        // Only do things on odd cycles\r\n        if ((lc & 1) === 0) return;\r\n\r\n        let v = this.io.v;\r\n\r\n        const in_tile_y: u32 = (v >>> 12) & 7; // Y position inside tile\r\n\r\n        if (((lc > 0) && (lc <= 256)) || (lc > 320)) {\r\n            // Do memory accesses and shifters\r\n            switch (lc & 7) {\r\n                case 1: // nametable, tile #\r\n                    this.bg_fetches0 = this.bus.mapper.PPU_read_effect(0x2000 | (v & 0xFFF));\r\n                    this.bg_tile_fetch_addr = this.fetch_chr_addr(this.io.bg_pattern_table, this.bg_fetches0, in_tile_y);\r\n                    //this.bg_tile_fetch_buffer = 0;\r\n                    // Reload shifters if needed\r\n                    if (lc !== 1) { // reload shifter at interval #9 9....257\r\n                        this.bg_shifter = (this.bg_shifter >>> 16) | (this.bg_fetches2 << 16) | (this.bg_fetches3 << 24);\r\n                        this.bg_palette_shifter = ((this.bg_palette_shifter << 2) | this.bg_fetches1) & 0x0F; //(this.bg_palette_shifter >>> 8) | (this.bg_fetches1 << 8);\r\n                    }\r\n                    return;\r\n                case 3: // attribute table\r\n                    let attrib_addr: u32 = 0x23C0 | (v & 0x0C00) | ((v >>> 4) & 0x38) | ((v >>> 2) & 7);\r\n                    let shift: u32 = ((v >>> 4) & 0x04) | (v & 0x02);\r\n                    this.bg_fetches1 = (this.bus.mapper.PPU_read_effect(attrib_addr) >>> shift) & 3;\r\n                    return;\r\n                case 5: // low buffer\r\n                    this.bg_tile_fetch_buffer = this.fetch_chr_line_low(this.bg_tile_fetch_addr);\r\n                    return;\r\n                case 7: // high buffer\r\n                    this.bg_tile_fetch_buffer = this.fetch_chr_line_high(this.bg_tile_fetch_addr, this.bg_tile_fetch_buffer);\r\n                    this.bg_fetches2 = this.bg_tile_fetch_buffer & 0xFF;\r\n                    this.bg_fetches3 = this.bg_tile_fetch_buffer >>> 8;\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Do evaluation of next line of sprites\r\n    oam_evaluate_slow(): void {\r\n        let odd: u32 = this.line_cycle & 1;\r\n        let eval_y: u32 = this.clock.ppu_y;\r\n        if (this.line_cycle < 65) {\r\n            if (this.line_cycle === 1) {\r\n                this.secondary_OAM_sprite_total = 0;\r\n                this.secondary_OAM_index = 0;\r\n                this.OAM_eval_index = 0;\r\n                this.secondary_OAM_lock = false;\r\n                this.OAM_eval_done = 0;\r\n                this.sprite0_on_next_line = false;\r\n                for (let n = 0; n < 32; n++) {\r\n                    this.secondary_OAM[n] = 0xFF;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (this.line_cycle <= 256) { // and >= 65...\r\n            if (this.OAM_eval_done) return;\r\n            if (!odd) {\r\n                this.OAM_transfer_latch = this.OAM[this.OAM_eval_index];\r\n                if (!this.secondary_OAM_lock) {\r\n                    this.secondary_OAM[this.secondary_OAM_index] = this.OAM_transfer_latch;\r\n                    if ((eval_y >= this.OAM_transfer_latch) && (eval_y < (this.OAM_transfer_latch + this.status.sprite_height))) {\r\n                        if (this.OAM_eval_index === 0) this.sprite0_on_next_line = true;\r\n                        this.secondary_OAM[this.secondary_OAM_index + 1] = this.OAM[this.OAM_eval_index + 1];\r\n                        this.secondary_OAM[this.secondary_OAM_index + 2] = this.OAM[this.OAM_eval_index + 2];\r\n                        this.secondary_OAM[this.secondary_OAM_index + 3] = this.OAM[this.OAM_eval_index + 3];\r\n                        this.secondary_OAM_index += 4;\r\n                        this.secondary_OAM_sprite_total++;\r\n                        //this.secondary_OAM_lock = this.secondary_OAM_index >= 32;\r\n                        this.OAM_eval_done |= +(this.secondary_OAM_index >= 32);\r\n                    }\r\n                }\r\n                this.OAM_eval_index += 4;\r\n                if (this.OAM_eval_index >= 256) {\r\n                    this.OAM_eval_index = 0;\r\n                    this.secondary_OAM_lock = true;\r\n                    this.OAM_eval_done = 1;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        if ((this.line_cycle >= 257) && (this.line_cycle <= 320)) { // Sprite tile fetches\r\n            if (this.line_cycle === 257) { // Do some housekeeping on cycle 257\r\n                this.sprite0_on_this_line = this.sprite0_on_next_line;\r\n                this.secondary_OAM_index = 0;\r\n                this.secondary_OAM_sprite_index = 0;\r\n                if (!this.io.sprite_overflow) {\r\n                    // Perform weird sprite overflow glitch\r\n                    let n: u32 = 0;\r\n                    let m: u32 = 0;\r\n                    let f: u32 = 0;\r\n                    while (n < 64) {\r\n                        let e: u32 = this.OAM[(n * 4) + m];\r\n                        // If value is in range....\r\n                        if ((eval_y >= e) && (eval_y < (e + this.status.sprite_height))) {\r\n                            // Set overflow flag if needed\r\n                            f++;\r\n                            if (f > 8) {\r\n                                this.io.sprite_overflow = 1;\r\n                                break;\r\n                            }\r\n                            m = (m + 4) & 0x03;\r\n                            n++;\r\n                        }\r\n                        // Value is not in range...\r\n                        else {\r\n                            n++;\r\n                            m = (m + 4) & 0x03; // Here is the hardware bug. This should be set to 0 instead!\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Sprite data fetches into shift registers\r\n            let sub_cycle = (this.line_cycle - 257) & 0x07;\r\n            switch (sub_cycle) {\r\n                case 0: // Read Y coordinate.  257\r\n                    let syl: i32 = eval_y - this.secondary_OAM[this.secondary_OAM_index];\r\n                    if (syl < 0) syl = 0;\r\n                    if (syl > <i32>(this.status.sprite_height - 1)) syl = this.status.sprite_height - 1;\r\n                    this.sprite_y_lines[this.secondary_OAM_sprite_index] = syl;\r\n                    this.secondary_OAM_index++;\r\n                    break;\r\n                case 1: // Read tile number 258, and do garbage NT address\r\n                    this.sprite_pattern_shifters[this.secondary_OAM_sprite_index] = this.secondary_OAM[this.secondary_OAM_index];\r\n                    this.secondary_OAM_index++;\r\n                    this.bus.mapper.a12_watch(this.io.v);\r\n                    break;\r\n                case 2: // Read attributes 259\r\n                    this.sprite_attribute_latches[this.secondary_OAM_sprite_index] = this.secondary_OAM[this.secondary_OAM_index];\r\n                    this.secondary_OAM_index++;\r\n                    break;\r\n                case 3: // Read X-coordinate 260 and do garbage NT access\r\n                    this.sprite_x_counters[this.secondary_OAM_sprite_index] = this.secondary_OAM[this.secondary_OAM_index];\r\n                    this.secondary_OAM_index++;\r\n                    this.bus.mapper.a12_watch(this.io.v);\r\n                    break;\r\n                case 4: // Fetch tiles for the shifters 261\r\n                    break;\r\n                case 5:\r\n                    let tn: u32 = this.sprite_pattern_shifters[this.secondary_OAM_sprite_index];\r\n                    let sy: i32 = this.sprite_y_lines[this.secondary_OAM_sprite_index];\r\n                    let table: u32 = this.io.sprite_pattern_table;\r\n                    let attr: u32 = this.sprite_attribute_latches[this.secondary_OAM_sprite_index];\r\n                    // Vertical flip....\r\n                    if (attr & 0x80) sy = (this.status.sprite_height - 1) - sy;\r\n                    if (this.status.sprite_height === 16) {\r\n                        table = tn & 1;\r\n                        tn &= 0xFE;\r\n                    }\r\n                    if (sy > 7) {\r\n                        sy -= 8;\r\n                        tn += 1;\r\n                    }\r\n                    this.sprite_pattern_shifters[this.secondary_OAM_sprite_index] = this.fetch_chr_line(table, tn, sy);\r\n                    break;\r\n                case 7:\r\n                    this.bus.mapper.a12_watch(this.last_sprite_addr);\r\n                    this.secondary_OAM_sprite_index++;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Do sprite counters & memory address updates\r\n    cycle_scanline_addr(): void {\r\n        const lc = this.line_cycle;\r\n        let io_v = this.io.v;\r\n        if (this.clock.ppu_y < this.clock.timing.bottom_rendered_line) {\r\n            // Sprites\r\n            if ((lc > 0) && (lc < 257)) {\r\n                this.sprite_x_counters[0]--;\r\n                this.sprite_x_counters[1]--;\r\n                this.sprite_x_counters[2]--;\r\n                this.sprite_x_counters[3]--;\r\n                this.sprite_x_counters[4]--;\r\n                this.sprite_x_counters[5]--;\r\n                this.sprite_x_counters[6]--;\r\n                this.sprite_x_counters[7]--;\r\n            }\r\n        }\r\n        if (!(this.io.bg_enable | this.io.sprite_enable) || (lc === 0)) return;\r\n        // Cycle # 8, 16,...248, and 328, 336. BUT NOT 0\r\n        if (lc == 256) {\r\n            if ((io_v & 0x7000) !== 0x7000) { // if fine y !== 7\r\n                io_v += 0x1000;               // add 1 to fine y\r\n            }\r\n            else {                                   // else it is overflow so\r\n                io_v &= 0x8FFF;                 // clear fine y to 0\r\n                let y: u32 = (io_v & 0x03E0) >>> 5;  // get coarse y\r\n                if (y == 29) {                      // y overflows 30->0 with vertical nametable swap\r\n                    y = 0;\r\n                    io_v ^= 0x0800;             // Change vertical nametable\r\n                } else if (y == 31) {               // y also overflows at 31 but without nametable swap\r\n                    y = 0;\r\n                }\r\n                else                                 // just add to coarse scroll\r\n                    y += 1;\r\n                io_v = (io_v & 0xFC1F) | (y << 5); // put scroll back in\r\n            }\r\n            this.io.v = io_v;\r\n            return;\r\n        }\r\n        if (((lc & 7) == 0) && ((lc >= 328) || (lc <= 256))) {\r\n            // INCREMENT HORIZONTAL SCROLL IN v\r\n            if ((io_v & 0x1F) == 0x1F) // If X scroll is 31...\r\n                this.io.v = (io_v & 0xFFE0) ^ 0x0400; // clear x scroll to 0 (& FFE0) and swap nametable (^ 0x400)\r\n            else\r\n                this.io.v++;  // just increment the X scroll\r\n            return;\r\n        }\r\n        // INCREMENT VERTICAL SCROLL IN v\r\n        // Cycles 257...320, copy parts of T to V over and over...\r\n        if ((lc == 257) && this.rendering_enabled())\r\n            this.io.v = (this.io.v & 0xFBE0) | (this.io.t & 0x41F);\r\n    }\r\n\r\n    cycle_visible(): void {\r\n        let sx: i32 = this.line_cycle-1;\r\n        let sy: i32 = this.clock.ppu_y;\r\n        let bo: u32 = (sy * 256) + sx;\r\n        if (!this.rendering_enabled()) {\r\n            if (this.line_cycle < 256)\r\n                store<u16>(this.out_buffer+(bo*2), <u16>this.CGRAM[0] | this.io.emph_bits);\r\n            return;\r\n        }\r\n\r\n        if (this.line_cycle < 1) {\r\n            if (this.clock.ppu_y == 0)\r\n                this.clock.ppu_frame_cycle = 0;\r\n            return;\r\n        }\r\n\r\n        //this.scanline_timer.record_split('startup');\r\n\r\n        this.cycle_scanline_addr();\r\n        this.oam_evaluate_slow();\r\n        this.perform_bg_fetches();\r\n        if (this.line_cycle >= 256) return;\r\n\r\n        // Shift out some bits for backgrounds\r\n        let bg_shift: u32 = 0, bg_color: u32 = 0;\r\n        let bg_has_pixel: bool = false;\r\n        if (this.io.bg_enable) {\r\n            bg_shift = (((sx & 7) + this.io.x) & 15) * 2;\r\n            bg_color = (this.bg_shifter >>> bg_shift) & 3;\r\n            bg_has_pixel = bg_color !== 0;\r\n        }\r\n        let sprite_has_pixel: bool = false;\r\n        if (bg_has_pixel) {\r\n            let agb = this.bg_palette_shifter;\r\n            if (this.io.x + (sx & 0x07) < 8) agb >>>= 2;\r\n            bg_color = this.CGRAM[bg_color | ((agb & 3) << 2)];\r\n        }\r\n        else bg_color = this.CGRAM[0];\r\n\r\n        //this.scanline_timer.record_split('bgcolor')\r\n\r\n        let sprite_priority = 0;\r\n        let sprite_color = 0;\r\n\r\n        // Check if any sprites need drawing\r\n        //for (let m = 0; m < 8; m++) {\r\n        for (let m: i32 = 7; m >= 0; m--) {\r\n            let sxc: i32 = this.sprite_x_counters[m];\r\n            if ((sxc >= -8) &&\r\n                (sxc <= -1)) {\r\n                let sal: u32 = this.sprite_attribute_latches[m];\r\n                let sps: u32 = this.sprite_pattern_shifters[m];\r\n                let s_x_flip: u32 = (sal & 0x40) >>> 6;\r\n                let my_color: u32 = 0;\r\n                if (s_x_flip) {\r\n                    my_color = (sps & 0xC000) >>> 14;\r\n                    this.sprite_pattern_shifters[m] = sps << 2;\r\n                } else {\r\n                    my_color = sps & 3;\r\n                    this.sprite_pattern_shifters[m] = sps >>> 2;\r\n                }\r\n                if (my_color !== 0) {\r\n                    sprite_has_pixel = true;\r\n                    my_color |= (sal & 3) << 2;\r\n                    sprite_priority = (sal & 0x20) >>> 5;\r\n                    sprite_color = this.CGRAM[0x10 + my_color];\r\n                    if ((!this.io.sprite0_hit) && (this.sprite0_on_this_line) && (m === 0) && bg_has_pixel && (this.line_cycle < 256)) {\r\n                        this.io.sprite0_hit = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //this.scanline_timer.record_split('sprite_eval');\r\n\r\n        // Decide background or sprite\r\n        let out_color: u32 = bg_color;\r\n        if (this.io.sprite_enable) {\r\n            if (sprite_color !== 0) {\r\n                if (!bg_has_pixel) {\r\n                    out_color = sprite_color;\r\n                } else {\r\n                    if (!sprite_priority) out_color = sprite_color;\r\n                    else out_color = bg_color;\r\n                }\r\n            }\r\n        }\r\n\r\n        store<u16>(this.out_buffer+(bo*2), <u16>out_color | this.io.emph_bits);\r\n    }\r\n\r\n    cycle_postrender(): void {\r\n        // 240, (also 241-260)\r\n        // LITERALLY DO NOTHING\r\n        if ((this.clock.ppu_y === this.clock.timing.vblank_start) && (this.line_cycle === 1)) {\r\n            this.status.nmi_out = 1;\r\n            this.update_nmi();\r\n        }\r\n    }\r\n\r\n    // Get tile info into shifters using screen X, Y coordinates\r\n    cycle_prerender(): void {\r\n        if ((this.clock.frame_odd) && (this.line_cycle === 0)) this.line_cycle++;\r\n        let lc = this.line_cycle;\r\n        if (lc === 1) {\r\n            this.io.sprite0_hit = 0;\r\n            this.io.sprite_overflow = 0;\r\n            this.status.nmi_out = 0;\r\n            this.update_nmi();\r\n        }\r\n        if (this.rendering_enabled()) {\r\n            if (lc === 257) this.io.v = (this.io.v & 0xFBE0) | (this.io.t & 0x41F);\r\n            if ((this.rendering_enabled()) && (this.line_cycle >= 280) && (this.line_cycle <= 304)) this.io.v = (this.io.v & 0x041F) | (this.io.t & 0x7BE0);\r\n        }\r\n        if (this.io.sprite_enable && (this.line_cycle >= 257)) {\r\n            this.oam_evaluate_slow();\r\n        }\r\n    }\r\n\r\n    render_cycle(): void {\r\n        if (this.clock.ppu_y < this.clock.timing.post_render_ppu_idle) { // 0-239\r\n            this.cycle_visible();\r\n            return;\r\n        }\r\n        else if (this.clock.ppu_y < this.clock.timing.ppu_pre_render) { // 240-260\r\n            this.cycle_postrender();\r\n            return;\r\n        }\r\n        this.cycle_prerender(); // 261\r\n    }\r\n\r\n    cycle(howmany: u32): u32 {\r\n        for (let i: u32 = 0; i < howmany; i++) {\r\n            let r: i64 = this.w2006_buffer.get((this.clock.ppu_master_clock / this.clock.timing.ppu_divisor));\r\n            if (r >= 0) {\r\n                this.io.v = <u32>r;\r\n                this.bus.mapper.a12_watch(<u32>r);\r\n            }\r\n            this.render_cycle();\r\n            this.line_cycle++;\r\n            this.clock.ppu_frame_cycle++;\r\n            if (this.line_cycle === 341) this.new_scanline();\r\n            this.clock.ppu_master_clock += this.clock.timing.ppu_divisor;\r\n        }\r\n        return howmany\r\n    }\r\n\r\n    update_nmi(): void {\r\n        if (this.status.nmi_out && this.io.nmi_enable) {\r\n            this.bus.CPU_notify_NMI(1);\r\n        }\r\n        else {\r\n            this.bus.CPU_notify_NMI(0);\r\n        }\r\n    }\r\n\r\n    reg_read(addr: u32, val: u32): u32 {\r\n        let output: u32 = val;\r\n        switch((addr & 7) | 0x2000) {\r\n            case 0x2002:\r\n                output = (this.io.sprite_overflow << 5) | (this.io.sprite0_hit << 6) | (this.status.nmi_out << 7);\r\n                //if (has_effect) {\r\n                    this.status.nmi_out = 0;\r\n                    this.update_nmi();\r\n\r\n                    this.io.w = 0;\r\n                //}\r\n                break;\r\n            case 0x2004: // OAMDATA\r\n                output = this.OAM[this.io.OAM_addr];\r\n                // reads do not increment counter\r\n                break;\r\n            case 0x2007:\r\n                if (this.rendering_enabled() && ((this.clock.ppu_y < this.clock.timing.vblank_start) || (this.clock.ppu_y > this.clock.timing.vblank_end))) {\r\n                    return 0;\r\n                }\r\n                if ((this.io.v & 0x3FF) >= 0x3F00) {\r\n                    output = this.read_cgram(addr);\r\n                }\r\n                else {\r\n                    output = this.latch.VRAM_read;\r\n                    this.latch.VRAM_read = this.bus.mapper.PPU_read_effect(this.io.v & 0x3FFF);\r\n                }\r\n                this.io.v = (this.io.v + this.io.vram_increment) & 0x7FFF;\r\n                break;\r\n            default:\r\n                console.log('READ UNIMPLEMENTED ' + addr.toString(16));\r\n                break;\r\n        }\r\n        return output;\r\n    }\r\n\r\n    reg_write(addr: u32, val: u32): void {\r\n        switch ((addr & 7) | 0x2000) {\r\n            case 0x2000: // PPUCTRL\r\n                this.io.sprite_pattern_table = (val & 8) >>> 3;\r\n                this.io.bg_pattern_table = (val & 0x10) >>> 4;\r\n                this.status.sprite_height = (val & 0x20) >>> 5 ? 16 : 8;\r\n                this.io.nmi_enable = (val & 0x80) >>> 7;\r\n                this.io.vram_increment = (val & 4) ? 32 : 1;\r\n\r\n                this.io.t = (this.io.t & 0x73FF) | ((val & 3) << 10);\r\n\r\n                this.update_nmi();\r\n                return;\r\n            case 0x2001: // PPUMASK\r\n                this.io.greyscale = val & 1;\r\n                this.io.bg_hide_left_8 = (val & 2) >>> 1;\r\n                this.io.sprite_hide_left_8 = (val & 4) >>> 2;\r\n                this.io.bg_enable = (val & 8) >>> 3;\r\n                this.io.sprite_enable = (val & 0x10) >>> 4;\r\n\r\n                this.io.emph_r = ((val & 0x20) >>> 5);\r\n                this.io.emph_g = ((val & 0x40) >>> 6);\r\n                this.io.emph_b = ((val & 0x80) >>> 7);\r\n                this.io.emph_bits = <u16>((val & 0xE0) << 1);\r\n                return;\r\n            case 0x2003: // OAMADDR\r\n                this.io.OAM_addr = val;\r\n                return;\r\n            case 0x2004: // OAMDATA\r\n                this.OAM[this.io.OAM_addr] = val;\r\n                this.io.OAM_addr = (this.io.OAM_addr + 1) & 0xFF;\r\n                return;\r\n            case 0x2005: // PPUSCROLL\r\n                if (this.io.w === 0) {\r\n                    this.io.x = val & 7;\r\n                    this.io.t = (this.io.t & 0x7FE0) | (val >>> 3);\r\n                    this.io.w = 1;\r\n                } else {\r\n                    this.io.t = (this.io.t & 0x0C1F) | ((val & 0xF8) << 2) | ((val & 7) << 12);\r\n                    this.io.w = 0;\r\n                }\r\n                //console.log('AS PPUSCROLL ON LINE ' + this.clock.ppu_y.toString() + ': ' + val.toString() + ', ' + this.io.t.toString());\r\n                return;\r\n            case 0x2006: // PPUADDR\r\n                if (this.io.w === 0) {\r\n                    this.io.t = (this.io.t & 0xFF) | ((val & 0x3F) << 8);\r\n                    this.io.w = 1;\r\n                } else {\r\n                    this.io.t = (this.io.t & 0x7F00) | val;\r\n                    this.w2006_buffer.set((this.clock.ppu_master_clock / this.clock.timing.ppu_divisor) + (3 * this.clock.timing.ppu_divisor), this.io.t);\r\n                    this.io.w = 0;\r\n                }\r\n                return;\r\n            case 0x2007: // PPUDATA\r\n                if (this.rendering_enabled() && ((this.clock.ppu_y < this.clock.timing.vblank_start) || (this.clock.ppu_y > this.clock.timing.vblank_end))) {\r\n                    console.log('REJECT WRITE ' + this.clock.ppu_y.toString() + ' ' + this.io.sprite_enable.toString() + ' ' + this.io.bg_enable.toString() + ' ' + this.io.v.toString(16) + ' ' + val.toString(16));\r\n                    return;\r\n                }\r\n                this.mem_write(this.io.v, val);\r\n                this.io.v = (this.io.v + this.io.vram_increment) & 0x7FFF;\r\n                this.bus.mapper.a12_watch(this.io.v & 0x3FFF);\r\n                return;\r\n        }\r\n    }\r\n}","/*\r\nexport interface systemEmulator {\r\n    //serialize(): funcref,\r\n    //deserialize()\r\n    get_description(): machine_description;\r\n    get_screenvars(): Uint32Array;\r\n    finish_frame(): void;\r\n    finish_scanline(): void;\r\n    update_inputs(): void;\r\n    step_master(cycles: u32): void;\r\n    reset(): void;\r\n    load_ROM(): void;\r\n    load_BIOS(): void;\r\n}\r\n\r\n */\r\n\r\n\r\nimport {NES_bus, NES_clock} from \"../nes_common\";\r\nimport {NES_cart} from \"../nes_cart\";\r\n\r\nexport enum NES_PPU_mirror_modes {\r\n    Horizontal,\r\n    Vertical,\r\n    FourWay,\r\n    ScreenAOnly,\r\n    ScreenBOnly\r\n}\r\n\r\n\r\nexport enum NES_a12_watcher_edge {\r\n    nothing = 0,\r\n    rise,\r\n    fall\r\n}\r\n\r\nexport class NES_a12_watcher_t {\r\n    clock: NES_clock\r\n    cycles_down: u32 = 0;\r\n    last_cycle: u32 = 0;\r\n    delay: u32\r\n\r\n    constructor(clock: NES_clock) {\r\n        this.clock = clock;\r\n        this.delay = this.clock.timing.ppu_divisor * 3;\r\n    }\r\n\r\n    @inline update(addr: u32): NES_a12_watcher_edge {\r\n        let result: NES_a12_watcher_edge = NES_a12_watcher_edge.nothing;\r\n        let ppufc: u32 = this.clock.ppu_frame_cycle;\r\n        if (this.cycles_down > 0) {\r\n            if (this.last_cycle > ppufc)\r\n                this.cycles_down += (89342 - this.last_cycle) + ppufc;\r\n            else\r\n                this.cycles_down += ppufc - this.last_cycle;\r\n        }\r\n\r\n        if ((addr & 0x1000) === 0) {\r\n            if (this.cycles_down === 0) {\r\n                this.cycles_down = 1;\r\n                result = NES_a12_watcher_edge.fall;\r\n            }\r\n        }\r\n        else if (addr & 0x1000) {\r\n            if (this.cycles_down > this.delay)\r\n                result = NES_a12_watcher_edge.rise;\r\n            this.cycles_down = 0;\r\n        }\r\n        this.last_cycle = ppufc;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nexport interface NES_mapper {\r\n    cycle(howmany: u32): void; // For VRC cycle-counting IRQs\r\n    CPU_read(addr: u32, val: u32, has_effect: u32): u32;\r\n    CPU_write(addr: u32, val: u32): void;\r\n    PPU_read_effect(addr: u32): u32;\r\n    PPU_read_noeffect(addr: u32): u32;\r\n    PPU_write(addr: u32, val: u32): void;\r\n    reset(): void;\r\n    set_cart(cart: NES_cart): void;\r\n    a12_watch(addr: u32): void;\r\n}\r\n\r\nexport function NES_mirror_ppu_four(addr: u32): u32 {\r\n    return addr & 0xFFF;\r\n}\r\n\r\nexport function NES_mirror_ppu_vertical(addr: u32): u32 {\r\n    return (addr & 0x0400) | (addr & 0x03FF);\r\n}\r\n\r\nexport function NES_mirror_ppu_horizontal(addr: u32): u32 {\r\n    return ((addr >>> 1) & 0x0400) | (addr & 0x03FF);\r\n}\r\n\r\nexport function NES_mirror_ppu_Aonly(addr: u32): u32 {\r\n    return addr & 0x3FF;\r\n}\r\n\r\nexport function NES_mirror_ppu_Bonly(addr: u32): u32 {\r\n    return 0x400 | (addr & 0x3FF);\r\n}\r\n","import {\r\n    console_mt_struct,\r\n    input_map_keypoint,\r\n    machine_description,\r\n    MD_STANDARD,\r\n    MD_TIMING,\r\n    systemEmulator\r\n} from \"../interface\"\r\nimport {m6502} from \"../../component/cpu/m6502/m6502\"\r\nimport {NES_clock, NES_bus, NES_VARIANTS} from \"./nes_common\"\r\nimport {NES_ppu} from \"./nes_ppu\";\r\nimport {NES_cart} from \"./nes_cart\";\r\nimport {ricoh2A03} from \"./cpu/r2a03\";\r\nimport {dbg} from \"../../helpers/debug\";\r\nimport {framevars_t} from \"../../glue/global_player\";\r\n\r\nlet NES_inputmap: Array<input_map_keypoint> = new Array<input_map_keypoint>(16);\r\n// p1                                    p2\r\n// Up down left right a b start select\r\n\r\nfunction fill_NES_inputmap(): void {\r\n    for (let i = 0; i < 16; i++) {\r\n        let kp = new input_map_keypoint();\r\n        let uber: String = (i < 8) ? 'p1' : 'p2';\r\n        kp.internal_code = i;\r\n        kp.buf_pos = i;\r\n        kp.uber = uber;\r\n        switch(i) {\r\n            case 0:\r\n            case 8:\r\n                kp.name = 'up';\r\n                break;\r\n            case 1:\r\n            case 9:\r\n                kp.name = 'down';\r\n                break;\r\n            case 2:\r\n            case 10:\r\n                kp.name = 'left';\r\n                break;\r\n            case 3:\r\n            case 11:\r\n                kp.name = 'right';\r\n                break;\r\n            case 4:\r\n            case 12:\r\n                kp.name = 'a';\r\n                break;\r\n            case 5:\r\n            case 13:\r\n                kp.name = 'b';\r\n                break;\r\n            case 6:\r\n            case 14:\r\n                kp.name = 'start';\r\n                break;\r\n            case 7:\r\n            case 15:\r\n                kp.name = 'select';\r\n                break;\r\n        }\r\n        NES_inputmap[i] = kp;\r\n    }\r\n}\r\nfill_NES_inputmap();\r\n\r\nexport class nespad_inputs {\r\n    a: u32 = 0;\r\n    b: u32 = 0;\r\n    start: u32 = 0;\r\n    select: u32 = 0;\r\n    up: u32 = 0;\r\n    down: u32 = 0;\r\n    left: u32 = 0;\r\n    right: u32 = 0;\r\n}\r\n\r\nexport class NES implements systemEmulator {\r\n    cpu: ricoh2A03\r\n    ppu: NES_ppu\r\n    variant: NES_VARIANTS\r\n    cart: NES_cart\r\n    bus: NES_bus\r\n    clock: NES_clock\r\n    cycles_left: i32\r\n    decode_array: StaticArray<u32> = new StaticArray<u32>(16);\r\n    controller1_in: nespad_inputs = new nespad_inputs();\r\n    controller2_in: nespad_inputs = new nespad_inputs();\r\n    framevars: framevars_t = new framevars_t();\r\n\r\n    constructor(variant: NES_VARIANTS, out_buffer: usize) {\r\n        this.variant = variant\r\n        let clock: NES_clock = new NES_clock(variant);\r\n        let bus: NES_bus = new NES_bus();\r\n        let cpu = new ricoh2A03(clock, bus);\r\n        let ppu: NES_ppu = new NES_ppu(out_buffer, variant, clock, bus)\r\n        this.cart = new NES_cart(clock, bus);\r\n        bus.ppu = ppu;\r\n        bus.cpu = cpu;\r\n        this.clock = clock;\r\n        this.ppu = ppu;\r\n        this.bus = bus;\r\n        this.cpu = cpu;\r\n        this.cycles_left = 0;\r\n    }\r\n\r\n    play(): void {};\r\n    pause(): void {};\r\n    stop(): void {};\r\n    get_mt_struct(): console_mt_struct {\r\n        return new console_mt_struct();\r\n    }\r\n\r\n\r\n    map_inputs(bufptr: usize): void {\r\n        // Hardcoded yo!\r\n        this.controller1_in.up = load<u32>(bufptr);\r\n        this.controller1_in.down = load<u32>(bufptr+(4));\r\n        this.controller1_in.left = load<u32>(bufptr+(4*2));\r\n        this.controller1_in.right = load<u32>(bufptr+(4*3));\r\n        this.controller1_in.a = load<u32>(bufptr+(4*4));\r\n        this.controller1_in.b = load<u32>(bufptr+(4*5));\r\n        this.controller1_in.start = load<u32>(bufptr+(4*6));\r\n        this.controller1_in.select = load<u32>(bufptr+(4*7));\r\n        this.controller2_in.up = load<u32>(bufptr+(4*8));\r\n        this.controller2_in.down = load<u32>(bufptr+(4*9));\r\n        this.controller2_in.left = load<u32>(bufptr+(4*101));\r\n        this.controller2_in.right = load<u32>(bufptr+(4*11));\r\n        this.controller2_in.a = load<u32>(bufptr+(4*12));\r\n        this.controller2_in.b = load<u32>(bufptr+(4*13));\r\n        this.controller2_in.start = load<u32>(bufptr+(4*14));\r\n        this.controller2_in.select = load<u32>(bufptr+(4*15));\r\n        this.cpu.update_inputs(this.controller1_in, this.controller2_in);\r\n    }\r\n\r\n    get_framevars(): framevars_t {\r\n        this.framevars.master_frame = this.clock.master_frame;\r\n        this.framevars.x = this.ppu.line_cycle;\r\n        this.framevars.scanline = this.clock.ppu_y;\r\n        return this.framevars;\r\n    }\r\n\r\n    get_description(): machine_description {\r\n        let d = new machine_description();\r\n        d.name = 'Nintendo Entertainment System';\r\n        d.fps = 60;\r\n        d.timing = MD_TIMING.frame;\r\n        d.standard = MD_STANDARD.NTSC;\r\n        d.x_resolution = 256;\r\n        d.y_resolution = 240;\r\n        d.xrh = 8;\r\n        d.xrw = 7;\r\n\r\n        d.overscan.top = 8;\r\n        d.overscan.bottom = 8;\r\n        d.overscan.left = 8;\r\n        d.overscan.right = 8;\r\n\r\n        d.out_size = (256*240*2);\r\n\r\n        for (let i = 0, k = NES_inputmap.length; i < k; i++) {\r\n            d.keymap.push(NES_inputmap[i]);\r\n        }\r\n        return d;\r\n    }\r\n\r\n    killall(): void {\r\n\r\n    }\r\n\r\n    finish_frame(): u32 {\r\n        let current_frame: u64 = this.clock.master_frame;\r\n        while (this.clock.master_frame === current_frame) {\r\n            this.finish_scanline();\r\n            if (dbg.do_break) break;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    finish_scanline(): u32 {\r\n        let cpu_step: u32 = this.clock.timing.cpu_divisor;\r\n        let ppu_step: u32 = this.clock.timing.ppu_divisor;\r\n        let done: u32 = 0;\r\n        let start_y: u32 = this.clock.ppu_y;\r\n        while (this.clock.ppu_y === start_y) {\r\n            this.clock.master_clock += cpu_step;\r\n            this.cpu.run_cycle();\r\n            this.bus.mapper.cycle(1);\r\n            this.clock.cpu_frame_cycle++;\r\n            this.clock.cpu_master_clock += cpu_step;\r\n            let ppu_left = this.clock.master_clock - this.clock.ppu_master_clock;\r\n            done = 0;\r\n            while (ppu_left >= ppu_step) {\r\n                ppu_left -= ppu_step;\r\n                done++;\r\n            }\r\n            this.ppu.cycle(done);\r\n            this.cycles_left -= cpu_step;\r\n            if (dbg.do_break) break;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    step_master(cycles: u32): u32 {\r\n        console.log('MASTER STEPS NOT SUPPORTED NES AS YET');\r\n        return 0;\r\n    }\r\n\r\n    reset(): void {\r\n        this.cpu.reset();\r\n        //this.ppu.reset();\r\n        this.clock.reset();\r\n        this.cart.reset();\r\n    }\r\n\r\n    // NES has no BIOS\r\n    load_BIOS(what: usize, sz: u32): void {\r\n    }\r\n\r\n    load_ROM(name: string, what: usize, sz: u32): void {\r\n        this.cart.load_cart_from_RAM(what, sz);\r\n        this.reset();\r\n    }\r\n}","import {systemEmulatorStandardClock} from \"../interface\";\r\nimport {NES_ppu} from \"./nes_ppu\"\r\nimport {NES_a12_watcher_t, NES_mapper} from \"./mappers/interface\";\r\nimport {NES_cart} from \"./nes_cart\";\r\nimport {ricoh2A03} from \"./cpu/r2a03\";\r\n\r\nexport enum NES_TIMINGS {\r\n    NTSC = 0,\r\n    PAL,\r\n    DENDY\r\n}\r\n\r\nexport enum NES_VARIANTS {\r\n    NTSCU = 0,\r\n    NTSCJ,\r\n    PAL,\r\n    DENDY\r\n}\r\n\r\nexport class NES_bus {\r\n    @inline PPU_read_effect(addr: u32): u32 {\r\n        return this.mapper.PPU_read_effect(addr);\r\n    }\r\n\r\n    @inline PPU_read_noeffect(addr: u32): u32 {\r\n        return this.mapper.PPU_read_noeffect(addr);\r\n    }\r\n\r\n    PPU_write(addr: u32, val: u32): void {\r\n        this.mapper.PPU_write(addr, val);\r\n    }\r\n\r\n    CPU_read(addr: u32, val: u32, has_effect: u32 = 1): u32 {\r\n        return this.mapper.CPU_read(addr, val, has_effect);\r\n    }\r\n\r\n    CPU_write(addr: u32, val: u32): void {\r\n        this.mapper.CPU_write(addr, val);\r\n    }\r\n\r\n    PPU_reg_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        return this.ppu.reg_read(addr, val);\r\n    }\r\n\r\n    PPU_reg_write(addr: u32, val: u32): void {\r\n        this.ppu.reg_write(addr, val);\r\n    }\r\n\r\n    CPU_reg_read(addr: u32, val: u32, has_effect: u32 = 1): u32 {\r\n        return this.cpu.reg_read(addr, val, has_effect);\r\n    }\r\n\r\n    CPU_reg_write(addr: u32, val: u32): void {\r\n        this.cpu.reg_write(addr, val);\r\n    }\r\n\r\n    CPU_notify_NMI(level: u32): void {\r\n        this.cpu.notify_NMI(level);\r\n    }\r\n\r\n    CPU_notify_IRQ(level: u32): void {\r\n        this.cpu.notify_IRQ(level);\r\n    }\r\n\r\n\r\n    mapper!: NES_mapper\r\n    ppu!: NES_ppu\r\n    cpu!: ricoh2A03\r\n\r\n    constructor() {\r\n    }\r\n}\r\n\r\nclass NES_timing {\r\n    variant: NES_VARIANTS\r\n    frame_lines: u32 = 262  // NTSC defaults values\r\n    cpu_divisor: u32 = 12\r\n    ppu_divisor: u32 = 4\r\n    bottom_rendered_line: u32 = 239\r\n    post_render_ppu_idle: u32 = 240\r\n    vblank_start: u32 = 241\r\n    vblank_end: u32 = 261\r\n    ppu_pre_render: u32 = 261\r\n\r\n    constructor(variant: NES_VARIANTS) {\r\n        this.variant = variant;\r\n        this.set_variant();\r\n    }\r\n\r\n    set_variant(): void {\r\n        this.post_render_ppu_idle = 240;\r\n        this.vblank_start = 241;\r\n        this.vblank_end = 261;\r\n        this.ppu_pre_render = 261;\r\n        switch(this.variant) {\r\n            case NES_VARIANTS.NTSCU:\r\n            case NES_VARIANTS.NTSCJ:\r\n                this.bottom_rendered_line = 239;\r\n                this.frame_lines = 262;\r\n                this.cpu_divisor = 12;\r\n                this.ppu_divisor = 4;\r\n                break;\r\n            case NES_VARIANTS.PAL:\r\n                this.bottom_rendered_line = 238;\r\n                this.frame_lines = 312;\r\n                this.cpu_divisor = 16;\r\n                this.ppu_divisor = 5;\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nexport class NES_clock implements systemEmulatorStandardClock {\r\n    master_clock: u64 = 0     // Master clock cycles since restart\r\n    master_frame: u64 = 0\r\n    cpu_master_clock: u64 = 0 // CPU's clock\r\n    ppu_master_clock: u64 = 0 // PPU's clock\r\n    trace_cycles: u64 = 0\r\n    frames_since_restart: u64 = 0\r\n\r\n    cpu_frame_cycle: u32 = 0\r\n    ppu_frame_cycle: u32 = 0\r\n    timing: NES_timing\r\n    variant: NES_VARIANTS\r\n    ppu_y: u32 = 0\r\n    frame_odd: u32 = 0\r\n    vblank: u32 = 0\r\n\r\n    constructor(variant: NES_VARIANTS) {\r\n        this.variant = variant;\r\n        this.timing = new NES_timing(variant);\r\n        this.reset();\r\n    }\r\n\r\n    reset(): void {\r\n        this.cpu_master_clock = 0;\r\n        this.ppu_master_clock = 0;\r\n        this.ppu_y = 0;\r\n        this.master_clock = 0;\r\n        this.master_frame = 0;\r\n        this.trace_cycles = 0;\r\n        this.frames_since_restart = 0;\r\n        this.cpu_frame_cycle = 0;\r\n        this.ppu_frame_cycle = 0;\r\n        this.ppu_y = 0;\r\n        this.frame_odd = 0;\r\n    }\r\n\r\n}\r\n","\"use strict\";\r\n\r\nimport {GB_bus, GB_clock, GBmappernull} from \"./gb\";\r\nimport {GB_variants} from \"./gb_common\";\r\nimport {GB_mapper} from \"./mappers/interface\";\r\nimport {heapArray} from \"../nes/nes_cart\";\r\nimport {GB_mapper_none} from \"./mappers/nomapper\";\r\nimport {hex2} from \"../../helpers/helpers\";\r\nimport {GB_mapper_MBC1} from \"./mappers/mbc1\";\r\nimport {GB_mapper_MBC2} from \"./mappers/mbc2\";\r\nimport {GB_mapper_MBC3} from \"./mappers/mbc3\";\r\nimport {GB_mapper_MBC5} from \"./mappers/mbc5\";\r\n\r\nconst GB_QUICK_BOOT = true;\r\n\r\n// number of 16KB banks\r\nconst GB_ROMBANKS: Map<u32, u32> = new Map<u32, u32>();\r\nGB_ROMBANKS.set(0, 0);\r\nGB_ROMBANKS.set(1, 4);\r\nGB_ROMBANKS.set(2, 8);\r\nGB_ROMBANKS.set(3, 16);\r\nGB_ROMBANKS.set(4, 32);\r\nGB_ROMBANKS.set(5, 64);\r\nGB_ROMBANKS.set(6, 128);\r\nGB_ROMBANKS.set(7, 256);\r\nGB_ROMBANKS.set(8, 512);\r\nGB_ROMBANKS.set(0x52, 72);\r\nGB_ROMBANKS.set(0x53, 80);\r\nGB_ROMBANKS.set(0x54, 96);\r\n\r\nexport enum GB_MAPPERS {\r\n    none,\r\n    MBC1,\r\n    MBC2,\r\n    MMM01,\r\n    MBC3,\r\n    MBC5,\r\n    MBC6,\r\n    MBC7,\r\n    POCKET_CAMERA,\r\n    BANDAI_TAMA5,\r\n    HUC3,\r\n    HUC1\r\n}\r\n\r\nclass GB_cart_header {\r\n    ROM_banks: u32 = 0;\r\n    ROM_size: u32 = 0;\r\n    RAM_size: u32 = 0;\r\n    RAM_banks: u32 = 0;\r\n    RAM_mask: u32 = 0;\r\n    mapper: GB_MAPPERS = GB_MAPPERS.none;\r\n    ram_present: u32 = 0;\r\n    battery_present: u32 = 0;\r\n    timer_present: u32 = 0;\r\n    rumble_present: u32 = 0;\r\n    sensor_present: u32 = 0;\r\n    sgb_functions: u32 = 0;\r\n    gb_compatible: u32 = 0;\r\n    cgb_compatible: u32 = 0;\r\n\r\n}\r\n\r\nexport class GB_cart {\r\n    variant: GB_variants;\r\n    clock: GB_clock;\r\n    bus: GB_bus;\r\n\r\n    ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    mapper: GB_mapper\r\n    header: GB_cart_header\r\n\r\n    constructor(variant: GB_variants, clock: GB_clock, bus: GB_bus) {\r\n        this.variant = variant;\r\n        this.bus = bus;\r\n        this.clock = clock;\r\n\r\n        this.header = new GB_cart_header();\r\n        this.mapper = new GBmappernull();\r\n    }\r\n\r\n    load_ROM_from_RAM(ibuf: usize, sz: u32): void {\r\n        let inp: heapArray = new heapArray(ibuf, sz);\r\n\r\n        // Look for header\r\n        // @ts-ignore\r\n        if ((inp[0x104] !== 0xCE) || (inp[0x105] !== 0xED)) {\r\n            console.log('Did not detect Nintendo header');\r\n            return;\r\n        }\r\n\r\n        // @ts-ignore\r\n        this.header.ROM_banks = GB_ROMBANKS.get(inp[0x0148]);\r\n        this.header.ROM_size = (this.header.ROM_banks ? (this.header.ROM_banks * 16384) : 32768);\r\n        console.log(this.header.ROM_size.toString());\r\n        this.ROM = new StaticArray<u8>(this.header.ROM_size);\r\n\r\n        // @ts-ignore\r\n        switch(inp[0x149]) {\r\n            case 0:\r\n                this.header.RAM_size = 0;\r\n                this.header.RAM_banks = 0;\r\n                this.header.RAM_mask = 0;\r\n                break;\r\n            case 1:\r\n                this.header.RAM_size = 2048;\r\n                this.header.RAM_mask = 0x7FF;\r\n                this.header.RAM_banks = 0;\r\n                break;\r\n            case 2:\r\n                this.header.RAM_mask = 0x1FFF;\r\n                this.header.RAM_size = 8192;\r\n                this.header.RAM_banks = 0;\r\n                break;\r\n            case 3:\r\n                this.header.RAM_mask = 0x1FFF;\r\n                this.header.RAM_size = 32768;\r\n                this.header.RAM_banks = 4;\r\n                break;\r\n            case 4:\r\n                this.header.RAM_mask = 0x1FFF;\r\n                this.header.RAM_size = 131072;\r\n                this.header.RAM_banks = 16;\r\n                break;\r\n            case 5:\r\n                this.header.RAM_mask = 0x1FFF;\r\n                this.header.RAM_size = 65536;\r\n                this.header.RAM_banks = 8;\r\n                break;\r\n            default:\r\n                // @ts-ignore\r\n                console.log('UNKNOWN RAM SIZE ' + inp[0x149].toString())\r\n                break;\r\n        }\r\n\r\n        this.header.battery_present = 0;\r\n        this.header.timer_present = 0;\r\n        this.header.rumble_present = 0;\r\n        this.header.sensor_present = 0;\r\n        // @ts-ignore\r\n        let mn: u32 = inp[0x0147];\r\n        this.header.mapper = GB_MAPPERS.none;\r\n        console.log('MAPPER ' + hex2(mn))\r\n        switch(mn) {\r\n            case 0:\r\n                this.header.mapper = GB_MAPPERS.none;\r\n                break;\r\n            case 1: // MBC1\r\n            case 2: // MBC1+RAM\r\n            case 3: // MBC1+RAM+BATTERY\r\n                this.header.mapper = GB_MAPPERS.MBC1;\r\n                break;\r\n            case 6: // MBC2+BATTERY\r\n            case 5: // MBC2\r\n                this.header.mapper = GB_MAPPERS.MBC2;\r\n                break;\r\n            case 0x0D:\r\n            case 0x0C:\r\n            case 0x0B: // MMM01\r\n                this.header.mapper = GB_MAPPERS.MMM01;\r\n                break;\r\n            case 0x0F: // MMBC3+TIMER+BATTERY\r\n            case 0x10: // MMBC3+TIMER+RAM+BATTERY\r\n            case 0x11: // MMBC3\r\n            case 0x12: // MMBC3+RAM\r\n            case 0x13: // MMBC3+RAM+BATTERY\r\n                this.header.mapper = GB_MAPPERS.MBC3;\r\n                break;\r\n            case 0x19:\r\n            case 0x1A:\r\n            case 0x1B:\r\n            case 0x1C:\r\n            case 0x1D:\r\n            case 0x1E:\r\n                this.header.mapper = GB_MAPPERS.MBC5;\r\n                break;\r\n            case 0x20:\r\n                this.header.mapper = GB_MAPPERS.MBC6;\r\n                break;\r\n            case 0x22:\r\n                this.header.mapper = GB_MAPPERS.MBC7;\r\n                break;\r\n            case 0xFC:\r\n                this.header.mapper = GB_MAPPERS.POCKET_CAMERA;\r\n                break;\r\n            case 0xFD:\r\n                this.header.mapper = GB_MAPPERS.BANDAI_TAMA5;\r\n                break;\r\n            case 0xFE:\r\n                this.header.mapper = GB_MAPPERS.HUC3;\r\n                break;\r\n            case 0xFF:\r\n                this.header.mapper = GB_MAPPERS.HUC1;\r\n                break;\r\n            default:\r\n                console.log('Unrecognized mapper ' + hex2(mn));\r\n                return;\r\n        }\r\n\r\n        switch(mn) {\r\n            case 0x02: // MBC1+RAM\r\n                this.header.ram_present = 1;\r\n                break;\r\n            case 0x03: // MBC1+RAM+BATTERY\r\n                this.header.battery_present = 1;\r\n                this.header.ram_present = 1;\r\n                break;\r\n            case 0x06: // MBC2+BATTERY\r\n                this.header.battery_present = 1;\r\n                break;\r\n            // @ts-ignore\r\n            case 0x08: // ROM+RAM\r\n                this.header.ram_present = 1;\r\n                break;\r\n            // @ts-ignore\r\n            case 0x09: // ROM+RAM+BATTERY\r\n                this.header.battery_present = 1;\r\n                this.header.ram_present = 1;\r\n                break;\r\n            case 0x0C: // MMM01+RAM\r\n                this.header.ram_present = 1;\r\n                break;\r\n            case 0x0D: // MMM01+RAM+BATTERY\r\n                this.header.battery_present = 1;\r\n                this.header.ram_present = 1;\r\n                break;\r\n            case 0x0F: // MMBC3+TIMER+BATTERY\r\n                this.header.timer_present = 1;\r\n                this.header.battery_present = 1;\r\n                break;\r\n            case 0x10: // MMBC3+TIMER+RAM+BATTERY\r\n                this.header.timer_present = 1;\r\n                this.header.battery_present = 1;\r\n                this.header.ram_present = 1;\r\n                break;\r\n            case 0x12: // MMBC3+RAM\r\n                this.header.ram_present = 1;\r\n                break;\r\n            case 0x13: // MMBC3+RAM+BATTERY\r\n                this.header.ram_present = 1;\r\n                this.header.battery_present = 1;\r\n                break;\r\n            case 0x1A: // +RAM\r\n                this.header.ram_present = 1;\r\n                break;\r\n            case 0x1B: // +RAM+BATTERY\r\n                this.header.ram_present = 1;\r\n                this.header.battery_present = 1;\r\n                break;\r\n            case 0x1C: // +RUMBLE\r\n                this.header.rumble_present = 1;\r\n                break;\r\n            case 0x1D: // +RUMBLE+RAM\r\n                this.header.rumble_present = 1;\r\n                this.header.ram_present = 1;\r\n                break;\r\n            case 0x1E: // +RUMBLE+RAM+BATTERY\r\n                this.header.rumble_present = 1;\r\n                this.header.ram_present = 1;\r\n                this.header.battery_present = 1;\r\n                break;\r\n            case 0x22: // +SENSOR+RUMBLE+RAM+BATTERY\r\n                this.header.rumble_present = 1;\r\n                this.header.ram_present = 1;\r\n                this.header.battery_present = 1;\r\n                this.header.sensor_present = 1;\r\n                break;\r\n            case 0xFF: // +RAM+BATTERY\r\n                this.header.ram_present = 1;\r\n                this.header.battery_present = 1;\r\n                break;\r\n        }\r\n        this.read_ROM(inp);\r\n        this.setup_mapper();\r\n    }\r\n\r\n    read_ROM(inp: heapArray): void {\r\n\t\t//this.ROM.set(inp.slice(0, this.header.ROM_size));\r\n        for (let i: u32 = 0, k: u32 = this.header.ROM_size; i < k; i++) {\r\n            // @ts-ignore\r\n            this.ROM[i] = inp[i];\r\n        }\r\n    }\r\n\r\n    setup_mapper(): void {\r\n        switch(this.header.mapper) {\r\n            case GB_MAPPERS.none:\r\n                console.log('TRYING TO DO NONE!');\r\n                this.mapper = new GB_mapper_none(this.clock, this.bus);\r\n                break;\r\n            case GB_MAPPERS.MBC1:\r\n                this.mapper = new GB_mapper_MBC1(this.clock, this.bus);\r\n                break;\r\n            case GB_MAPPERS.MBC2:\r\n                this.mapper = new GB_mapper_MBC2(this.clock, this.bus);\r\n                break;\r\n            case GB_MAPPERS.MBC3:\r\n                this.mapper = new GB_mapper_MBC3(this.clock, this.bus);\r\n                break;\r\n            case GB_MAPPERS.MBC5:\r\n                this.mapper = new GB_mapper_MBC5(this.clock, this.bus);\r\n                break;\r\n            default:\r\n                console.log('UNSUPPORTED MAPPER SO FAR ' + hex2(this.header.mapper));\r\n                return;\r\n        }\r\n        //this.bus.load_bios(this.bios);\r\n        this.bus.mapper = this.mapper;\r\n        this.mapper.set_cart(this, this.bus.BIOS);\r\n    }\r\n}\r\n\r\n","\"use strict\";\r\n\r\nimport {GB_mapper} from \"./interface\";\r\nimport {GB_bus, GB_clock} from \"../gb\";\r\nimport {GB_cart} from \"../gb_cart\";\r\nimport {GB_variants} from \"../gb_common\";\r\n\r\nconst RTC_START_TIME = 1000 * 1668634714;\r\n\r\nclass GB_mapper_MBC3_regs {\r\n    ext_RAM_enable: bool = false\r\n    ROM_bank_lo: u32 = 0\r\n    ROM_bank_hi: u32 = 1\r\n    RAM_bank: u32 = 0\r\n    last_RTC_latch_write: u32 = 0xFF\r\n    RTC_latched: Uint16Array = new Uint16Array(5) // addr - 0x08\r\n    RTC_start: u32 = 0\r\n}\r\n\r\nexport class GB_mapper_MBC3 implements GB_mapper {\r\n    clock: GB_clock\r\n    bus: GB_bus\r\n    ROM: StaticArray<u8> = new StaticArray<u8>(0)\r\n    BIOS_big: u32 = 0;\r\n    ROM_bank_offset_hi: u32 = 16384;\r\n    RAM_bank_offset: u32 = 0;\r\n    ROM_bank_offset_lo: u32 = 0;\r\n    num_ROM_banks: u32 = 0;\r\n    num_RAM_banks: u32 = 0;\r\n    VRAM_bank_offset: u32 = 0;\r\n    WRAM_bank_offset: u32 = 0x1000;\r\n    cartRAM: StaticArray<u8> = new StaticArray<u8>(0)\r\n    WRAM: StaticArray<u8> = new StaticArray<u8>(8192*8)\r\n    HRAM: StaticArray<u8> = new StaticArray<u8>(128)\r\n    VRAM: StaticArray<u8> = new StaticArray<u8>(32768);\r\n    BIOS: StaticArray<u8> = new StaticArray<u8>(0);\r\n    cart: GB_cart\r\n\r\n    RAM_mask: u32 = 0\r\n    has_RAM: bool = false;\r\n\r\n    regs: GB_mapper_MBC3_regs = new GB_mapper_MBC3_regs()\r\n\r\n    constructor(clock: GB_clock, bus: GB_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n\r\n        this.cart = new GB_cart(GB_variants.DMG, clock, bus);\r\n        this.bus.mapper = this;\r\n\r\n    }\r\n\r\n    reset(): void {\r\n        // This changes on other mappers for banking\r\n        this.ROM_bank_offset_hi = 16384;\r\n        // This changes on CGB\r\n        this.VRAM_bank_offset = 0;\r\n        // This changes on CGB\r\n        this.WRAM_bank_offset = 0x1000;\r\n\r\n\r\n        this.regs.ext_RAM_enable = false;\r\n        this.regs.ROM_bank_hi = 1;\r\n        this.regs.ROM_bank_lo = 0;\r\n        this.ROM_bank_offset_lo = 0;\r\n        this.regs.RAM_bank = 0;\r\n        this.RAM_bank_offset = 0;\r\n        this.regs.last_RTC_latch_write = 0xFF;\r\n    }\r\n\r\n    latch_RTC(): void {\r\n        console.log('NO RTC LATCH YET!')\r\n    }\r\n\r\n    remap(): void {\r\n        this.regs.ROM_bank_hi %= this.num_ROM_banks;\r\n\r\n        this.ROM_bank_offset_hi = this.regs.ROM_bank_hi * 16384;\r\n        let rb: u32 = this.regs.RAM_bank;\r\n        if (this.cart.header.timer_present) {\r\n            if ((this.regs.RAM_bank <= 3) && this.has_RAM) this.regs.RAM_bank %= this.num_RAM_banks;\r\n            if (rb <= 3) {\r\n                if (this.has_RAM) this.RAM_bank_offset = rb * 8192;\r\n            } else {\r\n                console.log('SET TO RTC! ' + rb.toString());\r\n                // RTC registers handled during read/write ops to the area\r\n            }\r\n        }\r\n        else {\r\n            if ((this.regs.RAM_bank <= 3) && this.has_RAM) this.regs.RAM_bank %= this.num_RAM_banks;\r\n            if (this.has_RAM) this.RAM_bank_offset = this.regs.RAM_bank * 8192;\r\n        }\r\n    }\r\n\r\n    CPU_read(addr: u32, val: u32): u32 {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (this.clock.bootROM_enabled) {\r\n            if (addr < 0x100)\r\n                return this.bus.BIOS[addr];\r\n            if (this.BIOS_big && (addr >= 0x200) && (addr < 0x900))\r\n                return this.bus.BIOS[addr - 0x100];\r\n        }\r\n        if (addr < 0x4000) // ROM lo bank\r\n            return this.ROM[(addr & 0x3FFF) + this.ROM_bank_offset_lo];\r\n        if (addr < 0x8000) // ROM hi bank\r\n            return this.ROM[(addr & 0x3FFF) + this.ROM_bank_offset_hi];\r\n        if (addr < 0xA000) { // VRAM, banked\r\n            if (this.clock.CPU_can_VRAM)\r\n                return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n            return 0xFF;\r\n        } // cart RAM if it's there\r\n        if (addr < 0xC000) {\r\n            if (!this.has_RAM) return 0xFF;\r\n            if (this.regs.RAM_bank < 4)\r\n                return this.cartRAM[(addr & 0x1FFF) + this.RAM_bank_offset];\r\n            else if ((this.regs.RAM_bank >= 8) && (this.regs.RAM_bank <= 0x0C) && this.cart.header.timer_present) {\r\n                return this.regs.last_RTC_latch_write;\r\n            }\r\n            return 0xFF;\r\n        }\r\n        // Adjust address for mirroring\r\n        if (addr < 0xD000) // WRAM lo bank\r\n            return this.WRAM[addr & 0xFFF];\r\n        if (addr < 0xE000) // WRAM hi bank\r\n            return this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset];\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.read_OAM(addr);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_read_IO(addr, val);\r\n        if (addr < 0xFFFF) // HRAM always accessible\r\n            return this.HRAM[addr - 0xFF80];\r\n        return this.bus.CPU_read_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    CPU_write(addr: u32, val: u32): void {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (addr < 0x8000) { // ROMs {\r\n            switch(addr & 0xE000) {\r\n                case 0x0000: // RAM and timer enable, write-only\r\n                    // A on, 0 off\r\n                    this.regs.ext_RAM_enable = val === 0x0A;\r\n                    return;\r\n                case 0x2000: // 16KB hi ROM bank number, 7 bits. 0 = 1, otherwise it's normal.\r\n                             // extended to 4MB 8 bits\r\n                    val &= 0xFF;\r\n                    if (val === 0) val = 1;\r\n                    this.regs.ROM_bank_hi = val;\r\n                    this.remap();\r\n                    return;\r\n                case 0x4000: // RAM bank, 0-3. 8-C maps RTC in the same range\r\n                    this.regs.RAM_bank = val & 0x0F;\r\n                    this.remap();\r\n                    return;\r\n                case 0x6000: // Write 0 then 1 to latch RTC clock data, no effect if no clock\r\n                    if ((this.regs.last_RTC_latch_write === 0) && (val === 1))\r\n                        this.latch_RTC();\r\n                    this.regs.last_RTC_latch_write = val;\r\n                    return;\r\n            }\r\n        }\r\n\r\n        if (addr < 0xA000) { // VRAM\r\n            if (this.clock.CPU_can_VRAM)\r\n                this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xC000) { // cart RAM\r\n            if (!this.has_RAM) return;\r\n            if (this.regs.RAM_bank < 4)\r\n                this.cartRAM[(addr & 0x1FFF) + this.RAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n\r\n        if (addr < 0xD000) { // WRAM lo bank\r\n            this.WRAM[addr & 0xFFF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xE000) { // WRAM hi bank\r\n            this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.write_OAM(addr, val);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_write_IO(addr, val);\r\n        if (addr < 0xFFFF) { // HRAM always accessible\r\n            this.HRAM[addr - 0xFF80] = <u8>val;\r\n            return;\r\n        }\r\n        this.bus.CPU_write_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    PPU_read(addr: u32): u32 {\r\n        if ((addr < 0x8000) || (addr > 0x9FFF)) return 0xFF;\r\n        return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n    }\r\n\r\n    set_cart(cart: GB_cart, BIOS: Uint8Array): void {\r\n       console.log('Loading MBC3 cart')\r\n        this.cart = cart;\r\n        this.cart = cart;\r\n        this.BIOS = new StaticArray<u8>(BIOS.byteLength);\r\n        for (let i = 0, k = BIOS.byteLength; i < k; i++) {\r\n            this.BIOS[i] = BIOS[i];\r\n        }\r\n        this.BIOS_big = +(BIOS.byteLength > 256);\r\n        this.ROM = new StaticArray<u8>(cart.header.ROM_size);\r\n        for (let i: u32 = 0, k: u32 = cart.header.ROM_size; i < k; i++) {\r\n            this.ROM[i] = cart.ROM[i];\r\n        }\r\n        this.num_ROM_banks = cart.header.ROM_size >>> 14;\r\n        this.cartRAM = new StaticArray<u8>(cart.header.RAM_size);\r\n        this.num_ROM_banks = cart.header.ROM_size / 16384;\r\n        this.RAM_mask = cart.header.RAM_mask;\r\n        this.has_RAM = cart.header.RAM_size > 0;\r\n        this.num_RAM_banks = cart.header.RAM_size / 8192;\r\n    }\r\n}","\"use strict\";\r\n\r\nimport {GB_variants} from \"./gb_common\";\r\nimport {GB_bus, GB_clock, gb_inputs} from \"./gb\";\r\nimport {SM83_regs_t, SM83_t} from \"../../component/cpu/sm83/sm83\";\r\nimport {SM83_S_DECODE} from \"../../component/cpu/sm83/sm83_opcodes\";\r\n\r\nclass GB_timer {\r\n    TIMA: u32 = 0\r\n    TMA: u32 = 0\r\n    TAC: u32 = 0\r\n    last_bit: u32 = 0\r\n    TIMA_reload_cycle: bool = false\r\n    SYSCLK: u32 = 0\r\n    cycles_til_TIMA_IRQ: u32 = 0\r\n\r\n    cpu_regs: SM83_regs_t\r\n\r\n    constructor(cpu_regs: SM83_regs_t) {\r\n        this.SYSCLK = 0;\r\n\r\n        this.cycles_til_TIMA_IRQ = 0;\r\n\r\n        this.cpu_regs = cpu_regs\r\n    }\r\n\r\n    // Increment 1 state\r\n    inc(): void {\r\n        this.TIMA_reload_cycle = false;\r\n        if (this.cycles_til_TIMA_IRQ > 0) {\r\n            this.cycles_til_TIMA_IRQ--;\r\n            if (this.cycles_til_TIMA_IRQ === 0) {\r\n                this.cpu_regs.IF |= 4;\r\n                this.TIMA = this.TMA;\r\n                this.TIMA_reload_cycle = true\r\n            }\r\n        }\r\n        this.SYSCLK_change((this.SYSCLK + 4) & 0xFFFF);\r\n    }\r\n\r\n    SYSCLK_change(new_value: u32): void {\r\n        // 00 = bit 9, lowest speed, /1024  4096 hz   & 0x200\r\n        // 01 = bit 3,               /16  262144 hz   & 0x08\r\n        // 10 = bit 5,               /64  65536 hz    & 0x20\r\n        // 11 = bit 7,              /256  16384 hz    & 0x80\r\n        this.SYSCLK = new_value;\r\n        let this_bit: u32 = 0;\r\n        switch(this.TAC & 3) {\r\n            case 0: // using bit 9\r\n                this_bit = (this.SYSCLK & 0x200) >>> 9;\r\n                break;\r\n            case 3: // using bit 7\r\n                this_bit = (this.SYSCLK & 0x80) >>> 7;\r\n                break;\r\n            case 2: // using bit 5\r\n                this_bit = (this.SYSCLK & 0x20) >>> 5;\r\n                break;\r\n            case 1: // using bit 3\r\n                this_bit = (this.SYSCLK & 0x08) >>> 3;\r\n                break;\r\n        }\r\n        this_bit &= ((this.TAC & 4) >>> 2);\r\n\r\n        // Detect falling edge...\r\n        if ((this.last_bit === 1) && (this_bit === 0)) {\r\n            this.TIMA = (this.TIMA + 1) & 0xFF; // Increment TIMA\r\n            if (this.TIMA === 0) { // If we overflow, schedule IRQ\r\n                this.cycles_til_TIMA_IRQ = 1;\r\n            }\r\n        }\r\n        this.last_bit = this_bit;\r\n    }\r\n\r\n    write_IO(addr: u32, val: u32): void {\r\n        switch(addr) {\r\n            case 0xFF04: // DIV, which is upper 8 bits of SYSCLK\r\n                this.SYSCLK_change(0);\r\n                break;\r\n            case 0xFF05: // TIMA, the timer counter\r\n                this.TIMA = val;\r\n                // \"During the strange cycle [A] you can prevent the IF flag from being set and prevent the TIMA from being reloaded from TMA by writing a value to TIMA. That new value will be the one that stays in the TIMA register after the instruction. Writing to DIV, TAC or other registers wont prevent the IF flag from being set or TIMA from being reloaded.\"\r\n                if (this.cycles_til_TIMA_IRQ === 1) this.cycles_til_TIMA_IRQ = 0;\r\n                break;\r\n            case 0xFF06: // TMA, the timer modulo\r\n                // \"If TMA is written the same cycle it is loaded to TIMA [B], TIMA is also loaded with that value.\"\r\n                if (this.TIMA_reload_cycle) this.TIMA = val;\r\n                this.TMA = val;\r\n                break;\r\n            case 0xFF07: // TAC, the timer control\r\n                this.TAC = val;\r\n                break;\r\n        }\r\n    }\r\n\r\n    read_IO(addr: u32): u32 {\r\n        switch(addr) {\r\n            case 0xFF04: // DIV, upper 8 bits of SYSCLK\r\n                return (this.SYSCLK & 0xFF00) >>> 8;\r\n            case 0xFF05:\r\n                return this.TIMA;\r\n            case 0xFF06:\r\n                return this.TMA;\r\n            case 0xFF07:\r\n                return this.TAC;\r\n        }\r\n        return 0xFF;\r\n    }\r\n}\r\n\r\nclass GB_CPU_io_JOYP {\r\n    action_select: u32 = 0\r\n    direction_select: u32 = 0\r\n}\r\n\r\nclass GB_CPU_io {\r\n    JOYP: GB_CPU_io_JOYP = new GB_CPU_io_JOYP();\r\n}\r\n\r\nclass GB_CPU_dma {\r\n    cycles_til: u32 = 0\r\n    new_high: u32 = 0\r\n    running: u32 = 0\r\n    index: u32 = 0\r\n    high: u32 = 0\r\n    last_write: u32 = 0\r\n}\r\n\r\nexport class GB_CPU {\r\n    variant: GB_variants\r\n    clock: GB_clock\r\n    bus: GB_bus\r\n    cpu: SM83_t\r\n\r\n    FFregs: StaticArray<u8> = new StaticArray<u8>(256); // For unimplemented FF-regs\r\n    timer: GB_timer\r\n    tracing: bool = false\r\n    io: GB_CPU_io = new GB_CPU_io()\r\n    dma: GB_CPU_dma = new GB_CPU_dma()\r\n    input_buffer: gb_inputs = new gb_inputs();\r\n\r\n    constructor(variant: GB_variants, clock: GB_clock, bus: GB_bus) {\r\n        this.bus = bus;\r\n        this.clock = clock;\r\n        this.variant = variant;\r\n\r\n        let cpu = new SM83_t(variant, clock, bus);\r\n        this.timer = new GB_timer(cpu.regs);\r\n        this.tracing = false;\r\n\r\n        this.cpu = cpu;\r\n        bus.cpu = this;\r\n    }\r\n\r\n    update_inputs(inp1: gb_inputs): void {\r\n        this.input_buffer.a = inp1.a;\r\n        this.input_buffer.b = inp1.b;\r\n        this.input_buffer.up = inp1.up;\r\n        this.input_buffer.down = inp1.down;\r\n        this.input_buffer.left = inp1.left;\r\n        this.input_buffer.right = inp1.right;\r\n        this.input_buffer.start = inp1.start;\r\n        this.input_buffer.select = inp1.select;\r\n    }\r\n\r\n    enable_tracing(): void {\r\n        if (this.tracing) return;\r\n        //this.cpu.enable_tracing(this.read_trace.bind(this));\r\n        this.tracing = true;\r\n    }\r\n\r\n    read_trace(addr: u32): u32 {\r\n        return this.bus.mapper.CPU_read(addr, 0);\r\n    }\r\n\r\n    disable_tracing(): void {\r\n        if (!this.tracing) return;\r\n        this.cpu.disable_tracing();\r\n        this.tracing = false;\r\n    }\r\n\r\n    reset(): void {\r\n        this.cpu.reset();\r\n        this.clock.cpu_frame_cycle = 0;\r\n        this.clock.bootROM_enabled = true;\r\n        this.dma.running = 0;\r\n    }\r\n\r\n    write_IO(addr: u32, val: u32): void {\r\n        switch(addr) {\r\n            case 0xFF00: // JOYP\r\n                this.io.JOYP.action_select = (val & 0x20) >>> 5;\r\n                this.io.JOYP.direction_select = (val & 0x10) >>> 4;\r\n                return;\r\n            case 0xFF01: // SB serial\r\n                this.FFregs[1] = <u8>val;\r\n                break;\r\n            case 0xFF02: // SC\r\n                this.FFregs[2] = <u8>val;\r\n                //this.cycles_til_serial_interrupt =\r\n                return;\r\n            case 0xFF04: // DIV\r\n            case 0xFF05: // TIMA\r\n            case 0xFF06: // TIMA reload\r\n            case 0xFF07: // TAC TIMA controler\r\n                this.timer.write_IO(addr, val);\r\n                return;\r\n            case 0xFF46: // OAM DMA\r\n                //this.dma.cycles_til = 2;\r\n                ////this.dma.running = 1;\r\n                //this.dma.new_high = (val << 8);\r\n                //this.dma.last_write = val;\r\n                this.dma.high = (val << 8);\r\n                for (let i: u32 = 0; i < 160; i++) {\r\n                    this.bus.ppu!.write_OAM(0xFE00 | i, this.bus.DMA_read(this.dma.high | i));\r\n                }\r\n                break;\r\n            case 0xFF50: // Boot ROM disable. Cannot re-enable\r\n                if (val > 0) {\r\n                    console.log('Disable boot ROM!');\r\n                    //dbg.break();\r\n                    this.clock.bootROM_enabled = false;\r\n                }\r\n                break;\r\n            case 0xFF51: // HDMA1\r\n\r\n                break;\r\n            case 0xFF0F:\r\n                console.log('WRITE IF ' + (val & 0x1F).toString());\r\n                this.cpu.regs.IF = val & 0x1F;\r\n                return;\r\n            case 0xFFFF: // IE: Interrupt Enable\r\n                console.log('WRITE IE ' + (val & 0x1F).toString());\r\n                this.cpu.regs.IE = val & 0x1F;\r\n                return;\r\n        }\r\n    }\r\n\r\n    get_input(): u32 {\r\n        let out1: u32;\r\n        let out3: u32 = 0x0F;\r\n        if (this.io.JOYP.action_select === 0) {\r\n            out1 = this.input_buffer.a | (this.input_buffer.b << 1) | (this.input_buffer.select << 2) | (this.input_buffer.start << 3);\r\n            out1 ^= 0x0F;\r\n            out3 &= out1;\r\n        }\r\n\r\n        if (this.io.JOYP.direction_select === 0) {\r\n            out1 = this.input_buffer.right | (this.input_buffer.left << 1) | (this.input_buffer.up << 2) | (this.input_buffer.down << 3);\r\n            out1 ^= 0x0F;\r\n            out3 &= out1;\r\n        }\r\n        return out3;\r\n    }\r\n\r\n    read_IO(addr: u32, val: u32, has_effect: bool = true): u32 {\r\n        switch(addr) {\r\n            case 0xFF00: // JOYP\r\n                // return not pressed=1 in bottom 4 bits\r\n                return this.get_input() | (this.io.JOYP.action_select << 5) | (this.io.JOYP.direction_select << 6);\r\n            case 0xFF01: // SB serial\r\n                return 0xFF;\r\n            case 0xFF02: // SC\r\n                return val;\r\n            case 0xFF04: // DIV\r\n            case 0xFF05: // TIMA\r\n            case 0xFF06: // TIMA reload\r\n            case 0xFF07: // TAC timer control\r\n                return this.timer.read_IO(addr);\r\n            case 0xFF0F: // IF: interrupt flag\r\n                //return this.cpu.regs.IF & 0x1F;\r\n                return this.cpu.regs.IF | 0xE0;\r\n                //return this.clock.irq.vblank_request | (this.clock.irq.lcd_stat_request << 1) | (this.clock.irq.timer_request << 2) | (this.clock.irq.serial_request << 3) | (this.clock.irq.joypad_request << 4);\r\n            case 0xFF46: // OAM DMA\r\n                return this.dma.last_write;\r\n            case 0xFFFF: // IE Interrupt Enable\r\n                //return this.cpu.regs.IE & 0x1F;\r\n                return this.cpu.regs.IE | 0xE0;\r\n        }\r\n        return 0xFF;\r\n    }\r\n\r\n    // perform one cycle of HDMA eval\r\n    hdma_eval(): void {\r\n\r\n    }\r\n\r\n    dma_eval(): void {\r\n        if (this.dma.cycles_til) {\r\n            this.dma.cycles_til--;\r\n            if (this.dma.cycles_til === 0) {\r\n                this.dma.running = 1;\r\n                this.dma.index = 0;\r\n                this.dma.high = this.dma.new_high;\r\n                this.clock.old_OAM_can = this.clock.CPU_can_OAM;\r\n                this.clock.CPU_can_OAM = 0;\r\n            }\r\n            else\r\n                return;\r\n        }\r\n        if (!this.dma.running) return;\r\n        if (this.dma.index >= 160) {\r\n            //console.log('DMA END!');\r\n            this.dma.running = 0;\r\n            this.clock.CPU_can_OAM = this.clock.old_OAM_can;\r\n            return;\r\n        }\r\n        this.bus.ppu!.write_OAM(0xFE00 | this.dma.index, this.bus.DMA_read(this.dma.high | this.dma.index));\r\n        this.dma.index++;\r\n    }\r\n\r\n    // Routine to set state as if boot ROM had run\r\n    quick_boot(): void {\r\n        let regs = this.cpu.regs;\r\n        let pins = this.cpu.pins;\r\n        switch(this.variant) {\r\n            case GB_variants.DMG:\r\n                regs.A = 1;\r\n                regs.F.Z = 0;\r\n                regs.SP = 0xFFFE;\r\n                regs.B = 0;\r\n                regs.C = 0x13;\r\n                regs.D = 0;\r\n                regs.E = 0xD8;\r\n                regs.H = 0x01;\r\n                regs.L = 0x4D;\r\n                regs.PC = 0x101;\r\n                regs.TCU = 0;\r\n                regs.IR = SM83_S_DECODE;\r\n                regs.IME = 0;\r\n                regs.IE = 0;\r\n                regs.IF = 1;\r\n                this.clock.bootROM_enabled = false;\r\n                pins.Addr = 0x100;\r\n                pins.MRQ = pins.RD = 1;\r\n                pins.WR = 0;\r\n                regs.poll_IRQ = true;\r\n                break;\r\n            case GB_variants.GBC:\r\n                regs.A = 0x11;\r\n                regs.F.Z = 1;\r\n                regs.F.N = regs.F.H = regs.F.C = 0;\r\n                regs.B = 0;\r\n                regs.C = 0;\r\n                regs.D = 0xFF;\r\n                regs.E = 0x56;\r\n                regs.H = 0;\r\n                regs.L = 0x0D;\r\n                regs.SP = 0xFFFE;\r\n                this.timer.TIMA = 0;\r\n                this.timer.TMA = 0;\r\n                this.timer.TAC = 0xF8;\r\n                regs.IF = 0xE1;\r\n                regs.IE = 0;\r\n                break;\r\n            default:\r\n                console.log('FAST BOOT NOT ENABLED FOR THIS VARIANT!');\r\n                break;\r\n        }\r\n    }\r\n\r\n    cycle(): void {\r\n        // Update timers\r\n        if (this.cpu.pins.RD && this.cpu.pins.MRQ) {\r\n            this.cpu.pins.D = this.bus.mapper.CPU_read(this.cpu.pins.Addr, 0xCC);\r\n            //if (this.tracing) {\r\n            //    dbg.traces.add(TRACERS.SM83, this.cpu.trace_cycles, trace_format_read('SM83', SM83_COLOR, this.cpu.trace_cycles, this.cpu.pins.Addr, this.cpu.pins.D));\r\n            //}\r\n        }\r\n        if (this.cpu.pins.WR && this.cpu.pins.MRQ) {\r\n            if ((!this.dma.running) || (this.cpu.pins.Addr >= 0xFF00))\r\n                this.bus.mapper.CPU_write(this.cpu.pins.Addr, this.cpu.pins.D);\r\n            //else\r\n             //   console.log('DMA BLOCK W!');\r\n\r\n            //if (this.tracing) {\r\n            //    dbg.traces.add(TRACERS.SM83, this.cpu.trace_cycles, trace_format_write('SM83', SM83_COLOR, this.cpu.trace_cycles, this.cpu.pins.Addr, this.cpu.pins.D));\r\n            //}\r\n        }\r\n        this.cpu.cycle();\r\n        this.dma_eval();\r\n        if (this.cpu.regs.STP)\r\n            this.timer.SYSCLK_change(0);\r\n        else\r\n            this.timer.inc();\r\n    }\r\n}\r\n","import {SM83_pins_t, SM83_regs_t} from \"./sm83\";\r\n\r\nexport enum SM83_MN {\r\n    NONE = 0,\r\n    ADC_di_da = 1,\r\n    ADC_di_di = 2,\r\n    ADC_di_ind = 3,\r\n    ADD_di_da = 4,\r\n    ADD_di_di = 5,\r\n    ADD16_di_di = 6,\r\n    ADD_di_ind = 7,\r\n    ADD_di_rel = 8,\r\n    AND_di_da = 9,\r\n    AND_di_di = 10,\r\n    AND_di_ind = 11,\r\n    BIT_idx_di = 12,\r\n    BIT_idx_ind = 13,\r\n    CALL_cond_addr = 14,\r\n    CCF = 15,\r\n    CP_di_da = 16,\r\n    CP_di_di = 17,\r\n    CP_di_ind = 18,\r\n    CPL = 19,\r\n    DAA = 20,\r\n    DEC_di = 21,\r\n    DEC16_di = 22,\r\n    DEC_ind = 23,\r\n    DI = 24,\r\n    EI = 25,\r\n    HALT = 26,\r\n    INC_di = 27,\r\n    INC16_di = 28,\r\n    INC_ind = 29,\r\n    JP_cond_addr = 30,\r\n    JP_di = 31,\r\n    JR_cond_rel = 32,\r\n    LD_addr_di = 33,\r\n    LD16_addr_di = 34,\r\n    LD_di_addr = 35,\r\n    LD_di_da = 36,\r\n    LD16_di_da = 37,\r\n    LD_di_di = 38,\r\n    LD16_di_di = 39,\r\n    LD_di_di_rel = 40,\r\n    LD_di_ind = 41,\r\n    LD_di_ind_dec = 42,\r\n    LD_di_ind_inc = 43,\r\n    LD_ind_da = 44,\r\n    LD_ind_di = 45,\r\n    LD_ind_dec_di = 46,\r\n    LD_ind_inc_di = 47,\r\n    LDH_addr_di = 48,\r\n    LDH_di_addr = 49,\r\n    LDH_di_ind = 50,\r\n    LDH_ind_di = 51,\r\n    NOP = 52,\r\n    OR_di_da = 53,\r\n    OR_di_di = 54,\r\n    OR_di_ind = 55,\r\n    POP_di = 56,\r\n    POP_di_AF = 57,\r\n    PUSH_di = 58,\r\n    RES_idx_di = 59,\r\n    RES_idx_ind = 60,\r\n    RET = 61,\r\n    RET_cond = 62,\r\n    RETI = 63,\r\n    RL_di = 64,\r\n    RL_ind = 65,\r\n    RLA = 66,\r\n    RLC_di = 67,\r\n    RLC_ind = 68,\r\n    RLCA = 69,\r\n    RR_di = 70,\r\n    RR_ind = 71,\r\n    RRA = 72,\r\n    RRC_di = 73,\r\n    RRC_ind = 74,\r\n    RRCA = 75,\r\n    RST_imp = 76,\r\n    SBC_di_da = 77,\r\n    SBC_di_di = 78,\r\n    SBC_di_ind = 79,\r\n    SCF = 80,\r\n    SET_idx_di = 81,\r\n    SET_idx_ind = 82,\r\n    SLA_di = 83,\r\n    SLA_ind = 84,\r\n    SRA_di = 85,\r\n    SRA_ind = 86,\r\n    SRL_di = 87,\r\n    SRL_ind = 88,\r\n    SUB_di_da = 89,\r\n    SUB_di_di = 90,\r\n    SUB_di_ind = 91,\r\n    SWAP_di = 92,\r\n    SWAP_ind = 93,\r\n    STOP = 94,\r\n    XOR_di_da = 95,\r\n    XOR_di_di = 96,\r\n    XOR_di_ind = 97,\r\n    RESET = 98,\r\n    S_IRQ = 99,\r\n}\r\n\r\nexport var SM83_MN_R: Map<u32, string> = new Map<u32, string>();\r\nSM83_MN_R.set(0, 'NONE');\r\nSM83_MN_R.set(1, 'ADC_di_da');\r\nSM83_MN_R.set(2, 'ADC_di_di');\r\nSM83_MN_R.set(3, 'ADC_di_ind');\r\nSM83_MN_R.set(4, 'ADD_di_da');\r\nSM83_MN_R.set(5, 'ADD_di_di');\r\nSM83_MN_R.set(6, 'ADD16_di_di');\r\nSM83_MN_R.set(7, 'ADD_di_ind');\r\nSM83_MN_R.set(8, 'ADD_di_rel');\r\nSM83_MN_R.set(9, 'AND_di_da');\r\nSM83_MN_R.set(10, 'AND_di_di');\r\nSM83_MN_R.set(11, 'AND_di_ind');\r\nSM83_MN_R.set(12, 'BIT_idx_di');\r\nSM83_MN_R.set(13, 'BIT_idx_ind');\r\nSM83_MN_R.set(14, 'CALL_cond_addr');\r\nSM83_MN_R.set(15, 'CCF');\r\nSM83_MN_R.set(16, 'CP_di_da');\r\nSM83_MN_R.set(17, 'CP_di_di');\r\nSM83_MN_R.set(18, 'CP_di_ind');\r\nSM83_MN_R.set(19, 'CPL');\r\nSM83_MN_R.set(20, 'DAA');\r\nSM83_MN_R.set(21, 'DEC_di');\r\nSM83_MN_R.set(22, 'DEC16_di');\r\nSM83_MN_R.set(23, 'DEC_ind');\r\nSM83_MN_R.set(24, 'DI');\r\nSM83_MN_R.set(25, 'EI');\r\nSM83_MN_R.set(26, 'HALT');\r\nSM83_MN_R.set(27, 'INC_di');\r\nSM83_MN_R.set(28, 'INC16_di');\r\nSM83_MN_R.set(29, 'INC_ind');\r\nSM83_MN_R.set(30, 'JP_cond_addr');\r\nSM83_MN_R.set(31, 'JP_di');\r\nSM83_MN_R.set(32, 'JR_cond_rel');\r\nSM83_MN_R.set(33, 'LD_addr_di');\r\nSM83_MN_R.set(34, 'LD16_addr_di');\r\nSM83_MN_R.set(35, 'LD_di_addr');\r\nSM83_MN_R.set(36, 'LD_di_da');\r\nSM83_MN_R.set(37, 'LD16_di_da');\r\nSM83_MN_R.set(38, 'LD_di_di');\r\nSM83_MN_R.set(39, 'LD16_di_di');\r\nSM83_MN_R.set(40, 'LD_di_di_rel');\r\nSM83_MN_R.set(41, 'LD_di_ind');\r\nSM83_MN_R.set(42, 'LD_di_ind_dec');\r\nSM83_MN_R.set(43, 'LD_di_ind_inc');\r\nSM83_MN_R.set(44, 'LD_ind_da');\r\nSM83_MN_R.set(45, 'LD_ind_di');\r\nSM83_MN_R.set(46, 'LD_ind_dec_di');\r\nSM83_MN_R.set(47, 'LD_ind_inc_di');\r\nSM83_MN_R.set(48, 'LDH_addr_di');\r\nSM83_MN_R.set(49, 'LDH_di_addr');\r\nSM83_MN_R.set(50, 'LDH_di_ind');\r\nSM83_MN_R.set(51, 'LDH_ind_di');\r\nSM83_MN_R.set(52, 'NOP');\r\nSM83_MN_R.set(53, 'OR_di_da');\r\nSM83_MN_R.set(54, 'OR_di_di');\r\nSM83_MN_R.set(55, 'OR_di_ind');\r\nSM83_MN_R.set(56, 'POP_di');\r\nSM83_MN_R.set(57, 'POP_di_AF');\r\nSM83_MN_R.set(58, 'PUSH_di');\r\nSM83_MN_R.set(59, 'RES_idx_di');\r\nSM83_MN_R.set(60, 'RES_idx_ind');\r\nSM83_MN_R.set(61, 'RET');\r\nSM83_MN_R.set(62, 'RET_cond');\r\nSM83_MN_R.set(63, 'RETI');\r\nSM83_MN_R.set(64, 'RL_di');\r\nSM83_MN_R.set(65, 'RL_ind');\r\nSM83_MN_R.set(66, 'RLA');\r\nSM83_MN_R.set(67, 'RLC_di');\r\nSM83_MN_R.set(68, 'RLC_ind');\r\nSM83_MN_R.set(69, 'RLCA');\r\nSM83_MN_R.set(70, 'RR_di');\r\nSM83_MN_R.set(71, 'RR_ind');\r\nSM83_MN_R.set(72, 'RRA');\r\nSM83_MN_R.set(73, 'RRC_di');\r\nSM83_MN_R.set(74, 'RRC_ind');\r\nSM83_MN_R.set(75, 'RRCA');\r\nSM83_MN_R.set(76, 'RST_imp');\r\nSM83_MN_R.set(77, 'SBC_di_da');\r\nSM83_MN_R.set(78, 'SBC_di_di');\r\nSM83_MN_R.set(79, 'SBC_di_ind');\r\nSM83_MN_R.set(80, 'SCF');\r\nSM83_MN_R.set(81, 'SET_idx_di');\r\nSM83_MN_R.set(82, 'SET_idx_ind');\r\nSM83_MN_R.set(83, 'SLA_di');\r\nSM83_MN_R.set(84, 'SLA_ind');\r\nSM83_MN_R.set(85, 'SRA_di');\r\nSM83_MN_R.set(86, 'SRA_ind');\r\nSM83_MN_R.set(87, 'SRL_di');\r\nSM83_MN_R.set(88, 'SRL_ind');\r\nSM83_MN_R.set(89, 'SUB_di_da');\r\nSM83_MN_R.set(90, 'SUB_di_di');\r\nSM83_MN_R.set(91, 'SUB_di_ind');\r\nSM83_MN_R.set(92, 'SWAP_di');\r\nSM83_MN_R.set(93, 'SWAP_ind');\r\nSM83_MN_R.set(94, 'STOP');\r\nSM83_MN_R.set(95, 'XOR_di_da');\r\nSM83_MN_R.set(96, 'XOR_di_di');\r\nSM83_MN_R.set(97, 'XOR_di_ind');\r\nSM83_MN_R.set(98, 'RESET');\r\nSM83_MN_R.set(99, 'S_IRQ');\r\nclass SM83_opcode_info {\r\n    opcode: u32\r\n    ins: SM83_MN\r\n    mnemonic: string = ''\r\n    arg1: string|null\r\n    arg2: string|null\r\n\r\n    constructor(opcode: u32, ins: SM83_MN, arg1: string|null=null, arg2:string|null=null) {\r\n        this.opcode = opcode;\r\n        this.ins = ins;\r\n        this.arg1 = arg1;\r\n        this.arg2 = arg2;\r\n    }\r\n}\r\n\r\nexport const SM83_S_RESET = 0x101;\r\nexport const SM83_S_IRQ = 0x100;\r\nexport const SM83_HALT = 0x76;\r\nexport const SM83_S_DECODE = 0x102;\r\n//const SM83_MAX_OPCODE = 0x101;\r\n\r\nexport var SM83_opcode_matrix: Map<u32, SM83_opcode_info> = new Map<u32, SM83_opcode_info>();\r\nexport var SM83_opcode_matrixCB: Map<u32, SM83_opcode_info> = new Map<u32, SM83_opcode_info>();\r\n\r\nfor (let i = 0; i < 0x102; i++) {\r\n    let x = SM83_get_matrix_item(i);\r\n    x.mnemonic = SM83_MN_R.get(x.ins);\r\n    SM83_opcode_matrix.set(i, x);\r\n    if (i < 0x100) {\r\n        x = SM83_get_matrixCB_item(i);\r\n        x.mnemonic = SM83_MN_R.get(x.ins);\r\n        SM83_opcode_matrixCB.set(i, x);\r\n    }\r\n}\r\n\r\nfunction SM83_get_matrix_item(i: u32): SM83_opcode_info {\r\n    switch(i) {\r\n        case 0x00: return new SM83_opcode_info(0x00, SM83_MN.NOP);\r\n        case 0x01: return new SM83_opcode_info(0x01, SM83_MN.LD16_di_da, 'BC');\r\n        case 0x02: return new SM83_opcode_info(0x02, SM83_MN.LD_ind_di, 'BC', 'A');\r\n        case 0x03: return new SM83_opcode_info(0x03, SM83_MN.INC16_di, 'BC');\r\n        case 0x04: return new SM83_opcode_info(0x04, SM83_MN.INC_di, 'B');\r\n        case 0x05: return new SM83_opcode_info(0x05, SM83_MN.DEC_di, 'B');\r\n        case 0x06: return new SM83_opcode_info(0x06, SM83_MN.LD_di_da, 'B');\r\n        case 0x07: return new SM83_opcode_info(0x07, SM83_MN.RLCA);\r\n        case 0x08: return new SM83_opcode_info(0x08, SM83_MN.LD16_addr_di, 'SP');\r\n        case 0x09: return new SM83_opcode_info(0x09, SM83_MN.ADD16_di_di, 'HL', 'BC');\r\n        case 0x0A: return new SM83_opcode_info(0x0A, SM83_MN.LD_di_ind, 'A', 'BC');\r\n        case 0x0B: return new SM83_opcode_info(0x0B, SM83_MN.DEC16_di, 'BC');\r\n        case 0x0C: return new SM83_opcode_info(0x0C, SM83_MN.INC_di, 'C');\r\n        case 0x0D: return new SM83_opcode_info(0x0D, SM83_MN.DEC_di, 'C');\r\n        case 0x0E: return new SM83_opcode_info(0x0E, SM83_MN.LD_di_da, 'C');\r\n        case 0x0F: return new SM83_opcode_info(0x0F, SM83_MN.RRCA);\r\n\r\n        case 0x10: return new SM83_opcode_info(0x10, SM83_MN.STOP);\r\n        case 0x11: return new SM83_opcode_info(0x11, SM83_MN.LD16_di_da, 'DE');\r\n        case 0x12: return new SM83_opcode_info(0x12, SM83_MN.LD_ind_di, 'DE', 'A');\r\n        case 0x13: return new SM83_opcode_info(0x13, SM83_MN.INC16_di, 'DE');\r\n        case 0x14: return new SM83_opcode_info(0x14, SM83_MN.INC_di, 'D');\r\n        case 0x15: return new SM83_opcode_info(0x15, SM83_MN.DEC_di, 'D');\r\n        case 0x16: return new SM83_opcode_info(0x16, SM83_MN.LD_di_da, 'D');\r\n        case 0x17: return new SM83_opcode_info(0x17, SM83_MN.RLA);\r\n        case 0x18: return new SM83_opcode_info(0x18, SM83_MN.JR_cond_rel, '1');\r\n        case 0x19: return new SM83_opcode_info(0x19, SM83_MN.ADD16_di_di, 'HL', 'DE');\r\n        case 0x1A: return new SM83_opcode_info(0x1A, SM83_MN.LD_di_ind, 'A', 'DE');\r\n        case 0x1B: return new SM83_opcode_info(0x1B, SM83_MN.DEC16_di, 'DE');\r\n        case 0x1C: return new SM83_opcode_info(0x1C, SM83_MN.INC_di, 'E');\r\n        case 0x1D: return new SM83_opcode_info(0x1D, SM83_MN.DEC_di, 'E');\r\n        case 0x1E: return new SM83_opcode_info(0x1E, SM83_MN.LD_di_da, 'E');\r\n        case 0x1F: return new SM83_opcode_info(0x1F, SM83_MN.RRA);\r\n\r\n        case 0x20: return new SM83_opcode_info(0x20, SM83_MN.JR_cond_rel, 'regs.F.Z == 0');\r\n        case 0x21: return new SM83_opcode_info(0x21, SM83_MN.LD16_di_da, 'HL');\r\n        case 0x22: return new SM83_opcode_info(0x22, SM83_MN.LD_ind_inc_di, 'HL', 'A');\r\n        case 0x23: return new SM83_opcode_info(0x23, SM83_MN.INC16_di, 'HL');\r\n        case 0x24: return new SM83_opcode_info(0x24, SM83_MN.INC_di, 'H');\r\n        case 0x25: return new SM83_opcode_info(0x25, SM83_MN.DEC_di, 'H');\r\n        case 0x26: return new SM83_opcode_info(0x26, SM83_MN.LD_di_da, 'H');\r\n        case 0x27: return new SM83_opcode_info(0x27, SM83_MN.DAA);\r\n        case 0x28: return new SM83_opcode_info(0x28, SM83_MN.JR_cond_rel, 'regs.F.Z == 1');\r\n        case 0x29: return new SM83_opcode_info(0x29, SM83_MN.ADD16_di_di, 'HL', 'HL');\r\n        case 0x2A: return new SM83_opcode_info(0x2A, SM83_MN.LD_di_ind_inc, 'A', 'HL');\r\n        case 0x2B: return new SM83_opcode_info(0x2B, SM83_MN.DEC16_di, 'HL');\r\n        case 0x2C: return new SM83_opcode_info(0x2C, SM83_MN.INC_di, 'L');\r\n        case 0x2D: return new SM83_opcode_info(0x2D, SM83_MN.DEC_di, 'L');\r\n        case 0x2E: return new SM83_opcode_info(0x2E, SM83_MN.LD_di_da, 'L');\r\n        case 0x2F: return new SM83_opcode_info(0x2F, SM83_MN.CPL);\r\n\r\n        case 0x30: return new SM83_opcode_info(0x30, SM83_MN.JR_cond_rel, 'regs.F.C == 0');\r\n        case 0x31: return new SM83_opcode_info(0x31, SM83_MN.LD16_di_da, 'SP');\r\n        case 0x32: return new SM83_opcode_info(0x32, SM83_MN.LD_ind_dec_di, 'HL', 'A');\r\n        case 0x33: return new SM83_opcode_info(0x33, SM83_MN.INC16_di, 'SP');\r\n        case 0x34: return new SM83_opcode_info(0x34, SM83_MN.INC_ind, 'HL');\r\n        case 0x35: return new SM83_opcode_info(0x35, SM83_MN.DEC_ind, 'HL');\r\n        case 0x36: return new SM83_opcode_info(0x36, SM83_MN.LD_ind_da, 'HL');\r\n        case 0x37: return new SM83_opcode_info(0x37, SM83_MN.SCF);\r\n        case 0x38: return new SM83_opcode_info(0x38, SM83_MN.JR_cond_rel, 'regs.F.C == 1');\r\n        case 0x39: return new SM83_opcode_info(0x39, SM83_MN.ADD16_di_di, 'HL', 'SP');\r\n        case 0x3A: return new SM83_opcode_info(0x3A, SM83_MN.LD_di_ind_dec, 'A', 'HL');\r\n        case 0x3B: return new SM83_opcode_info(0x3B, SM83_MN.DEC16_di, 'SP');\r\n        case 0x3C: return new SM83_opcode_info(0x3C, SM83_MN.INC_di, 'A');\r\n        case 0x3D: return new SM83_opcode_info(0x3D, SM83_MN.DEC_di, 'A');\r\n        case 0x3E: return new SM83_opcode_info(0x3E, SM83_MN.LD_di_da, 'A');\r\n        case 0x3F: return new SM83_opcode_info(0x3F, SM83_MN.CCF);\r\n\r\n        case 0x40: return new SM83_opcode_info(0x40, SM83_MN.LD_di_di, 'B', 'B');\r\n        case 0x41: return new SM83_opcode_info(0x41, SM83_MN.LD_di_di, 'B', 'C');\r\n        case 0x42: return new SM83_opcode_info(0x42, SM83_MN.LD_di_di, 'B', 'D');\r\n        case 0x43: return new SM83_opcode_info(0x43, SM83_MN.LD_di_di, 'B', 'E');\r\n        case 0x44: return new SM83_opcode_info(0x44, SM83_MN.LD_di_di, 'B', 'H');\r\n        case 0x45: return new SM83_opcode_info(0x45, SM83_MN.LD_di_di, 'B', 'L');\r\n        case 0x46: return new SM83_opcode_info(0x46, SM83_MN.LD_di_ind, 'B', 'HL');\r\n        case 0x47: return new SM83_opcode_info(0x47, SM83_MN.LD_di_di, 'B', 'A');\r\n        case 0x48: return new SM83_opcode_info(0x48, SM83_MN.LD_di_di, 'C', 'B');\r\n        case 0x49: return new SM83_opcode_info(0x49, SM83_MN.LD_di_di, 'C', 'C');\r\n        case 0x4A: return new SM83_opcode_info(0x4A, SM83_MN.LD_di_di, 'C', 'D');\r\n        case 0x4B: return new SM83_opcode_info(0x4B, SM83_MN.LD_di_di, 'C', 'E');\r\n        case 0x4C: return new SM83_opcode_info(0x4C, SM83_MN.LD_di_di, 'C', 'H');\r\n        case 0x4D: return new SM83_opcode_info(0x4D, SM83_MN.LD_di_di, 'C', 'L');\r\n        case 0x4E: return new SM83_opcode_info(0x4E, SM83_MN.LD_di_ind, 'C', 'HL');\r\n        case 0x4F: return new SM83_opcode_info(0x4F, SM83_MN.LD_di_di, 'C', 'A');\r\n\r\n        case 0x50: return new SM83_opcode_info(0x50, SM83_MN.LD_di_di, 'D', 'B');\r\n        case 0x51: return new SM83_opcode_info(0x51, SM83_MN.LD_di_di, 'D', 'C');\r\n        case 0x52: return new SM83_opcode_info(0x52, SM83_MN.LD_di_di, 'D', 'D');\r\n        case 0x53: return new SM83_opcode_info(0x53, SM83_MN.LD_di_di, 'D', 'E');\r\n        case 0x54: return new SM83_opcode_info(0x54, SM83_MN.LD_di_di, 'D', 'H');\r\n        case 0x55: return new SM83_opcode_info(0x55, SM83_MN.LD_di_di, 'D', 'L');\r\n        case 0x56: return new SM83_opcode_info(0x56, SM83_MN.LD_di_ind, 'D', 'HL');\r\n        case 0x57: return new SM83_opcode_info(0x57, SM83_MN.LD_di_di, 'D', 'A');\r\n        case 0x58: return new SM83_opcode_info(0x58, SM83_MN.LD_di_di, 'E', 'B');\r\n        case 0x59: return new SM83_opcode_info(0x59, SM83_MN.LD_di_di, 'E', 'C');\r\n        case 0x5A: return new SM83_opcode_info(0x5A, SM83_MN.LD_di_di, 'E', 'D');\r\n        case 0x5B: return new SM83_opcode_info(0x5B, SM83_MN.LD_di_di, 'E', 'E');\r\n        case 0x5C: return new SM83_opcode_info(0x5C, SM83_MN.LD_di_di, 'E', 'H');\r\n        case 0x5D: return new SM83_opcode_info(0x5D, SM83_MN.LD_di_di, 'E', 'L');\r\n        case 0x5E: return new SM83_opcode_info(0x5E, SM83_MN.LD_di_ind, 'E', 'HL');\r\n        case 0x5F: return new SM83_opcode_info(0x5F, SM83_MN.LD_di_di, 'E', 'A');\r\n\r\n        case 0x60: return new SM83_opcode_info(0x60, SM83_MN.LD_di_di, 'H', 'B');\r\n        case 0x61: return new SM83_opcode_info(0x61, SM83_MN.LD_di_di, 'H', 'C');\r\n        case 0x62: return new SM83_opcode_info(0x62, SM83_MN.LD_di_di, 'H', 'D');\r\n        case 0x63: return new SM83_opcode_info(0x63, SM83_MN.LD_di_di, 'H', 'E');\r\n        case 0x64: return new SM83_opcode_info(0x64, SM83_MN.LD_di_di, 'H', 'H');\r\n        case 0x65: return new SM83_opcode_info(0x65, SM83_MN.LD_di_di, 'H', 'L');\r\n        case 0x66: return new SM83_opcode_info(0x66, SM83_MN.LD_di_ind, 'H', 'HL');\r\n        case 0x67: return new SM83_opcode_info(0x67, SM83_MN.LD_di_di, 'H', 'A');\r\n        case 0x68: return new SM83_opcode_info(0x68, SM83_MN.LD_di_di, 'L', 'B');\r\n        case 0x69: return new SM83_opcode_info(0x69, SM83_MN.LD_di_di, 'L', 'C');\r\n        case 0x6A: return new SM83_opcode_info(0x6A, SM83_MN.LD_di_di, 'L', 'D');\r\n        case 0x6B: return new SM83_opcode_info(0x6B, SM83_MN.LD_di_di, 'L', 'E');\r\n        case 0x6C: return new SM83_opcode_info(0x6C, SM83_MN.LD_di_di, 'L', 'H');\r\n        case 0x6D: return new SM83_opcode_info(0x6D, SM83_MN.LD_di_di, 'L', 'L');\r\n        case 0x6E: return new SM83_opcode_info(0x6E, SM83_MN.LD_di_ind, 'L', 'HL');\r\n        case 0x6F: return new SM83_opcode_info(0x6F, SM83_MN.LD_di_di, 'L', 'A');\r\n\r\n        case 0x70: return new SM83_opcode_info(0x70, SM83_MN.LD_ind_di, 'HL', 'B');\r\n        case 0x71: return new SM83_opcode_info(0x71, SM83_MN.LD_ind_di, 'HL', 'C');\r\n        case 0x72: return new SM83_opcode_info(0x72, SM83_MN.LD_ind_di, 'HL', 'D');\r\n        case 0x73: return new SM83_opcode_info(0x73, SM83_MN.LD_ind_di, 'HL', 'E');\r\n        case 0x74: return new SM83_opcode_info(0x74, SM83_MN.LD_ind_di, 'HL', 'H');\r\n        case 0x75: return new SM83_opcode_info(0x75, SM83_MN.LD_ind_di, 'HL', 'L');\r\n        case 0x76: return new SM83_opcode_info(0x76, SM83_MN.HALT);\r\n        case 0x77: return new SM83_opcode_info(0x77, SM83_MN.LD_ind_di, 'HL', 'A');\r\n        case 0x78: return new SM83_opcode_info(0x78, SM83_MN.LD_di_di, 'A', 'B');\r\n        case 0x79: return new SM83_opcode_info(0x79, SM83_MN.LD_di_di, 'A', 'C');\r\n        case 0x7A: return new SM83_opcode_info(0x7A, SM83_MN.LD_di_di, 'A', 'D');\r\n        case 0x7B: return new SM83_opcode_info(0x7B, SM83_MN.LD_di_di, 'A', 'E');\r\n        case 0x7C: return new SM83_opcode_info(0x7C, SM83_MN.LD_di_di, 'A', 'H');\r\n        case 0x7D: return new SM83_opcode_info(0x7D, SM83_MN.LD_di_di, 'A', 'L');\r\n        case 0x7E: return new SM83_opcode_info(0x7E, SM83_MN.LD_di_ind, 'A', 'HL');\r\n        case 0x7F: return new SM83_opcode_info(0x7F, SM83_MN.LD_di_di, 'A', 'A');\r\n\r\n        case 0x80: return new SM83_opcode_info(0x80, SM83_MN.ADD_di_di, 'A', 'B');\r\n        case 0x81: return new SM83_opcode_info(0x81, SM83_MN.ADD_di_di, 'A', 'C');\r\n        case 0x82: return new SM83_opcode_info(0x82, SM83_MN.ADD_di_di, 'A', 'D');\r\n        case 0x83: return new SM83_opcode_info(0x83, SM83_MN.ADD_di_di, 'A', 'E');\r\n        case 0x84: return new SM83_opcode_info(0x84, SM83_MN.ADD_di_di, 'A', 'H');\r\n        case 0x85: return new SM83_opcode_info(0x85, SM83_MN.ADD_di_di, 'A', 'L');\r\n        case 0x86: return new SM83_opcode_info(0x86, SM83_MN.ADD_di_ind, 'A', 'HL');\r\n        case 0x87: return new SM83_opcode_info(0x87, SM83_MN.ADD_di_di, 'A', 'A');\r\n        case 0x88: return new SM83_opcode_info(0x88, SM83_MN.ADC_di_di, 'A', 'B');\r\n        case 0x89: return new SM83_opcode_info(0x89, SM83_MN.ADC_di_di, 'A', 'C');\r\n        case 0x8A: return new SM83_opcode_info(0x8A, SM83_MN.ADC_di_di, 'A', 'D');\r\n        case 0x8B: return new SM83_opcode_info(0x8B, SM83_MN.ADC_di_di, 'A', 'E');\r\n        case 0x8C: return new SM83_opcode_info(0x8C, SM83_MN.ADC_di_di, 'A', 'H');\r\n        case 0x8D: return new SM83_opcode_info(0x8D, SM83_MN.ADC_di_di, 'A', 'L');\r\n        case 0x8E: return new SM83_opcode_info(0x8E, SM83_MN.ADC_di_ind, 'A', 'HL');\r\n        case 0x8F: return new SM83_opcode_info(0x8F, SM83_MN.ADC_di_di, 'A', 'A');\r\n\r\n        case 0x90: return new SM83_opcode_info(0x90, SM83_MN.SUB_di_di, 'A', 'B');\r\n        case 0x91: return new SM83_opcode_info(0x91, SM83_MN.SUB_di_di, 'A', 'C');\r\n        case 0x92: return new SM83_opcode_info(0x92, SM83_MN.SUB_di_di, 'A', 'D');\r\n        case 0x93: return new SM83_opcode_info(0x93, SM83_MN.SUB_di_di, 'A', 'E');\r\n        case 0x94: return new SM83_opcode_info(0x94, SM83_MN.SUB_di_di, 'A', 'H');\r\n        case 0x95: return new SM83_opcode_info(0x95, SM83_MN.SUB_di_di, 'A', 'L');\r\n        case 0x96: return new SM83_opcode_info(0x96, SM83_MN.SUB_di_ind, 'A', 'HL');\r\n        case 0x97: return new SM83_opcode_info(0x97, SM83_MN.SUB_di_di, 'A', 'A');\r\n        case 0x98: return new SM83_opcode_info(0x98, SM83_MN.SBC_di_di, 'A', 'B');\r\n        case 0x99: return new SM83_opcode_info(0x99, SM83_MN.SBC_di_di, 'A', 'C');\r\n        case 0x9A: return new SM83_opcode_info(0x9A, SM83_MN.SBC_di_di, 'A', 'D');\r\n        case 0x9B: return new SM83_opcode_info(0x9B, SM83_MN.SBC_di_di, 'A', 'E');\r\n        case 0x9C: return new SM83_opcode_info(0x9C, SM83_MN.SBC_di_di, 'A', 'H');\r\n        case 0x9D: return new SM83_opcode_info(0x9D, SM83_MN.SBC_di_di, 'A', 'L');\r\n        case 0x9E: return new SM83_opcode_info(0x9E, SM83_MN.SBC_di_ind, 'A', 'HL');\r\n        case 0x9F: return new SM83_opcode_info(0x9F, SM83_MN.SBC_di_di, 'A', 'A');\r\n\r\n        case 0xA0: return new SM83_opcode_info(0xA0, SM83_MN.AND_di_di, 'A', 'B');\r\n        case 0xA1: return new SM83_opcode_info(0xA1, SM83_MN.AND_di_di, 'A', 'C');\r\n        case 0xA2: return new SM83_opcode_info(0xA2, SM83_MN.AND_di_di, 'A', 'D');\r\n        case 0xA3: return new SM83_opcode_info(0xA3, SM83_MN.AND_di_di, 'A', 'E');\r\n        case 0xA4: return new SM83_opcode_info(0xA4, SM83_MN.AND_di_di, 'A', 'H');\r\n        case 0xA5: return new SM83_opcode_info(0xA5, SM83_MN.AND_di_di, 'A', 'L');\r\n        case 0xA6: return new SM83_opcode_info(0xA6, SM83_MN.AND_di_ind, 'A', 'HL');\r\n        case 0xA7: return new SM83_opcode_info(0xA7, SM83_MN.AND_di_di, 'A', 'A');\r\n        case 0xA8: return new SM83_opcode_info(0xA8, SM83_MN.XOR_di_di, 'A', 'B');\r\n        case 0xA9: return new SM83_opcode_info(0xA9, SM83_MN.XOR_di_di, 'A', 'C');\r\n        case 0xAA: return new SM83_opcode_info(0xAA, SM83_MN.XOR_di_di, 'A', 'D');\r\n        case 0xAB: return new SM83_opcode_info(0xAB, SM83_MN.XOR_di_di, 'A', 'E');\r\n        case 0xAC: return new SM83_opcode_info(0xAC, SM83_MN.XOR_di_di, 'A', 'H');\r\n        case 0xAD: return new SM83_opcode_info(0xAD, SM83_MN.XOR_di_di, 'A', 'L');\r\n        case 0xAE: return new SM83_opcode_info(0xAE, SM83_MN.XOR_di_ind, 'A', 'HL');\r\n        case 0xAF: return new SM83_opcode_info(0xAF, SM83_MN.XOR_di_di, 'A', 'A');\r\n\r\n        case 0xB0: return new SM83_opcode_info(0xB0, SM83_MN.OR_di_di, 'A', 'B');\r\n        case 0xB1: return new SM83_opcode_info(0xB1, SM83_MN.OR_di_di, 'A', 'C');\r\n        case 0xB2: return new SM83_opcode_info(0xB2, SM83_MN.OR_di_di, 'A', 'D');\r\n        case 0xB3: return new SM83_opcode_info(0xB3, SM83_MN.OR_di_di, 'A', 'E');\r\n        case 0xB4: return new SM83_opcode_info(0xB4, SM83_MN.OR_di_di, 'A', 'H');\r\n        case 0xB5: return new SM83_opcode_info(0xB5, SM83_MN.OR_di_di, 'A', 'L');\r\n        case 0xB6: return new SM83_opcode_info(0xB6, SM83_MN.OR_di_ind, 'A', 'HL');\r\n        case 0xB7: return new SM83_opcode_info(0xB7, SM83_MN.OR_di_di, 'A', 'A');\r\n        case 0xB8: return new SM83_opcode_info(0xB8, SM83_MN.CP_di_di, 'A', 'B');\r\n        case 0xB9: return new SM83_opcode_info(0xB9, SM83_MN.CP_di_di, 'A', 'C');\r\n        case 0xBA: return new SM83_opcode_info(0xBA, SM83_MN.CP_di_di, 'A', 'D');\r\n        case 0xBB: return new SM83_opcode_info(0xBB, SM83_MN.CP_di_di, 'A', 'E');\r\n        case 0xBC: return new SM83_opcode_info(0xBC, SM83_MN.CP_di_di, 'A', 'H');\r\n        case 0xBD: return new SM83_opcode_info(0xBD, SM83_MN.CP_di_di, 'A', 'L');\r\n        case 0xBE: return new SM83_opcode_info(0xBE, SM83_MN.CP_di_ind, 'A', 'HL');\r\n        case 0xBF: return new SM83_opcode_info(0xBF, SM83_MN.CP_di_di, 'A', 'A');\r\n\r\n        case 0xC0: return new SM83_opcode_info(0xC0, SM83_MN.RET_cond, 'regs.F.Z == 0');\r\n        case 0xC1: return new SM83_opcode_info(0xC1, SM83_MN.POP_di, 'BC');\r\n        case 0xC2: return new SM83_opcode_info(0xC2, SM83_MN.JP_cond_addr, 'regs.F.Z == 0');\r\n        case 0xC3: return new SM83_opcode_info(0xC3, SM83_MN.JP_cond_addr, \"1\");\r\n        case 0xC4: return new SM83_opcode_info(0xC4, SM83_MN.CALL_cond_addr, 'regs.F.Z == 0');\r\n        case 0xC5: return new SM83_opcode_info(0xC5, SM83_MN.PUSH_di, 'BC');\r\n        case 0xC6: return new SM83_opcode_info(0xC6, SM83_MN.ADD_di_da, 'A');\r\n        case 0xC7: return new SM83_opcode_info(0xC7, SM83_MN.RST_imp, '0');\r\n        case 0xC8: return new SM83_opcode_info(0xC8, SM83_MN.RET_cond, 'regs.F.Z == 1');\r\n        case 0xC9: return new SM83_opcode_info(0xC9, SM83_MN.RET);\r\n        case 0xCA: return new SM83_opcode_info(0xCA, SM83_MN.JP_cond_addr, 'regs.F.Z == 1');\r\n        case 0xCB: return new SM83_opcode_info(0xCB, SM83_MN.NONE);\r\n        case 0xCC: return new SM83_opcode_info(0xCC, SM83_MN.CALL_cond_addr, 'regs.F.Z == 1');\r\n        case 0xCD: return new SM83_opcode_info(0xCD, SM83_MN.CALL_cond_addr, '1');\r\n        case 0xCE: return new SM83_opcode_info(0xCE, SM83_MN.ADC_di_da, 'A');\r\n        case 0xCF: return new SM83_opcode_info(0xCF, SM83_MN.RST_imp, '8');\r\n\r\n        case 0xD0: return new SM83_opcode_info(0xD0, SM83_MN.RET_cond, 'regs.F.C == 0');\r\n        case 0xD1: return new SM83_opcode_info(0xD1, SM83_MN.POP_di, 'DE');\r\n        case 0xD2: return new SM83_opcode_info(0xD2, SM83_MN.JP_cond_addr, 'regs.F.C == 0');\r\n        //0xD3: return new SM83_opcode_info(0xD3, SM83_MN.);\r\n        case 0xD4: return new SM83_opcode_info(0xD4, SM83_MN.CALL_cond_addr, 'regs.F.C == 0');\r\n        case 0xD5: return new SM83_opcode_info(0xD5, SM83_MN.PUSH_di, 'DE');\r\n        case 0xD6: return new SM83_opcode_info(0xD6, SM83_MN.SUB_di_da, 'A');\r\n        case 0xD7: return new SM83_opcode_info(0xD7, SM83_MN.RST_imp, '0x10');\r\n        case 0xD8: return new SM83_opcode_info(0xD8, SM83_MN.RET_cond, 'regs.F.C == 1');\r\n        case 0xD9: return new SM83_opcode_info(0xD9, SM83_MN.RETI);\r\n        case 0xDA: return new SM83_opcode_info(0xDA, SM83_MN.JP_cond_addr, 'regs.F.C == 1');\r\n        //0xDB: return new SM83_opcode_info(0xDB, SM83_MN.);\r\n        case 0xDC: return new SM83_opcode_info(0xDC, SM83_MN.CALL_cond_addr, 'regs.F.C == 1');\r\n        //0xDD: return new SM83_opcode_info(0xDD, SM83_MN.);\r\n        case 0xDE: return new SM83_opcode_info(0xDE, SM83_MN.SBC_di_da, 'A');\r\n        case 0xDF: return new SM83_opcode_info(0xDF, SM83_MN.RST_imp, '0x18');\r\n\r\n        case 0xE0: return new SM83_opcode_info(0xE0, SM83_MN.LDH_addr_di, 'A');\r\n        case 0xE1: return new SM83_opcode_info(0xE1, SM83_MN.POP_di, 'HL');\r\n        case 0xE2: return new SM83_opcode_info(0xE2, SM83_MN.LDH_ind_di, 'C', 'A');\r\n        //0xE3: return new SM83_opcode_info(0xE3, SM83_MN.);\r\n        //0xE4: return new SM83_opcode_info(0xE4, SM83_MN.);\r\n        case 0xE5: return new SM83_opcode_info(0xE5, SM83_MN.PUSH_di, 'HL');\r\n        case 0xE6: return new SM83_opcode_info(0xE6, SM83_MN.AND_di_da, 'A');\r\n        case 0xE7: return new SM83_opcode_info(0xE7, SM83_MN.RST_imp, '0x20');\r\n        case 0xE8: return new SM83_opcode_info(0xE8, SM83_MN.ADD_di_rel, 'SP');\r\n        case 0xE9: return new SM83_opcode_info(0xE9, SM83_MN.JP_di, 'HL');\r\n        case 0xEA: return new SM83_opcode_info(0xEA, SM83_MN.LD_addr_di, 'A');\r\n        //0xEB: return new SM83_opcode_info(0xEB, SM83_MN.);\r\n        //0xEC: return new SM83_opcode_info(0xEC, SM83_MN.);\r\n        //0xED: return new SM83_opcode_info(0xED, SM83_MN.);\r\n        case 0xEE: return new SM83_opcode_info(0xEE, SM83_MN.XOR_di_da, 'A');\r\n        case 0xEF: return new SM83_opcode_info(0xEF, SM83_MN.RST_imp, '0x28');\r\n\r\n        case 0xF0: return new SM83_opcode_info(0xF0, SM83_MN.LDH_di_addr, 'A');\r\n        case 0xF1: return new SM83_opcode_info(0xF1, SM83_MN.POP_di_AF, 'AF');\r\n        case 0xF2: return new SM83_opcode_info(0xF2, SM83_MN.LDH_di_ind, 'A', 'C');\r\n        case 0xF3: return new SM83_opcode_info(0xF3, SM83_MN.DI);\r\n        //0xF4: return new SM83_opcode_info(0xF4, SM83_MN.);\r\n        case 0xF5: return new SM83_opcode_info(0xF5, SM83_MN.PUSH_di, 'AF');\r\n        case 0xF6: return new SM83_opcode_info(0xF6, SM83_MN.OR_di_da, 'A');\r\n        case 0xF7: return new SM83_opcode_info(0xF7, SM83_MN.RST_imp, '0x30');\r\n        case 0xF8: return new SM83_opcode_info(0xF8, SM83_MN.LD_di_di_rel, 'HL', 'SP');\r\n        case 0xF9: return new SM83_opcode_info(0xF9, SM83_MN.LD16_di_di, 'SP', 'HL');\r\n        case 0xFA: return new SM83_opcode_info(0xFA, SM83_MN.LD_di_addr, 'A');\r\n        case 0xFB: return new SM83_opcode_info(0xFB, SM83_MN.EI);\r\n        //0xFC: return new SM83_opcode_info(0xFC, SM83_MN.);\r\n        //0xFD: return new SM83_opcode_info(0xFD, SM83_MN.);\r\n        case 0xFE: return new SM83_opcode_info(0xFE, SM83_MN.CP_di_da, 'A');\r\n        case 0xFF: return new SM83_opcode_info(0xFF, SM83_MN.RST_imp, '0x38');\r\n        case SM83_S_RESET: return new SM83_opcode_info(SM83_S_RESET, SM83_MN.RESET);\r\n        case SM83_S_IRQ: return new SM83_opcode_info(SM83_S_IRQ, SM83_MN.S_IRQ)\r\n    }\r\n    return new SM83_opcode_info(i, SM83_MN.NONE);\r\n}\r\n\r\n\r\nfunction SM83_get_matrixCB_item(i: u32): SM83_opcode_info {\r\n    switch(i) {\r\n        case 0x00: return new SM83_opcode_info(0x00, SM83_MN.RLC_di, 'B');\r\n        case 0x01: return new SM83_opcode_info(0x01, SM83_MN.RLC_di, 'C');\r\n        case 0x02: return new SM83_opcode_info(0x02, SM83_MN.RLC_di, 'D');\r\n        case 0x03: return new SM83_opcode_info(0x03, SM83_MN.RLC_di, 'E');\r\n        case 0x04: return new SM83_opcode_info(0x04, SM83_MN.RLC_di, 'H');\r\n        case 0x05: return new SM83_opcode_info(0x05, SM83_MN.RLC_di, 'L');\r\n        case 0x06: return new SM83_opcode_info(0x06, SM83_MN.RLC_ind, 'HL');\r\n        case 0x07: return new SM83_opcode_info(0x07, SM83_MN.RLC_di, 'A');\r\n        case 0x08: return new SM83_opcode_info(0x08, SM83_MN.RRC_di, 'B');\r\n        case 0x09: return new SM83_opcode_info(0x09, SM83_MN.RRC_di, 'C');\r\n        case 0x0A: return new SM83_opcode_info(0x0A, SM83_MN.RRC_di, 'D');\r\n        case 0x0B: return new SM83_opcode_info(0x0B, SM83_MN.RRC_di, 'E');\r\n        case 0x0C: return new SM83_opcode_info(0x0C, SM83_MN.RRC_di, 'H');\r\n        case 0x0D: return new SM83_opcode_info(0x0D, SM83_MN.RRC_di, 'L');\r\n        case 0x0E: return new SM83_opcode_info(0x0E, SM83_MN.RRC_ind, 'HL');\r\n        case 0x0F: return new SM83_opcode_info(0x0F, SM83_MN.RRC_di, 'A');\r\n\r\n        case 0x10: return new SM83_opcode_info(0x10, SM83_MN.RL_di, 'B');\r\n        case 0x11: return new SM83_opcode_info(0x11, SM83_MN.RL_di, 'C');\r\n        case 0x12: return new SM83_opcode_info(0x12, SM83_MN.RL_di, 'D');\r\n        case 0x13: return new SM83_opcode_info(0x13, SM83_MN.RL_di, 'E');\r\n        case 0x14: return new SM83_opcode_info(0x14, SM83_MN.RL_di, 'H');\r\n        case 0x15: return new SM83_opcode_info(0x15, SM83_MN.RL_di, 'L');\r\n        case 0x16: return new SM83_opcode_info(0x16, SM83_MN.RL_ind, 'HL');\r\n        case 0x17: return new SM83_opcode_info(0x17, SM83_MN.RL_di, 'A');\r\n        case 0x18: return new SM83_opcode_info(0x18, SM83_MN.RR_di, 'B');\r\n        case 0x19: return new SM83_opcode_info(0x19, SM83_MN.RR_di, 'C');\r\n        case 0x1A: return new SM83_opcode_info(0x1A, SM83_MN.RR_di, 'D');\r\n        case 0x1B: return new SM83_opcode_info(0x1B, SM83_MN.RR_di, 'E');\r\n        case 0x1C: return new SM83_opcode_info(0x1C, SM83_MN.RR_di, 'H');\r\n        case 0x1D: return new SM83_opcode_info(0x1D, SM83_MN.RR_di, 'L');\r\n        case 0x1E: return new SM83_opcode_info(0x1E, SM83_MN.RR_ind, 'HL');\r\n        case 0x1F: return new SM83_opcode_info(0x1F, SM83_MN.RR_di, 'A');\r\n\r\n        case 0x20: return new SM83_opcode_info(0x20, SM83_MN.SLA_di, 'B');\r\n        case 0x21: return new SM83_opcode_info(0x21, SM83_MN.SLA_di, 'C');\r\n        case 0x22: return new SM83_opcode_info(0x22, SM83_MN.SLA_di, 'D');\r\n        case 0x23: return new SM83_opcode_info(0x23, SM83_MN.SLA_di, 'E');\r\n        case 0x24: return new SM83_opcode_info(0x24, SM83_MN.SLA_di, 'H');\r\n        case 0x25: return new SM83_opcode_info(0x25, SM83_MN.SLA_di, 'L');\r\n        case 0x26: return new SM83_opcode_info(0x26, SM83_MN.SLA_ind, 'HL');\r\n        case 0x27: return new SM83_opcode_info(0x27, SM83_MN.SLA_di, 'A');\r\n        case 0x28: return new SM83_opcode_info(0x28, SM83_MN.SRA_di, 'B');\r\n        case 0x29: return new SM83_opcode_info(0x29, SM83_MN.SRA_di, 'C');\r\n        case 0x2A: return new SM83_opcode_info(0x2A, SM83_MN.SRA_di, 'D');\r\n        case 0x2B: return new SM83_opcode_info(0x2B, SM83_MN.SRA_di, 'E');\r\n        case 0x2C: return new SM83_opcode_info(0x2C, SM83_MN.SRA_di, 'H');\r\n        case 0x2D: return new SM83_opcode_info(0x2D, SM83_MN.SRA_di, 'L');\r\n        case 0x2E: return new SM83_opcode_info(0x2E, SM83_MN.SRA_ind, 'HL');\r\n        case 0x2F: return new SM83_opcode_info(0x2F, SM83_MN.SRA_di, 'A');\r\n\r\n        case 0x30: return new SM83_opcode_info(0x30, SM83_MN.SWAP_di, 'B');\r\n        case 0x31: return new SM83_opcode_info(0x31, SM83_MN.SWAP_di, 'C');\r\n        case 0x32: return new SM83_opcode_info(0x32, SM83_MN.SWAP_di, 'D');\r\n        case 0x33: return new SM83_opcode_info(0x33, SM83_MN.SWAP_di, 'E');\r\n        case 0x34: return new SM83_opcode_info(0x34, SM83_MN.SWAP_di, 'H');\r\n        case 0x35: return new SM83_opcode_info(0x35, SM83_MN.SWAP_di, 'L');\r\n        case 0x36: return new SM83_opcode_info(0x36, SM83_MN.SWAP_ind, 'HL');\r\n        case 0x37: return new SM83_opcode_info(0x37, SM83_MN.SWAP_di, 'A');\r\n        case 0x38: return new SM83_opcode_info(0x38, SM83_MN.SRL_di, 'B');\r\n        case 0x39: return new SM83_opcode_info(0x39, SM83_MN.SRL_di, 'C');\r\n        case 0x3A: return new SM83_opcode_info(0x3A, SM83_MN.SRL_di, 'D');\r\n        case 0x3B: return new SM83_opcode_info(0x3B, SM83_MN.SRL_di, 'E');\r\n        case 0x3C: return new SM83_opcode_info(0x3C, SM83_MN.SRL_di, 'H');\r\n        case 0x3D: return new SM83_opcode_info(0x3D, SM83_MN.SRL_di, 'L');\r\n        case 0x3E: return new SM83_opcode_info(0x3E, SM83_MN.SRL_ind, 'HL');\r\n        case 0x3F: return new SM83_opcode_info(0x3F, SM83_MN.SRL_di, 'A');\r\n        \r\n        case 0x40: return new SM83_opcode_info(0x40, SM83_MN.BIT_idx_di, '0', 'B');\r\n        case 0x41: return new SM83_opcode_info(0x41, SM83_MN.BIT_idx_di, '0', 'C');\r\n        case 0x42: return new SM83_opcode_info(0x42, SM83_MN.BIT_idx_di, '0', 'D');\r\n        case 0x43: return new SM83_opcode_info(0x43, SM83_MN.BIT_idx_di, '0', 'E');\r\n        case 0x44: return new SM83_opcode_info(0x44, SM83_MN.BIT_idx_di, '0', 'H');\r\n        case 0x45: return new SM83_opcode_info(0x45, SM83_MN.BIT_idx_di, '0', 'L');\r\n        case 0x46: return new SM83_opcode_info(0x46, SM83_MN.BIT_idx_ind, '0', 'HL');\r\n        case 0x47: return new SM83_opcode_info(0x47, SM83_MN.BIT_idx_di, '0', 'A');\r\n        case 0x48: return new SM83_opcode_info(0x48, SM83_MN.BIT_idx_di, '1', 'B');\r\n        case 0x49: return new SM83_opcode_info(0x49, SM83_MN.BIT_idx_di, '1', 'C');\r\n        case 0x4A: return new SM83_opcode_info(0x4A, SM83_MN.BIT_idx_di, '1', 'D');\r\n        case 0x4B: return new SM83_opcode_info(0x4B, SM83_MN.BIT_idx_di, '1', 'E');\r\n        case 0x4C: return new SM83_opcode_info(0x4C, SM83_MN.BIT_idx_di, '1', 'H');\r\n        case 0x4D: return new SM83_opcode_info(0x4D, SM83_MN.BIT_idx_di, '1', 'L');\r\n        case 0x4E: return new SM83_opcode_info(0x4E, SM83_MN.BIT_idx_ind, '1', 'HL');\r\n        case 0x4F: return new SM83_opcode_info(0x4F, SM83_MN.BIT_idx_di, '1', 'A');\r\n\r\n        case 0x50: return new SM83_opcode_info(0x50, SM83_MN.BIT_idx_di, '2', 'B');\r\n        case 0x51: return new SM83_opcode_info(0x51, SM83_MN.BIT_idx_di, '2', 'C');\r\n        case 0x52: return new SM83_opcode_info(0x52, SM83_MN.BIT_idx_di, '2', 'D');\r\n        case 0x53: return new SM83_opcode_info(0x53, SM83_MN.BIT_idx_di, '2', 'E');\r\n        case 0x54: return new SM83_opcode_info(0x54, SM83_MN.BIT_idx_di, '2', 'H');\r\n        case 0x55: return new SM83_opcode_info(0x55, SM83_MN.BIT_idx_di, '2', 'L');\r\n        case 0x56: return new SM83_opcode_info(0x56, SM83_MN.BIT_idx_ind, '2', 'HL');\r\n        case 0x57: return new SM83_opcode_info(0x57, SM83_MN.BIT_idx_di, '2', 'A');\r\n        case 0x58: return new SM83_opcode_info(0x58, SM83_MN.BIT_idx_di, '3', 'B');\r\n        case 0x59: return new SM83_opcode_info(0x59, SM83_MN.BIT_idx_di, '3', 'C');\r\n        case 0x5A: return new SM83_opcode_info(0x5A, SM83_MN.BIT_idx_di, '3', 'D');\r\n        case 0x5B: return new SM83_opcode_info(0x5B, SM83_MN.BIT_idx_di, '3', 'E');\r\n        case 0x5C: return new SM83_opcode_info(0x5C, SM83_MN.BIT_idx_di, '3', 'H');\r\n        case 0x5D: return new SM83_opcode_info(0x5D, SM83_MN.BIT_idx_di, '3', 'L');\r\n        case 0x5E: return new SM83_opcode_info(0x5E, SM83_MN.BIT_idx_ind, '3', 'HL');\r\n        case 0x5F: return new SM83_opcode_info(0x5F, SM83_MN.BIT_idx_di, '3', 'A');\r\n\r\n        case 0x60: return new SM83_opcode_info(0x60, SM83_MN.BIT_idx_di, '4', 'B');\r\n        case 0x61: return new SM83_opcode_info(0x61, SM83_MN.BIT_idx_di, '4', 'C');\r\n        case 0x62: return new SM83_opcode_info(0x62, SM83_MN.BIT_idx_di, '4', 'D');\r\n        case 0x63: return new SM83_opcode_info(0x63, SM83_MN.BIT_idx_di, '4', 'E');\r\n        case 0x64: return new SM83_opcode_info(0x64, SM83_MN.BIT_idx_di, '4', 'H');\r\n        case 0x65: return new SM83_opcode_info(0x65, SM83_MN.BIT_idx_di, '4', 'L');\r\n        case 0x66: return new SM83_opcode_info(0x66, SM83_MN.BIT_idx_ind, '4', 'HL');\r\n        case 0x67: return new SM83_opcode_info(0x67, SM83_MN.BIT_idx_di, '4', 'A');\r\n        case 0x68: return new SM83_opcode_info(0x68, SM83_MN.BIT_idx_di, '5', 'B');\r\n        case 0x69: return new SM83_opcode_info(0x69, SM83_MN.BIT_idx_di, '5', 'C');\r\n        case 0x6A: return new SM83_opcode_info(0x6A, SM83_MN.BIT_idx_di, '5', 'D');\r\n        case 0x6B: return new SM83_opcode_info(0x6B, SM83_MN.BIT_idx_di, '5', 'E');\r\n        case 0x6C: return new SM83_opcode_info(0x6C, SM83_MN.BIT_idx_di, '5', 'H');\r\n        case 0x6D: return new SM83_opcode_info(0x6D, SM83_MN.BIT_idx_di, '5', 'L');\r\n        case 0x6E: return new SM83_opcode_info(0x6E, SM83_MN.BIT_idx_ind, '5', 'HL');\r\n        case 0x6F: return new SM83_opcode_info(0x6F, SM83_MN.BIT_idx_di, '5', 'A');\r\n\r\n        case 0x70: return new SM83_opcode_info(0x70, SM83_MN.BIT_idx_di, '6', 'B');\r\n        case 0x71: return new SM83_opcode_info(0x71, SM83_MN.BIT_idx_di, '6', 'C');\r\n        case 0x72: return new SM83_opcode_info(0x72, SM83_MN.BIT_idx_di, '6', 'D');\r\n        case 0x73: return new SM83_opcode_info(0x73, SM83_MN.BIT_idx_di, '6', 'E');\r\n        case 0x74: return new SM83_opcode_info(0x74, SM83_MN.BIT_idx_di, '6', 'H');\r\n        case 0x75: return new SM83_opcode_info(0x75, SM83_MN.BIT_idx_di, '6', 'L');\r\n        case 0x76: return new SM83_opcode_info(0x76, SM83_MN.BIT_idx_ind, '6', 'HL');\r\n        case 0x77: return new SM83_opcode_info(0x77, SM83_MN.BIT_idx_di, '6', 'A');\r\n        case 0x78: return new SM83_opcode_info(0x78, SM83_MN.BIT_idx_di, '7', 'B');\r\n        case 0x79: return new SM83_opcode_info(0x79, SM83_MN.BIT_idx_di, '7', 'C');\r\n        case 0x7A: return new SM83_opcode_info(0x7A, SM83_MN.BIT_idx_di, '7', 'D');\r\n        case 0x7B: return new SM83_opcode_info(0x7B, SM83_MN.BIT_idx_di, '7', 'E');\r\n        case 0x7C: return new SM83_opcode_info(0x7C, SM83_MN.BIT_idx_di, '7', 'H');\r\n        case 0x7D: return new SM83_opcode_info(0x7D, SM83_MN.BIT_idx_di, '7', 'L');\r\n        case 0x7E: return new SM83_opcode_info(0x7E, SM83_MN.BIT_idx_ind, '7', 'HL');\r\n        case 0x7F: return new SM83_opcode_info(0x7F, SM83_MN.BIT_idx_di, '7', 'A');\r\n\r\n        case 0x80: return new SM83_opcode_info(0x80, SM83_MN.RES_idx_di, '0', 'B');\r\n        case 0x81: return new SM83_opcode_info(0x81, SM83_MN.RES_idx_di, '0', 'C');\r\n        case 0x82: return new SM83_opcode_info(0x82, SM83_MN.RES_idx_di, '0', 'D');\r\n        case 0x83: return new SM83_opcode_info(0x83, SM83_MN.RES_idx_di, '0', 'E');\r\n        case 0x84: return new SM83_opcode_info(0x84, SM83_MN.RES_idx_di, '0', 'H');\r\n        case 0x85: return new SM83_opcode_info(0x85, SM83_MN.RES_idx_di, '0', 'L');\r\n        case 0x86: return new SM83_opcode_info(0x86, SM83_MN.RES_idx_ind, '0', 'HL');\r\n        case 0x87: return new SM83_opcode_info(0x87, SM83_MN.RES_idx_di, '0', 'A');\r\n        case 0x88: return new SM83_opcode_info(0x88, SM83_MN.RES_idx_di, '1', 'B');\r\n        case 0x89: return new SM83_opcode_info(0x89, SM83_MN.RES_idx_di, '1', 'C');\r\n        case 0x8A: return new SM83_opcode_info(0x8A, SM83_MN.RES_idx_di, '1', 'D');\r\n        case 0x8B: return new SM83_opcode_info(0x8B, SM83_MN.RES_idx_di, '1', 'E');\r\n        case 0x8C: return new SM83_opcode_info(0x8C, SM83_MN.RES_idx_di, '1', 'H');\r\n        case 0x8D: return new SM83_opcode_info(0x8D, SM83_MN.RES_idx_di, '1', 'L');\r\n        case 0x8E: return new SM83_opcode_info(0x8E, SM83_MN.RES_idx_ind, '1', 'HL');\r\n        case 0x8F: return new SM83_opcode_info(0x8F, SM83_MN.RES_idx_di, '1', 'A');\r\n\r\n        case 0x90: return new SM83_opcode_info(0x90, SM83_MN.RES_idx_di, '2', 'B');\r\n        case 0x91: return new SM83_opcode_info(0x91, SM83_MN.RES_idx_di, '2', 'C');\r\n        case 0x92: return new SM83_opcode_info(0x92, SM83_MN.RES_idx_di, '2', 'D');\r\n        case 0x93: return new SM83_opcode_info(0x93, SM83_MN.RES_idx_di, '2', 'E');\r\n        case 0x94: return new SM83_opcode_info(0x94, SM83_MN.RES_idx_di, '2', 'H');\r\n        case 0x95: return new SM83_opcode_info(0x95, SM83_MN.RES_idx_di, '2', 'L');\r\n        case 0x96: return new SM83_opcode_info(0x96, SM83_MN.RES_idx_ind, '2', 'HL');\r\n        case 0x97: return new SM83_opcode_info(0x97, SM83_MN.RES_idx_di, '2', 'A');\r\n        case 0x98: return new SM83_opcode_info(0x98, SM83_MN.RES_idx_di, '3', 'B');\r\n        case 0x99: return new SM83_opcode_info(0x99, SM83_MN.RES_idx_di, '3', 'C');\r\n        case 0x9A: return new SM83_opcode_info(0x9A, SM83_MN.RES_idx_di, '3', 'D');\r\n        case 0x9B: return new SM83_opcode_info(0x9B, SM83_MN.RES_idx_di, '3', 'E');\r\n        case 0x9C: return new SM83_opcode_info(0x9C, SM83_MN.RES_idx_di, '3', 'H');\r\n        case 0x9D: return new SM83_opcode_info(0x9D, SM83_MN.RES_idx_di, '3', 'L');\r\n        case 0x9E: return new SM83_opcode_info(0x9E, SM83_MN.RES_idx_ind, '3', 'HL');\r\n        case 0x9F: return new SM83_opcode_info(0x9F, SM83_MN.RES_idx_di, '3', 'A');\r\n\r\n        case 0xA0: return new SM83_opcode_info(0xA0, SM83_MN.RES_idx_di, '4', 'B');\r\n        case 0xA1: return new SM83_opcode_info(0xA1, SM83_MN.RES_idx_di, '4', 'C');\r\n        case 0xA2: return new SM83_opcode_info(0xA2, SM83_MN.RES_idx_di, '4', 'D');\r\n        case 0xA3: return new SM83_opcode_info(0xA3, SM83_MN.RES_idx_di, '4', 'E');\r\n        case 0xA4: return new SM83_opcode_info(0xA4, SM83_MN.RES_idx_di, '4', 'H');\r\n        case 0xA5: return new SM83_opcode_info(0xA5, SM83_MN.RES_idx_di, '4', 'L');\r\n        case 0xA6: return new SM83_opcode_info(0xA6, SM83_MN.RES_idx_ind, '4', 'HL');\r\n        case 0xA7: return new SM83_opcode_info(0xA7, SM83_MN.RES_idx_di, '4', 'A');\r\n        case 0xA8: return new SM83_opcode_info(0xA8, SM83_MN.RES_idx_di, '5', 'B');\r\n        case 0xA9: return new SM83_opcode_info(0xA9, SM83_MN.RES_idx_di, '5', 'C');\r\n        case 0xAA: return new SM83_opcode_info(0xAA, SM83_MN.RES_idx_di, '5', 'D');\r\n        case 0xAB: return new SM83_opcode_info(0xAB, SM83_MN.RES_idx_di, '5', 'E');\r\n        case 0xAC: return new SM83_opcode_info(0xAC, SM83_MN.RES_idx_di, '5', 'H');\r\n        case 0xAD: return new SM83_opcode_info(0xAD, SM83_MN.RES_idx_di, '5', 'L');\r\n        case 0xAE: return new SM83_opcode_info(0xAE, SM83_MN.RES_idx_ind, '5', 'HL');\r\n        case 0xAF: return new SM83_opcode_info(0xAF, SM83_MN.RES_idx_di, '5', 'A');\r\n\r\n        case 0xB0: return new SM83_opcode_info(0xB0, SM83_MN.RES_idx_di, '6', 'B');\r\n        case 0xB1: return new SM83_opcode_info(0xB1, SM83_MN.RES_idx_di, '6', 'C');\r\n        case 0xB2: return new SM83_opcode_info(0xB2, SM83_MN.RES_idx_di, '6', 'D');\r\n        case 0xB3: return new SM83_opcode_info(0xB3, SM83_MN.RES_idx_di, '6', 'E');\r\n        case 0xB4: return new SM83_opcode_info(0xB4, SM83_MN.RES_idx_di, '6', 'H');\r\n        case 0xB5: return new SM83_opcode_info(0xB5, SM83_MN.RES_idx_di, '6', 'L');\r\n        case 0xB6: return new SM83_opcode_info(0xB6, SM83_MN.RES_idx_ind, '6', 'HL');\r\n        case 0xB7: return new SM83_opcode_info(0xB7, SM83_MN.RES_idx_di, '6', 'A');\r\n        case 0xB8: return new SM83_opcode_info(0xB8, SM83_MN.RES_idx_di, '7', 'B');\r\n        case 0xB9: return new SM83_opcode_info(0xB9, SM83_MN.RES_idx_di, '7', 'C');\r\n        case 0xBA: return new SM83_opcode_info(0xBA, SM83_MN.RES_idx_di, '7', 'D');\r\n        case 0xBB: return new SM83_opcode_info(0xBB, SM83_MN.RES_idx_di, '7', 'E');\r\n        case 0xBC: return new SM83_opcode_info(0xBC, SM83_MN.RES_idx_di, '7', 'H');\r\n        case 0xBD: return new SM83_opcode_info(0xBD, SM83_MN.RES_idx_di, '7', 'L');\r\n        case 0xBE: return new SM83_opcode_info(0xBE, SM83_MN.RES_idx_ind, '7', 'HL');\r\n        case 0xBF: return new SM83_opcode_info(0xBF, SM83_MN.RES_idx_di, '7', 'A');\r\n\r\n        case 0xC0: return new SM83_opcode_info(0xC0, SM83_MN.SET_idx_di, '0', 'B');\r\n        case 0xC1: return new SM83_opcode_info(0xC1, SM83_MN.SET_idx_di, '0', 'C');\r\n        case 0xC2: return new SM83_opcode_info(0xC2, SM83_MN.SET_idx_di, '0', 'D');\r\n        case 0xC3: return new SM83_opcode_info(0xC3, SM83_MN.SET_idx_di, '0', 'E');\r\n        case 0xC4: return new SM83_opcode_info(0xC4, SM83_MN.SET_idx_di, '0', 'H');\r\n        case 0xC5: return new SM83_opcode_info(0xC5, SM83_MN.SET_idx_di, '0', 'L');\r\n        case 0xC6: return new SM83_opcode_info(0xC6, SM83_MN.SET_idx_ind, '0', 'HL');\r\n        case 0xC7: return new SM83_opcode_info(0xC7, SM83_MN.SET_idx_di, '0', 'A');\r\n        case 0xC8: return new SM83_opcode_info(0xC8, SM83_MN.SET_idx_di, '1', 'B');\r\n        case 0xC9: return new SM83_opcode_info(0xC9, SM83_MN.SET_idx_di, '1', 'C');\r\n        case 0xCA: return new SM83_opcode_info(0xCA, SM83_MN.SET_idx_di, '1', 'D');\r\n        case 0xCB: return new SM83_opcode_info(0xCB, SM83_MN.SET_idx_di, '1', 'E');\r\n        case 0xCC: return new SM83_opcode_info(0xCC, SM83_MN.SET_idx_di, '1', 'H');\r\n        case 0xCD: return new SM83_opcode_info(0xCD, SM83_MN.SET_idx_di, '1', 'L');\r\n        case 0xCE: return new SM83_opcode_info(0xCE, SM83_MN.SET_idx_ind, '1', 'HL');\r\n        case 0xCF: return new SM83_opcode_info(0xCF, SM83_MN.SET_idx_di, '1', 'A');\r\n\r\n        case 0xD0: return new SM83_opcode_info(0xD0, SM83_MN.SET_idx_di, '2', 'B');\r\n        case 0xD1: return new SM83_opcode_info(0xD1, SM83_MN.SET_idx_di, '2', 'C');\r\n        case 0xD2: return new SM83_opcode_info(0xD2, SM83_MN.SET_idx_di, '2', 'D');\r\n        case 0xD3: return new SM83_opcode_info(0xD3, SM83_MN.SET_idx_di, '2', 'E');\r\n        case 0xD4: return new SM83_opcode_info(0xD4, SM83_MN.SET_idx_di, '2', 'H');\r\n        case 0xD5: return new SM83_opcode_info(0xD5, SM83_MN.SET_idx_di, '2', 'L');\r\n        case 0xD6: return new SM83_opcode_info(0xD6, SM83_MN.SET_idx_ind, '2', 'HL');\r\n        case 0xD7: return new SM83_opcode_info(0xD7, SM83_MN.SET_idx_di, '2', 'A');\r\n        case 0xD8: return new SM83_opcode_info(0xD8, SM83_MN.SET_idx_di, '3', 'B');\r\n        case 0xD9: return new SM83_opcode_info(0xD9, SM83_MN.SET_idx_di, '3', 'C');\r\n        case 0xDA: return new SM83_opcode_info(0xDA, SM83_MN.SET_idx_di, '3', 'D');\r\n        case 0xDB: return new SM83_opcode_info(0xDB, SM83_MN.SET_idx_di, '3', 'E');\r\n        case 0xDC: return new SM83_opcode_info(0xDC, SM83_MN.SET_idx_di, '3', 'H');\r\n        case 0xDD: return new SM83_opcode_info(0xDD, SM83_MN.SET_idx_di, '3', 'L');\r\n        case 0xDE: return new SM83_opcode_info(0xDE, SM83_MN.SET_idx_ind, '3', 'HL');\r\n        case 0xDF: return new SM83_opcode_info(0xDF, SM83_MN.SET_idx_di, '3', 'A');\r\n\r\n        case 0xE0: return new SM83_opcode_info(0xE0, SM83_MN.SET_idx_di, '4', 'B');\r\n        case 0xE1: return new SM83_opcode_info(0xE1, SM83_MN.SET_idx_di, '4', 'C');\r\n        case 0xE2: return new SM83_opcode_info(0xE2, SM83_MN.SET_idx_di, '4', 'D');\r\n        case 0xE3: return new SM83_opcode_info(0xE3, SM83_MN.SET_idx_di, '4', 'E');\r\n        case 0xE4: return new SM83_opcode_info(0xE4, SM83_MN.SET_idx_di, '4', 'H');\r\n        case 0xE5: return new SM83_opcode_info(0xE5, SM83_MN.SET_idx_di, '4', 'L');\r\n        case 0xE6: return new SM83_opcode_info(0xE6, SM83_MN.SET_idx_ind, '4', 'HL');\r\n        case 0xE7: return new SM83_opcode_info(0xE7, SM83_MN.SET_idx_di, '4', 'A');\r\n        case 0xE8: return new SM83_opcode_info(0xE8, SM83_MN.SET_idx_di, '5', 'B');\r\n        case 0xE9: return new SM83_opcode_info(0xE9, SM83_MN.SET_idx_di, '5', 'C');\r\n        case 0xEA: return new SM83_opcode_info(0xEA, SM83_MN.SET_idx_di, '5', 'D');\r\n        case 0xEB: return new SM83_opcode_info(0xEB, SM83_MN.SET_idx_di, '5', 'E');\r\n        case 0xEC: return new SM83_opcode_info(0xEC, SM83_MN.SET_idx_di, '5', 'H');\r\n        case 0xED: return new SM83_opcode_info(0xED, SM83_MN.SET_idx_di, '5', 'L');\r\n        case 0xEE: return new SM83_opcode_info(0xEE, SM83_MN.SET_idx_ind, '5', 'HL');\r\n        case 0xEF: return new SM83_opcode_info(0xEF, SM83_MN.SET_idx_di, '5', 'A');\r\n\r\n        case 0xF0: return new SM83_opcode_info(0xF0, SM83_MN.SET_idx_di, '6', 'B');\r\n        case 0xF1: return new SM83_opcode_info(0xF1, SM83_MN.SET_idx_di, '6', 'C');\r\n        case 0xF2: return new SM83_opcode_info(0xF2, SM83_MN.SET_idx_di, '6', 'D');\r\n        case 0xF3: return new SM83_opcode_info(0xF3, SM83_MN.SET_idx_di, '6', 'E');\r\n        case 0xF4: return new SM83_opcode_info(0xF4, SM83_MN.SET_idx_di, '6', 'H');\r\n        case 0xF5: return new SM83_opcode_info(0xF5, SM83_MN.SET_idx_di, '6', 'L');\r\n        case 0xF6: return new SM83_opcode_info(0xF6, SM83_MN.SET_idx_ind, '6', 'HL');\r\n        case 0xF7: return new SM83_opcode_info(0xF7, SM83_MN.SET_idx_di, '6', 'A');\r\n        case 0xF8: return new SM83_opcode_info(0xF8, SM83_MN.SET_idx_di, '7', 'B');\r\n        case 0xF9: return new SM83_opcode_info(0xF9, SM83_MN.SET_idx_di, '7', 'C');\r\n        case 0xFA: return new SM83_opcode_info(0xFA, SM83_MN.SET_idx_di, '7', 'D');\r\n        case 0xFB: return new SM83_opcode_info(0xFB, SM83_MN.SET_idx_di, '7', 'E');\r\n        case 0xFC: return new SM83_opcode_info(0xFC, SM83_MN.SET_idx_di, '7', 'H');\r\n        case 0xFD: return new SM83_opcode_info(0xFD, SM83_MN.SET_idx_di, '7', 'L');\r\n        case 0xFE: return new SM83_opcode_info(0xFE, SM83_MN.SET_idx_ind, '7', 'HL');\r\n        case 0xFF: return new SM83_opcode_info(0xFF, SM83_MN.SET_idx_di, '7', 'A');\r\n    }\r\n    return new SM83_opcode_info(i, SM83_MN.NONE);\r\n}\r\n\r\nexport const SM83_MAX_OPCODE = 0x101;\r\n\r\nexport const SM83_prefixes: StaticArray<u32> = [0, 0xCB]\r\nexport const SM83_prefix_to_codemap: Map<u32, u32> = new Map<u32, u32>();\r\nSM83_prefix_to_codemap.set(0, 0);\r\nSM83_prefix_to_codemap.set(1, SM83_MAX_OPCODE + 1);\r\nSM83_prefix_to_codemap.set(0xCB, SM83_MAX_OPCODE + 1);\r\n\r\nexport class SM83_opcode_functions {\r\n    opcode: u32\r\n    ins: SM83_MN = 0\r\n    mnemonic: String = ''\r\n    exec_func: (regs: SM83_regs_t, pins: SM83_pins_t) => void;\r\n    constructor(opcode_info: SM83_opcode_info, exec_func: (regs: SM83_regs_t, pins: SM83_pins_t) => void) {\r\n        this.opcode = opcode_info.opcode;\r\n        this.ins = opcode_info.ins;\r\n        this.mnemonic = opcode_info.mnemonic;\r\n        this.exec_func = exec_func;\r\n    }\r\n}\r\n\r\n","import {SM83_opcode_functions, SM83_opcode_matrix, SM83_opcode_matrixCB, SM83_MAX_OPCODE, SM83_S_DECODE} from \"../../../component/cpu/sm83/sm83_opcodes\";\r\nimport {SM83_pins_t, SM83_regs_t} from \"../../../component/cpu/sm83/sm83\";\r\nimport {mksigned8} from \"../../../helpers/helpers\"\r\n\r\nexport var sm83_decoded_opcodes: Array<SM83_opcode_functions> = new Array<SM83_opcode_functions>(SM83_MAX_OPCODE+0xFF);\r\n\r\nfunction sm83_get_opcode_function(opcode: u32): SM83_opcode_functions {\r\n    switch(opcode) {\r\n        case 0x00: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x01: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x01),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD16_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    regs.RR = pins.D;\r\n                    regs.TR |= (regs.RR << 8);\r\n                    regs.B = (regs.TR & 0xFF00) >>> 8;\r\n                    regs.C = regs.TR & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x02: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x02),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.B << 8) | regs.C;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x03: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x03),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC16_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    let a = (regs.B << 8) | regs.C;\r\n                    a = (a + 1) & 0xFFFF;\r\n                    regs.B = (a & 0xFF00) >>> 8;\r\n                    regs.C = a & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x04: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x04),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = ((regs.B) + 1) & 0xFF;\r\n                    regs.F.H = +(((regs.B) & 0x0F) == 0);\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x05: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x05),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = ((regs.B) - 1) & 0xFF;\r\n                    regs.F.H = +(((regs.B) & 0x0F) == 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x06: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x06),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.B = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x07: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x07),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLCA\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = ((regs.A << 1) | (regs.A >>> 7)) & 0xFF;\r\n                    regs.F.C = regs.A & 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    regs.F.Z = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x08: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x08),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD16_addr_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 3: // Do write\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.SP & 0xFF;\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 4: // Do write\r\n                    pins.Addr = ((regs.TA + 1) & 0xFFFF);\r\n                    pins.D = (regs.SP & 0xFF00) >>> 8;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 5: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x09: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x09),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD16_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // idle\r\n                    let target = (regs.H << 8) | regs.L;\r\n                    let source = (regs.B << 8) | regs.C;\r\n                    let x = target + source;\r\n                    let y = (target & 0xFFF) + (source & 0xFFF);\r\n                    regs.H = (x & 0xFF00) >>> 8;\r\n                    regs.L = x & 0xFF;\r\n                    regs.F.C = +(x > 0xFFFF);\r\n                    regs.F.H = +(y > 0x0FFF);\r\n                    regs.F.N = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x0A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x0A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.B << 8) | regs.C\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x0B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x0B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC16_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    let a = (regs.B << 8) | regs.C;\r\n                    a = (a - 1) & 0xFFFF;\r\n                    regs.B = (a & 0xFF00) >>> 8;\r\n                    regs.C = a & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x0C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x0C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = ((regs.C) + 1) & 0xFF;\r\n                    regs.F.H = +(((regs.C) & 0x0F) == 0);\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x0D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x0D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = ((regs.C) - 1) & 0xFF;\r\n                    regs.F.H = +(((regs.C) & 0x0F) == 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x0E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x0E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.C = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x0F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x0F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRCA\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = (((regs.A) << 7) | ((regs.A) >>> 1)) & 0xFF;\r\n                    regs.F.C = ((regs.A) & 0x80) >>> 7;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    regs.F.Z = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x10: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x10),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // STOP\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    if (!regs.stoppable()) {break;}\r\n                    console.log('STP!');\r\n                    regs.STP = 1;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2:\r\n                    if (regs.STP) regs.TCU--;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x11: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x11),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD16_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    regs.RR = pins.D;\r\n                    regs.TR |= (regs.RR << 8);\r\n                    regs.D = (regs.TR & 0xFF00) >>> 8;\r\n                    regs.E = regs.TR & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x12: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x12),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.D << 8) | regs.E;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x13: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x13),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC16_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    let a = (regs.D << 8) | regs.E;\r\n                    a = (a + 1) & 0xFFFF;\r\n                    regs.D = (a & 0xFF00) >>> 8;\r\n                    regs.E = a & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x14: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x14),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = ((regs.D) + 1) & 0xFF;\r\n                    regs.F.H = +(((regs.D) & 0x0F) == 0);\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x15: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x15),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = ((regs.D) - 1) & 0xFF;\r\n                    regs.F.H = +(((regs.D) & 0x0F) == 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x16: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x16),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.D = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x17: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x17),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLA\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.A) & 0x80) >>> 7;\r\n                    regs.A = (((regs.A) << 1) & 0xFE) | regs.F.C;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    regs.F.Z = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x18: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x18),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JR_cond_rel\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(1)) { regs.TCU += 1; break; } // CHECKHERE\r\n                    break;\r\n                case 2:\r\n                    regs.TA = pins.D;\r\n                    regs.PC = (mksigned8(regs.TA) + regs.PC) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x19: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x19),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD16_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // idle\r\n                    let target = (regs.H << 8) | regs.L;\r\n                    let source = (regs.D << 8) | regs.E;\r\n                    let x = target + source;\r\n                    let y = (target & 0xFFF) + (source & 0xFFF);\r\n                    regs.H = (x & 0xFF00) >>> 8;\r\n                    regs.L = x & 0xFF;\r\n                    regs.F.C = +(x > 0xFFFF);\r\n                    regs.F.H = +(y > 0x0FFF);\r\n                    regs.F.N = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x1A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.D << 8) | regs.E\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x1B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC16_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    let a = (regs.D << 8) | regs.E;\r\n                    a = (a - 1) & 0xFFFF;\r\n                    regs.D = (a & 0xFF00) >>> 8;\r\n                    regs.E = a & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x1C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = ((regs.E) + 1) & 0xFF;\r\n                    regs.F.H = +(((regs.E) & 0x0F) == 0);\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x1D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = ((regs.E) - 1) & 0xFF;\r\n                    regs.F.H = +(((regs.E) & 0x0F) == 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x1E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.E = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x1F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRA\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.A) & 1;\r\n                    regs.A = ((regs.A) >>> 1) | (regs.F.C << 7);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    regs.F.Z = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x20: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x20),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JR_cond_rel\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.Z == 0)) { regs.TCU += 1; break; } // CHECKHERE\r\n                    break;\r\n                case 2:\r\n                    regs.TA = pins.D;\r\n                    regs.PC = (mksigned8(regs.TA) + regs.PC) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x21: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x21),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD16_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    regs.RR = pins.D;\r\n                    regs.TR |= (regs.RR << 8);\r\n                    regs.H = (regs.TR & 0xFF00) >>> 8;\r\n                    regs.L = regs.TR & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x22: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x22),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_inc_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.A;\r\n                    regs.TA = (regs.TA + 1) & 0xFFFF;\r\n                    regs.H = (regs.TA & 0xFF00) >>> 8;\r\n                    regs.L = regs.TA & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x23: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x23),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC16_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    let a = (regs.H << 8) | regs.L;\r\n                    a = (a + 1) & 0xFFFF;\r\n                    regs.H = (a & 0xFF00) >>> 8;\r\n                    regs.L = a & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x24: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x24),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = ((regs.H) + 1) & 0xFF;\r\n                    regs.F.H = +(((regs.H) & 0x0F) == 0);\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x25: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x25),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = ((regs.H) - 1) & 0xFF;\r\n                    regs.F.H = +(((regs.H) & 0x0F) == 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x26: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x26),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.H = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x27: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x27),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DAA\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let a = regs.A;\r\n                    if (!regs.F.N) {\r\n                        if (regs.F.H || ((regs.A & 0x0F) > 0x09)) a += 0x06;\r\n                        if (regs.F.C || (regs.A > 0x99)) {\r\n                            a += 0x60;\r\n                            regs.F.C = 1;\r\n                        }\r\n                    } else {\r\n                        a -= (0x06 * regs.F.H);\r\n                        a -= (0x60 * regs.F.C);\r\n                    }\r\n                    regs.A = a & 0xFF;\r\n                    regs.F.H = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x28: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x28),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JR_cond_rel\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.Z == 1)) { regs.TCU += 1; break; } // CHECKHERE\r\n                    break;\r\n                case 2:\r\n                    regs.TA = pins.D;\r\n                    regs.PC = (mksigned8(regs.TA) + regs.PC) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x29: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x29),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD16_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // idle\r\n                    let target = (regs.H << 8) | regs.L;\r\n                    let source = (regs.H << 8) | regs.L;\r\n                    let x = target + source;\r\n                    let y = (target & 0xFFF) + (source & 0xFFF);\r\n                    regs.H = (x & 0xFF00) >>> 8;\r\n                    regs.L = x & 0xFF;\r\n                    regs.F.C = +(x > 0xFFFF);\r\n                    regs.F.H = +(y > 0x0FFF);\r\n                    regs.F.N = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x2A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x2A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind_inc\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    regs.TA = (regs.TA + 1) & 0xFFFF;\r\n                    regs.H = (regs.TA & 0xFF00) >>> 8;\r\n                    regs.L = regs.TA & 0xFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x2B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x2B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC16_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    let a = (regs.H << 8) | regs.L;\r\n                    a = (a - 1) & 0xFFFF;\r\n                    regs.H = (a & 0xFF00) >>> 8;\r\n                    regs.L = a & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x2C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x2C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = ((regs.L) + 1) & 0xFF;\r\n                    regs.F.H = +(((regs.L) & 0x0F) == 0);\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x2D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x2D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = ((regs.L) - 1) & 0xFF;\r\n                    regs.F.H = +(((regs.L) & 0x0F) == 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x2E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x2E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.L = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x2F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x2F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CPL\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A ^= 0xFF;\r\n                    regs.F.H = regs.F.N = 1;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x30: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x30),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JR_cond_rel\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.C == 0)) { regs.TCU += 1; break; } // CHECKHERE\r\n                    break;\r\n                case 2:\r\n                    regs.TA = pins.D;\r\n                    regs.PC = (mksigned8(regs.TA) + regs.PC) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x31: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x31),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD16_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    regs.RR = pins.D;\r\n                    regs.TR |= (regs.RR << 8);\r\n                    regs.SP = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x32: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x32),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_dec_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.A;\r\n                    regs.TA = (regs.TA - 1) & 0xFFFF;\r\n                    regs.H = (regs.TA & 0xFF00) >>> 8;\r\n                    regs.L = regs.TA & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x33: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x33),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC16_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    let a = regs.SP;\r\n                    a = (a + 1) & 0xFFFF;\r\n                    regs.SP = a;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x34: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x34),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR = ((regs.TR) + 1) & 0xFF;\r\n                    regs.F.H = +(((regs.TR) & 0x0F) == 0);\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x35: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x35),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR = ((regs.TR) - 1) & 0xFF;\r\n                    regs.F.H = +(((regs.TR) & 0x0F) == 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x36: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x36),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x37: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x37),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SCF\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.C = 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x38: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x38),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JR_cond_rel\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.C == 1)) { regs.TCU += 1; break; } // CHECKHERE\r\n                    break;\r\n                case 2:\r\n                    regs.TA = pins.D;\r\n                    regs.PC = (mksigned8(regs.TA) + regs.PC) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x39: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x39),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD16_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // idle\r\n                    let target = (regs.H << 8) | regs.L;\r\n                    let source = regs.SP;\r\n                    let x = target + source;\r\n                    let y = (target & 0xFFF) + (source & 0xFFF);\r\n                    regs.H = (x & 0xFF00) >>> 8;\r\n                    regs.L = x & 0xFF;\r\n                    regs.F.C = +(x > 0xFFFF);\r\n                    regs.F.H = +(y > 0x0FFF);\r\n                    regs.F.N = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x3A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x3A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind_dec\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    regs.TA = (regs.TA - 1) & 0xFFFF;\r\n                    regs.H = (regs.TA & 0xFF00) >>> 8;\r\n                    regs.L = regs.TA & 0xFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x3B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x3B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC16_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    let a = regs.SP;\r\n                    a = (a - 1) & 0xFFFF;\r\n                    regs.SP = a;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x3C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x3C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // INC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = ((regs.A) + 1) & 0xFF;\r\n                    regs.F.H = +(((regs.A) & 0x0F) == 0);\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x3D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x3D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DEC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = ((regs.A) - 1) & 0xFF;\r\n                    regs.F.H = +(((regs.A) & 0x0F) == 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x3E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x3E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.A = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x3F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x3F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CCF\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.C ^= 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x40: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x40),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.B;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x41: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x41),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.C;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x42: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x42),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.D;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x43: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x43),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.E;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x44: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x44),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.H;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x45: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x45),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x46: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x46),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.B = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x47: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x47),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x48: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x48),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.B;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x49: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x49),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.C;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x4A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x4A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.D;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x4B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x4B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.E;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x4C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x4C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.H;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x4D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x4D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x4E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x4E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.C = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x4F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x4F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x50: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x50),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.B;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x51: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x51),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.C;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x52: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x52),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.D;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x53: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x53),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.E;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x54: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x54),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.H;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x55: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x55),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x56: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x56),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x57: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x57),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x58: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x58),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.B;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x59: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x59),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.C;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x5A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x5A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.D;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x5B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x5B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.E;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x5C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x5C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.H;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x5D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x5D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x5E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x5E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.E = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x5F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x5F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x60: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x60),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.B;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x61: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x61),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.C;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x62: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x62),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.D;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x63: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x63),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.E;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x64: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x64),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.H;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x65: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x65),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x66: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x66),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.H = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x67: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x67),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x68: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x68),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.B;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x69: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x69),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.C;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x6A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x6A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.D;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x6B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x6B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.E;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x6C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x6C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.H;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x6D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x6D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x6E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x6E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.L = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x6F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x6F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x70: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x70),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.B;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x71: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x71),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.C;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x72: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x72),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.D;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x73: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x73),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.E;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x74: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x74),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.H;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x75: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x75),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x76: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x76),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // HALT\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    console.log('HALT!');\r\n                    if ((!regs.IME) && (regs.interrupt_latch !== 0)) regs.halt_bug = 1; \r\n                    regs.HLT = 1;\r\n                    if (regs.HLT) { regs.poll_IRQ = true; regs.TCU--; }\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    //YOYOYO\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x77: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x77),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x78: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x78),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.B;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x79: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x79),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.C;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x7A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x7A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.D;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x7B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x7B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.E;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x7C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x7C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.H;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x7D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x7D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x7E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x7E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x7F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x7F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x80: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x80),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.B);\r\n                    let y = ((regs.A) & 0x0F) + ((regs.B) & 0x0F);\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x81: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x81),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.C);\r\n                    let y = ((regs.A) & 0x0F) + ((regs.C) & 0x0F);\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x82: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x82),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.D);\r\n                    let y = ((regs.A) & 0x0F) + ((regs.D) & 0x0F);\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x83: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x83),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.E);\r\n                    let y = ((regs.A) & 0x0F) + ((regs.E) & 0x0F);\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x84: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x84),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.H);\r\n                    let y = ((regs.A) & 0x0F) + ((regs.H) & 0x0F);\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x85: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x85),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.L);\r\n                    let y = ((regs.A) & 0x0F) + ((regs.L) & 0x0F);\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x86: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x86),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = (regs.A) + (regs.TR);\r\n                    let y = ((regs.A) & 0x0F) + ((regs.TR) & 0x0F);\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x87: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x87),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.A);\r\n                    let y = ((regs.A) & 0x0F) + ((regs.A) & 0x0F);\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x88: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x88),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.B) + regs.F.C;\r\n                    let y = ((regs.A) & 0x0F) + ((regs.B) & 0x0F) + regs.F.C;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x89: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x89),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.C) + regs.F.C;\r\n                    let y = ((regs.A) & 0x0F) + ((regs.C) & 0x0F) + regs.F.C;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x8A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x8A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.D) + regs.F.C;\r\n                    let y = ((regs.A) & 0x0F) + ((regs.D) & 0x0F) + regs.F.C;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x8B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x8B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.E) + regs.F.C;\r\n                    let y = ((regs.A) & 0x0F) + ((regs.E) & 0x0F) + regs.F.C;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x8C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x8C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.H) + regs.F.C;\r\n                    let y = ((regs.A) & 0x0F) + ((regs.H) & 0x0F) + regs.F.C;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x8D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x8D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.L) + regs.F.C;\r\n                    let y = ((regs.A) & 0x0F) + ((regs.L) & 0x0F) + regs.F.C;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x8E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x8E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADC_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = (regs.A) + (regs.TR) + regs.F.C;\r\n                    let y = ((regs.A) & 0x0F) + ((regs.TR) & 0x0F) + regs.F.C;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x8F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x8F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = (regs.A) + (regs.A) + regs.F.C;\r\n                    let y = ((regs.A) & 0x0F) + ((regs.A) & 0x0F) + regs.F.C;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x90: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x90),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SUB_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.B)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.B) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x91: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x91),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SUB_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.C)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.C) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x92: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x92),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SUB_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.D)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.D) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x93: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x93),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SUB_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.E)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.E) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x94: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x94),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SUB_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.H)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.H) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x95: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x95),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SUB_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.L)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.L) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x96: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x96),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SUB_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = ((regs.A) - (regs.TR)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.TR) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x97: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x97),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SUB_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.A)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.A) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x98: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x98),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SBC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.B) - regs.F.C) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.B) &0x0F) - regs.F.C) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x99: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x99),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SBC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.C) - regs.F.C) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.C) &0x0F) - regs.F.C) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x9A: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x9A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SBC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.D) - regs.F.C) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.D) &0x0F) - regs.F.C) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x9B: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x9B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SBC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.E) - regs.F.C) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.E) &0x0F) - regs.F.C) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x9C: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x9C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SBC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.H) - regs.F.C) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.H) &0x0F) - regs.F.C) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x9D: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x9D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SBC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.L) - regs.F.C) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.L) &0x0F) - regs.F.C) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x9E: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x9E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SBC_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = ((regs.A) - (regs.TR) - regs.F.C) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.TR) &0x0F) - regs.F.C) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x9F: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x9F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SBC_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.A) - regs.F.C) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.A) &0x0F) - regs.F.C) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA0: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // AND_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) & (regs.B);\r\n                    regs.F.C = regs.F.N = 0;\r\n                    regs.F.H = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA1: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // AND_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) & (regs.C);\r\n                    regs.F.C = regs.F.N = 0;\r\n                    regs.F.H = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA2: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // AND_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) & (regs.D);\r\n                    regs.F.C = regs.F.N = 0;\r\n                    regs.F.H = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA3: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // AND_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) & (regs.E);\r\n                    regs.F.C = regs.F.N = 0;\r\n                    regs.F.H = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA4: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // AND_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) & (regs.H);\r\n                    regs.F.C = regs.F.N = 0;\r\n                    regs.F.H = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA5: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // AND_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) & (regs.L);\r\n                    regs.F.C = regs.F.N = 0;\r\n                    regs.F.H = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA6: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // AND_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.TR = (regs.A) & (regs.TR);\r\n                    regs.F.C = regs.F.N = 0;\r\n                    regs.F.H = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA7: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // AND_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) & (regs.A);\r\n                    regs.F.C = regs.F.N = 0;\r\n                    regs.F.H = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA8: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // XOR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) ^ (regs.B);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xA9: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xA9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // XOR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) ^ (regs.C);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xAA: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xAA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // XOR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) ^ (regs.D);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xAB: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xAB),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // XOR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) ^ (regs.E);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xAC: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xAC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // XOR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) ^ (regs.H);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xAD: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xAD),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // XOR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) ^ (regs.L);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xAE: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xAE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // XOR_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.TR = (regs.A) ^ (regs.TR);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xAF: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xAF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // XOR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) ^ (regs.A);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB0: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // OR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) | (regs.B);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB1: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // OR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) | (regs.C);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB2: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // OR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) | (regs.D);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB3: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // OR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) | (regs.E);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB4: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // OR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) | (regs.H);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB5: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // OR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) | (regs.L);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB6: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // OR_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.TR = (regs.A) | (regs.TR);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB7: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // OR_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.TR = (regs.A) | (regs.A);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB8: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CP_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.B)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.B) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((x & 0xFF) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xB9: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xB9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CP_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.C)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.C) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((x & 0xFF) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xBA: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xBA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CP_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.D)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.D) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((x & 0xFF) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xBB: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xBB),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CP_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.E)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.E) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((x & 0xFF) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xBC: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xBC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CP_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.H)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.H) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((x & 0xFF) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xBD: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xBD),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CP_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.L)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.L) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((x & 0xFF) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xBE: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xBE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CP_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = ((regs.A) - (regs.TR)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.TR) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((x & 0xFF) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xBF: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xBF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CP_di_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let x = ((regs.A) - (regs.A)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.A) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((x & 0xFF) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC0: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RET_cond\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    if (!(regs.F.Z == 0)) { pins.RD = 0; pins.MRQ = 0; regs.TCU += 3; break; } // CHECKHERE\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 4:\r\n                    regs.TR = pins.D;\r\n                    regs.TA |= (regs.TR << 8);\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 5: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC1: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // POP_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.C = pins.D;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    regs.B = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC2: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JP_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.Z == 0)) { regs.TCU++; }\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.PC = regs.TA\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC3: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JP_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC4: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CALL_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.Z == 0)) { regs.TCU += 3; break; } // CHECKHERE\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 5: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 6: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC5: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // PUSH_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.B;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.C;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC6: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = (regs.A) + (regs.TR);\r\n                    let y = ((regs.A) & 0x0F) + ((regs.TR) & 0x0F);\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC7: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RST_imp\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = 0x0000;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC8: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RET_cond\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    if (!(regs.F.Z == 1)) { pins.RD = 0; pins.MRQ = 0; regs.TCU += 3; break; } // CHECKHERE\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 4:\r\n                    regs.TR = pins.D;\r\n                    regs.TA |= (regs.TR << 8);\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 5: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xC9: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xC9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RET\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 3:\r\n                    regs.TR = pins.D;\r\n                    regs.TA |= (regs.TR << 8);\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xCA: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xCA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JP_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.Z == 1)) { regs.TCU++; }\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.PC = regs.TA\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xCB: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xCC: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xCC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CALL_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.Z == 1)) { regs.TCU += 3; break; } // CHECKHERE\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 5: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 6: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xCD: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xCD),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CALL_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(1)) { regs.TCU += 3; break; } // CHECKHERE\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 5: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 6: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xCE: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xCE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADC_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = (regs.A) + (regs.TR) + regs.F.C;\r\n                    let y = ((regs.A) & 0x0F) + ((regs.TR) & 0x0F) + regs.F.C;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 0;\r\n                    regs.TR = (x & 0xFF);\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xCF: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xCF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RST_imp\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = 0x0008;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD0: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xD0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RET_cond\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    if (!(regs.F.C == 0)) { pins.RD = 0; pins.MRQ = 0; regs.TCU += 3; break; } // CHECKHERE\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 4:\r\n                    regs.TR = pins.D;\r\n                    regs.TA |= (regs.TR << 8);\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 5: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD1: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xD1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // POP_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.E = pins.D;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    regs.D = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD2: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xD2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JP_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.C == 0)) { regs.TCU++; }\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.PC = regs.TA\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD3: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD4: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xD4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CALL_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.C == 0)) { regs.TCU += 3; break; } // CHECKHERE\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 5: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 6: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD5: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xD5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // PUSH_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.D;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.E;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD6: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xD6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SUB_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = ((regs.A) - (regs.TR)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.TR) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD7: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xD7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RST_imp\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = 0x0010;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD8: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xD8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RET_cond\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    if (!(regs.F.C == 1)) { pins.RD = 0; pins.MRQ = 0; regs.TCU += 3; break; } // CHECKHERE\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 4:\r\n                    regs.TR = pins.D;\r\n                    regs.TA |= (regs.TR << 8);\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 5: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xD9: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xD9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RETI\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 3:\r\n                    regs.TR = pins.D;\r\n                    regs.TA |= (regs.TR << 8);\r\n                    regs.PC = regs.TA;\r\n                    regs.IME = 1;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xDA: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xDA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JP_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.C == 1)) { regs.TCU++; }\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.PC = regs.TA\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xDB: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xDC: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xDC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CALL_cond_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    if (!(regs.F.C == 1)) { regs.TCU += 3; break; } // CHECKHERE\r\n                    break;\r\n                case 3:\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 4: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 5: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = regs.TA;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 6: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xDD: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xDE: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xDE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SBC_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = ((regs.A) - (regs.TR) - regs.F.C) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.TR) &0x0F) - regs.F.C) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.TR = x & 0xFF;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xDF: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xDF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RST_imp\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = 0x0018;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE0: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xE0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LDH_addr_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TA = pins.D;\r\n                    regs.TA |= 0xFF00;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE1: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xE1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // POP_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.L = pins.D;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    regs.H = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE2: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xE2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LDH_ind_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do write\r\n                    regs.TA = 0xFF00 | regs.C;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE3: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE4: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE5: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xE5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // PUSH_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.H;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE6: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xE6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // AND_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.TR = (regs.A) & (regs.TR);\r\n                    regs.F.C = regs.F.N = 0;\r\n                    regs.F.H = 1;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE7: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xE7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RST_imp\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = 0x0020;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE8: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xE8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // ADD_di_rel\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2:\r\n                    regs.TR = pins.D;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 3:\r\n                    let target = regs.SP;\r\n                    regs.F.C = +(((target & 0xFF) + regs.TR) > 0xFF);\r\n                    regs.F.H = +(((target & 0x0F) + (regs.TR & 0x0F)) > 0x0F);\r\n                    regs.F.N = regs.F.Z = 0;\r\n                    target = (target + mksigned8(regs.TR)) & 0xFFFF;\r\n                    regs.SP = target;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xE9: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xE9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // JP_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.PC = (regs.H << 8) | regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xEA: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xEA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_addr_di\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 3: // Do write\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.A;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xEB: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xEC: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xED: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xEE: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xEE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // XOR_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.TR = (regs.A) ^ (regs.TR);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xEF: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xEF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RST_imp\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = 0x0028;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF0: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xF0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LDH_di_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    regs.TA |= 0xFF00;\r\n                    pins.Addr = (regs.TA);\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    regs.A = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF1: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xF1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // POP_di_AF\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.SP);\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TR = pins.D;\r\n                    regs.F.setbyte(regs.TR & 0xF0);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    pins.Addr = (regs.SP);\r\n                    regs.SP = (regs.SP + 1) & 0xFFFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    regs.A = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF2: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xF2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LDH_di_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = 0xFF00 | regs.C;\r\n                    pins.Addr = (regs.TA);\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.A = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF3: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xF3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // DI\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.IME = 0;\r\n                    console.log('DI!');\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF4: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF5: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xF5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // PUSH_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.A;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.F.getbyte();\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF6: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xF6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // OR_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.TR = (regs.A) | (regs.TR);\r\n                    regs.F.C = regs.F.N = regs.F.H = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    regs.A = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF7: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xF7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RST_imp\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = 0x0030;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF8: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xF8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_di_rel\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2:\r\n                    regs.TR = pins.D;\r\n                    let source = regs.SP;\r\n                    regs.F.C = +(((source & 0xFF) + regs.TR) > 0xFF);\r\n                    regs.F.H = +(((source & 0x0F) + (regs.TR & 0x0F)) > 0x0F);\r\n                    regs.F.N = regs.F.Z = 0;\r\n                    source = (source + mksigned8(regs.TR)) & 0xFFFF;\r\n                    regs.H = (source & 0xFF00) >>> 8;\r\n                    regs.L = source & 0xFF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xF9: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xF9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD16_di_di\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.H << 8) | regs.L;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xFA: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xFA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // LD_di_addr\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // Do read\r\n                    regs.TA = pins.D;\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 3: // Do read\r\n                    regs.RR = pins.D;\r\n                    regs.TA |= (regs.RR << 8);\r\n                    pins.Addr = (regs.TA);\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    regs.A = pins.D;\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xFB: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xFB),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // EI\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    console.log('EI!');\r\n                    regs.IME_DELAY = 2;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xFC: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xFD: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xFE: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xFE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // CP_di_da\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = (regs.PC);\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    let x = ((regs.A) - (regs.TR)) & 0xFFFF;\r\n                    let y = (((regs.A) & 0x0F) - ((regs.TR) & 0x0F)) & 0xFFFF;\r\n                    regs.F.C = +(x > 0xFF);\r\n                    regs.F.H = +(y > 0x0F);\r\n                    regs.F.N = 1;\r\n                    regs.F.Z = +((x & 0xFF) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0xFF: return new SM83_opcode_functions(SM83_opcode_matrix.get(0xFF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RST_imp\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = regs.PC & 0xFF;\r\n                    regs.PC = 0x0038;\r\n                    // Following is auto-generated code for instruction finish\r\n                    break;\r\n                case 4: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x100: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x100),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // S_IRQ\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    regs.IME = 0;\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2:\r\n                    regs.PC = (regs.PC - 1) & 0xFFFF;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    break;\r\n                case 3: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF00) >>> 8;\r\n                    regs.SP = (regs.SP - 1) & 0xFFFF;\r\n                    pins.WR = 1; pins.MRQ = 1;\r\n                    break;\r\n                case 4: // Do write\r\n                    pins.Addr = (regs.SP);\r\n                    pins.D = (regs.PC & 0xFF);\r\n                    break;\r\n                case 5:\r\n                    regs.PC = regs.IV;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.WR = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 6: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x101: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x101),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RESET\r\n            switch(regs.TCU) {\r\n                case 1:\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.MRQ = 0;\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.MRQ = 1;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x102: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = ((regs.B << 1) | (regs.B >>> 7)) & 0xFF;\r\n                    regs.F.C = regs.B & 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x103: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x01),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = ((regs.C << 1) | (regs.C >>> 7)) & 0xFF;\r\n                    regs.F.C = regs.C & 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x104: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x02),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = ((regs.D << 1) | (regs.D >>> 7)) & 0xFF;\r\n                    regs.F.C = regs.D & 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x105: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x03),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = ((regs.E << 1) | (regs.E >>> 7)) & 0xFF;\r\n                    regs.F.C = regs.E & 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x106: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x04),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = ((regs.H << 1) | (regs.H >>> 7)) & 0xFF;\r\n                    regs.F.C = regs.H & 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x107: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x05),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = ((regs.L << 1) | (regs.L >>> 7)) & 0xFF;\r\n                    regs.F.C = regs.L & 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x108: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x06),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLC_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L;\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR = ((regs.TR << 1) | (regs.TR >>> 7)) & 0xFF;\r\n                    regs.F.C = regs.TR & 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x109: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x07),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RLC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = ((regs.A << 1) | (regs.A >>> 7)) & 0xFF;\r\n                    regs.F.C = regs.A & 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x10A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x08),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = (((regs.B) << 7) | ((regs.B) >>> 1)) & 0xFF;\r\n                    regs.F.C = ((regs.B) & 0x80) >>> 7;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x10B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x09),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = (((regs.C) << 7) | ((regs.C) >>> 1)) & 0xFF;\r\n                    regs.F.C = ((regs.C) & 0x80) >>> 7;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x10C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x0A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = (((regs.D) << 7) | ((regs.D) >>> 1)) & 0xFF;\r\n                    regs.F.C = ((regs.D) & 0x80) >>> 7;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x10D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x0B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = (((regs.E) << 7) | ((regs.E) >>> 1)) & 0xFF;\r\n                    regs.F.C = ((regs.E) & 0x80) >>> 7;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x10E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x0C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = (((regs.H) << 7) | ((regs.H) >>> 1)) & 0xFF;\r\n                    regs.F.C = ((regs.H) & 0x80) >>> 7;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x10F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x0D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = (((regs.L) << 7) | ((regs.L) >>> 1)) & 0xFF;\r\n                    regs.F.C = ((regs.L) & 0x80) >>> 7;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x110: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x0E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRC_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR = (((regs.TR) << 7) | ((regs.TR) >>> 1)) & 0xFF;\r\n                    regs.F.C = ((regs.TR) & 0x80) >>> 7;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x111: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x0F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RRC_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = (((regs.A) << 7) | ((regs.A) >>> 1)) & 0xFF;\r\n                    regs.F.C = ((regs.A) & 0x80) >>> 7;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x112: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x10),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.B) & 0x80) >>> 7;\r\n                    regs.B = (((regs.B) << 1) & 0xFE) | regs.F.C;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x113: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x11),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.C) & 0x80) >>> 7;\r\n                    regs.C = (((regs.C) << 1) & 0xFE) | regs.F.C;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x114: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x12),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.D) & 0x80) >>> 7;\r\n                    regs.D = (((regs.D) << 1) & 0xFE) | regs.F.C;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x115: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x13),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.E) & 0x80) >>> 7;\r\n                    regs.E = (((regs.E) << 1) & 0xFE) | regs.F.C;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x116: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x14),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.H) & 0x80) >>> 7;\r\n                    regs.H = (((regs.H) << 1) & 0xFE) | regs.F.C;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x117: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x15),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.L) & 0x80) >>> 7;\r\n                    regs.L = (((regs.L) << 1) & 0xFE) | regs.F.C;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x118: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x16),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RL_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    let carry = ((regs.TR) & 0x80) >>> 7;\r\n                    regs.TR = (((regs.TR) << 1) & 0xFE) | regs.F.C;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x119: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x17),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.A) & 0x80) >>> 7;\r\n                    regs.A = (((regs.A) << 1) & 0xFE) | regs.F.C;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x11A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x18),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RR_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.B) & 1;\r\n                    regs.B = ((regs.B) >>> 1) | (regs.F.C << 7);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x11B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x19),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RR_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.C) & 1;\r\n                    regs.C = ((regs.C) >>> 1) | (regs.F.C << 7);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x11C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x1A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RR_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.D) & 1;\r\n                    regs.D = ((regs.D) >>> 1) | (regs.F.C << 7);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x11D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x1B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RR_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.E) & 1;\r\n                    regs.E = ((regs.E) >>> 1) | (regs.F.C << 7);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x11E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x1C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RR_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.H) & 1;\r\n                    regs.H = ((regs.H) >>> 1) | (regs.F.C << 7);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x11F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x1D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RR_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.L) & 1;\r\n                    regs.L = ((regs.L) >>> 1) | (regs.F.C << 7);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x120: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x1E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RR_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    let carry = (regs.TR) & 1;\r\n                    regs.TR = ((regs.TR) >>> 1) | (regs.F.C << 7);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x121: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x1F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RR_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.A) & 1;\r\n                    regs.A = ((regs.A) >>> 1) | (regs.F.C << 7);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x122: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x20),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SLA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.B) & 0x80) >>> 7;\r\n                    regs.B = ((regs.B) << 1) & 0xFF;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x123: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x21),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SLA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.C) & 0x80) >>> 7;\r\n                    regs.C = ((regs.C) << 1) & 0xFF;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x124: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x22),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SLA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.D) & 0x80) >>> 7;\r\n                    regs.D = ((regs.D) << 1) & 0xFF;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x125: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x23),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SLA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.E) & 0x80) >>> 7;\r\n                    regs.E = ((regs.E) << 1) & 0xFF;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x126: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x24),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SLA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.H) & 0x80) >>> 7;\r\n                    regs.H = ((regs.H) << 1) & 0xFF;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x127: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x25),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SLA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.L) & 0x80) >>> 7;\r\n                    regs.L = ((regs.L) << 1) & 0xFF;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x128: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x26),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SLA_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    let carry = ((regs.TR) & 0x80) >>> 7;\r\n                    regs.TR = ((regs.TR) << 1) & 0xFF;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x129: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x27),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SLA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = ((regs.A) & 0x80) >>> 7;\r\n                    regs.A = ((regs.A) << 1) & 0xFF;\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x12A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x28),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.B) & 1;\r\n                    regs.B = ((regs.B) & 0x80) | ((regs.B) >>> 1);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x12B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x29),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.C) & 1;\r\n                    regs.C = ((regs.C) & 0x80) | ((regs.C) >>> 1);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x12C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x2A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.D) & 1;\r\n                    regs.D = ((regs.D) & 0x80) | ((regs.D) >>> 1);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x12D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x2B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.E) & 1;\r\n                    regs.E = ((regs.E) & 0x80) | ((regs.E) >>> 1);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x12E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x2C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.H) & 1;\r\n                    regs.H = ((regs.H) & 0x80) | ((regs.H) >>> 1);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x12F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x2D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.L) & 1;\r\n                    regs.L = ((regs.L) & 0x80) | ((regs.L) >>> 1);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x130: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x2E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRA_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    let carry = (regs.TR) & 1;\r\n                    regs.TR = ((regs.TR) & 0x80) | ((regs.TR) >>> 1);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x131: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x2F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRA_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    let carry = (regs.A) & 1;\r\n                    regs.A = ((regs.A) & 0x80) | ((regs.A) >>> 1);\r\n                    regs.F.C = carry;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x132: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x30),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SWAP_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = (((regs.B) << 4) | ((regs.B) >>> 4)) & 0xFF;\r\n                    regs.F.C = regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x133: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x31),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SWAP_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = (((regs.C) << 4) | ((regs.C) >>> 4)) & 0xFF;\r\n                    regs.F.C = regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x134: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x32),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SWAP_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = (((regs.D) << 4) | ((regs.D) >>> 4)) & 0xFF;\r\n                    regs.F.C = regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x135: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x33),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SWAP_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = (((regs.E) << 4) | ((regs.E) >>> 4)) & 0xFF;\r\n                    regs.F.C = regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x136: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x34),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SWAP_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = (((regs.H) << 4) | ((regs.H) >>> 4)) & 0xFF;\r\n                    regs.F.C = regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x137: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x35),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SWAP_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = (((regs.L) << 4) | ((regs.L) >>> 4)) & 0xFF;\r\n                    regs.F.C = regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x138: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x36),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SWAP_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR = (((regs.TR) << 4) | ((regs.TR) >>> 4)) & 0xFF;\r\n                    regs.F.C = regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x139: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x37),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SWAP_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = (((regs.A) << 4) | ((regs.A) >>> 4)) & 0xFF;\r\n                    regs.F.C = regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x13A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x38),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.C = (regs.B) & 1;\r\n                    regs.B = (regs.B) >>> 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x13B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x39),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.C = (regs.C) & 1;\r\n                    regs.C = (regs.C) >>> 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x13C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x3A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.C = (regs.D) & 1;\r\n                    regs.D = (regs.D) >>> 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x13D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x3B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.C = (regs.E) & 1;\r\n                    regs.E = (regs.E) >>> 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x13E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x3C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.C = (regs.H) & 1;\r\n                    regs.H = (regs.H) >>> 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x13F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x3D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.C = (regs.L) & 1;\r\n                    regs.L = (regs.L) >>> 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x140: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x3E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRL_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.F.C = (regs.TR) & 1;\r\n                    regs.TR = (regs.TR) >>> 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR) == 0);\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x141: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x3F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SRL_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.C = (regs.A) & 1;\r\n                    regs.A = (regs.A) >>> 1;\r\n                    regs.F.H = regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x142: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x40),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B & 1) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x143: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x41),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C & 1) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x144: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x42),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D & 1) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x145: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x43),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E & 1) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x146: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x44),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H & 1) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x147: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x45),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L & 1) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x148: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x46),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR & 1) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x149: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x47),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A & 1) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x14A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x48),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B & 2) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x14B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x49),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C & 2) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x14C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x4A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D & 2) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x14D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x4B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E & 2) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x14E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x4C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H & 2) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x14F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x4D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L & 2) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x150: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x4E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR & 2) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x151: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x4F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A & 2) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x152: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x50),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B & 4) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x153: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x51),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C & 4) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x154: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x52),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D & 4) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x155: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x53),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E & 4) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x156: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x54),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H & 4) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x157: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x55),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L & 4) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x158: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x56),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR & 4) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x159: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x57),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A & 4) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x15A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x58),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B & 8) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x15B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x59),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C & 8) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x15C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x5A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D & 8) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x15D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x5B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E & 8) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x15E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x5C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H & 8) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x15F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x5D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L & 8) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x160: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x5E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR & 8) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x161: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x5F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A & 8) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x162: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x60),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B & 16) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x163: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x61),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C & 16) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x164: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x62),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D & 16) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x165: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x63),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E & 16) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x166: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x64),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H & 16) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x167: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x65),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L & 16) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x168: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x66),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR & 16) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x169: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x67),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A & 16) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x16A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x68),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B & 32) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x16B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x69),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C & 32) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x16C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x6A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D & 32) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x16D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x6B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E & 32) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x16E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x6C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H & 32) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x16F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x6D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L & 32) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x170: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x6E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR & 32) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x171: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x6F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A & 32) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x172: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x70),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B & 64) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x173: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x71),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C & 64) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x174: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x72),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D & 64) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x175: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x73),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E & 64) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x176: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x74),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H & 64) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x177: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x75),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L & 64) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x178: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x76),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR & 64) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x179: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x77),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A & 64) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x17A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x78),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.B & 128) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x17B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x79),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.C & 128) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x17C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x7A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.D & 128) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x17D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x7B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.E & 128) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x17E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x7C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.H & 128) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x17F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x7D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.L & 128) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x180: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x7E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    pins.Addr = ((regs.H << 8) | regs.L);\r\n                    break;\r\n                case 2: // cleanup_custom\r\n                    regs.TR = pins.D;\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.TR & 128) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x181: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x7F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // BIT_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.F.H = 1;\r\n                    regs.F.N = 0;\r\n                    regs.F.Z = +((regs.A & 128) == 0);\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x182: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x80),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B &= 0xFE;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x183: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x81),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C &= 0xFE;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x184: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x82),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D &= 0xFE;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x185: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x83),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E &= 0xFE;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x186: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x84),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H &= 0xFE;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x187: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x85),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L &= 0xFE;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x188: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x86),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR & 0xFE;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x189: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x87),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A &= 0xFE;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x18A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x88),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B &= 0xFD;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x18B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x89),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C &= 0xFD;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x18C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x8A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D &= 0xFD;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x18D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x8B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E &= 0xFD;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x18E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x8C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H &= 0xFD;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x18F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x8D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L &= 0xFD;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x190: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x8E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR & 0xFD;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x191: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x8F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A &= 0xFD;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x192: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x90),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B &= 0xFB;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x193: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x91),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C &= 0xFB;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x194: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x92),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D &= 0xFB;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x195: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x93),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E &= 0xFB;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x196: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x94),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H &= 0xFB;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x197: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x95),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L &= 0xFB;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x198: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x96),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR & 0xFB;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x199: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x97),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A &= 0xFB;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x19A: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x98),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B &= 0xF7;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x19B: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x99),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C &= 0xF7;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x19C: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x9A),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D &= 0xF7;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x19D: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x9B),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E &= 0xF7;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x19E: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x9C),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H &= 0xF7;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x19F: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x9D),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L &= 0xF7;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A0: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x9E),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR & 0xF7;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A1: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0x9F),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A &= 0xF7;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A2: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B &= 0xEF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A3: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C &= 0xEF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A4: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D &= 0xEF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A5: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E &= 0xEF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A6: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H &= 0xEF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A7: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L &= 0xEF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A8: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR & 0xEF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1A9: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A &= 0xEF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1AA: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B &= 0xDF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1AB: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xA9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C &= 0xDF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1AC: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xAA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D &= 0xDF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1AD: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xAB),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E &= 0xDF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1AE: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xAC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H &= 0xDF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1AF: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xAD),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L &= 0xDF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B0: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xAE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR & 0xDF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B1: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xAF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A &= 0xDF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B2: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B &= 0xBF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B3: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C &= 0xBF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B4: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D &= 0xBF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B5: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E &= 0xBF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B6: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H &= 0xBF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B7: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L &= 0xBF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B8: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR & 0xBF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1B9: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A &= 0xBF;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1BA: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B &= 0x7F;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1BB: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xB9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C &= 0x7F;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1BC: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xBA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D &= 0x7F;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1BD: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xBB),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E &= 0x7F;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1BE: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xBC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H &= 0x7F;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1BF: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xBD),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L &= 0x7F;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C0: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xBE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR & 0x7F;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C1: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xBF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // RES_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A &= 0x7F;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C2: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.B | 0x01;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C3: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.C | 0x01;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C4: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.D | 0x01;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C5: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.E | 0x01;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C6: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.H | 0x01;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C7: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.L | 0x01;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C8: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR |= 0x01;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1C9: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.A | 0x01;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1CA: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.B | 0x02;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1CB: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xC9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.C | 0x02;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1CC: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xCA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.D | 0x02;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1CD: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xCB),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.E | 0x02;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1CE: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xCC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.H | 0x02;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1CF: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xCD),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.L | 0x02;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D0: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xCE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR |= 0x02;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D1: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xCF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.A | 0x02;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D2: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.B | 0x04;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D3: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.C | 0x04;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D4: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.D | 0x04;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D5: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.E | 0x04;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D6: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.H | 0x04;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D7: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.L | 0x04;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D8: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR |= 0x04;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1D9: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.A | 0x04;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1DA: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.B | 0x08;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1DB: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xD9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.C | 0x08;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1DC: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xDA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.D | 0x08;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1DD: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xDB),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.E | 0x08;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1DE: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xDC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.H | 0x08;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1DF: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xDD),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.L | 0x08;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E0: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xDE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR |= 0x08;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E1: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xDF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.A | 0x08;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E2: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.B | 0x10;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E3: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.C | 0x10;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E4: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.D | 0x10;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E5: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.E | 0x10;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E6: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.H | 0x10;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E7: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.L | 0x10;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E8: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR |= 0x10;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1E9: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.A | 0x10;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1EA: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.B | 0x20;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1EB: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xE9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.C | 0x20;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1EC: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xEA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.D | 0x20;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1ED: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xEB),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.E | 0x20;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1EE: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xEC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.H | 0x20;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1EF: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xED),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.L | 0x20;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F0: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xEE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR |= 0x20;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F1: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xEF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.A | 0x20;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F2: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF0),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.B | 0x40;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F3: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF1),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.C | 0x40;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F4: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF2),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.D | 0x40;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F5: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF3),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.E | 0x40;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F6: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF4),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.H | 0x40;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F7: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF5),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.L | 0x40;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F8: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF6),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR |= 0x40;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1F9: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF7),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.A | 0x40;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1FA: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF8),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.B = regs.B | 0x80;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1FB: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xF9),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.C = regs.C | 0x80;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1FC: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xFA),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.D = regs.D | 0x80;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1FD: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xFB),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.E = regs.E | 0x80;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1FE: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xFC),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.H = regs.H | 0x80;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x1FF: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xFD),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.L = regs.L | 0x80;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x200: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xFE),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_ind\r\n            switch(regs.TCU) {\r\n                case 1: // Do read\r\n                    regs.TA = (regs.H << 8) | regs.L\r\n                    pins.Addr = (regs.TA);\r\n                    break;\r\n                case 2: // Do write\r\n                    regs.TR = pins.D;\r\n                    regs.TR |= 0x80;\r\n                    pins.Addr = (regs.TA);\r\n                    pins.D = regs.TR;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.RD = 0; pins.WR = 1;\r\n                    break;\r\n                case 3: // cleanup_custom\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    pins.RD = 1; pins.WR = 0;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x201: return new SM83_opcode_functions(SM83_opcode_matrixCB.get(0xFF),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // SET_idx_di\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    regs.A = regs.A | 0x80;\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x202: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n        case 0x203: return new SM83_opcode_functions(SM83_opcode_matrix.get(0x00),\r\n            function(regs: SM83_regs_t, pins: SM83_pins_t): void { // NOP\r\n            switch(regs.TCU) {\r\n                case 1: // cleanup_custom\r\n                    //NOPE!\r\n                    // Following is auto-generated code for instruction finish\r\n                    pins.Addr = regs.PC;\r\n                    regs.PC = (regs.PC + 1) & 0xFFFF;\r\n                    regs.TCU = 0;\r\n                    regs.IR = SM83_S_DECODE;\r\n                    regs.poll_IRQ = true;\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    return new SM83_opcode_functions(SM83_opcode_matrix.get(0), function(regs: SM83_regs_t, pins: SM83_pins_t): void { console.log('INVALID OPCODE');});\r\n}\r\n\r\nfor (let i = 0; i <= (SM83_MAX_OPCODE+0xFF); i++) {\r\n    sm83_decoded_opcodes[i] = sm83_get_opcode_function(i);\r\n}\r\n","import {GB_variants} from \"../../../system/gb/gb_common\";\r\nimport {hex2, hex4} from \"../../../helpers/helpers\";\r\nimport {\r\n    SM83_HALT,\r\n    SM83_opcode_functions,\r\n    SM83_opcode_matrix,\r\n    SM83_prefix_to_codemap,\r\n    SM83_S_DECODE, SM83_S_IRQ,\r\n    SM83_S_RESET\r\n} from \"./sm83_opcodes\";\r\nimport {GB_bus, GB_clock} from \"../../../system/gb/gb\";\r\nimport {dbg} from \"../../../helpers/debug\";\r\nimport {sm83_decoded_opcodes} from \"./sm83_generated_opcodes\";\r\n\r\nexport var SM83_PC_BRK: i32 = -1;\r\n\r\nclass SM83_regs_F {\r\n        Z: u32 = 0;\r\n        N: u32 = 0;\r\n        H: u32 = 0;\r\n        C: u32 = 0;\r\n\r\n    getbyte(): u32 {\r\n        return (this.C << 4) | (this.H << 5) | (this.N << 6) | (this.Z << 7);\r\n    }\r\n\r\n    setbyte(val: u32): void {\r\n        this.C = (val & 0x10) >>> 4;\r\n        this.H = (val & 0x20) >>> 5;\r\n        this.N = (val & 0x40) >>> 6;\r\n        this.Z = (val & 0x80) >>> 7;\r\n    }\r\n\r\n    formatbyte(): string {\r\n\t\tlet outstr = '';\r\n\t\toutstr += this.C ? 'C' : 'c';\r\n\t\toutstr += this.H ? 'H' : 'h';\r\n\t\toutstr += this.N ? 'N' : 'n';\r\n\t\toutstr += this.Z ? 'Z' : 'z';\r\n\t\treturn outstr;\r\n    }\r\n}\r\n\r\nexport class SM83_regs_t {\r\n    A: u32 = 0\r\n    F: SM83_regs_F = new SM83_regs_F()\r\n    B: u32 = 0;\r\n    C: u32 = 0;\r\n    D: u32 = 0;\r\n    E: u32 = 0;\r\n    H: u32 = 0;\r\n    L: u32 = 0;\r\n    SP: u32 = 0;\r\n    PC: u32 = 0;\r\n\r\n    IV: i32 = 0; // interrupt vector to execute\r\n    IME_DELAY: i32 = 0;\r\n\r\n    IE: u32 = 0; // Enable interrupt?\r\n    IF: u32 = 0; // Interrupt flag\r\n    HLT: u32 = 0;\r\n    STP: u32 = 0;\r\n    IME: u32 = 0; // Global enable interrupt\r\n\r\n    halt_bug: u32 = 0;\r\n\r\n    interrupt_latch: u32 = 0;\r\n    interrupt_flag: u32 = 0;\r\n\r\n\r\n        // internal/speculative\r\n    TCU: u32 = 0; // \"Timing Control Unit\" basically which cycle of an op we're on\r\n    IR: u32 = 0; // \"Instruction Register\" currently-executing register\r\n\r\n    TR: u32 = 0; // Temporary Register\r\n    TA: u32 = 0; // Temporary Address\r\n    RR: u32 = 0; // Remorary Register\r\n\r\n    prefix: u32 = 0;\r\n    poll_IRQ: bool = false;\r\n\r\n    stoppable(): bool {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport class SM83_pins_t {\r\n    RD: u32 = 0; // External read request\r\n    WR: u32 = 0; // External write request\r\n    MRQ: u32 = 0; // Extermal memory request\r\n\r\n    D: u32 = 0; // Data; 8 bits\r\n    Addr: u32 = 0; // Address; 16 bits\r\n}\r\n\r\nexport class SM83_t {\r\n    regs: SM83_regs_t = new SM83_regs_t();\r\n    pins: SM83_pins_t = new SM83_pins_t();\r\n    clock: GB_clock\r\n    bus: GB_bus\r\n    variant: GB_variants\r\n\r\n    trace_on: bool = false;\r\n    //trace_peek: null = null\r\n\r\n    trace_cycles: u64 = 0\r\n    current_instruction: SM83_opcode_functions = sm83_decoded_opcodes[SM83_S_RESET];\r\n\r\n    constructor(variant: GB_variants, clock: GB_clock, bus: GB_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n\r\n        this.variant = variant;\r\n    }\r\n\r\n    /*enable_tracing(trace_peek: null = null): void {\r\n        console.log('ENABLE THIS ENABLE TRACING')\r\n        this.trace_on = true;\r\n        if (trace_peek !== null)\r\n            this.trace_peek = trace_peek;\r\n        console.log('TRACING ENABLED HERE!')\r\n    }*/\r\n\r\n    disable_tracing(): void {\r\n        console.log('ENABLE THIS DISABLE TRACING');\r\n        if (!this.trace_on) return;\r\n        this.trace_on = false;\r\n    }\r\n\r\n    /*trace_format(dass, PCO) {\r\n\t\tlet outstr = trace_start_format('SM83', SM83_COLOR, this.trace_cycles, ' ', PCO);\r\n\t\t// General trace format is...\r\n\t\toutstr += dass;\r\n\t\tlet sp = dass.length;\r\n\t\twhile(sp < TRACE_INS_PADDING) {\r\n\t\t\toutstr += ' ';\r\n\t\t\tsp++;\r\n\t\t}\r\n\r\n\t\toutstr += 'TCU:' + this.regs.TCU + ' ';\r\n        outstr += 'PC:' + hex4(this.regs.PC) + ' ';\r\n\t\toutstr += ' A:' + hex2(this.regs.A);\r\n\t\toutstr += ' B:' + hex2(this.regs.B);\r\n\t\toutstr += ' C:' + hex2(this.regs.C);\r\n\t\toutstr += ' D:' + hex2(this.regs.D);\r\n\t\toutstr += ' E:' + hex2(this.regs.E);\r\n\t\toutstr += ' HL:' + hex4((this.regs.H << 8) | (this.regs.L));\r\n\t\toutstr += ' SP:' + hex4(this.regs.SP);\r\n\t\toutstr += ' F:' + this.regs.F.formatbyte();\r\n        return outstr;\r\n\t}*/\r\n\r\n    reset(): void {\r\n        this.regs.PC = 1;\r\n        this.regs.TCU = 0;\r\n        this.pins.Addr = 0;\r\n        this.pins.RD = this.pins.MRQ = 1;\r\n        this.pins.WR = 0;\r\n        this.regs.IR = SM83_S_DECODE;\r\n    }\r\n\r\n    ins_cycles(): void {\r\n        switch(this.regs.TCU) {\r\n            case 1: // Initial opcode fetch has already been done as last cycle of last instruction\r\n                this.regs.IR = this.pins.D;\r\n                if (this.regs.IR === 0xCB) {\r\n                    this.regs.IR = SM83_S_DECODE;\r\n                    this.pins.Addr = this.regs.PC;\r\n                    this.regs.PC = (this.regs.PC + 1) & 0xFFFF;\r\n                    break;\r\n                }\r\n\r\n                this.current_instruction = sm83_decoded_opcodes[this.regs.IR];\r\n                /*if (this.trace_on) {\r\n                    dbg.traces.add(TRACERS.SM83, this.trace_cycles, this.trace_format(SM83_disassemble(this.pins.Addr, this.trace_peek), this.pins.Addr));\r\n                }*/\r\n\r\n                this.current_instruction.exec_func(this.regs, this.pins);\r\n                break;\r\n            case 2:\r\n                this.regs.IR = this.pins.D;\r\n                this.current_instruction = sm83_decoded_opcodes[SM83_prefix_to_codemap.get(0xCB) + this.regs.IR];\r\n                /*if (this.trace_on) {\r\n                    dbg.traces.add(TRACERS.SM83, this.trace_cycles, this.trace_format(SM83_disassemble((this.pins.Addr-1) & 0xFFFF, this.trace_peek), this.pins.Addr));\r\n                }*/\r\n                this.regs.TCU = 1;\r\n                this.current_instruction.exec_func(this.regs, this.pins);\r\n                break;\r\n        }\r\n    }\r\n\r\n    cycle(): void {\r\n        this.regs.TCU++;\r\n        this.trace_cycles++;\r\n        // Enable interrupts on next cycle\r\n        if (this.regs.IME_DELAY > 0) {\r\n            this.regs.IME_DELAY--;\r\n            if (this.regs.IME_DELAY <= 0) {\r\n                this.regs.IME = 1;\r\n            }\r\n        }\r\n        if ((this.regs.IR === SM83_HALT) ||\r\n            ((this.regs.IR === SM83_S_DECODE) && (this.regs.TCU === 1) && (this.regs.poll_IRQ))) {\r\n            let is_halt = ((this.regs.IR === SM83_HALT) && (this.regs.IME === 0));\r\n            //if (dbg.watch_on) console.log('IRQ poll', this.regs.IME, this.regs.IF, this.regs.IE);\r\n            this.regs.poll_IRQ = false;\r\n            let imask: u32 = 0xFF;\r\n            if ((this.regs.IME) || is_halt) {\r\n                let mask = this.regs.IE & this.regs.IF & 0x1F;\r\n                this.regs.IV = -1;\r\n                imask = 0xFF;\r\n                if (mask & 1) { // VBLANK interrupt\r\n                    imask = 0xFE;\r\n                    this.regs.IV = 0x40;\r\n                } else if (mask & 2) { // STAT interrupt\r\n                    //if (this.bus.ppu!.enabled)\r\n                    imask = 0xFD;\r\n                    this.regs.IV = 0x48;\r\n                } else if (mask & 4) { // Timer interrupt\r\n                    imask = 0xFB;\r\n                    this.regs.IV = 0x50;\r\n                } else if (mask & 8) { // Serial interrupt\r\n                    imask = 0xF7;\r\n                    this.regs.IV = 0x58;\r\n                } else if (mask & 0x10) { // Joypad interrupt\r\n                    imask = 0xEF;\r\n                    this.regs.IV = 0x60;\r\n                }\r\n                if (this.regs.IV > 0) {\r\n                    if (is_halt && (this.regs.IME === 0)) {\r\n                        this.regs.HLT = 0;\r\n                        this.regs.TCU++;\r\n                    }\r\n                    else {\r\n                        //console.log('SO IRQ ACTUALLY GOING TO HAPPEN!', hex2(this.regs.IV));\r\n                        if (dbg.brk_on_NMIRQ) {\r\n                            console.log('NMIRQ BRK!');\r\n                            dbg.break();\r\n                        }\r\n                        // Right here, the STAT is not supposed to be cleared if LCD disabled\r\n                        if (this.regs.HLT) {\r\n                            //console.log('HALT BUSTER!');\r\n                            this.regs.PC = (this.regs.PC + 1) & 0xFFFF;\r\n                        }// else {\r\n                            //console.log('NO HALT BUST!');\r\n                        //}\r\n                        this.regs.IF &= imask;\r\n                        this.regs.HLT = 0;\r\n                        this.regs.IR = SM83_S_IRQ;\r\n                        //console.log('SETTING IRQ!');\r\n                        this.current_instruction = sm83_decoded_opcodes[SM83_S_IRQ];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.regs.IR === SM83_S_DECODE) {\r\n            // operand()\r\n            // if CB, operand() again\r\n            //if (this.regs.TCU === 1) this.PCO = this.pins.Addr;\r\n            this.ins_cycles();\r\n        } else {\r\n            // Execute an actual opcode\r\n            //console.log('EXEC IDX:' + this.current_instruction.exec_func.index.toString() + ' ' + hex4(this.regs.PC) + ' ' + this.current_instruction.mnemonic + ' ' + this.current_instruction.ins.toString());\r\n            this.current_instruction.exec_func(this.regs, this.pins);\r\n        }\r\n        /*if (this.regs.PC === SM83_PC_BRK) {\r\n            SM83_PC_BRK = -1;\r\n            console.log('PCBRK!');\r\n            dbg.break();\r\n        }*/\r\n    }\r\n}\r\n","import {GB_PPU_modes, GB_variants} from \"./gb_common\";\r\nimport {GB_cart} from \"./gb_cart\";\r\nimport {GB_mapper} from \"./mappers/interface\";\r\nimport {GB_CPU} from \"./gb_cpu\";\r\nimport {hex4} from \"../../helpers/helpers\";\r\nimport {GB_PPU} from \"./gb_ppu\";\r\nimport {framevars_t} from \"../../glue/global_player\";\r\nimport {\r\n    console_mt_struct,\r\n    input_map_keypoint,\r\n    machine_description,\r\n    MD_STANDARD,\r\n    MD_TIMING,\r\n    systemEmulator\r\n} from \"../interface\";\r\nimport {dbg} from \"../../helpers/debug\";\r\n\r\nexport const GB_QUICK_BOOT = true;\r\n\r\nlet GB_inputmap: Array<input_map_keypoint> = new Array<input_map_keypoint>(8);\r\nfunction fill_GB_inputmap(): void {\r\n    for (let i = 0; i < 8; i++) {\r\n        let kp = new input_map_keypoint();\r\n        kp.internal_code = i;\r\n        kp.buf_pos = i;\r\n        kp.uber = 'p1';\r\n        switch(i) {\r\n            case 0:\r\n                kp.name = 'up';\r\n                break;\r\n            case 1:\r\n                kp.name = 'down';\r\n                break;\r\n            case 2:\r\n                kp.name = 'left';\r\n                break;\r\n            case 3:\r\n                kp.name = 'right';\r\n                break;\r\n            case 4:\r\n                kp.name = 'a';\r\n                break;\r\n            case 5:\r\n                kp.name = 'b';\r\n                break;\r\n            case 6:\r\n                kp.name = 'start';\r\n                break;\r\n            case 7:\r\n                kp.name = 'select';\r\n                break;\r\n        }\r\n        GB_inputmap[i] = kp;\r\n    }\r\n}\r\nfill_GB_inputmap();\r\n\r\nconst GB_CYCLES_PER_FRAME: u32 = 70224\r\nconst GB_CYCLES_PER_SCANLINE: u32 = GB_CYCLES_PER_FRAME / 154;\r\n\r\nexport class gb_inputs {\r\n    a: u32 = 0;\r\n    b: u32 = 0;\r\n    start: u32 = 0;\r\n    select: u32 = 0;\r\n    up: u32 = 0;\r\n    down: u32 = 0;\r\n    left: u32 = 0;\r\n    right: u32 = 0;\r\n}\r\n\r\nclass GB_clock_timing {\r\n    ppu_divisor: u32 = 1\r\n    cpu_divisor: u32 = 4\r\n    apu_divisor: u32 = 4\r\n}\r\n\r\nexport class GB_clock {\r\n    ppu_mode: GB_PPU_modes = GB_PPU_modes.OAM_search; // PPU mode. OAM search, etc.\r\n    frames_since_restart: u32 = 0;\r\n    master_frame: u32 = 0;\r\n\r\n    cycles_left_this_frame: i32 = GB_CYCLES_PER_FRAME;\r\n\r\n    trace_cycles: u32 = 0;\r\n\r\n    master_clock: u32 = 0;\r\n    ppu_master_clock: u32 = 0;\r\n    cpu_master_clock: u32 = 0;\r\n\r\n    ly: u32 = 0;\r\n    lx: u32 = 0;\r\n\r\n    wly: u32 = 0;\r\n\r\n    cpu_frame_cycle: u32 = 0;\r\n    ppu_frame_cycle: u32 = 0;\r\n    CPU_can_VRAM: u32 = 1;\r\n    old_OAM_can: u32 = 0;\r\n    CPU_can_OAM: u32 = 0;\r\n    bootROM_enabled: bool = true;\r\n\r\n    //irq = new GB_clock_irq();\r\n    timing: GB_clock_timing = new GB_clock_timing();\r\n\r\n    reset(): void {\r\n        this.ppu_mode = 2;\r\n        this.frames_since_restart = 0;\r\n        this.master_clock = 0;\r\n        this.cpu_master_clock = 0;\r\n        this.ppu_master_clock = 0;\r\n        this.lx = 0;\r\n        this.ly = 0;\r\n        this.timing.ppu_divisor = 1;\r\n        this.timing.cpu_divisor = 4;\r\n        this.cpu_frame_cycle = 0;\r\n        this.ppu_frame_cycle = 0;\r\n        this.CPU_can_VRAM = 1;\r\n        this.CPU_can_OAM = 0;\r\n        this.bootROM_enabled = true;\r\n    }\r\n\r\n    setCPU_can_OAM(to: u32): void {\r\n        this.CPU_can_OAM = to;\r\n        this.old_OAM_can = to;\r\n    }\r\n}\r\n\r\nexport class GBmappernull implements GB_mapper {\r\n    reset(): void {\r\n        console.log('SHOULDNT GET HERE 1');\r\n    }\r\n\r\n    CPU_read(addr: u32, val: u32): u32 {\r\n        console.log('SHOULDNT GET HERE 2');\r\n        return 0xFF;\r\n    }\r\n\r\n    CPU_write(addr: u32, val: u32): void {\r\n        console.log('SHOULDNT GET HERE 3');\r\n    }\r\n\r\n    PPU_read(addr: u32): u32 {\r\n        console.log('SHOULDNT GET HERE 4');\r\n        return 0xFF;\r\n    }\r\n\r\n    set_cart(cart: GB_cart, BIOS: Uint8Array): void {\r\n        console.log('SHOULDNT GET HERE 5');\r\n    }\r\n\r\n}\r\n\r\nexport class GB_bus {\r\n    cart: GB_cart|null = null;\r\n    mapper: GB_mapper = new GBmappernull()\r\n    ppu: GB_PPU|null = null;\r\n    cpu: GB_CPU|null = null;\r\n\r\n    BIOS: Uint8Array = new Uint8Array(0)\r\n\r\n    constructor() {\r\n    }\r\n\r\n    load_BIOS_from_RAM(what: usize, sz: u32): void {\r\n        this.BIOS = new Uint8Array(sz);\r\n        for (let i = 0; i < sz; i++) {\r\n            this.BIOS[i] = load<u8>(what+i);\r\n        }\r\n    }\r\n\r\n    CPU_read_IO(addr: u32, val: u32, has_effect: bool = true): u32 {\r\n        let out = 0xFF;\r\n        out &= this.cpu!.read_IO(addr, val, has_effect);\r\n        out &= this.ppu!.read_IO(addr, val, has_effect);\r\n        return out;\r\n    }\r\n\r\n    CPU_write_IO(addr: u32, val: u32): void {\r\n        this.cpu!.write_IO(addr, val);\r\n        this.ppu!.write_IO(addr, val);\r\n    }\r\n\r\n    DMA_read(addr: u32): u32 {\r\n        return this.mapper.CPU_read(addr, 0);\r\n\r\n        if (addr >= 0xA000) {\r\n            console.log('IMPLEMENT OAM >0xA000!' + hex4(addr));\r\n        } else {\r\n            return this.mapper.CPU_read(addr, 0);\r\n        }\r\n    }\r\n\r\n    IRQ_vblank_down(): void {\r\n        //console.log('VBLANK DOWN!', this.cpu.cpu.regs.IF);\r\n    }\r\n\r\n    IRQ_vblank_up(): void {\r\n        this.cpu!.cpu.regs.IF |= 1;\r\n        //console.log('VBLANK UP!', this.ppu.clock.master_frame, this.cpu.cpu.regs.IE, this.cpu.cpu.regs.IF, this.cpu.cpu.regs.IE & this.cpu.cpu.regs.IF);\r\n    }\r\n}\r\n\r\nexport class GameBoy implements systemEmulator {\r\n    bus: GB_bus\r\n    clock: GB_clock\r\n    cpu: GB_CPU\r\n    ppu: GB_PPU\r\n    variant: GB_variants\r\n    out_buffer: usize\r\n    controller_in: gb_inputs = new gb_inputs();\r\n    framevars: framevars_t = new framevars_t();\r\n    cycles_left: i32 = 0\r\n    cart: GB_cart\r\n\r\n    constructor(variant: GB_variants, out_buffer: usize) {\r\n        this.variant = variant;\r\n        let clock = new GB_clock();\r\n        let bus = new GB_bus();\r\n        let cpu = new GB_CPU(variant, clock, bus)\r\n        let ppu = new GB_PPU(out_buffer, variant, clock, bus)\r\n\r\n        this.cart = new GB_cart(variant, clock, bus);\r\n\r\n        this.out_buffer = out_buffer;\r\n        this.bus = bus;\r\n        this.clock = clock;\r\n        this.cpu = cpu;\r\n        this.ppu = ppu;\r\n    }\r\n\r\n    map_inputs(bufptr: usize): void {\r\n        this.controller_in.up = load<u32>(bufptr);\r\n        this.controller_in.down = load<u32>(bufptr+(4));\r\n        this.controller_in.left = load<u32>(bufptr+(4*2));\r\n        this.controller_in.right = load<u32>(bufptr+(4*3));\r\n        this.controller_in.a = load<u32>(bufptr+(4*4));\r\n        this.controller_in.b = load<u32>(bufptr+(4*5));\r\n        this.controller_in.start = load<u32>(bufptr+(4*6));\r\n        this.controller_in.select = load<u32>(bufptr+(4*7));\r\n        this.cpu.update_inputs(this.controller_in);\r\n    }\r\n\r\n    get_framevars(): framevars_t {\r\n        this.framevars.master_frame = this.clock.master_frame;\r\n        this.framevars.x = this.clock.lx;\r\n        this.framevars.scanline = this.clock.ly;\r\n        return this.framevars;\r\n    }\r\n\r\n    get_description(): machine_description {\r\n        let d = new machine_description();\r\n        d.name = 'GameBoy';\r\n        switch(this.variant) {\r\n            case GB_variants.GBC:\r\n                d.name = 'GameBoy Color';\r\n                break;\r\n            case GB_variants.SGB:\r\n                d.name = 'Super GameBoy';\r\n                break;\r\n        }\r\n        d.fps = 60;\r\n        d.timing = MD_TIMING.frame;\r\n        d.standard = MD_STANDARD.LCD;\r\n        d.x_resolution = 160;\r\n        d.y_resolution = 144;\r\n        d.xrh = 160;\r\n        d.xrw = 144;\r\n\r\n        d.overscan.top = 0;\r\n        d.overscan.bottom = 0;\r\n        d.overscan.left = 0;\r\n        d.overscan.right = 0;\r\n\r\n        d.out_size = (160*144*4);\r\n\r\n        for (let i = 0, k = GB_inputmap.length; i < k; i++) {\r\n            d.keymap.push(GB_inputmap[i]);\r\n        }\r\n        return d;\r\n    }\r\n\r\n    killall(): void {\r\n\r\n    }\r\n\r\n    finish_frame(): u32 {\r\n        let cycles_left: i32 = this.clock.cycles_left_this_frame;\r\n        this.step_master(cycles_left);\r\n        return this.ppu.last_used_buffer;\r\n    }\r\n\r\n    finish_scanline(): u32 {\r\n        console.log('STEP SCANLINE NOT SUPPORT GB AS YET')\r\n        return this.ppu.last_used_buffer ^ 1;\r\n    }\r\n\r\n    step_master(howmany: u32): u32 {\r\n        this.cycles_left += <i32>howmany;\r\n        let cpu_step = this.clock.timing.cpu_divisor;\r\n        while (this.cycles_left > 0) {\r\n            this.clock.cycles_left_this_frame--;\r\n            if (this.clock.cycles_left_this_frame <= 0) this.clock.cycles_left_this_frame += GB_CYCLES_PER_FRAME;\r\n            if ((this.clock.master_clock & 3) === 0) {\r\n                this.cpu.cycle();\r\n                this.clock.cpu_frame_cycle++;\r\n                this.clock.cpu_master_clock += cpu_step;\r\n            }\r\n            this.clock.master_clock++;\r\n            this.ppu.run_cycles(1);\r\n            this.clock.ppu_master_clock += 1;\r\n            this.cycles_left--;\r\n            if (dbg.do_break) break;\r\n        }\r\n        return this.ppu.last_used_buffer ^ 1;\r\n    }\r\n\r\n    reset(): void {\r\n        this.clock.reset();\r\n        this.cpu.reset();\r\n        this.ppu.reset();\r\n        if (this.cart.mapper !== null)\r\n            this.cart.mapper.reset();\r\n        if (GB_QUICK_BOOT) {\r\n            this.ppu.quick_boot();\r\n            this.cpu.quick_boot();\r\n        }\r\n    }\r\n\r\n    load_ROM(name: string, what: usize, sz: u32): void {\r\n        this.cart.load_ROM_from_RAM(what, sz);\r\n        this.reset();\r\n    }\r\n\r\n    load_BIOS(what: usize, sz: u32): void {\r\n        this.bus.load_BIOS_from_RAM(what, sz);\r\n    }\r\n\r\n    play(): void {};\r\n    pause(): void {};\r\n    stop(): void {};\r\n    get_mt_struct(): console_mt_struct {\r\n        return new console_mt_struct();\r\n    }\r\n}\r\n","import {console_mt_struct, machine_description, systemEmulator} from \"../system/interface\";\r\nimport {NES_VARIANTS} from \"../system/nes/nes_common\";\r\nimport {NES} from \"../system/nes/nes\";\r\nimport {GB_variants} from \"../system/gb/gb_common\";\r\nimport {GameBoy} from \"../system/gb/gb\";\r\n\r\nexport class framevars_t {\r\n    master_frame: u64 = 0\r\n    x: u32 = 0\r\n    scanline: u32 = 0\r\n}\r\n\r\nexport enum JSMOO_SYSTEMS {\r\n    NONE = 0,\r\n    NES_USA,\r\n    SMS2_USA,\r\n    SPECTRUM48,\r\n    SNES_USA,\r\n\r\n    TEST_NESM6502,\r\n\r\n    DMG,\r\n    GBC\r\n}\r\n\r\nexport enum input_types {\r\n    CONTROLLER = 0,\r\n    KEYBOARD\r\n}\r\n\r\nexport class global_player_t {\r\n    system_kind: JSMOO_SYSTEMS = JSMOO_SYSTEMS.NONE\r\n    playing: bool = false\r\n    system!: systemEmulator\r\n    ready: bool = false;\r\n    tech_specs: machine_description = new machine_description();\r\n    video_output_buffer: usize = heap.alloc(1024*1024*2);\r\n    input_buffer: usize = heap.alloc(1024*1024*6);\r\n\r\n    constructor() {\r\n        this.ready = false;\r\n    }\r\n\r\n    get_mt_struct(): console_mt_struct {\r\n        return this.system.get_mt_struct();\r\n    }\r\n\r\n    play(): void {\r\n        this.system.play();\r\n    }\r\n\r\n    pause(): void {\r\n        this.system.pause();\r\n    }\r\n\r\n    stop(): void {\r\n        this.system.stop();\r\n    }\r\n\r\n    set_system(to: JSMOO_SYSTEMS): void {\r\n        if (this.system_kind == to) {\r\n            this.system.reset();\r\n            return;\r\n        }\r\n        if (this.system_kind !== JSMOO_SYSTEMS.NONE) this.system.killall();\r\n\r\n        switch(to) {\r\n            case JSMOO_SYSTEMS.NES_USA:\r\n                this.system = new NES(NES_VARIANTS.NTSCU, this.video_output_buffer);\r\n                break;\r\n            case JSMOO_SYSTEMS.DMG:\r\n                this.system = new GameBoy(GB_variants.DMG, this.video_output_buffer);\r\n                break;\r\n            default:\r\n                console.log('UNIMPLEMENTED SYSTEM');\r\n                return;\r\n        }\r\n        this.tech_specs = this.system.get_description();\r\n        this.tech_specs.out_ptr = this.video_output_buffer;\r\n        this.ready = true;\r\n    }\r\n\r\n    ext_set_system(to: String): bool {\r\n        let ct: JSMOO_SYSTEMS = JSMOO_SYSTEMS.NONE;\r\n        if (to == 'nes_as') {\r\n            ct = JSMOO_SYSTEMS.NES_USA;\r\n        }\r\n        if (to === 'gb_as') {\r\n            ct = JSMOO_SYSTEMS.DMG;\r\n        }\r\n        switch(ct) {\r\n            case JSMOO_SYSTEMS.NES_USA:\r\n                this.set_system(JSMOO_SYSTEMS.NES_USA);\r\n                return true;\r\n            case JSMOO_SYSTEMS.DMG:\r\n                this.set_system(JSMOO_SYSTEMS.DMG);\r\n                return true;\r\n            default:\r\n                console.log('UNKNOWN SYSTEM ' + to);\r\n                return false;\r\n        }\r\n    }\r\n\r\n    load_rom(name: string, sz: u32): void {\r\n        //let r: usize = this.input_buffer;\r\n        this.system.load_ROM(name, this.input_buffer, sz);\r\n    }\r\n\r\n    get_framevars(): framevars_t {\r\n        return this.system.get_framevars();\r\n    }\r\n\r\n    run_frame(): u32 {\r\n        if (this.system !== null) {\r\n            this.system.map_inputs(this.input_buffer);\r\n            return this.system.finish_frame();\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\nexport function new_global_player(): global_player_t {\r\n    return new global_player_t();\r\n}\r\n\r\nexport function gp_set_system(player: global_player_t, to: String): void {\r\n    player.ext_set_system(to);\r\n}\r\n\r\nexport function gp_play(player: global_player_t): void {\r\n    player.play();\r\n}\r\n\r\nexport function gp_pause(player: global_player_t): void {\r\n    player.pause();\r\n}\r\n\r\nexport function gp_stop(player: global_player_t): void {\r\n    player.stop();\r\n}\r\n\r\nexport function gp_get_mt(player: global_player_t): console_mt_struct {\r\n    return player.get_mt_struct();\r\n}\r\n\r\nexport function gp_load_ROM_from_RAM(player: global_player_t, name: string, sz: u32): void {\r\n    player.load_rom(name, sz);\r\n}\r\n\r\nexport function gp_run_frame(player: global_player_t): u32 {\r\n    return player.run_frame();\r\n}\r\n\r\nexport function gp_get_specs(player: global_player_t): machine_description {\r\n    return player.tech_specs;\r\n}\r\n\r\nexport function gp_get_input_buffer(player: global_player_t): usize {\r\n    return player.input_buffer;\r\n}\r\n\r\nexport function gp_get_framevars(player: global_player_t): framevars_t {\r\n    return player.get_framevars();\r\n}","import {m6502} from \"../component/cpu/m6502/m6502\";\r\nimport {nesm6502_opcodes_decoded} from \"../system/nes/cpu/nesm6502_generated_opcodes\";\r\n\r\nclass TST_M6502_IO {\r\n    A: u32 = 0\r\n    X: u32 = 0\r\n    Y: u32 = 0\r\n    PC: u32 = 0\r\n    S: u32 = 0\r\n    P: u32 = 0\r\n    IR: u32 = 0\r\n    pins_D: u32 = 0;\r\n    pins_Addr: u32 = 0\r\n    pins_RW: u32 = 0\r\n    TCU: u32 = 0\r\n    RES_pending: u32 = 0\r\n}\r\n\r\nclass TST_M6502 {\r\n    cpu: m6502\r\n    constructor() {\r\n        this.cpu = new m6502(nesm6502_opcodes_decoded);\r\n    }\r\n\r\n    cycle(): void {\r\n        this.cpu.cycle();\r\n    }\r\n\r\n    set_cpu(to: TST_M6502_IO): void {\r\n        this.cpu.regs.A = to.A;\r\n        this.cpu.regs.X = to.X;\r\n        this.cpu.regs.Y = to.Y;\r\n        this.cpu.regs.PC = to.PC;\r\n        this.cpu.regs.S = to.S;\r\n        this.cpu.regs.P.setbyte(to.P);\r\n        this.cpu.regs.IR = to.IR;\r\n        this.cpu.pins.D = to.pins_D;\r\n        this.cpu.pins.Addr = to.pins_Addr;\r\n        this.cpu.regs.TCU = to.TCU;\r\n        this.cpu.pins.RW = to.pins_RW;\r\n    }\r\n\r\n    get_cpu(): TST_M6502_IO {\r\n        let o = new TST_M6502_IO();\r\n        o.A = this.cpu.regs.A;\r\n        o.X = this.cpu.regs.X;\r\n        o.Y = this.cpu.regs.Y;\r\n        o.PC = this.cpu.regs.PC;\r\n        o.S = this.cpu.regs.S;\r\n        o.P = this.cpu.regs.P.getbyte();\r\n        o.IR = this.cpu.regs.IR;\r\n        o.pins_D = this.cpu.pins.D;\r\n        o.pins_Addr = this.cpu.pins.Addr;\r\n        o.TCU = this.cpu.regs.TCU;\r\n        o.pins_RW = this.cpu.pins.RW;\r\n        return o;\r\n    }\r\n}\r\n\r\nexport function TST_M6502_new(): TST_M6502 {\r\n    return new TST_M6502();\r\n}\r\n\r\nexport function TST_M6502_set(obj: TST_M6502, to: TST_M6502_IO): void {\r\n    obj.set_cpu(to);\r\n}\r\n\r\nexport function TST_M6502_get(obj: TST_M6502): TST_M6502_IO {\r\n    return obj.get_cpu();\r\n}\r\n\r\nexport function TST_M6502_cycle(obj: TST_M6502): void {\r\n    obj.cycle();\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","import {NES_bus, NES_clock} from \"../nes_common\";\r\nimport {m6502} from \"../../../component/cpu/m6502/m6502\";\r\nimport {NES_controllerport} from \"./controller_port\";\r\nimport {nesm6502_opcodes_decoded} from \"./nesm6502_generated_opcodes\";\r\nimport {nespad_inputs} from \"../nes\";\r\nimport {NES_joypad} from \"../../../component/controller/nes_joypad\";\r\n\r\n\r\n\r\nclass ricoh2A03_DMA {\r\n    addr: u32 = 0\r\n    running: u32 = 0\r\n    bytes_left: u32 = 0\r\n    step: u32 = 0\r\n}\r\n\r\nexport class ricoh2A03 {\r\n    cpu: m6502\r\n    bus: NES_bus\r\n    clock: NES_clock\r\n\r\n    tracing: bool = false;\r\n    dma: ricoh2A03_DMA = new ricoh2A03_DMA();\r\n\r\n    joypad1: NES_joypad = new NES_joypad(1);\r\n    joypad2: NES_joypad = new NES_joypad(2);\r\n\r\n    controller_port1: NES_controllerport = new NES_controllerport();\r\n    controller_port2: NES_controllerport = new NES_controllerport();\r\n    constructor(clock: NES_clock, bus: NES_bus) {\r\n        this.cpu = new m6502(nesm6502_opcodes_decoded);\r\n        this.bus = bus;\r\n        this.clock = clock;\r\n        this.bus.cpu = this;\r\n\r\n        this.controller_port1.device = this.joypad1;\r\n        this.controller_port2.device = this.joypad2;\r\n        this.cpu.reset();\r\n    }\r\n\r\n    update_inputs(inp1: nespad_inputs, inp2: nespad_inputs): void {\r\n        this.joypad1.buffer_input(inp1);\r\n        this.joypad2.buffer_input(inp2);\r\n    }\r\n\r\n    notify_NMI(level: u32): void {\r\n        this.cpu.pins.NMI = +level;\r\n    }\r\n\r\n    notify_IRQ(level: u32): void {\r\n        if ((+level) === 0) this.cpu.IRQ_ack = true;\r\n        else if ((+level) !== this.cpu.pins.IRQ) this.cpu.IRQ_ack = false;\r\n        this.cpu.pins.IRQ = +level;\r\n    }\r\n\r\n    reset(): void {\r\n        this.cpu.reset();\r\n        this.clock.cpu_frame_cycle = 0;\r\n        this.dma.running = 0;\r\n    }\r\n\r\n    run_cycle(): void {\r\n        // Do DMA if we're engaged in that\r\n        if (this.dma.running) {\r\n            this.dma.step++;\r\n            if (this.dma.step === 1) {\r\n                return;\r\n            }\r\n            this.dma.step = 0;\r\n            this.bus.PPU_reg_write(0x2004, this.bus.CPU_read(this.dma.addr, 0));\r\n            this.dma.bytes_left--;\r\n            this.dma.addr = (this.dma.addr + 1) & 0xFFFF;\r\n            if (this.dma.bytes_left === 0) {\r\n                this.dma.running = 0;\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Service RW pins\r\n        if (!this.cpu.pins.RW) {\r\n            this.cpu.pins.D = this.bus.CPU_read(this.cpu.pins.Addr, this.cpu.pins.D);\r\n            //if (this.tracing) {\r\n                //dbg.traces.add(TRACERS.M6502, this.clock.trace_cycles, trace_format_read('MOS', MOS_COLOR, this.clock.trace_cycles, this.cpu.pins.Addr, this.cpu.pins.D));\r\n            //}\r\n        }\r\n        this.clock.trace_cycles++;\r\n        this.cpu.cycle();\r\n        if (this.cpu.pins.RW) {\r\n            this.bus.CPU_write(this.cpu.pins.Addr, this.cpu.pins.D);\r\n            /*if (this.tracing) {\r\n                //dbg.traces.add(TRACERS.M6502, this.clock.trace_cycles, trace_format_write('MOS', MOS_COLOR, this.clock.trace_cycles, this.cpu.pins.Addr, this.cpu.pins.D));\r\n            }*/\r\n        }\r\n    }\r\n\r\n    reg_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        switch(addr) {\r\n            case 0x4016: // JOYSER0\r\n                let r: u32 = this.controller_port1.data();\r\n                return r;\r\n            case 0x4017: // JOYSER1\r\n                return 0;\r\n                //return this.controller_port2.data();\r\n        }\r\n        return val;\r\n    }\r\n\r\n    reg_write(addr: u32, val: u32): void {\r\n        switch(addr) {\r\n            case 0x4014: //OAMDMA\r\n                this.dma.addr = val << 8;\r\n                this.dma.running = 1;\r\n                this.dma.bytes_left = 256;\r\n                this.dma.step = 0;\r\n                return;\r\n            case 0x4016: // JOYSER0\r\n                this.controller_port1.latch(val & 1);\r\n                return;\r\n       }\r\n    }\r\n}","/*\r\nJoypad register emulation classes and functions.\r\n */\r\n\r\nimport {nespad_inputs} from \"../../system/nes/nes\";\r\nimport {NES_controller} from \"../../system/nes/cpu/controller_port\";\r\n\r\nexport class NES_joypad implements NES_controller {\r\n    counter: u32 = 0\r\n    latched: u32 = 0\r\n    joynum: u32 = 0\r\n    input_buffer: nespad_inputs = new nespad_inputs();\r\n    input_waiting: nespad_inputs = new nespad_inputs();\r\n    constructor(joynum: u32) {\r\n        this.joynum = joynum;\r\n    }\r\n\r\n    buffer_input(from: nespad_inputs): void {\r\n        this.input_waiting.up = from.up;\r\n        this.input_waiting.down = from.down;\r\n        this.input_waiting.left = from.left;\r\n        this.input_waiting.right = from.right;\r\n        this.input_waiting.a = from.a;\r\n        this.input_waiting.b = from.b;\r\n        this.input_waiting.start = from.start;\r\n        this.input_waiting.select = from.select;\r\n    }\r\n\r\n    latch(what: u32): void {\r\n        if (this.latched === what) return;\r\n        this.latched = what;\r\n        this.counter = 0;\r\n        if (this.latched === 0) {\r\n            this.input_buffer.up = this.input_waiting.up;\r\n            this.input_buffer.down = this.input_waiting.down;\r\n            this.input_buffer.left = this.input_waiting.left;\r\n            this.input_buffer.right = this.input_waiting.right;\r\n            this.input_buffer.a = this.input_waiting.a;\r\n            this.input_buffer.b = this.input_waiting.b;\r\n            this.input_buffer.start = this.input_waiting.start;\r\n            this.input_buffer.select = this.input_waiting.select;\r\n        }\r\n    }\r\n\r\n    data(): u32 {\r\n        if (this.latched === 1) {\r\n            return this.input_buffer.a;\r\n        }\r\n\r\n        switch(this.counter++) {\r\n            case 0: return this.input_buffer.a;\r\n            case 1: return this.input_buffer.b;\r\n            case 2: return this.input_buffer.select;\r\n            case 3: return this.input_buffer.start;\r\n            case 4: return this.input_buffer.up;\r\n            case 5: return this.input_buffer.down;\r\n            case 6: return this.input_buffer.left;\r\n            case 7: return this.input_buffer.right;\r\n        }\r\n\r\n        this.counter = 8;\r\n        return 1;\r\n    }\r\n}","export interface NES_controller {\r\n    data(): u32;\r\n    latch(what: u32): void;\r\n}\r\n\r\nexport class NES_controllerport {\r\n\tdevice: NES_controller | null = null\r\n    constructor() {\r\n\t\tthis.device = null;\r\n\t}\r\n\r\n\tdata(): u32 {\r\n\t\tif (this.device !== null) return this.device!.data() & 3;\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tlatch(what: u32): u32 {\r\n\t\tif (this.device !== null)\r\n\t\t\tthis.device!.latch(what);\r\n\t\treturn 0;\r\n\t}\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","import {NES_bus, NES_clock, NES_TIMINGS} from \"./nes_common\";\r\nimport {NES_mapper_none} from \"./mappers/mapper_none\";\r\nimport {NES_MMC3b} from \"./mappers/mmc3b\";\r\nimport {NES_mapper_VRC2B_4E_4F} from \"./mappers/vrc_2b_4e_4f\";\r\nimport {NES_mapper_MMC1} from \"./mappers/mmc1\";\r\nimport {NES_mapper_UXROM} from \"./mappers/uxrom\";\r\nimport {NES_mapper_CXROM} from \"./mappers/cxrom\";\r\nimport {NES_mapper_DXROM} from \"./mappers/dxrom\";\r\nimport {NES_PPU_mirror_modes} from \"./mappers/interface\";\r\nimport {NES_mapper_AXROM} from \"./mappers/axrom\";\r\n\r\nexport class heapArray {\r\n\tptr: usize = 0;\r\n\tsz: u32 = 0;\r\n\r\n\tconstructor(ptr: usize, sz: u32) {\r\n\t\tthis.ptr = ptr;\r\n\t\tthis.sz = sz;\r\n\t}\r\n\r\n\t@operator(\"[]\")\r\n\t__get(key: u32): u8 {\r\n\t\treturn load<u8>(this.ptr+key);\r\n\t}\r\n\r\n\t@operator(\"[]=\")\r\n\t__set(key: u32, value: u8): void {\r\n\t\tstore<u8>(this.ptr+key, value);\r\n\t}\r\n}\r\n\r\nclass NES_cart_header {\r\n    mapper_number: u32 = 0;\r\n    nes_timing: u32 = 0;\r\n    submapper: u32 = 0;\r\n    mirroring: NES_PPU_mirror_modes = NES_PPU_mirror_modes.Horizontal;\r\n    battery_present: u32 = 0;\r\n    trainer_present: u32 = 0;\r\n    four_screen_mode: u32 = 0;\r\n    chr_ram_present: u32 = 0;\r\n    chr_rom_size: u32 = 0;\r\n    prg_rom_size: u32 = 0;\r\n    prg_ram_size: u32 = 0;\r\n    prg_nvram_size: u32 = 0;\r\n    chr_ram_size: u32 = 0;\r\n    chr_nvram_size: u32 = 0;\r\n}\r\n\r\nexport class NES_cart {\r\n    clock: NES_clock\r\n    bus: NES_bus\r\n    header: NES_cart_header\r\n\r\n    valid: bool = false\r\n    PRG_ROM: Uint8Array\r\n    CHR_ROM: Uint8Array\r\n    constructor(clock: NES_clock, bus: NES_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n        this.header = new NES_cart_header();\r\n        this.PRG_ROM = new Uint8Array(1);\r\n        this.CHR_ROM = new Uint8Array(1);\r\n    }\r\n\r\n    reset(): void {\r\n\r\n    }\r\n\r\n    load_cart_from_RAM(ibuf: usize, sz: u32): bool {\r\n\t\tlet fil: heapArray = new heapArray(ibuf, sz);\r\n\t\t// @ts-ignore\r\n\t\tif ((fil[0] !== 0x4E) || (fil[1] !== 0x45) || (fil[2] !== 0x53) || (fil[3] !== 0x1A)) {\r\n\t\t\tconsole.log('Bad iNES header');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tlet worked: bool;\r\n\t\t// @ts-ignore\r\n\t\tif ((fil[7] & 12) === 8)\r\n\t\t\tworked = this.read_ines2_header(fil);\r\n\t\telse\r\n\t\t\tworked = this.read_ines1_header(fil);\r\n\t\tif (!worked) return false;\r\n\r\n\t\tthis.read_ROM_RAM(fil, 16 + (this.header.trainer_present ? 512 : 0));\r\n\t\tthis.valid = worked = this.setup_mapper();\r\n\t\treturn worked;\r\n    }\r\n\r\n    setup_mapper(): bool {\r\n        switch(this.header.mapper_number) {\r\n            case 0: // no mapper\r\n                this.bus.mapper = new NES_mapper_none(this.clock, this.bus);\r\n                break;\r\n\t\t\tcase 1: // MMC1\r\n\t\t\t\tthis.bus.mapper = new NES_mapper_MMC1(this.clock, this.bus);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2: // UxROM\r\n\t\t\t\tthis.bus.mapper = new NES_mapper_UXROM(this.clock, this.bus);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3: // CxROM\r\n\t\t\t\tthis.bus.mapper = new NES_mapper_CXROM(this.clock, this.bus);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4: // MMC3\r\n                this.bus.mapper = new NES_MMC3b(this.clock, this.bus);\r\n                break;\r\n\t\t\tcase 7: // AXROM\r\n\t\t\t\tthis.bus.mapper = new NES_mapper_AXROM(this.clock, this.bus);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 23: // VRC4\r\n\t\t\t\tthis.bus.mapper = new NES_mapper_VRC2B_4E_4F(this.clock, this.bus, true);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 206: // DXROM\r\n\t\t\t\tthis.bus.mapper = new NES_mapper_DXROM(this.clock, this.bus);\r\n\t\t\t\tbreak;\r\n            default:\r\n                console.log('Unknown mapper number dawg! ' + this.header.mapper_number.toString());\r\n                return false;\r\n        }\r\n        this.bus.mapper.set_cart(this);\r\n        return true;\r\n    }\r\n\r\n    read_ROM_RAM(inp: heapArray, offset: u32): void {\r\n        this.PRG_ROM = new Uint8Array(this.header.prg_rom_size);\r\n        this.CHR_ROM = new Uint8Array(this.header.chr_rom_size);\r\n\t\tlet p: u32 = 0;\r\n\t\tfor (let i: u32 = offset, k: u32 = offset+this.header.prg_rom_size; i < k; i++) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tthis.PRG_ROM[p] = inp[i];\r\n\t\t\tp++;\r\n\t\t}\r\n\t\tp = 0;\r\n\t\t//this.PRG_ROM.set(inp.slice(offset, offset+this.header.prg_rom_size));\r\n\t\tfor (let i: u32 = offset+this.header.prg_rom_size, k=offset+this.header.prg_rom_size+this.header.chr_rom_size; i < k; i++) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tthis.CHR_ROM[p] = inp[i];\r\n\t\t\tp++;\r\n\t\t}\r\n\t\t//this.CHR_ROM.set(inp.slice(offset+this.header.prg_rom_size, offset+this.header.prg_rom_size+this.header.chr_rom_size));\r\n\t\tconsole.log('Read ' + this.PRG_ROM.byteLength.toString() + ' PRG ROM bytes');\r\n\t\tconsole.log('Read ' + this.CHR_ROM.byteLength.toString() + ' CHR ROM bytes');\r\n    }\r\n\r\n    read_ines1_header(fil: heapArray): bool {\r\n\t\tconsole.log('iNES version 1 header found');\r\n\t\t// @ts-ignore\r\n\t\tthis.header.prg_rom_size = 16384 * fil[4];\r\n\t\t// @ts-ignore\r\n\t\tthis.header.chr_rom_size = 8192 * fil[5];\r\n\t\tthis.header.chr_ram_present = +(this.header.chr_rom_size === 0);\r\n\t\tif (this.header.chr_ram_present) this.header.chr_ram_size = 8192;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.mirroring = fil[6] & 1;\r\n\t\tif (this.header.mirroring === 0) this.header.mirroring = NES_PPU_mirror_modes.Horizontal;\r\n\t\telse this.header.mirroring = NES_PPU_mirror_modes.Vertical;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.battery_present = (fil[6] & 2) >>> 1;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.trainer_present = (fil[6] & 4) >>> 2;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.four_screen_mode = (fil[6] & 8) >>> 3;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.mapper_number = (fil[6] >>> 4) | (fil[7] & 0xF0);\r\n\t\tconsole.log('MAPPER ' + this.header.mapper_number.toString());\r\n\t\t// @ts-ignore\r\n\t\tthis.header.prg_ram_size = fil[8] !== 0 ? fil[8] * 8192 : 8192;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.nes_timing = (fil[9] & 1) ? NES_TIMINGS.PAL : NES_TIMINGS.NTSC;\r\n\t\treturn true;\r\n\t}\r\n\r\n    read_ines2_header(fil: heapArray): bool {\r\n\t\tconsole.log('iNES version 2 header found');\r\n\t\t// @ts-ignore\r\n\t\tlet prgrom_msb: u32 = fil[9] & 0x0F;\r\n\t\t// @ts-ignore\r\n\t\tlet chrrom_msb: u32 = (fil[9] & 0xF0) >>> 4;\r\n\t\tif (prgrom_msb === 0x0F) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tlet E = (fil[4] & 0xFC) >>> 2;\r\n\t\t\t// @ts-ignore\r\n\t\t\tlet M = fil[4] & 0x03;\r\n\t\t\tthis.header.prg_rom_size = (2 ** E) * ((M*2)+1);\r\n\t\t} else {\r\n\t\t\t// @ts-ignore\r\n\t\t\tthis.header.prg_rom_size = ((prgrom_msb << 8) | fil[4]) * 16384;\r\n\t\t}\r\n\t\tconsole.log('PRGROM found: ' + (this.header.prg_rom_size / 1024).toString() + 'kb');\r\n\r\n\t\tif (chrrom_msb === 0x0F) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tlet E = (fil[5] & 0xFC) >>> 2;\r\n\t\t\t// @ts-ignore\r\n\t\t\tlet M = fil[5] & 0x03;\r\n\t\t\tthis.header.chr_rom_size = (2 ** E) * ((M*2)+1);\r\n\t\t} else {\r\n\t\t\t// @ts-ignore\r\n\t\t\tthis.header.chr_rom_size = ((chrrom_msb << 8) | fil[5]) * 8192;\r\n\t\t}\r\n\t\tconsole.log('CHR ROM found: ' + (this.header.chr_rom_size).toString());\r\n\r\n\t\t// @ts-ignore\r\n\t\tthis.header.mirroring = fil[6] & 1;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.battery_present = (fil[6] & 2) >>> 1;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.trainer_present = (fil[6] & 4) >>> 2;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.four_screen_mode = (fil[6] & 8) >>> 3;\r\n\t\t// @ts-ignore\r\n\t\tthis.header.mapper_number = (fil[6] >>> 4) | (fil[7] & 0xF0) | ((fil[8] & 0x0F) << 8);\r\n\t\t// @ts-ignore\r\n\t\tthis.header.submapper = fil[8] >>> 4;\r\n\r\n\t\t// @ts-ignore\r\n\t\tlet prg_shift: u32 = fil[10] & 0x0F;\r\n\t\t// @ts-ignore\r\n\t\tlet prgnv_shift: u32 = fil[10] >>> 4;\r\n\t\tif (prg_shift !== 0) this.header.prg_ram_size = 64 << prg_shift;\r\n\t\tif (prgnv_shift !== 0) this.header.prg_nvram_size = 64 << prgnv_shift;\r\n\r\n\t\t// @ts-ignore\r\n\t\tlet chr_shift: u32 = fil[11] & 0x0F;\r\n\t\t// @ts-ignore\r\n\t\tlet chrnv_shift: u32 = fil[11] >>> 4;\r\n\t\tif (chr_shift !== 0) this.header.chr_ram_size = 64 << chr_shift;\r\n\t\tif (chrnv_shift !== 0) this.header.chr_nvram_size = 64 << chrnv_shift;\r\n\t\t// @ts-ignore\r\n\t\tswitch(fil[12] & 3) {\r\n\t\t\tcase 0:\r\n\t\t\t\tthis.header.nes_timing = NES_TIMINGS.NTSC;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tthis.header.nes_timing = NES_TIMINGS.PAL;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tconsole.log('WTF even is this');\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tthis.header.nes_timing = NES_TIMINGS.DENDY;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): Int8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): Uint8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): Uint8ClampedArray {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    let len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): Int16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    let len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): Uint16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    let len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): Int32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    let len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    FILL<u32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): Uint32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    let len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): Int64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    let len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    FILL<u64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): Uint64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    let len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    FILL<f32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): Float32Array {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    let len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    FILL<f64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): Float64Array {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  let slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\n  let count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  let byteLength = len << alignof<T>();\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  let len = array.length;\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  let dataStart  = array.dataStart;\n  let j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  let byteLength = j << alignof<T>();\n  let data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  let dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  let dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  let byteLength: i32;\n  let bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<\n  TArray extends ArrayLike<number>,\n  UArray extends ArrayLike<number>\n>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<valueof<UArray>>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n  let sourceLen = source.length;\n  if (offset < 0 || sourceLen + offset > target.length) {\n    // offset is out of bounds\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  // @ts-ignore: dataStart\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\n  // @ts-ignore: dataStart\n  let sourceStart = source.dataStart;\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\n  ) {\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\n  } else {\n    for (let i = 0; i < sourceLen; i++) {\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<valueof<UArray>>()) {\n          store<valueof<TArray>>(ptr,\n            isFinite<valueof<UArray>>(value)\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\n              : 0\n          );\n        } else {\n          if (!isSigned<valueof<UArray>>()) {\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\n          } else if (sizeof<valueof<TArray>>() <= 4) {\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\n          } else {\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\n          }\n        }\n      } else {\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\n        } else {\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\n        }\n      }\n    }\n  }\n}\n","import {GB_PPU_modes, GB_variants} from \"./gb_common\";\r\nimport {GB_bus, GB_clock} from \"./gb\";\r\nimport {dbg} from \"../../helpers/debug\";\r\n\r\nfunction GB_sp_tile_addr(tn: u32, y: u32, big_sprites: u32, y_flip: u32): u32 {\r\n    if (big_sprites) {\r\n        tn &= 0xFE;\r\n        if (y_flip) y = 15 - y;\r\n        if (y > 7) tn++;\r\n        return (0x8000 | (tn << 4) | ((y & 7) << 1));\r\n    }\r\n    if (y_flip) y = 7 - y;\r\n    return (0x8000 | (tn << 4) | (y << 1));\r\n}\r\n\r\n\r\nclass GB_PPU_sprite_t {\r\n    x: u32 = 0\r\n    y: u32 = 0\r\n    tile: u32 = 0\r\n    attr: u32 = 0\r\n    in_q: u32 = 0\r\n}\r\n\r\nclass GB_FIFO_item_t {\r\n    pixel: u32\r\n    palette: u32\r\n    cgb_priority: u32\r\n    sprite_priority: u32\r\n    sprite_obj: GB_PPU_sprite_t|null = null\r\n\r\n    constructor(pixel: u32 = 0, palette: u32 = 0, cgb_priority: u32 = 0, sprite_priority: u32 = 0) {\r\n        this.pixel = pixel;\r\n        this.palette = palette;\r\n        this.cgb_priority = cgb_priority;\r\n        this.sprite_priority = sprite_priority;\r\n    }\r\n}\r\n\r\nclass GB_FIFO_t {\r\n    variant: GB_variants\r\n    compat_mode: u32 = 1  // 1 for DMG or GBC compatability\r\n    items: StaticArray<GB_FIFO_item_t> = new StaticArray<GB_FIFO_item_t>(8);\r\n    head: u32 = 0;\r\n    tail: u32 = 0;\r\n    num_items: u32 = 0;\r\n    blank: GB_FIFO_item_t = new GB_FIFO_item_t();\r\n\r\n    constructor(variant: GB_variants) {\r\n        this.variant = variant;\r\n        this.compat_mode = 1;\r\n\r\n        for (let i: u32 = 0; i < 8; i++) {\r\n            this.items[i] = new GB_FIFO_item_t();\r\n        }\r\n    }\r\n\r\n    set_cgb_mode(on: u32): void {\r\n        if (on)\r\n            this.compat_mode = 0;\r\n        else\r\n            this.compat_mode = 1;\r\n    }\r\n\r\n    any_there(): bool {\r\n        return this.num_items > 0;\r\n    }\r\n\r\n    clear(): void {\r\n        this.head = this.tail = 0;\r\n        this.num_items = 0;\r\n    }\r\n\r\n    empty(): bool {\r\n        return this.num_items === 0;\r\n    }\r\n\r\n    full(): bool {\r\n        return this.num_items === 8;\r\n    }\r\n\r\n    // This is for \"mixing\" on sprite encounter\r\n    sprite_mix(bp0: u32, bp1: u32, sp_priority: u32, sp_palette: u32, flip: u32): void {\r\n        // First fill with transparent pixels\r\n        while(this.num_items < 8) {\r\n            let b = this.push();\r\n            b!.sprite_priority = 0;\r\n            b!.cgb_priority = 0;\r\n            b!.pixel = 0;\r\n            b!.palette = 0;\r\n        }\r\n\r\n        for (let j: u32 = 0; j < 8; j++) {\r\n            let r: u32 = j;\r\n            if (flip) r = 7 - r;\r\n            let i: u32 = (r + this.head) & 7;\r\n            let px: u32 = ((bp0 & 0x80) >>> 7) | ((bp1 & 0x80) >>> 6);\r\n            let item = this.items[i];\r\n            bp0 <<= 1;\r\n            bp1 <<= 1;\r\n            if (this.compat_mode == 1) {\r\n                // DMG/CGB compatability\r\n                if (item.pixel === 0) {\r\n                    item.palette = sp_palette;\r\n                    item.sprite_priority = sp_priority;\r\n                    item.pixel = px;\r\n                    item.cgb_priority = 0;\r\n                }\r\n            } else {\r\n                if (item.cgb_priority < sp_priority) {\r\n                    item.palette = sp_palette;\r\n                    item.sprite_priority = sp_priority;\r\n                    item.pixel = px;\r\n                    item.cgb_priority = sp_priority;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Discard up to num pixels\r\n    discard(num: u32): void {\r\n        for (let i: u32 = 0; i < num; i++) {\r\n            this.pop();\r\n        }\r\n    }\r\n\r\n    push(): GB_FIFO_item_t|null {\r\n        if (this.num_items >= 8) {\r\n            console.log('NO!');\r\n            return null;\r\n        }\r\n        let r = this.items[this.tail];\r\n        this.tail = (this.tail + 1) & 7;\r\n        this.num_items++;\r\n        return r;\r\n    }\r\n\r\n    peek(): GB_FIFO_item_t|null {\r\n        if (this.num_items === 0) return null;\r\n        return this.items[this.head];\r\n    }\r\n\r\n    pop(): GB_FIFO_item_t {\r\n        if (this.num_items === 0) return this.blank;\r\n        let r = this.items[this.head];\r\n        this.head = (this.head + 1) & 7;\r\n        this.num_items--;\r\n        return r;\r\n    }\r\n}\r\n\r\n\r\nclass GB_px {\r\n    had_pixel: bool = false\r\n    color: u32 = 0\r\n    bg_or_sp: u32 = 0  // 0 for BG\r\n    palette: u32 = 0\r\n}\r\n\r\n\r\nclass GB_pixel_slice_fetcher {\r\n    variant: GB_variants\r\n    ppu: GB_PPU|null = null\r\n    clock: GB_clock\r\n    bus: GB_bus\r\n\r\n    fetch_cycle: u32 = 0\r\n    fetch_addr: u32 = 0\r\n\r\n    fetch_obj: GB_PPU_sprite_t|null = null;\r\n    fetch_bp0: u32 = 0;\r\n    fetch_bp1: u32 = 0;\r\n    fetch_cgb_attr: u32 = 0;\r\n\r\n    bg_FIFO: GB_FIFO_t\r\n    obj_FIFO: GB_FIFO_t\r\n\r\n    bg_request_x: u32 = 0;\r\n    sp_request: u32 = 0;\r\n    sp_min: u32 = 0;\r\n    sprites_queue: GB_FIFO_t\r\n    out_px: GB_px = new GB_px()\r\n\r\n    constructor(variant: GB_variants, clock: GB_clock, bus: GB_bus) {\r\n        this.variant = variant\r\n\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n\r\n        this.bg_FIFO = new GB_FIFO_t(variant);\r\n        this.obj_FIFO = new GB_FIFO_t(variant);\r\n        this.sprites_queue = new GB_FIFO_t(variant);\r\n    }\r\n\r\n    advance_line(): void {\r\n        this.fetch_cycle = 0;\r\n        this.bg_FIFO.clear();\r\n        this.obj_FIFO.clear();\r\n        this.sprites_queue.clear();\r\n        this.bg_request_x = this.ppu!.io.SCX;\r\n        this.sp_request = 0;\r\n        this.sp_min = 0;\r\n    }\r\n\r\n    trigger_window(): void {\r\n        this.bg_FIFO.clear();\r\n        this.bg_request_x = 0;\r\n        this.fetch_cycle = 0;\r\n    }\r\n\r\n    cycle(): GB_px {\r\n        let r = this.get_px_if_available();\r\n        this.run_fetch_cycle();\r\n        return r;\r\n    }\r\n\r\n    get_px_if_available(): GB_px {\r\n        this.out_px.had_pixel = false;\r\n        this.out_px.bg_or_sp = -1;\r\n        if ((this.sp_request == 0) && (!this.bg_FIFO.empty())) {\r\n            this.out_px.had_pixel = true;\r\n            let has_bg = this.ppu!.io.bg_window_enable\r\n            let bg = this.bg_FIFO.pop();\r\n            let bg_color: u32 = bg.pixel;\r\n            let has_sp: bool = false;\r\n            let sp_color: i32 = -1;\r\n            let sp_palette: u32 = 0;\r\n            let use_what:u32; // 0 for BG, 1 for OBJ\r\n            let obj: GB_FIFO_item_t = this.obj_FIFO.blank;\r\n\r\n            if (!this.obj_FIFO.empty()) {\r\n                obj = this.obj_FIFO.pop();\r\n                sp_color = <i32>obj.pixel;\r\n                sp_palette = obj.palette;\r\n            }\r\n            if (this.ppu!.io.obj_enable && (sp_color !== -1)) has_sp = true;\r\n\r\n            if ((has_bg) && (!has_sp)) {\r\n                use_what = 1;\r\n            } else if ((!has_bg) && (has_sp)) {\r\n                use_what = 1;\r\n            } else if (has_bg && has_sp) {\r\n                if (obj.sprite_priority && (bg_color !== 0)) // \"If the OBJ pixel has its priority bit set, and the BG pixel's ID is not 0, pick the BG pixel.\"\r\n                    use_what = 1; // BG\r\n                else if (sp_color === 0) // \"If the OBJ pixel is 0, pick the BG pixel; \"\r\n                    use_what = 1; // BG\r\n                else // \"otherwise, pick the OBJ pixel\"\r\n                    use_what = 2; // sprite\r\n            } else {\r\n                use_what = 0;\r\n                this.out_px.color = 0;\r\n            }\r\n\r\n            if (use_what === 0) {\r\n            }\r\n            else if (use_what === 1) {\r\n                this.out_px.bg_or_sp = 0;\r\n                this.out_px.color = bg_color;\r\n                this.out_px.palette = 0;\r\n            } else {\r\n                this.out_px.bg_or_sp = 1;\r\n                this.out_px.color = sp_color;\r\n                // @ts-ignore\r\n                this.out_px.palette = sp_palette;\r\n            }\r\n        }\r\n        return this.out_px;\r\n    }\r\n\r\n    run_fetch_cycle(): void {\r\n        // Scan any sprites\r\n        for (let i: u32 = 0; i < this.ppu!.sprites.num; i++) {\r\n            let ppuo: GB_PPU_sprite_t = this.ppu!.OBJ[i];\r\n            if ((!ppuo.in_q) && (ppuo.x == this.clock.lx)) {\r\n                this.sp_request++;\r\n                let p = this.sprites_queue.push();\r\n                p!.sprite_obj = ppuo;\r\n                ppuo.in_q = 1;\r\n            }\r\n        }\r\n\r\n        let tn: u32;\r\n        switch(this.fetch_cycle) {\r\n            case 0: // nothing\r\n                this.fetch_cycle = 1;\r\n                break;\r\n            case 1: // tile\r\n                if (this.ppu!.in_window()) {\r\n                    tn = this.bus.mapper.PPU_read(this.ppu!.bg_tilemap_addr_window(this.bg_request_x));\r\n                    this.fetch_addr = this.ppu!.bg_tile_addr_window(tn);\r\n                }\r\n                else {\r\n                    tn = this.bus.mapper.PPU_read(this.ppu!.bg_tilemap_addr_nowindow(this.bg_request_x));\r\n                    this.fetch_addr = this.ppu!.bg_tile_addr_nowindow(tn);\r\n                }\r\n                this.fetch_cycle = 2;\r\n                break;\r\n            case 2: // nothing\r\n                this.fetch_cycle = 3;\r\n                break;\r\n            case 3: // bp0\r\n                this.fetch_bp0 = this.bus.mapper.PPU_read(this.fetch_addr);\r\n                //if (this.ppu.in_window()) this.fetch_bp0 = 0x55;\r\n                this.fetch_cycle = 4;\r\n                break;\r\n            case 4: // nothing\r\n                this.fetch_cycle = 5;\r\n                break;\r\n            case 5: // bp1\r\n                this.fetch_bp1 = this.bus.mapper.PPU_read(this.fetch_addr+1);\r\n                //if (this.ppu.in_window()) this.fetch_bp1 = 0x55;\r\n                this.fetch_cycle = 6;\r\n                break;\r\n            case 6: // attempt background push, OR, hijack by sprite\r\n                if (this.sp_request > 0) { // SPRITE HIJACK!\r\n                    this.fetch_cycle = 7;\r\n                    this.fetch_obj = this.sprites_queue.peek()!.sprite_obj;\r\n                    this.fetch_addr = GB_sp_tile_addr(this.fetch_obj!.tile, this.clock.ly - this.fetch_obj!.y, this.ppu!.io.sprites_big, this.fetch_obj!.attr & 0x40);\r\n                } else { // attempt to push to BG FIFO, which only accepts when empty.\r\n                    if (this.bg_FIFO.empty()) {\r\n                        // Push to FIFO\r\n                        for (let i = 0; i < 8; i++) {\r\n                            let b = this.bg_FIFO.push();\r\n                            b!.pixel = ((this.fetch_bp0 & 0x80) >>> 7) | ((this.fetch_bp1 & 0x80) >>> 6);\r\n                            this.fetch_bp0 <<= 1;\r\n                            this.fetch_bp1 <<= 1;\r\n                        }\r\n                        this.bg_request_x += 8;\r\n                        if ((this.ppu!.line_cycle < 88) && (!this.ppu!.in_window())) {\r\n                            this.bg_request_x -= 8;\r\n                            // Now discard some pixels for scrolling!\r\n                            let sx = this.ppu!.io.SCX & 7;\r\n                            this.bg_FIFO.discard(sx);\r\n                        }\r\n                        this.fetch_cycle = 0; // Restart fetching\r\n                    }\r\n                }\r\n                // do NOT advance if BG_FIFO won't take it\r\n                break;\r\n            case 7: // sprite bp0 fetch\r\n                this.fetch_bp0 = this.bus.mapper.PPU_read(this.fetch_addr);\r\n                this.fetch_cycle = 8;\r\n                break;\r\n            case 8: // nothing\r\n                this.fetch_cycle = 9;\r\n                break;\r\n            case 9: // sprite bp1 fetch, mix, & restart\r\n                this.fetch_bp1 = this.bus.mapper.PPU_read(this.fetch_addr+1);\r\n                this.sprites_queue.pop();\r\n                this.obj_FIFO.sprite_mix(this.fetch_bp0, this.fetch_bp1, (this.fetch_obj!.attr & 0x80) >>> 7, (this.fetch_obj!.attr & 0x10) >>> 4, (this.fetch_obj!.attr & 0x20));\r\n                this.sp_request--;\r\n                this.fetch_cycle = 0;\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nclass GB_PPU_sprites {\r\n    num: u32 = 0\r\n    index: u32 = 0\r\n    search_index: u32 = 0\r\n}\r\n\r\nclass GB_PPU_io {\r\n    sprites_big: u32 = 0\r\n\r\n    lyc: u32 = 0\r\n\r\n    STAT_IF: u32 = 0\r\n    STAT_IE: u32 = 0\r\n    old_mask: u32 = 0\r\n\r\n    window_tile_map_base: u32 = 0\r\n    window_enable: u32 = 0\r\n    bg_window_tile_data_base: u32 = 0\r\n    bg_tile_map_base: u32 = 0\r\n    obj_enable: u32 = 1\r\n    bg_window_enable: u32 = 1\r\n\r\n    SCX: u32 = 0 // X scroll\r\n    SCY: u32 = 0 // Y scroll\r\n    wx: u32 = 0 // Window X\r\n    wy: u32 = 0 // Window Y\r\n\r\n    IE: u32 = 0\r\n    IF: u32 = 0\r\n}\r\n\r\n\r\nexport class GB_PPU {\r\n    variant: GB_variants\r\n    clock: GB_clock\r\n    bus: GB_bus\r\n\r\n    slice_fetcher: GB_pixel_slice_fetcher\r\n\r\n    line_cycle: u32 = 0\r\n    cycles_til_vblank: i32 = 0\r\n    enabled: bool = false\r\n    display_upate: bool = false\r\n\r\n    bg_palette: StaticArray<u8> = new StaticArray<u8>(4);\r\n    sp_palette: StaticArray<StaticArray<u8>> = new StaticArray<StaticArray<u8>>(2);\r\n\r\n    OAM: StaticArray<u8> = new StaticArray<u8>(160);\r\n    OBJ: StaticArray<GB_PPU_sprite_t> = new StaticArray<GB_PPU_sprite_t>(10);\r\n\r\n    io: GB_PPU_io = new GB_PPU_io();\r\n    sprites: GB_PPU_sprites = new GB_PPU_sprites();\r\n    out_buffer: StaticArray<usize> = new StaticArray<usize>(2);\r\n\r\n    first_reset: bool = true;\r\n\r\n    is_window_line: bool = false;\r\n    window_triggered_on_line: bool = false;\r\n\r\n    display_update: bool = false;\r\n\r\n    last_used_buffer: u32 = 0\r\n    cur_output_num: u32 = 0\r\n    cur_buffer: usize = 0\r\n\r\n    constructor(out_buffer: usize, variant: GB_variants, clock: GB_clock, bus: GB_bus) {\r\n        this.variant = variant;\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n\r\n        this.slice_fetcher = new GB_pixel_slice_fetcher(variant, clock, bus);\r\n        this.bg_palette[0] = this.bg_palette[1] = this.bg_palette[2] = this.bg_palette[3] = 0;\r\n        this.sp_palette[0] = new StaticArray<u8>(4);\r\n        this.sp_palette[1] = new StaticArray<u8>(4);\r\n        for (let i = 0; i < 2; i++) {\r\n            this.sp_palette[0][i] = this.sp_palette[1][i] = 0;\r\n        }\r\n\r\n        for (let i = 0; i < 10; i++) {\r\n            this.OBJ[i] = new GB_PPU_sprite_t();\r\n        }\r\n\r\n        this.cur_buffer = this.out_buffer[this.cur_output_num];\r\n        this.out_buffer[0] = out_buffer;\r\n        this.out_buffer[1] = out_buffer+((160*144)*2);\r\n        bus.ppu = this;\r\n        this.slice_fetcher.ppu = this;\r\n        this.disable();\r\n    }\r\n\r\n    bg_tilemap_addr_window(wlx: u32): u32 {\r\n        return (0x9800 | (this.io.window_tile_map_base << 10) |\r\n            ((this.clock.wly >>> 3) << 5) |\r\n            (wlx >>> 3)\r\n        );\r\n    }\r\n\r\n    bg_tilemap_addr_nowindow(lx: u32): u32 {\r\n        // LCDC3 enabled and X coord NOT inside window, 9c00 used\r\n        // OR\r\n        // LCDC6 enabled and inside window, 9C00 used\r\n\r\n        return (0x9800 | ((this.io.bg_tile_map_base | this.io.bg_window_tile_data_base) << 10) |\r\n            ((((this.clock.ly + this.io.SCY) & 0xFF) >>> 3) << 5) |\r\n            (((lx) & 0xFF) >>> 3)\r\n        );\r\n    }\r\n\r\n    bg_tile_addr_window(tn: u32): u32 {\r\n        let b12: u32;\r\n        if (this.io.bg_window_tile_data_base) b12 = 0;\r\n        else b12 = ((tn & 0x80) ^ 0x80) << 5;\r\n        return (0x8000 | b12 |\r\n            (tn << 4) |\r\n            ((this.clock.wly & 7) << 1)\r\n        );\r\n    }\r\n\r\n    bg_tile_addr_nowindow(tn: u32): u32 {\r\n        let b12: u32;\r\n        if (this.io.bg_window_tile_data_base) b12 = 0;\r\n        else b12 = ((tn & 0x80) ^ 0x80) << 5;\r\n        return (0x8000 | b12 |\r\n            (tn << 4) |\r\n            ((((this.clock.ly + this.io.SCY) & 0xFF) & 7) << 1)\r\n        );\r\n    }\r\n\r\n    write_OAM(addr: u32, val: u32): void {\r\n        if ((addr >= 0xFE00) && (addr < 0xFEA0)) this.OAM[addr - 0xFE00] = <u8>val;\r\n    }\r\n\r\n    read_OAM(addr: u32): u32 {\r\n        if ((addr >= 0xFE00) && (addr < 0xFEA0)) return this.OAM[addr - 0xFE00];\r\n        return 0xFF;\r\n    }\r\n\r\n    write_IO(addr: u32, val: u32): void {\r\n        switch(addr) {\r\n            case 0xFF01:\r\n                /*let nstr = String.fromCharCode(val);\r\n                this.console_str += nstr;\r\n                console.log(this.console_str);*/\r\n                break;\r\n            case 0xFF40: // LCDC LCD Control\r\n                if (val & 0x80) this.enable();\r\n                else this.disable();\r\n\r\n                this.io.window_tile_map_base = (val & 0x40) >>> 6;\r\n                this.io.window_enable = (val & 0x20) >>> 5;\r\n                this.io.bg_window_tile_data_base = (val & 0x10) >>> 4;\r\n                this.io.bg_tile_map_base = (val & 8) >>> 3;\r\n                this.io.sprites_big = (val & 4) >>> 2;\r\n                this.io.obj_enable = (val & 2) >>> 1;\r\n                this.io.bg_window_enable = val & 1;\r\n                return;\r\n            case 0xFF41: // STAT LCD status\r\n                if (this.variant === GB_variants.DMG) {\r\n                    this.io.STAT_IE = 0x0F;\r\n                    this.eval_STAT();\r\n                }\r\n                let mode0_enable = (val & 8) >>> 3;\r\n                let mode1_enable = (val & 0x10) >>> 4;\r\n                let mode2_enable = (val & 0x20) >>> 5;\r\n                let lylyc_enable = (val & 0x40) >>> 6;\r\n                this.io.STAT_IE = mode0_enable | (mode1_enable << 1) | (mode2_enable << 2) | (lylyc_enable << 3);\r\n                this.eval_STAT();\r\n                return;\r\n            case 0xFF42: // SCY\r\n                //console.log('SCY!', val);\r\n                this.io.SCY = val;\r\n                return;\r\n            case 0xFF43: // SCX\r\n                this.io.SCX = val;\r\n                return;\r\n            case 0xFF45: // LYC\r\n                this.io.lyc = val;\r\n                //console.log('LYC:', this.io.lyc)\r\n                if (this.enabled) this.eval_lyc();\r\n                return;\r\n            case 0xFF4A: // window Y\r\n                this.io.wy = val;\r\n                return;\r\n            case 0xFF4B: // window x + 7\r\n                this.io.wx = val+1;\r\n                return;\r\n            case 0xFF47: // BGP pallete\r\n                //if (!this.clock.CPU_can_VRAM) return;\r\n                this.bg_palette[0] = <u8>(val & 3);\r\n                this.bg_palette[1] = <u8>((val >>> 2) & 3);\r\n                this.bg_palette[2] = <u8>((val >>> 4) & 3);\r\n                this.bg_palette[3] = <u8>((val >>> 6) & 3);\r\n                return;\r\n            case 0xFF48: // OBP0 sprite palette 0\r\n                //if (!this.clock.CPU_can_VRAM) return;\r\n                this.sp_palette[0][0] = <u8>(val & 3);\r\n                this.sp_palette[0][1] = <u8>((val >>> 2) & 3);\r\n                this.sp_palette[0][2] = <u8>((val >>> 4) & 3);\r\n                this.sp_palette[0][3] = <u8>((val >>> 6) & 3);\r\n                return;\r\n            case 0xFF49: // OBP1 sprite palette 1\r\n                //if (!this.clock.CPU_can_VRAM) return;\r\n                this.sp_palette[1][0] = <u8>(val & 3);\r\n                this.sp_palette[1][1] = <u8>((val >>> 2) & 3);\r\n                this.sp_palette[1][2] = <u8>((val >>> 4) & 3);\r\n                this.sp_palette[1][3] = <u8>((val >>> 6) & 3);\r\n                return;\r\n\r\n        }\r\n    }\r\n\r\n    read_IO(addr: u32, val: u32, has_effect: bool = true): u32 {\r\n        switch(addr) {\r\n            case 0xFF40: // LCDC LCD Control\r\n                let e: u32 = this.enabled ? 0x80: 0;\r\n                return e | (this.io.window_tile_map_base << 6) | (this.io.window_enable << 5) | (this.io.bg_window_tile_data_base << 4) |\r\n                    (this.io.bg_tile_map_base << 3) | (this.io.sprites_big << 2) |\r\n                    (this.io.obj_enable << 1) | (this.io.bg_window_enable);\r\n            case 0xFF41: // STAT LCD status\r\n                let mode0_enable = this.io.IE & 1;\r\n                let mode1_enable = (this.io.IE & 2) >>> 1;\r\n                let mode2_enable = (this.io.IE & 4) >>> 2;\r\n                let lylyc_enable = (this.io.IE & 8) >>> 3;\r\n                return this.clock.ppu_mode |\r\n                    ((this.clock.ly === this.io.lyc) ? 1 : 0) |\r\n                    (mode0_enable << 3) |\r\n                    (mode1_enable << 4) |\r\n                    (mode2_enable << 5) |\r\n                    (lylyc_enable << 6);\r\n            case 0xFF42: // SCY\r\n                return this.io.SCY;\r\n            case 0xFF43: // SCX\r\n                return this.io.SCX;\r\n            case 0xFF44: // LY\r\n                /*console.log('READ FF44!', this.clock.ly);\r\n                if (this.clock.ly === 0x90) dbg.break();*/\r\n                let ly = this.clock.ly;\r\n                if ((ly === 153) && (this.line_cycle > 1)) ly = 0;\r\n                return ly;\r\n            case 0xFF45: // LYC\r\n                return this.io.lyc;\r\n            case 0xFF4A: // window Y\r\n                return this.io.wy;\r\n            case 0xFF4B: // window x + 7\r\n                return this.io.wx;\r\n            case 0xFF47: // BGP\r\n                //if (!this.clock.CPU_can_VRAM) return 0xFF;\r\n                return this.bg_palette[0] | (this.bg_palette[1] << 2) | (this.bg_palette[2] << 4) | (this.bg_palette[3] << 6);\r\n            case 0xFF48: // OBP0\r\n                //if (!this.clock.CPU_can_VRAM) return 0xFF;\r\n                return this.sp_palette[0][0] | (this.sp_palette[0][1] << 2) | (this.sp_palette[0][2] << 4) | (this.sp_palette[0][3] << 6);\r\n            case 0xFF49: // OBP1\r\n                //if (!this.clock.CPU_can_VRAM) return 0xFF;\r\n                return this.sp_palette[1][0] | (this.sp_palette[1][1] << 2) | (this.sp_palette[1][2] << 4) | (this.sp_palette[1][3] << 6);\r\n        }\r\n        return 0xFF;\r\n    }\r\n\r\n    disable(): void {\r\n        if (!this.enabled) return;\r\n        this.enabled = false;\r\n        console.log('DISABLE PPU')\r\n        this.clock.CPU_can_VRAM = 1;\r\n        this.clock.setCPU_can_OAM(1);\r\n        this.io.STAT_IF = 0;\r\n        this.eval_STAT();\r\n    }\r\n\r\n    enable(): void {\r\n        if (this.enabled) return;\r\n        console.log('ENABLE PPU');\r\n        this.enabled = true;\r\n        this.advance_frame(false)\r\n        this.clock.lx = 0;\r\n        this.clock.ly = 0;\r\n        this.line_cycle = 0;\r\n        this.cycles_til_vblank = 0;\r\n        this.io.STAT_IF = 0;\r\n        this.set_mode(GB_PPU_modes.OAM_search);\r\n        this.eval_lyc();\r\n        this.eval_STAT();\r\n    }\r\n\r\n    set_mode(which: GB_PPU_modes): void {\r\n        if (this.clock.ppu_mode == which) return;\r\n        this.clock.ppu_mode = which;\r\n\r\n        switch(which) {\r\n            case GB_PPU_modes.OAM_search: // 2. after vblank, so after 1\r\n                this.clock.setCPU_can_OAM(0);\r\n                this.clock.CPU_can_VRAM = 1;\r\n                if (this.enabled) {\r\n                    this.bus.IRQ_vblank_down();\r\n                    this.IRQ_mode1_down();\r\n                    this.IRQ_mode2_up();\r\n                }\r\n                break;\r\n            case GB_PPU_modes.pixel_transfer: // 3, comes after 2\r\n                this.IRQ_mode2_down();\r\n                this.clock.CPU_can_VRAM = 0;\r\n                this.clock.setCPU_can_OAM(0);\r\n                this.slice_fetcher.advance_line();\r\n                break;\r\n            case GB_PPU_modes.HBLANK: // 0, comes after 3\r\n                this.IRQ_mode0_up();\r\n                this.clock.CPU_can_VRAM = 1;\r\n                this.clock.setCPU_can_OAM(1);\r\n                break;\r\n            case GB_PPU_modes.VBLANK: // 1, comes after 0\r\n                this.IRQ_mode0_down();\r\n                this.IRQ_mode1_up();\r\n                this.IRQ_vblank_up();\r\n                this.clock.CPU_can_VRAM = 1;\r\n                this.clock.setCPU_can_OAM(1);\r\n                break;\r\n        }\r\n    }\r\n\r\n    run_cycles(howmany: u32): void {\r\n        // We don't do anything, and in fact are off, if LCD is off\r\n        for (let i: u32 = 0; i < howmany; i++) {\r\n            if (this.cycles_til_vblank) {\r\n                this.cycles_til_vblank--;\r\n                if (this.cycles_til_vblank === 0)\r\n                    this.bus.IRQ_vblank_up();\r\n            }\r\n            if (this.enabled) {\r\n                this.cycle();\r\n                this.line_cycle++;\r\n                if (this.line_cycle === 456) this.advance_line();\r\n            }\r\n            if (dbg.do_break) break;\r\n        }\r\n    }\r\n\r\n    advance_line(): void {\r\n        if (this.window_triggered_on_line) this.clock.wly++;\r\n        this.clock.lx = 0;\r\n        this.clock.ly++;\r\n        // @ts-ignore\r\n        this.is_window_line = this.is_window_line | (this.clock.ly == this.io.wy);\r\n        this.window_triggered_on_line = false;\r\n        this.line_cycle = 0;\r\n        if (this.clock.ly >= 154)\r\n            this.advance_frame();\r\n        if (this.enabled) {\r\n            this.eval_lyc();\r\n            if (this.clock.ly < 144)\r\n                this.set_mode(GB_PPU_modes.OAM_search); // OAM search\r\n            else if (this.clock.ly === 144)\r\n                this.set_mode(GB_PPU_modes.VBLANK); // VBLANK\r\n        }\r\n    }\r\n\r\n    // TODO: trigger IRQ if enabled properly\r\n    @inline eval_lyc(): void {\r\n        let cly: u32 = this.clock.ly;\r\n        if ((cly === 153) && (this.io.lyc !== 153)) cly = 0;\r\n        if (cly === this.io.lyc) {\r\n            this.IRQ_lylyc_up();\r\n        }\r\n        else\r\n            this.IRQ_lylyc_down();\r\n    }\r\n\r\n    @inline IRQ_lylyc_up(): void {\r\n        this.io.STAT_IF |= 8;\r\n        this.eval_STAT();\r\n    }\r\n\r\n    @inline IRQ_lylyc_down(): void {\r\n        this.io.STAT_IF &= 0xF7;\r\n        this.eval_STAT();\r\n    }\r\n\r\n    @inline IRQ_mode0_up(): void {\r\n        this.io.STAT_IF |= 1;\r\n        this.eval_STAT();\r\n    }\r\n\r\n    @inline IRQ_mode0_down(): void {\r\n        this.io.STAT_IF &= 0xFE;\r\n        this.eval_STAT();\r\n    }\r\n\r\n    @inline IRQ_vblank_up(): void {\r\n        this.cycles_til_vblank = 2;\r\n    }\r\n\r\n    @inline IRQ_mode1_up(): void {\r\n        this.io.STAT_IF |= 2;\r\n        this.eval_STAT();\r\n    }\r\n\r\n    @inline IRQ_mode1_down(): void {\r\n        this.io.STAT_IF &= 0xFD;\r\n        this.eval_STAT();\r\n    }\r\n\r\n    @inline IRQ_mode2_up(): void {\r\n        this.io.STAT_IF |= 4;\r\n        this.eval_STAT();\r\n    }\r\n\r\n    @inline IRQ_mode2_down(): void {\r\n        this.io.STAT_IF &= 0xFB;\r\n        this.eval_STAT();\r\n    }\r\n\r\n    eval_STAT(): void {\r\n        let mask = this.io.STAT_IF & this.io.STAT_IE;\r\n        if ((this.io.old_mask === 0) && (mask !== 0)) {\r\n            this.bus.cpu!.cpu.regs.IF |= 2;\r\n        }\r\n        else {\r\n            //console.log('DID NOT TRIGGER STAT!');\r\n        }\r\n        this.io.old_mask = mask;\r\n    }\r\n\r\n    advance_frame(update_buffer: bool = true): void {\r\n        this.clock.ly = 0;\r\n        this.clock.wly = 0;\r\n        if (this.enabled) {\r\n            this.display_update = true;\r\n        }\r\n        this.clock.frames_since_restart++;\r\n        this.clock.master_frame++;\r\n        this.is_window_line = false;\r\n        if (update_buffer) {\r\n            this.last_used_buffer = this.cur_output_num;\r\n            this.cur_output_num ^= 1;\r\n            this.cur_buffer = this.out_buffer[this.cur_output_num];\r\n        }\r\n    }\r\n\r\n    /********************/\r\n    OAM_search(): void {\r\n        if (this.line_cycle != 75) return;\r\n\r\n        // Check if a sprite is at the right place\r\n        this.sprites.num = 0;\r\n        this.sprites.index = 0;\r\n        this.sprites.search_index = 0;\r\n        for (let i = 0; i < 10; i++) {\r\n            let o = this.OBJ[i];\r\n            o.x = 0;\r\n            o.y = 0;\r\n            o.in_q = 0;\r\n        }\r\n\r\n        let cly: i32 = <i32>this.clock.ly;\r\n\r\n        for (let i = 0; i < 40; i++) {\r\n            if (this.sprites.num === 10) break;\r\n            let sy: i32 = <i32>(this.OAM[this.sprites.search_index] - 16);\r\n            let sy_bottom: i32 = sy + (this.io.sprites_big ? 16 : 8);\r\n            if ((cly >= sy) && (cly < sy_bottom)) {\r\n                let o_sn = this.OBJ[this.sprites.num];\r\n                o_sn.y = sy;\r\n                o_sn.x = this.OAM[this.sprites.search_index + 1] - 1;\r\n                o_sn.tile = this.OAM[this.sprites.search_index + 2];\r\n                o_sn.attr = this.OAM[this.sprites.search_index + 3];\r\n                o_sn.in_q = 0;\r\n\r\n                this.sprites.num++;\r\n            }\r\n            this.sprites.search_index += 4\r\n        }\r\n    }\r\n\r\n    @inline in_window(): bool {\r\n        return this.io.window_enable && this.is_window_line && (this.clock.lx >= this.io.wx);\r\n    }\r\n\r\n    pixel_transfer(): void {\r\n        if ((this.io.window_enable) && ((this.clock.lx) === this.io.wx) && this.is_window_line && !this.window_triggered_on_line) {\r\n            this.slice_fetcher.trigger_window();\r\n            this.window_triggered_on_line = true;\r\n        }\r\n        let p: GB_px = this.slice_fetcher.cycle();\r\n\r\n        if (p.had_pixel) {\r\n            if (this.clock.lx > 7) {\r\n                let cv: u8;\r\n                if (p.bg_or_sp === 0) {\r\n                    cv = this.bg_palette[p.color];\r\n                } else {\r\n                    cv = this.sp_palette[p.palette][p.color];\r\n                }\r\n                store<u16>(this.cur_buffer+(((this.clock.ly * 160) + (this.clock.lx - 8))*2), <u8>cv);\r\n            }\r\n            this.clock.lx++;\r\n        }\r\n    }\r\n\r\n    /*******************/\r\n    cycle(): void {\r\n        // During HBlank and VBlank do nothing...\r\n        if (this.clock.ly > 143) return;\r\n        if (this.clock.ppu_mode < 2) return;\r\n\r\n        // Clear sprites\r\n        if (this.line_cycle === 0) {\r\n            this.set_mode(GB_PPU_modes.OAM_search); // OAM search\r\n        }\r\n\r\n        switch (this.clock.ppu_mode) {\r\n            case GB_PPU_modes.OAM_search: // OAM search 0-80\r\n                // 80 dots long, 2 per entry, find up to 10 sprites 0...n on this line\r\n                this.OAM_search();\r\n                if (this.line_cycle === 79) this.set_mode(GB_PPU_modes.pixel_transfer);\r\n                break;\r\n            case GB_PPU_modes.pixel_transfer: // Pixel transfer. Rendering time!\r\n                this.pixel_transfer();\r\n                if (this.clock.lx > 167)\r\n                    this.set_mode(GB_PPU_modes.HBLANK);\r\n                break;\r\n        }\r\n    }\r\n\r\n    reset(): void {\r\n        // Reset variables\r\n        this.clock.lx = 0;\r\n        this.clock.ly = 0;\r\n        this.line_cycle = 0;\r\n        this.display_update = false;\r\n        this.cycles_til_vblank = 0;\r\n\r\n        // Reset IRQs\r\n        //this.io.STAT_IE = 0; // Interrupt enables\r\n        //this.io.STAT_IF = 0; // Interrupt flags\r\n        //this.io.old_mask = 0;\r\n\r\n        //this.eval_STAT();\r\n\r\n        // Set mode to OAM search\r\n        this.set_mode(GB_PPU_modes.OAM_search);\r\n        this.first_reset = false;\r\n   }\r\n\r\n   quick_boot(): void {\r\n        switch(this.variant) {\r\n            case GB_variants.DMG:\r\n                this.enabled = true;\r\n                //let val = 0xFC;\r\n                //this.clock.ly = 90;\r\n                this.write_IO(0xFF40, 0x91);\r\n                this.write_IO(0xFF41, 0x85);\r\n                this.write_IO(0xFF47, 0xFC);\r\n                this.io.lyc = 0;\r\n                this.io.SCX = this.io.SCY = 0;\r\n\r\n                this.advance_frame();\r\n                break;\r\n            case GB_variants.GBC:\r\n                this.write_IO(0xFF40, 0x91);\r\n                this.write_IO(0xFF47, 0xFC);\r\n\r\n                this.io.lyc = 0;\r\n                this.io.SCX = this.io.SCY = 0;\r\n\r\n                break;\r\n            default:\r\n                console.log('QUICKBOOT NOT SUPPROTEDO N THSI GAMEBOY MODEL');\r\n                break;\r\n        }\r\n   }\r\n}\r\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    let index: usize = 0;\n    let total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare let __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","import { Math as JSMath } from \"./bindings/dom\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of π/2 * |x|\n *\n * y = π/4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of π/4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  let shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  let lo = umuldi(p1, q1);\n  let hi = res128_hi;\n\n  let ahi = hi >> 11;\n  let alo = lo >> 11 | hi << 53;\n  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  let magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  let offset = (magnitude >> 52) - 1045;\n  let shift  = offset & 63;\n  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  let s0: u64, s1: u64, s2: u64;\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 / π with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2π)\n  let blo = umuldi(s1, significand);\n  let bhi = res128_hi;\n\n  let ahi = s0 * significand;\n  let clo = (s2 >> 32) * (significand >> 32);\n  let plo = blo + clo;\n  let phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  let rlo = plo << 2;\n  let rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  let slo = <i64>rhi >> 63;\n  let shi = slo >> 1;\n  let q   = (<i64>phi >> 62) - slo;\n\n  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  let signbit = (u ^ rhi) & 0x8000000000000000;\n  let coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  let ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  let q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  let z = x * x;\n  let w = z * z;\n  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  let v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  let z = x * x;\n  let w = z * z;\n  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  let hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  let z: f64, r: f64, v: f64, w: f64, s: f64;\n  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  let ix = hx & 0x7FFFFFFF; // high word of |x|\n  let big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  let a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, <i64>u < 0);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy let random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy let random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    let s: f64, w: f64, z: f64;\n    if (<i32>hx < 0) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    let c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    let u = reinterpret<u64>(x);\n    // Prevent propagation for all input values less than 1.0.\n    // Note musl lib didn't fix this yet.\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\n    let e = u >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    let z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z);\n    let r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    return select(-x, x, <i32>hx < 0);\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let ix = <u32>(reinterpret<u64>(x) >> 32);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let u = reinterpret<u64>(x);\n    let ix = <u32>(u >> 32);\n    let lx = <u32>u;\n    u = reinterpret<u64>(y);\n    let iy = <u32>(u >> 32);\n    let ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    let z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    let t = reinterpret<f64>(u);\n    let r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    let s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    let w = <u32>(u >> 32);\n    let t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = u32(reinterpret<u64>(x) >> 32);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32) & 0x7FFFFFFF;\n    let sign = u32(u >> 63);\n    let k = 0;\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    let c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    let hfx = 0.5 * x;\n    let hxs = x * hfx;\n    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    let hxq = hxs * hxs;\n    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    let twopk = reinterpret<f64>(u);\n    let y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    let ex = i32(ux >> 52);\n    let ey = i32(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    let z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    let c = x * SPLIT;\n    let h = x - c + c;\n    let l = x - h;\n    let hx = x * x;\n    let lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    let hy = y * y;\n    let ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 0;\n    let sign = hx >> 31;\n    if (sign || hx < 0x00100000) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = u32(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += i32(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    let f = x - 1.0;\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let val_hi = hi * ivln10hi;\n    let dk = <f64>k;\n    let y = dk * log10_2hi;\n    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 1;\n    let c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || bool(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = u32(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = i32(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += i32(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = i32(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = i32(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = u32(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = u32(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    // Instead zero seed use golden ratio:\n    // phi = (1 + sqrt(5)) / 2\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\n    if (value == 0) value = 0x9e3779b97f4a7c15;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    random_seeded = true;\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    let s1 = random_state0_64;\n    let s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    let r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  export function round(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f64>(x);\n      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return bool(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    let a = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >>> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    let n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    let y = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    let y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    let sx = ux >> 63;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= u64(-1) >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    let shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    let uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u64(-1) >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    let q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return <i64>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3FE921FB) {  // |x| ~<= π/4\n      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n    let s = sin_kern(y0, y1, 1);\n    let c = cos_kern(y0, y1);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  let p = z * (pS0 + z * (pS1 + z * pS2));\n  let q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n\n  let offset = (u >> 23) - 152;\n  let shift  = u64(offset & 63);\n  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  let hi = (b1 >> (64 - shift)) | (b0 << shift);\n  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  let product = mantissa * hi + (mantissa * lo >> 32);\n  let r: i64 = product << 2;\n  let q = i32((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { // π * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  let q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  let z = x * x;\n  let w = z * z;\n  let r = S3 + z * S4;\n  let s = z * x;\n  return f32((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  let z = x * x;\n  let w = z * z;\n  let r = C2 + z * C3;\n  return f32(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  let z = x * x;\n  let r = T4 + z * T5;\n  let t = T2 + z * T3;\n  let w = z * z;\n  let s = z * x;\n  let u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return f32(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  let i = reinterpret<i64>(x);\n  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  let xx = x * x;\n  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  let n = nearest(x);\n  x -= n;\n  let xx = x * x;\n  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let hx = reinterpret<u32>(x);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    let z: f32, w: f32, s: f32;\n    if (<i32>hx < 0) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    let df = reinterpret<f32>(hx & 0xFFFFF000);\n    let c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x);\n    let a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let sx = x;\n    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z); // sic\n    x = f32(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    let ix = reinterpret<u32>(x);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * aT4));\n    let s2 = w * (aT1 + w * aT3);\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    let u = reinterpret<u32>(x);\n    let y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let ix = reinterpret<u32>(x);\n    let iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    let z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    let t = <f64>reinterpret<f32>(u);\n    let r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {  // |x| ~<= 5π/4\n        if (ux > 0x4016CBE3) { // |x|  ~> 3π/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ux <= 0x40E231D5) {  // |x| ~<= 9π/4\n        if (ux > 0x40AFEDDF) { // |x|  ~> 7π/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    let sign = u >> 31;\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    let c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    let hfx: f32 = 0.5 * x;\n    let hxs: f32 = x * hfx;\n    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    let twopk = reinterpret<f32>(u);\n    let y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    let z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      let sign = u >> 31;\n      if (sign || u < 0x00800000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += i32(u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    let ux = reinterpret<u32>(x);\n    let k = 0;\n    let sign = ux >> 31;\n    if (sign || ux < 0x00800000) {\n      if (ux << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ux = reinterpret<u32>(x);\n    } else if (ux >= 0x7F800000) {\n      return x;\n    } else if (ux == 0x3F800000) {\n      return 0;\n    }\n    ux += 0x3F800000 - 0x3F3504F3;\n    k += i32(ux >> 23) - 0x7F;\n    ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ux);\n    let f = x - 1.0;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let hi = f - hfsq;\n    ux = reinterpret<u32>(hi);\n    ux &= 0xFFFFF000;\n    hi = reinterpret<f32>(ux);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    let ix = reinterpret<u32>(x);\n    let c: f32 = 0;\n    let f: f32 = 0;\n    let k = 1;\n    if (ix < 0x3ED413D0 || bool(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = i32(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ux = reinterpret<u32>(x);\n      let k = 0;\n      let sign = ux >> 31;\n      if (sign || ux < 0x00800000) {\n        if (ux << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ux = reinterpret<u32>(x);\n      } else if (ux >= 0x7F800000) {\n        return x;\n      } else if (ux == 0x3F800000) {\n        return 0;\n      }\n      ux += 0x3F800000 - 0x3F3504F3;\n      k += i32(ux >> 23) - 0x7F;\n      ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ux);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = <i32>uy < 0 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = <i32>uy < 0 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    let s0 = random_state0_32;\n    let s1 = random_state1_32;\n    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  export function round(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f32>(x);\n      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let a = reinterpret<f32>(u);\n    let h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // argument reduction\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    let t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    let y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let sm = ux & 0x80000000;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    let shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u32(-1) >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    let q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return <i32>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    let s = sin_kernf(y);\n    let c = cos_kernf(y);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  let out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  let out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol, strtod } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f64 {\n    return strtod(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","import {\r\n    NES_a12_watcher_t,\r\n    NES_mapper,\r\n    NES_mirror_ppu_Aonly,\r\n    NES_mirror_ppu_Bonly,\r\n    NES_mirror_ppu_four,\r\n    NES_mirror_ppu_horizontal,\r\n    NES_mirror_ppu_vertical, NES_PPU_mirror_modes\r\n} from \"./interface\";\r\nimport {NES_bus, NES_clock} from \"../nes_common\";\r\nimport {NES_cart} from \"../nes_cart\";\r\n\r\nexport class NES_mapper_none implements NES_mapper {\r\n    clock: NES_clock\r\n    bus: NES_bus\r\n    a12_watcher: NES_a12_watcher_t\r\n    CHR_ROM: StaticArray<u8>\r\n    PRG_ROM: StaticArray<u8>\r\n    CIRAM: StaticArray<u8>\r\n    CPU_RAM: StaticArray<u8>\r\n    ppu_mirror: NES_PPU_mirror_modes = NES_PPU_mirror_modes.Horizontal;\r\n    PRG_ROM_size: u32\r\n    mirror_ppu_addr: (addr: u32) => u32 = NES_mirror_ppu_horizontal;\r\n    constructor(clock: NES_clock, bus: NES_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n        this.a12_watcher = new NES_a12_watcher_t(clock);\r\n\r\n        this.CHR_ROM = new StaticArray<u8>(0x2000);\r\n        this.PRG_ROM = new StaticArray<u8>(0x8000);\r\n        this.PRG_ROM_size = 0\r\n        this.CIRAM = new StaticArray<u8>(0x2000); // PPU RAM\r\n        this.CPU_RAM = new StaticArray<u8>(0x800);\r\n        this.ppu_mirror = 0;\r\n    }\r\n\r\n    @inline cycle(howmany: u32) : void {}\r\n\r\n    @inline a12_watch(addr: u32): void {}\r\n\r\n    @inline CPU_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        addr &= 0xFFFF;\r\n        if (addr < 0x2000)\r\n            return this.CPU_RAM[addr & 0x7FF];\r\n        if (addr < 0x3FFF)\r\n            return this.bus.PPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_read(addr, val, has_effect);\r\n        if (addr >= 0x8000)\r\n            return this.PRG_ROM[(addr - 0x8000) % this.PRG_ROM_size];\r\n        return val;\r\n    }\r\n\r\n    @inline CPU_write(addr: u32, val: u32): void {\r\n        addr &= 0xFFFF;\r\n        if (addr < 0x2000) {\r\n            this.CPU_RAM[addr & 0x7FF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0x3FFF) {\r\n            this.bus.PPU_reg_write(addr, val);\r\n            return;\r\n        }\r\n        if (addr < 0x4020) {\r\n            this.bus.CPU_reg_write(addr, val);\r\n            return;\r\n        }\r\n    }\r\n\r\n    @inline PPU_read_effect(addr: u32): u32 {\r\n        if (addr < 0x2000)\r\n            return this.CHR_ROM[addr];\r\n        return this.CIRAM[this.mirror_ppu_addr(addr)];\r\n    }\r\n\r\n    PPU_read_noeffect(addr: u32): u32 {\r\n        return this.PPU_read_effect(addr);\r\n    }\r\n\r\n    @inline PPU_write(addr: u32, val: u32): void {\r\n        if (addr < 0x2000) return;\r\n        this.CIRAM[this.mirror_ppu_addr(addr)] = <u8>val;\r\n    }\r\n\r\n    set_mirroring(): void {\r\n        switch(this.ppu_mirror) {\r\n            case NES_PPU_mirror_modes.Vertical:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_vertical;\r\n                return;\r\n            case NES_PPU_mirror_modes.Horizontal:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_horizontal;\r\n                return;\r\n            case NES_PPU_mirror_modes.FourWay:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_four;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenAOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Aonly;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenBOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Bonly;\r\n                return;\r\n        }\r\n    }\r\n\r\n    reset(): void { } // naught to do on reset\r\n\r\n    set_cart(cart: NES_cart): void {\r\n        for (let i = 0; i < 0x2000; i++) {\r\n            this.CHR_ROM[i] = cart.CHR_ROM[i];\r\n        }\r\n        this.PRG_ROM = new StaticArray<u8>(cart.PRG_ROM.byteLength);\r\n        for (let i = 0, k = cart.PRG_ROM.byteLength; i < k; i++) {\r\n            this.PRG_ROM[i] = cart.PRG_ROM[i];\r\n        }\r\n        this.PRG_ROM_size = cart.header.prg_rom_size;\r\n\r\n        this.ppu_mirror = cart.header.mirroring;\r\n        this.set_mirroring();\r\n    }\r\n}","import {\r\n    NES_mapper,\r\n    NES_mirror_ppu_Aonly,\r\n    NES_mirror_ppu_Bonly,\r\n    NES_mirror_ppu_four,\r\n    NES_mirror_ppu_horizontal,\r\n    NES_mirror_ppu_vertical,\r\n    NES_PPU_mirror_modes\r\n} from \"./interface\";\r\nimport {NES_bus, NES_clock} from \"../nes_common\";\r\nimport {MMC3b_map} from \"./mmc3b\";\r\nimport {NES_cart} from \"../nes_cart\";\r\n\r\nclass io {\r\n    shift_pos: u32 = 0;\r\n    shift_value: u32 = 0;\r\n    swapped_banks: u32 = 0;\r\n    ppu_bank00: u32 = 0;\r\n    ppu_bank10: u32 = 0;\r\n    bank: u32 = 0;\r\n    ctrl: u32 = 0;\r\n    prg_bank_mode: u32 = 3;\r\n    chr_bank_mode: u32 = 0;\r\n}\r\n\r\nexport class NES_mapper_MMC1 implements NES_mapper {\r\n    clock: NES_clock\r\n    bus: NES_bus\r\n    CHR_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    PRG_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    CIRAM: StaticArray<u8> = new StaticArray<u8>(0x2000); // PPU RAM\r\n    CPU_RAM: StaticArray<u8> = new StaticArray<u8>(0x800); // CPU RAM\r\n    PRG_RAM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    CHR_RAM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    prg_ram_size: u32 = 0;\r\n    chr_ram_size: u32 = 0;\r\n    has_chr_ram: bool = false;\r\n    has_prg_ram: bool = false;\r\n\r\n    last_cycle_write: u64 = 0;\r\n\r\n    PRG_map: StaticArray<MMC3b_map> = new StaticArray<MMC3b_map>(2);\r\n    CHR_map: StaticArray<MMC3b_map> = new StaticArray<MMC3b_map>(2);\r\n\r\n    num_CHR_banks: u32 = 0\r\n    num_PRG_banks: u32 = 0\r\n    ppu_mirror: NES_PPU_mirror_modes = NES_PPU_mirror_modes.Horizontal;\r\n    mirror_ppu_addr: (addr: u32) => u32 = NES_mirror_ppu_horizontal;\r\n\r\n    io: io = new io();\r\n\r\n    constructor(clock: NES_clock, bus: NES_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n        for (let i: u32 = 0; i < 2; i++) {\r\n            this.PRG_map[i] = new MMC3b_map();\r\n            this.CHR_map[i] = new MMC3b_map();\r\n        }\r\n    }\r\n\r\n    @inline cycle(howmany: u32): void { }\r\n\r\n    @inline a12_watch(addr: u32): void {}\r\n\r\n    remap(boot: bool = false): void {\r\n        if (boot) {\r\n            for (let i = 0; i < 2; i++) {\r\n                this.PRG_map[i].data = this.PRG_ROM;\r\n                this.PRG_map[i].ROM = true;\r\n                this.PRG_map[i].RAM = false;\r\n                this.PRG_map[i].addr = (0x8000) + (i * 0x4000);\r\n\r\n                this.CHR_map[i].data = this.CHR_ROM;\r\n                this.CHR_map[i].addr = 0x1000 * i;\r\n                this.CHR_map[i].ROM = true;\r\n                this.CHR_map[i].RAM = false;\r\n            }\r\n        }\r\n\r\n        switch(this.io.prg_bank_mode) {\r\n            case 0:\r\n            case 1: // 32k at 0x8000\r\n                this.set_PRG_ROM(0x8000, this.io.bank & 0xFE);\r\n                this.set_PRG_ROM(0xC000, this.io.bank | 1);\r\n                break;\r\n            case 2:\r\n                this.set_PRG_ROM(0x8000, 0);\r\n                this.set_PRG_ROM(0xC000, this.io.bank);\r\n                break;\r\n            case 3:\r\n                this.set_PRG_ROM(0x8000, this.io.bank);\r\n                this.set_PRG_ROM(0xC000, this.num_PRG_banks - 1);\r\n                break;\r\n        }\r\n\r\n        if (!this.has_chr_ram) {\r\n            switch (this.io.chr_bank_mode) {\r\n                case 0: // 8kb switch at a time\r\n                    this.set_CHR_ROM(0x0000, this.io.ppu_bank00 & 0xFE);\r\n                    this.set_CHR_ROM(0x1000, this.io.ppu_bank00 | 1);\r\n                    break;\r\n                case 1: // 4kb switch at a time\r\n                    this.set_CHR_ROM(0x0000, this.io.ppu_bank00);\r\n                    this.set_CHR_ROM(0x1000, this.io.ppu_bank10);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    PPU_write(addr: u32, val: u32): void {\r\n        addr &= 0x3FFF;\r\n        if (addr < 0x2000) {\r\n            if (this.has_chr_ram) this.CHR_RAM[addr] = <u8>val;\r\n            return;\r\n        }\r\n        this.CIRAM[this.mirror_ppu_addr(addr)] = <u8>val;\r\n    }\r\n\r\n    @inline PPU_read_effect(addr: u32): u32 {\r\n        addr &= 0x3FFF;\r\n        if (addr < 0x2000) {\r\n            if (this.has_chr_ram) return this.CHR_RAM[addr];\r\n            return this.CHR_map[addr >>> 12].read(addr);\r\n        }\r\n        return this.CIRAM[this.mirror_ppu_addr(addr)];\r\n    }\r\n\r\n    PPU_read_noeffect(addr: u32): u32 {\r\n        return this.PPU_read_effect(addr);\r\n    }\r\n\r\n    CPU_write(addr: u32, val: u32): void {\r\n        // Conventional CPU map\r\n        if (addr < 0x2000) {\r\n            this.CPU_RAM[addr & 0x7FF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0x4000)\r\n            return this.bus.PPU_reg_write(addr, val);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_write(addr, val);\r\n        if (addr < 0x6000) return;\r\n        if (addr < 0x8000) {\r\n            if (this.has_prg_ram) this.PRG_RAM[addr - 0x6000] = <u8>val;\r\n            return;\r\n        }\r\n\r\n        // MMC1 stuff\r\n\r\n        // 8000-FFFF register\r\n        // Clear with bit 7 set\r\n        if (val & 0x80) {\r\n            // Writes ctrl | 0x0C\r\n            this.io.shift_pos = 4;\r\n            this.io.shift_value = this.io.ctrl | 0x0C;\r\n            this.last_cycle_write = this.clock.cpu_master_clock;\r\n            addr = 0x8000;\r\n        } else {\r\n            if (this.clock.cpu_master_clock === (this.last_cycle_write + this.clock.timing.cpu_divisor)) {\r\n                // writes on consecutive cycles fail\r\n                this.last_cycle_write = this.clock.cpu_master_clock;\r\n                return;\r\n            } else {\r\n                this.io.shift_value = (this.io.shift_value >>> 1) | ((val & 1) << 4);\r\n            }\r\n        }\r\n\r\n        this.last_cycle_write = this.clock.cpu_master_clock;\r\n\r\n        this.io.shift_pos++;\r\n        if (this.io.shift_pos === 5) {\r\n            addr &= 0xE000;\r\n            val = this.io.shift_value;\r\n            switch (addr) {\r\n                case 0x8000: // control register\r\n                    this.io.ctrl = this.io.shift_value;\r\n                    switch(val & 3) {\r\n                        case 0: this.ppu_mirror = NES_PPU_mirror_modes.ScreenAOnly; break;\r\n                        case 1: this.ppu_mirror = NES_PPU_mirror_modes.ScreenBOnly; break;\r\n                        case 2: this.ppu_mirror = NES_PPU_mirror_modes.Vertical; break;\r\n                        case 3: this.ppu_mirror = NES_PPU_mirror_modes.Horizontal; break;\r\n                    }\r\n                    this.set_mirroring();\r\n                    this.io.prg_bank_mode = (val >>> 2) & 3;\r\n                    this.io.chr_bank_mode = (val >>> 4) & 1;\r\n                    this.remap();\r\n                    break;\r\n                case 0xA000: // CHR bank 0x0000\r\n                    this.io.ppu_bank00 = this.io.shift_value;\r\n                    this.remap();\r\n                    break;\r\n                case 0xC000: // CHR bank 1\r\n                    this.io.ppu_bank10 = this.io.shift_value;\r\n                    this.remap();\r\n                    break;\r\n                case 0xE000: // PRG bank\r\n                    this.io.bank = this.io.shift_value & 0x0F;\r\n                    if (this.io.shift_value & 0x10) console.log('WARNING50!');\r\n                    this.remap();\r\n                    break;\r\n            }\r\n            this.io.shift_value = 0;\r\n            this.io.shift_pos = 0;\r\n        }\r\n    }\r\n\r\n    @inline CPU_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        if (addr < 0x2000)\r\n            return this.CPU_RAM[addr & 0x7FF];\r\n        if (addr < 0x4000)\r\n            return this.bus.PPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x6000) return val;\r\n        if (addr < 0x8000) {\r\n            if (this.has_prg_ram) return this.PRG_RAM[addr - 0x6000];\r\n            return val;\r\n        }\r\n        return this.PRG_map[(addr - 0x8000) >>> 14].read(addr);\r\n    }\r\n\r\n    reset(): void {\r\n        this.io.prg_bank_mode = 3;\r\n        this.remap(true);\r\n    }\r\n\r\n    set_CHR_ROM(addr: u32, bank_num: u32): void {\r\n        bank_num %= this.num_CHR_banks;\r\n        let b = (addr >>> 12);\r\n        this.CHR_map[b].addr = addr;\r\n        this.CHR_map[b].offset = (bank_num % this.num_CHR_banks) * 0x1000;\r\n    }\r\n\r\n    set_PRG_ROM(addr: u32, bank_num: u32): void {\r\n        bank_num %= this.num_PRG_banks;\r\n        let b = (addr - 0x8000) >>> 14;\r\n        this.PRG_map[b].addr = addr;\r\n        this.PRG_map[b].offset = (bank_num % this.num_PRG_banks) * 0x4000;\r\n    }\r\n\r\n    set_mirroring(): void {\r\n        switch(this.ppu_mirror) {\r\n            case NES_PPU_mirror_modes.Vertical:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_vertical;\r\n                return;\r\n            case NES_PPU_mirror_modes.Horizontal:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_horizontal;\r\n                return;\r\n            case NES_PPU_mirror_modes.FourWay:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_four;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenAOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Aonly;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenBOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Bonly;\r\n                return;\r\n        }\r\n    }\r\n\r\n    set_cart(cart: NES_cart): void {\r\n        this.CHR_ROM = new StaticArray<u8>(cart.CHR_ROM.byteLength);\r\n        for (let i: u32 = 0, k: u32 = cart.CHR_ROM.byteLength; i < k; i++) {\r\n            this.CHR_ROM[i] = cart.CHR_ROM[i];\r\n        }\r\n        this.PRG_ROM = new StaticArray<u8>(cart.PRG_ROM.byteLength);\r\n        for (let i: u32 = 0, k: u32 = cart.PRG_ROM.byteLength; i < k; i++) {\r\n            this.PRG_ROM[i] = cart.PRG_ROM[i];\r\n        }\r\n\r\n        this.prg_ram_size = cart.header.prg_ram_size;\r\n        console.log('MMC1 PRG RAM SIZE ' + cart.header.prg_ram_size.toString());\r\n        this.chr_ram_size = cart.header.chr_ram_size;\r\n        console.log('MMC1 CHR RAM SIZE ' + cart.header.chr_ram_size.toString());\r\n\r\n        this.PRG_RAM = new StaticArray<u8>(this.prg_ram_size);\r\n        this.has_prg_ram = this.prg_ram_size !== 0;\r\n\r\n        this.CHR_RAM = new StaticArray<u8>(this.chr_ram_size);\r\n        this.has_chr_ram = this.chr_ram_size !== 0;\r\n\r\n        this.ppu_mirror = cart.header.mirroring;\r\n        this.set_mirroring();\r\n        this.num_PRG_banks = (cart.PRG_ROM.byteLength / 16384);\r\n        this.num_CHR_banks = (cart.CHR_ROM.byteLength / 4096);\r\n        console.log('Num PRG banks ' + this.num_PRG_banks.toString());\r\n        console.log('Num CHR banks ' + this.num_CHR_banks.toString());\r\n        this.remap(true);\r\n    }\r\n}\r\n","import {\r\n    NES_a12_watcher_edge,\r\n    NES_a12_watcher_t,\r\n    NES_mapper, NES_mirror_ppu_Aonly, NES_mirror_ppu_Bonly, NES_mirror_ppu_four,\r\n    NES_mirror_ppu_horizontal,\r\n    NES_mirror_ppu_vertical, NES_PPU_mirror_modes\r\n} from \"./interface\";\r\nimport {NES_bus, NES_clock} from \"../nes_common\";\r\nimport {NES_cart} from \"../nes_cart\";\r\n\r\nexport class MMC3b_map {\r\n    addr: i32 = 0\r\n    offset: i32 = 0;\r\n    ROM: bool = false;\r\n    RAM: bool = false;\r\n    data: StaticArray<u8> = new StaticArray<u8>(0);\r\n\r\n    set(addr: i32, offset: i32, ROM: bool, RAM: bool): void {\r\n        this.addr = addr;\r\n        this.offset = offset;\r\n        this.ROM = ROM;\r\n        this.RAM = RAM;\r\n    }\r\n\r\n    @inline write(addr: u32, val: u32): void {\r\n        if (this.ROM) return;\r\n        this.data[(addr - this.addr) + this.offset] = <u8>val;\r\n    }\r\n\r\n    @inline read(addr: u32): u32 {\r\n        return this.data[(addr - this.addr) + this.offset];\r\n    }\r\n}\r\n\r\nclass NES_MMC3b_regs {\r\n    rC000: u32 = 0;\r\n    bank_select: u32 = 0;\r\n    bank: StaticArray<u32> = new StaticArray<u32>(8);\r\n}\r\n\r\nclass NES_MMC3b_status {\r\n    ROM_bank_mode: u32 = 0;\r\n    CHR_mode: u32 = 0;\r\n    PRG_mode: u32 = 0;\r\n}\r\n\r\n\r\nexport class NES_MMC3b implements NES_mapper {\r\n    clock: NES_clock\r\n    bus: NES_bus\r\n    a12_watcher: NES_a12_watcher_t\r\n    CHR_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    CHR_RAM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    PRG_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    CIRAM: StaticArray<u8> = new StaticArray<u8>(0x2000); // PPU RAM\r\n    CPU_RAM: StaticArray<u8> = new StaticArray<u8>(0x800); // CPU RAM\r\n    PRG_RAM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    prg_ram_size: u32 = 0\r\n    has_chr_ram: bool = false\r\n    regs: NES_MMC3b_regs = new NES_MMC3b_regs();\r\n    status: NES_MMC3b_status = new NES_MMC3b_status();\r\n\r\n    irq_enable: u32 = 0;\r\n    irq_counter: i32 = 0;\r\n    irq_reload: bool = false;\r\n\r\n    ppu_mirror: NES_PPU_mirror_modes = NES_PPU_mirror_modes.Horizontal;\r\n    PRG_map: StaticArray<MMC3b_map> = new StaticArray<MMC3b_map>(5);\r\n    CHR_map: StaticArray<MMC3b_map> = new StaticArray<MMC3b_map>(8);\r\n    num_PRG_banks: u32 = 0;\r\n    num_CHR_banks: u32 = 0;\r\n    mirror_ppu_addr: (addr: u32) => u32 = NES_mirror_ppu_horizontal;\r\n\r\n    constructor(clock: NES_clock, bus: NES_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n        this.a12_watcher = new NES_a12_watcher_t(clock);\r\n        for (let i = 0; i < this.PRG_map.length; i++) {\r\n            this.PRG_map[i] = new MMC3b_map();\r\n        }\r\n        for (let i = 0; i < this.CHR_map.length; i++) {\r\n            this.CHR_map[i] = new MMC3b_map();\r\n        }\r\n    }\r\n\r\n    // MMC3 no cycle counter\r\n    @inline cycle(howmany: u32) : void {}\r\n\r\n    @inline a12_watch(addr: u32): void {\r\n        if (this.a12_watcher.update(addr) === NES_a12_watcher_edge.rise) {\r\n            if ((this.irq_counter === 0) || this.irq_reload)\r\n                this.irq_counter = <i32>this.regs.rC000;\r\n            else {\r\n                this.irq_counter--;\r\n                if (this.irq_counter < 0) this.irq_counter = 0;\r\n            }\r\n\r\n            if ((this.irq_counter === 0) && this.irq_enable)\r\n                this.bus.CPU_notify_IRQ(1);\r\n            this.irq_reload = false;\r\n        }\r\n    }\r\n\r\n    set_PRG_ROM(addr: u32, bank_num: u32): void {\r\n        let b: u32 = (addr - 0x6000) >>> 13;\r\n        this.PRG_map[b].addr = <i32>addr;\r\n        this.PRG_map[b].offset = (bank_num % this.num_PRG_banks) * 0x2000;\r\n    }\r\n\r\n    set_CHR_ROM_1k(b: u32, bank_num: u32): void {\r\n        this.CHR_map[b].offset = (bank_num % this.num_CHR_banks) * 0x0400;\r\n    }\r\n\r\n    remap(boot: bool = false): void {\r\n        if (boot) {\r\n            for (let i: u32 = 0; i < 5; i++) {\r\n                this.PRG_map[i].data = this.PRG_ROM;\r\n                this.PRG_map[i].ROM = true;\r\n                this.PRG_map[i].RAM = false;\r\n            }\r\n            for (let i: u32 = 0; i < 8; i++) {\r\n                this.CHR_map[i].data = this.CHR_ROM;\r\n                this.CHR_map[i].addr = 0x400 * i;\r\n                this.CHR_map[i].ROM = true;\r\n                this.CHR_map[i].RAM = false;\r\n            }\r\n            if (this.PRG_RAM.length > 0) {\r\n                this.PRG_map[0].set(0x6000, 0, false, true);\r\n                this.PRG_map[0].data = this.PRG_RAM;\r\n                this.PRG_map[0].RAM = true;\r\n                this.PRG_map[0].ROM = false;\r\n            }\r\n            this.set_PRG_ROM(0xE000, this.num_PRG_banks-1);\r\n        }\r\n\r\n        if (this.status.PRG_mode === 0) {\r\n            // 0 = 8000-9FFF swappable,\r\n            //     C000-DFFF fixed to second-last bank\r\n            // 1 = 8000-9FFF fixed to second-last bank\r\n            //     C000-DFFF swappable\r\n            this.set_PRG_ROM(0x8000, this.regs.bank[6]);\r\n            this.set_PRG_ROM(0xC000, this.num_PRG_banks-2);\r\n        }\r\n        else {\r\n            this.set_PRG_ROM(0x8000, this.num_PRG_banks-2);\r\n            this.set_PRG_ROM(0xC000, this.regs.bank[6]);\r\n        }\r\n        this.set_PRG_ROM(0xA000, this.regs.bank[7]);\r\n\r\n        if (this.status.CHR_mode === 0) {\r\n            // 2KB CHR banks 0, 1KB CHR banks at 1000\r\n            this.set_CHR_ROM_1k(0, this.regs.bank[0] & 0xFE);\r\n            this.set_CHR_ROM_1k(1, this.regs.bank[0] | 0x01);\r\n            this.set_CHR_ROM_1k(2, this.regs.bank[1] & 0xFE);\r\n            this.set_CHR_ROM_1k(3, this.regs.bank[1] | 0x01);\r\n            this.set_CHR_ROM_1k(4, this.regs.bank[2]);\r\n            this.set_CHR_ROM_1k(5, this.regs.bank[3]);\r\n            this.set_CHR_ROM_1k(6, this.regs.bank[4]);\r\n            this.set_CHR_ROM_1k(7, this.regs.bank[5]);\r\n        }\r\n        else {\r\n            // 1KB CHR banks at 0, 2KB CHR banks at 1000\r\n            this.set_CHR_ROM_1k(0, this.regs.bank[2]);\r\n            this.set_CHR_ROM_1k(1, this.regs.bank[3]);\r\n            this.set_CHR_ROM_1k(2, this.regs.bank[4]);\r\n            this.set_CHR_ROM_1k(3, this.regs.bank[5]);\r\n            this.set_CHR_ROM_1k(4, this.regs.bank[0] & 0xFE);\r\n            this.set_CHR_ROM_1k(5, this.regs.bank[0] | 0x01);\r\n            this.set_CHR_ROM_1k(6, this.regs.bank[1] & 0xFE);\r\n            this.set_CHR_ROM_1k(7, this.regs.bank[1] | 0x01);\r\n        }\r\n    }\r\n\r\n    @inline CPU_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        if (addr < 0x2000)\r\n            return this.CPU_RAM[addr & 0x7FF];\r\n        if (addr < 0x4000)\r\n            return this.bus.PPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_read(addr, val, has_effect);\r\n        if (addr >= 0x6000)\r\n            return this.PRG_map[(addr - 0x6000) >>> 13].read(addr);\r\n        return val;\r\n    }\r\n\r\n    @inline CPU_write(addr: u32, val: u32): void {\r\n        if (addr < 0x2000) {\r\n            this.CPU_RAM[addr & 0x7FF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0x4000)\r\n            return this.bus.PPU_reg_write(addr, val);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_write(addr, val);\r\n\r\n        if (addr < 0x6000) return;\r\n\r\n        if (addr < 0x8000)\r\n            return this.PRG_map[(addr - 0x6000) >>> 13].write(addr, val);\r\n\r\n        switch(addr & 0xE001) {\r\n            case 0x8000:\r\n                this.regs.bank_select = val & 7;\r\n                this.status.PRG_mode = (val & 0x40) >>> 6;\r\n                this.status.CHR_mode = (val & 0x80) >>> 7;\r\n                return;\r\n            case 0x8001: // Bank data\r\n                this.regs.bank[this.regs.bank_select] = val;\r\n                this.remap();\r\n                break;\r\n            case 0xA000:\r\n                this.ppu_mirror = (val & 1) ? NES_PPU_mirror_modes.Horizontal : NES_PPU_mirror_modes.Vertical;\r\n                this.set_mirroring();\r\n                break;\r\n            case 0xA001:\r\n                break;\r\n            case 0xC000:\r\n                this.regs.rC000 = val;\r\n                break;\r\n            case 0xC001:\r\n                this.irq_counter = 0;\r\n                this.irq_reload = true;\r\n                break;\r\n            case 0xE000:\r\n                this.irq_enable = 0;\r\n                break;\r\n            case 0xE001:\r\n                this.irq_enable = 1;\r\n                break;\r\n        }\r\n    }\r\n\r\n    @inline PPU_read_effect(addr: u32): u32 {\r\n        this.a12_watch(addr);\r\n        if (addr < 0x2000) {\r\n            if (this.has_chr_ram) return this.CHR_RAM[addr];\r\n            return this.CHR_map[addr >>> 10].read(addr);\r\n        }\r\n\r\n        return this.CIRAM[this.mirror_ppu_addr(addr)];\r\n    }\r\n\r\n    PPU_read_noeffect(addr: u32): u32 {\r\n        if (addr < 0x2000) {\r\n            if (this.has_chr_ram) return this.CHR_RAM[addr];\r\n            return this.CHR_map[addr >>> 10].read(addr);\r\n        }\r\n\r\n        return this.CIRAM[this.mirror_ppu_addr(addr)];\r\n    }\r\n\r\n    @inline PPU_write(addr: u32, val: u32): void {\r\n        this.a12_watch(addr);\r\n        if (addr < 0x2000) {\r\n            if (this.has_chr_ram) this.CHR_RAM[addr] = <u8>val\r\n            return;\r\n        }\r\n        this.CIRAM[this.mirror_ppu_addr(addr)] = <u8>val;\r\n    }\r\n\r\n    reset(): void {\r\n        this.remap(true);\r\n    }\r\n\r\n    set_mirroring(): void {\r\n        switch(this.ppu_mirror) {\r\n            case NES_PPU_mirror_modes.Vertical:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_vertical;\r\n                return;\r\n            case NES_PPU_mirror_modes.Horizontal:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_horizontal;\r\n                return;\r\n            case NES_PPU_mirror_modes.FourWay:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_four;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenAOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Aonly;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenBOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Bonly;\r\n                return;\r\n        }\r\n    }\r\n\r\n    set_cart(cart: NES_cart): void {\r\n        this.CHR_ROM = new StaticArray<u8>(cart.CHR_ROM.byteLength);\r\n        for (let i: u32 = 0, k: u32 = cart.CHR_ROM.byteLength; i < k; i++) {\r\n            this.CHR_ROM[i] = cart.CHR_ROM[i];\r\n        }\r\n        this.PRG_ROM = new StaticArray<u8>(cart.PRG_ROM.byteLength);\r\n        for (let i: u32 = 0, k: u32 = cart.PRG_ROM.byteLength; i < k; i++) {\r\n            this.PRG_ROM[i] = cart.PRG_ROM[i];\r\n        }\r\n\r\n        this.prg_ram_size = cart.header.prg_ram_size;\r\n        console.log('MMC3 PRG RAM SIZE ' + cart.header.prg_ram_size.toString());\r\n        this.PRG_RAM = new StaticArray<u8>(this.prg_ram_size);\r\n\r\n        this.CHR_RAM = new StaticArray<u8>(cart.header.chr_ram_size);\r\n        this.has_chr_ram = cart.header.chr_ram_size > 0;\r\n\r\n        this.ppu_mirror = cart.header.mirroring;\r\n        if (cart.header.four_screen_mode === 1) this.ppu_mirror = NES_PPU_mirror_modes.FourWay;\r\n        this.set_mirroring();\r\n\r\n        this.num_PRG_banks = cart.PRG_ROM.byteLength / 8192;\r\n        this.num_CHR_banks = cart.CHR_ROM.byteLength / 1024;\r\n        console.log('NUM CHR BANKS ' + this.num_CHR_banks.toString());\r\n        console.log('PPU MIRROR MODE ' + this.ppu_mirror.toString());\r\n        this.remap(true);\r\n    }\r\n}\r\n","import {\r\n    NES_mapper, NES_mirror_ppu_Aonly, NES_mirror_ppu_Bonly,\r\n    NES_mirror_ppu_four,\r\n    NES_mirror_ppu_horizontal,\r\n    NES_mirror_ppu_vertical,\r\n    NES_PPU_mirror_modes\r\n} from \"./interface\";\r\nimport {NES_cart} from \"../nes_cart\";\r\nimport {NES_bus, NES_clock} from \"../nes_common\";\r\n\r\nexport class NES_mapper_UXROM implements NES_mapper {\r\n    clock: NES_clock\r\n    bus: NES_bus\r\n    CHR_RAM: StaticArray<u8> = new StaticArray<u8>(0x2000);\r\n    PRG_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    CIRAM: StaticArray<u8> = new StaticArray<u8>(0x2000); // PPU RAM\r\n    CPU_RAM: StaticArray<u8> = new StaticArray<u8>(0x800); // CPU RAM\r\n\r\n    ppu_mirror: NES_PPU_mirror_modes = NES_PPU_mirror_modes.Horizontal;\r\n    mirror_ppu_addr: (addr: u32) => u32 = NES_mirror_ppu_horizontal;\r\n\r\n    num_PRG_banks: u32 = 0;\r\n    PRG_ROM_size: u32 = 0;\r\n    prg_bank_offset: u32 = 0;\r\n    last_bank_offset: u32 = 0;\r\n\r\n    is_unrom: u32 = 0;\r\n    is_uorom: u32 = 0;\r\n\r\n    constructor(clock: NES_clock, bus: NES_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n    }\r\n\r\n    @inline cycle(howmany: u32): void {}\r\n\r\n    @inline a12_watch(addr: u32): void {}\r\n\r\n    @inline PPU_read_effect(addr: u32): u32 {\r\n        if (addr < 0x2000) return this.CHR_RAM[addr];\r\n        return this.CIRAM[this.mirror_ppu_addr(addr)];\r\n    }\r\n\r\n    PPU_read_noeffect(addr: u32): u32 {\r\n        return this.PPU_read_effect(addr);\r\n    }\r\n\r\n    @inline PPU_write(addr: u32, val: u32): void {\r\n        if (addr < 0x2000) this.CHR_RAM[addr] = <u8>val;\r\n        else this.CIRAM[this.mirror_ppu_addr(addr)] = <u8>val;\r\n    }\r\n\r\n    @inline CPU_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        addr &= 0xFFFF;\r\n        if (addr < 0x2000)\r\n            return this.CPU_RAM[addr & 0x7FF];\r\n        if (addr < 0x3FFF)\r\n            return this.bus.PPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x8000) return val;\r\n        if (addr < 0xC000) return this.PRG_ROM[(addr - 0x8000) + this.prg_bank_offset];\r\n        return this.PRG_ROM[(addr - 0xC000) + this.last_bank_offset];\r\n    }\r\n\r\n    @inline CPU_write(addr: u32, val: u32): void {\r\n        addr &= 0xFFFF;\r\n        if (addr < 0x2000) {\r\n            this.CPU_RAM[addr & 0x7FF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0x3FFF)\r\n            return this.bus.PPU_reg_write(addr, val);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_write(addr, val);\r\n\r\n        if (addr < 0x8000) return;\r\n        if (this.is_unrom)\r\n            val &= 7;\r\n        if (this.is_uorom)\r\n            val &= 15;\r\n        this.prg_bank_offset = 16384 * (val % this.num_PRG_banks);\r\n    }\r\n\r\n    reset(): void {\r\n        this.prg_bank_offset = 0;\r\n    }\r\n\r\n    set_mirroring(): void {\r\n        switch(this.ppu_mirror) {\r\n            case NES_PPU_mirror_modes.Vertical:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_vertical;\r\n                return;\r\n            case NES_PPU_mirror_modes.Horizontal:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_horizontal;\r\n                return;\r\n            case NES_PPU_mirror_modes.FourWay:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_four;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenAOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Aonly;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenBOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Bonly;\r\n                return;\r\n        }\r\n    }\r\n\r\n\r\n    set_cart(cart: NES_cart): void {\r\n        this.PRG_ROM = new StaticArray<u8>(cart.PRG_ROM.byteLength);\r\n        for (let i = 0, k = cart.PRG_ROM.byteLength; i < k; i++) {\r\n            this.PRG_ROM[i] = cart.PRG_ROM[i];\r\n        }\r\n        this.PRG_ROM_size = cart.header.prg_rom_size;\r\n        this.num_PRG_banks = cart.header.prg_rom_size / 16384;\r\n\r\n        this.ppu_mirror = cart.header.mirroring;\r\n        this.set_mirroring();\r\n\r\n        this.prg_bank_offset = 0;\r\n        this.last_bank_offset = (this.num_PRG_banks - 1) * 16384;\r\n    }\r\n}","import {\r\n    NES_mapper, NES_mirror_ppu_Aonly, NES_mirror_ppu_Bonly,\r\n    NES_mirror_ppu_four,\r\n    NES_mirror_ppu_horizontal,\r\n    NES_mirror_ppu_vertical,\r\n    NES_PPU_mirror_modes\r\n} from \"./interface\";\r\nimport {NES_cart} from \"../nes_cart\";\r\nimport {NES_bus, NES_clock} from \"../nes_common\";\r\n\r\nexport class NES_mapper_CXROM implements NES_mapper {\r\n    clock: NES_clock\r\n    bus: NES_bus\r\n    CHR_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    PRG_ROM: StaticArray<u8> = new StaticArray<u8>(0x8000);\r\n    CIRAM: StaticArray<u8> = new StaticArray<u8>(0x2000); // PPU RAM\r\n    CPU_RAM: StaticArray<u8> = new StaticArray<u8>(0x800); // CPU RAM\r\n\r\n    ppu_mirror: NES_PPU_mirror_modes = NES_PPU_mirror_modes.Horizontal;\r\n    mirror_ppu_addr: (addr: u32) => u32 = NES_mirror_ppu_horizontal;\r\n    num_CHR_banks: u32 = 0;\r\n    PRG_ROM_size: u32 = 0;\r\n    PRG_ROM_mask: u32 = 0\r\n    chr_bank_offset: u32 = 0;\r\n\r\n    is_cnrom: u32 = 0;\r\n\r\n    constructor(clock: NES_clock, bus: NES_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n    }\r\n\r\n    @inline cycle(howmany: u32): void {}\r\n\r\n    @inline a12_watch(addr: u32): void {}\r\n\r\n    @inline PPU_read_effect(addr: u32): u32 {\r\n        if (addr < 0x2000) return this.CHR_ROM[addr + this.chr_bank_offset];\r\n        return this.CIRAM[this.mirror_ppu_addr(addr)];\r\n    }\r\n\r\n    PPU_read_noeffect(addr: u32): u32 {\r\n        return this.PPU_read_effect(addr);\r\n    }\r\n\r\n    @inline PPU_write(addr: u32, val: u32): void {\r\n        if (addr < 0x2000) return;\r\n        this.CIRAM[this.mirror_ppu_addr(addr)] = <u8>val;\r\n    }\r\n\r\n    @inline CPU_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        addr &= 0xFFFF;\r\n        if (addr < 0x2000)\r\n            return this.CPU_RAM[addr & 0x7FF];\r\n        if (addr < 0x3FFF)\r\n            return this.bus.PPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x8000) return val;\r\n        return this.PRG_ROM[(addr - 0x8000) & this.PRG_ROM_mask];\r\n    }\r\n\r\n    @inline CPU_write(addr: u32, val: u32): void {\r\n        addr &= 0xFFFF;\r\n        if (addr < 0x2000) {\r\n            this.CPU_RAM[addr & 0x7FF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0x3FFF)\r\n            return this.bus.PPU_reg_write(addr, val);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_write(addr, val);\r\n\r\n        if (addr < 0x8000) return;\r\n        if (this.is_cnrom) val &= 3;\r\n        else val &= 7;\r\n        this.chr_bank_offset = (val % this.num_CHR_banks) * 8192;\r\n    }\r\n\r\n    reset(): void {\r\n        this.chr_bank_offset = 0;\r\n    }\r\n\r\n    set_mirroring(): void {\r\n        switch(this.ppu_mirror) {\r\n            case NES_PPU_mirror_modes.Vertical:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_vertical;\r\n                return;\r\n            case NES_PPU_mirror_modes.Horizontal:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_horizontal;\r\n                return;\r\n            case NES_PPU_mirror_modes.FourWay:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_four;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenAOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Aonly;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenBOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Bonly;\r\n                return;\r\n        }\r\n    }\r\n\r\n    set_cart(cart: NES_cart): void {\r\n        this.CHR_ROM = new StaticArray<u8>(cart.CHR_ROM.byteLength);\r\n        for (let i: u32 = 0, k: u32 = cart.CHR_ROM.byteLength; i < k; i++) {\r\n            this.CHR_ROM[i] = cart.CHR_ROM[i];\r\n        }\r\n        this.PRG_ROM = new StaticArray<u8>(cart.PRG_ROM.byteLength);\r\n        for (let i = 0, k = cart.PRG_ROM.byteLength; i < k; i++) {\r\n            this.PRG_ROM[i] = cart.PRG_ROM[i];\r\n        }\r\n        if (cart.PRG_ROM.byteLength === 16384) this.PRG_ROM_mask = 0x3FFF;\r\n        else this.PRG_ROM_mask = 0x7FFF;\r\n\r\n        this.num_CHR_banks = cart.header.chr_rom_size / 8192;\r\n\r\n        this.ppu_mirror = cart.header.mirroring;\r\n        this.set_mirroring();\r\n        this.chr_bank_offset = 0;\r\n    }\r\n}","import {\r\n    NES_mapper,\r\n    NES_mirror_ppu_Aonly, NES_mirror_ppu_Bonly, NES_mirror_ppu_four,\r\n    NES_mirror_ppu_horizontal,\r\n    NES_mirror_ppu_vertical,\r\n    NES_PPU_mirror_modes\r\n} from \"./interface\";\r\nimport {NES_cart} from \"../nes_cart\";\r\nimport {NES_bus, NES_clock} from \"../nes_common\";\r\n\r\nexport class NES_mapper_AXROM implements NES_mapper {\r\n    clock: NES_clock\r\n    bus: NES_bus\r\n    PRG_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    CHR_RAM: StaticArray<u8> = new StaticArray<u8>(0x2000);\r\n    CIRAM: StaticArray<u8> = new StaticArray<u8>(0x800); // PPU RAM\r\n    CPU_RAM: StaticArray<u8> = new StaticArray<u8>(0x800); // CPU RAM\r\n\r\n    ppu_mirror: NES_PPU_mirror_modes = NES_PPU_mirror_modes.ScreenAOnly;\r\n    mirror_ppu_addr: (addr: u32) => u32 = NES_mirror_ppu_Aonly;\r\n    num_PRG_banks: u32 = 0;\r\n    prg_bank_offset: u32 = 0;\r\n\r\n    constructor(clock: NES_clock, bus: NES_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n    }\r\n\r\n    @inline cycle(howmany: u32): void {}\r\n\r\n    @inline a12_watch(addr: u32): void {}\r\n\r\n    @inline PPU_read_effect(addr: u32): u32 {\r\n        if (addr < 0x2000) return this.CHR_RAM[addr];\r\n        return this.CIRAM[this.mirror_ppu_addr(addr)];\r\n    }\r\n\r\n    PPU_read_noeffect(addr: u32): u32 {\r\n        return this.PPU_read_effect(addr);\r\n    }\r\n\r\n    PPU_write(addr: u32, val: u32): void {\r\n        if (addr < 0x2000) this.CHR_RAM[addr] = <u8>val;\r\n        else this.CIRAM[this.mirror_ppu_addr(addr)] = <u8>val;\r\n    }\r\n\r\n    @inline CPU_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        addr &= 0xFFFF;\r\n        if (addr < 0x2000)\r\n            return this.CPU_RAM[addr & 0x7FF];\r\n        if (addr < 0x3FFF)\r\n            return this.bus.PPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x8000) return val;\r\n        return this.PRG_ROM[(addr - 0x8000) + this.prg_bank_offset];\r\n    }\r\n\r\n    @inline CPU_write(addr: u32, val: u32): void {\r\n        addr &= 0xFFFF;\r\n        if (addr < 0x2000) {\r\n            this.CPU_RAM[addr & 0x7FF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0x3FFF)\r\n            return this.bus.PPU_reg_write(addr, val);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_write(addr, val);\r\n\r\n        if (addr < 0x8000) return;\r\n\r\n        this.prg_bank_offset = ((val & 15) % this.num_PRG_banks) * 32768;\r\n        this.ppu_mirror = (val & 0x10) ? NES_PPU_mirror_modes.ScreenBOnly : NES_PPU_mirror_modes.ScreenAOnly;\r\n        this.set_mirroring();\r\n    }\r\n\r\n    reset(): void {\r\n        this.prg_bank_offset = (this.num_PRG_banks - 1) * 32768;\r\n    }\r\n\r\n    set_mirroring(): void {\r\n        switch(this.ppu_mirror) {\r\n            case NES_PPU_mirror_modes.Vertical:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_vertical;\r\n                return;\r\n            case NES_PPU_mirror_modes.Horizontal:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_horizontal;\r\n                return;\r\n            case NES_PPU_mirror_modes.FourWay:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_four;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenAOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Aonly;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenBOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Bonly;\r\n                return;\r\n        }\r\n    }\r\n\r\n    set_cart(cart: NES_cart): void {\r\n        this.PRG_ROM = new StaticArray<u8>(cart.PRG_ROM.byteLength);\r\n        for (let i = 0, k = cart.PRG_ROM.byteLength; i < k; i++) {\r\n            this.PRG_ROM[i] = cart.PRG_ROM[i];\r\n        }\r\n        this.num_PRG_banks = cart.header.prg_rom_size / 32768;\r\n\r\n        this.ppu_mirror = cart.header.mirroring;\r\n        this.set_mirroring();\r\n\r\n        this.prg_bank_offset = 0;\r\n    }\r\n}","import {\r\n    NES_mapper,\r\n    NES_mirror_ppu_Aonly,\r\n    NES_mirror_ppu_Bonly,\r\n    NES_mirror_ppu_four,\r\n    NES_mirror_ppu_horizontal,\r\n    NES_mirror_ppu_vertical,\r\n    NES_PPU_mirror_modes\r\n} from \"./interface\";\r\nimport {NES_bus, NES_clock} from \"../nes_common\";\r\nimport {MMC3b_map} from \"./mmc3b\";\r\nimport {NES_cart} from \"../nes_cart\";\r\n\r\n\r\n// @ts-ignore\r\n@inline function mess_up_addr(addr: u32): u32 {\r\n    // Thanks Mesen! NESdev is not correct!\r\n    let A0: u32 = addr & 0x01;\r\n    let A1: u32 = (addr >>> 1) & 0x01;\r\n\r\n    //VRC4e\r\n    A0 |= (addr >> 2) & 0x01;\r\n    A1 |= (addr >> 3) & 0x01;\r\n    return (addr & 0xFF00) | (A1 << 1) | A0;\r\n}\r\n\r\nexport class NES_VRC_IRQ {\r\n    cycle_mode: u32 = 0\r\n    enable: u32 = 0\r\n    enable_after_ack: u32 = 0\r\n    reload: i32 = 0\r\n    prescaler: i32 = 341\r\n    counter: i32 = 0\r\n    bus: NES_bus\r\n\r\n    constructor(bus: NES_bus) {\r\n        this.bus = bus;\r\n    }\r\n\r\n    @inline cycle(): void {\r\n        if (this.enable) {\r\n            this.prescaler -= 3;\r\n            if (this.cycle_mode || ((this.prescaler <= 0) && !this.cycle_mode)) {\r\n                if (this.counter === 0xFF) {\r\n                    this.counter = this.reload;\r\n                    this.bus.CPU_notify_IRQ(1);\r\n                } else {\r\n                    this.counter++;\r\n                }\r\n                this.prescaler += 341;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass mapper_io {\r\n    wram_enabled: u32 = 0\r\n    latch60: u32 = 0\r\n    vrc4_banks_swapped: u32 = 0\r\n    ppu_banks: StaticArray<u32> = new StaticArray<u32>(8);\r\n    cpu_bank80: u32 = 0;\r\n    cpu_banka0: u32 = 0;\r\n}\r\n\r\nexport class NES_mapper_VRC2B_4E_4F implements NES_mapper {\r\n    clock: NES_clock\r\n    bus: NES_bus\r\n    CHR_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    PRG_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    CIRAM: StaticArray<u8> = new StaticArray<u8>(0x2000); // PPU RAM\r\n    CPU_RAM: StaticArray<u8> = new StaticArray<u8>(0x800); // CPU RAM\r\n    PRG_RAM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    prg_ram_size: u32 = 0;\r\n\r\n    PRG_map: StaticArray<MMC3b_map> = new StaticArray<MMC3b_map>(8);\r\n    CHR_map: StaticArray<MMC3b_map> = new StaticArray<MMC3b_map>(8);\r\n\r\n    num_CHR_banks: u32 = 0\r\n    num_PRG_banks: u32 = 0\r\n\r\n    is_vrc4: bool = false\r\n    ppu_mirror: NES_PPU_mirror_modes = NES_PPU_mirror_modes.Horizontal;\r\n    mirror_ppu_addr: (addr: u32) => u32 = NES_mirror_ppu_horizontal;\r\n    is_vrc2a: bool = false\r\n\r\n    irq: NES_VRC_IRQ\r\n    io: mapper_io = new mapper_io();\r\n\r\n    constructor(clock: NES_clock, bus: NES_bus, is_vrc4: bool = false) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n        this.is_vrc4 = is_vrc4;\r\n\r\n        this.irq = new NES_VRC_IRQ(bus);\r\n\r\n        for (let i: u32 = 0; i < 8; i++) {\r\n            this.PRG_map[i] = new MMC3b_map();\r\n            this.CHR_map[i] = new MMC3b_map();\r\n        }\r\n    }\r\n\r\n    @inline cycle(howmany: u32): void {\r\n        if (!this.is_vrc4) return;\r\n        this.irq.cycle();\r\n    }\r\n\r\n    @inline a12_watch(addr: u32): void {}\r\n\r\n\r\n    set_CHR_ROM_1k(b: u32, bank_num: u32): void {\r\n        this.CHR_map[b].offset = (bank_num % this.num_CHR_banks) * 0x0400;\r\n    }\r\n\r\n    set_PRG_ROM(addr: u32, bank_num: u32): void {\r\n        let b = addr >>> 13;\r\n        this.PRG_map[b].addr = addr;\r\n        this.PRG_map[b].offset = (bank_num % this.num_PRG_banks) * 0x2000;\r\n    }\r\n\r\n    @inline PPU_read_effect(addr: u32): u32 {\r\n        if (addr < 0x2000){\r\n            const b = this.CHR_map[addr >>> 10];\r\n            return b.data[(addr - b.addr) + b.offset];\r\n        }\r\n        return this.CIRAM[this.mirror_ppu_addr(addr)];\r\n    }\r\n\r\n    PPU_read_noeffect(addr: u32): u32 {\r\n        return this.PPU_read_effect(addr);\r\n    }\r\n\r\n    PPU_write(addr: u32, val: u32): void {\r\n        if (addr < 0x2000) return;\r\n        this.CIRAM[this.mirror_ppu_addr(addr)] = <u8>val;\r\n    }\r\n\r\n    set_ppu_lo(bank: u32, val: u32): void {\r\n        let b: u32 = this.io.ppu_banks[bank];\r\n        if (this.is_vrc2a) b <<= 1;\r\n\r\n        b = (b & 0x1F0) | (val & 0x0F);\r\n\r\n        if (this.is_vrc2a) b >>>= 1;\r\n        this.io.ppu_banks[bank] = b;\r\n        this.remap();\r\n    }\r\n\r\n    set_ppu_hi(bank: u32, val: u32): void {\r\n        let b = this.io.ppu_banks[bank];\r\n        if (this.is_vrc2a) b <<= 1;\r\n        if (this.is_vrc4) val = (val & 0x1F) << 4;\r\n        else val = (val & 0x0F) << 4;\r\n        b = (b & 0x0F) | val;\r\n        if (this.is_vrc2a) b >>>= 1;\r\n        this.io.ppu_banks[bank] = b;\r\n        this.remap();\r\n    }\r\n\r\n    @inline CPU_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        // Conventional RAM addr\r\n        if (addr < 0x2000)\r\n            return this.CPU_RAM[addr & 0x7FF];\r\n        if (addr < 0x4000)\r\n            return this.bus.PPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_read(addr, val, has_effect);\r\n        // VRC mapping\r\n        if (addr < 0x6000) return val;\r\n        if (addr < 0x8000) {\r\n            if (this.io.wram_enabled) return this.PRG_RAM[addr - 0x6000];\r\n            // HMMMM....\r\n            if (!this.is_vrc4) return (val & 0xFE) | this.io.latch60;\r\n        }\r\n        return this.PRG_map[addr >>> 13].read(addr);\r\n    }\r\n\r\n    CPU_write(addr: u32, val: u32): void {\r\n        // Conventional CPU map\r\n        if (addr < 0x2000) { // 0x0000-0x1FFF 4 mirrors of 2KB banks\r\n            this.CPU_RAM[addr & 0x7FF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0x4000) // 0x2000-0x3FFF mirrored PPU registers\r\n            return this.bus.PPU_reg_write(addr, val);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_write(addr, val);\r\n        if (addr < 0x6000) return;\r\n        if (addr < 0x8000) {\r\n            if (this.io.wram_enabled) {\r\n                this.PRG_RAM[addr - 0x6000] = <u8>val;\r\n            }\r\n            else if (!this.is_vrc4) {\r\n                this.io.latch60 = val & 1;\r\n            }\r\n            return;\r\n        }\r\n\r\n        addr = mess_up_addr(addr) & 0xF00F;\r\n        switch(addr) {\r\n            case 0x8000:\r\n            case 0x8001:\r\n            case 0x8002:\r\n            case 0x8003:\r\n            case 0x8004:\r\n            case 0x8005:\r\n            case 0x8006:\r\n                this.io.cpu_bank80 = val & 0x1F;\r\n                this.remap();\r\n                return;\r\n            case 0x9000:\r\n            case 0x9001:\r\n            case 0x9002:\r\n            case 0x9003:\r\n            case 0x9004:\r\n            case 0x9005:\r\n            case 0x9006:\r\n                if (this.is_vrc4 && (addr === 0x9002)) {\r\n                    console.log('a1');\r\n                    // wram control\r\n                    this.io.wram_enabled = (val & 1);\r\n                    // swap mode\r\n                    this.io.vrc4_banks_swapped = (val & 2) >>> 1;\r\n                }\r\n                if (this.is_vrc4 && (addr === 0x9003)) {\r\n                    console.log('a2');\r\n                    return;\r\n                }\r\n\r\n                if (this.is_vrc4) val &= 3;\r\n                else val &= 1;\r\n                // 0 vertical 1 horizontal 2 a 3 b\r\n\r\n                switch(val) {\r\n                    case 0: this.ppu_mirror = NES_PPU_mirror_modes.Vertical; break;\r\n                    case 1: this.ppu_mirror = NES_PPU_mirror_modes.Horizontal; break;\r\n                    case 2: this.ppu_mirror = NES_PPU_mirror_modes.ScreenAOnly; break;\r\n                    case 3: this.ppu_mirror = NES_PPU_mirror_modes.ScreenBOnly; break;\r\n                }\r\n                this.set_mirroring();\r\n                return;\r\n            case 0xA000:\r\n            case 0xA001:\r\n            case 0xA002:\r\n            case 0xA003:\r\n            case 0xA004:\r\n            case 0xA005:\r\n            case 0xA006:\r\n                this.io.cpu_banka0 = val & 0x1F;\r\n                this.remap();\r\n                return;\r\n            case 0xF000: // IRQ latch low 4\r\n                if (!this.is_vrc4) return;\r\n                this.irq.reload = (this.irq.reload & 0xF0) | (val & 0x0F);\r\n                return;\r\n            case 0xF001: // IRQ latch hi 4\r\n                if (!this.is_vrc4) return;\r\n                this.irq.reload = (this.irq.reload & 0x0F) | ((val & 0x0F) << 4);\r\n                return;\r\n            case 0xF002: // IRQ control\r\n                if (!this.is_vrc4) return;\r\n                this.irq.prescaler = 341;\r\n                if (val & 2) this.irq.counter = this.irq.reload;\r\n                this.irq.cycle_mode = (val & 4) >>> 2;\r\n                this.irq.enable = (val & 2) >>> 1;\r\n                this.irq.enable_after_ack = (val & 1);\r\n                return;\r\n            case 0xF003: // IRQ ack\r\n                if (!this.is_vrc4) return;\r\n                this.irq.enable = this.irq.enable_after_ack;\r\n                return;\r\n        }\r\n        // Thanks Messen! NESdev wiki was wrong here...\r\n        if ((addr >= 0xB000) && (addr <= 0xE006)) {\r\n            let rn = ((((addr >>> 12) & 0x07) - 3) << 1) + ((addr >>> 1) & 0x01);\r\n            let lowBits = (addr & 0x01) === 0;\r\n            if (lowBits) {\r\n                //The other reg contains the low 4 bits\r\n                this.set_ppu_lo(rn, val)\r\n            } else {\r\n                //One reg contains the high 5 bits\r\n                this.set_ppu_hi(rn, val);\r\n            }\r\n        }\r\n    }\r\n\r\n    reset(): void {\r\n        this.remap(true);\r\n    }\r\n\r\n    remap(boot: bool = false): void {\r\n        if (boot) {\r\n            this.io.vrc4_banks_swapped = 0;\r\n            for (let i: u32 = 0; i < 8; i++) {\r\n                this.PRG_map[i].data = this.PRG_ROM;\r\n                this.PRG_map[i].addr = 0x2000 * i;\r\n                this.PRG_map[i].ROM = true;\r\n                this.PRG_map[i].RAM = false;\r\n\r\n                this.CHR_map[i].data = this.CHR_ROM;\r\n                this.CHR_map[i].addr = 0x400 * i;\r\n                this.CHR_map[i].ROM = true;\r\n                this.CHR_map[i].RAM = false;\r\n            }\r\n\r\n            this.PRG_map[0x6000 >>> 13].ROM = false;\r\n            this.PRG_map[0x6000 >>> 13].RAM = true;\r\n            this.PRG_map[0x6000 >>> 13].offset = 0;\r\n            this.PRG_map[0x6000 >>> 13].data = this.PRG_RAM;\r\n            this.set_PRG_ROM(0xE000, this.num_PRG_banks - 1);\r\n        }\r\n\r\n        if (this.is_vrc4 && this.io.vrc4_banks_swapped) {\r\n            this.set_PRG_ROM(0x8000, this.num_PRG_banks - 2);\r\n            this.set_PRG_ROM(0xA000, this.io.cpu_banka0);\r\n            this.set_PRG_ROM(0xC000, this.io.cpu_bank80);\r\n        } else {\r\n            // VRC2\r\n            this.set_PRG_ROM(0x8000, this.io.cpu_bank80);\r\n            this.set_PRG_ROM(0xA000, this.io.cpu_banka0);\r\n            this.set_PRG_ROM(0xC000, this.num_PRG_banks - 2);\r\n        }\r\n        this.set_CHR_ROM_1k(0, this.io.ppu_banks[0]);\r\n        this.set_CHR_ROM_1k(1, this.io.ppu_banks[1]);\r\n        this.set_CHR_ROM_1k(2, this.io.ppu_banks[2]);\r\n        this.set_CHR_ROM_1k(3, this.io.ppu_banks[3]);\r\n        this.set_CHR_ROM_1k(4, this.io.ppu_banks[4]);\r\n        this.set_CHR_ROM_1k(5, this.io.ppu_banks[5]);\r\n        this.set_CHR_ROM_1k(6, this.io.ppu_banks[6]);\r\n        this.set_CHR_ROM_1k(7, this.io.ppu_banks[7]);\r\n    }\r\n\r\n     set_mirroring(): void {\r\n        switch(this.ppu_mirror) {\r\n            case NES_PPU_mirror_modes.Vertical:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_vertical;\r\n                return;\r\n            case NES_PPU_mirror_modes.Horizontal:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_horizontal;\r\n                return;\r\n            case NES_PPU_mirror_modes.FourWay:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_four;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenAOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Aonly;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenBOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Bonly;\r\n                return;\r\n        }\r\n    }\r\n\r\n   set_cart(cart: NES_cart): void {\r\n        this.CHR_ROM = new StaticArray<u8>(cart.CHR_ROM.byteLength);\r\n        for (let i: u32 = 0, k: u32 = cart.CHR_ROM.byteLength; i < k; i++) {\r\n            this.CHR_ROM[i] = cart.CHR_ROM[i];\r\n        }\r\n        this.PRG_ROM = new StaticArray<u8>(cart.PRG_ROM.byteLength);\r\n        for (let i: u32 = 0, k: u32 = cart.PRG_ROM.byteLength; i < k; i++) {\r\n            this.PRG_ROM[i] = cart.PRG_ROM[i];\r\n        }\r\n\r\n        this.prg_ram_size = cart.header.prg_ram_size;\r\n        console.log('VRC2/4 PRG RAM SIZE ' + cart.header.prg_ram_size.toString());\r\n        this.PRG_RAM = new StaticArray<u8>(this.prg_ram_size);\r\n\r\n        this.num_PRG_banks = (cart.PRG_ROM.byteLength / 8192);\r\n        this.num_CHR_banks = (cart.CHR_ROM.byteLength / 1024);\r\n        console.log('Num PRG banks ' + this.num_PRG_banks.toString());\r\n        console.log('Num CHR banks ' + this.num_CHR_banks.toString());\r\n        this.remap(true);\r\n    }\r\n\r\n}","import {NES_bus, NES_clock} from \"../nes_common\";\r\nimport {\r\n    NES_mapper, NES_mirror_ppu_Aonly, NES_mirror_ppu_Bonly,\r\n    NES_mirror_ppu_four,\r\n    NES_mirror_ppu_horizontal,\r\n    NES_mirror_ppu_vertical,\r\n    NES_PPU_mirror_modes\r\n} from \"./interface\";\r\nimport {NES_cart} from \"../nes_cart\";\r\n\r\nclass CD_regs {\r\n    select: u32 = 0\r\n    prg_banks: StaticArray<u32> = new StaticArray<u32>(4);\r\n    chr_banks: StaticArray<u32> = new StaticArray<u32>(8);\r\n}\r\n\r\nexport class NES_mapper_DXROM implements NES_mapper {\r\n    bus: NES_bus;\r\n    clock: NES_clock;\r\n    regs: CD_regs = new CD_regs();\r\n    num_PRG_banks: u32 = 0;\r\n    num_CHR_banks: u32 = 0;\r\n\r\n    ppu_mirror: NES_PPU_mirror_modes = NES_PPU_mirror_modes.Horizontal;\r\n    mirror_ppu_addr: (addr: u32) => u32 = NES_mirror_ppu_horizontal;\r\n\r\n    CHR_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    PRG_ROM: StaticArray<u8> = new StaticArray<u8>(0);\r\n    CIRAM: StaticArray<u8> = new StaticArray<u8>(0x2000); // PPU RAM\r\n    CPU_RAM: StaticArray<u8> = new StaticArray<u8>(0x800); // CPU RAM\r\n\r\n    last_bank_offset: u32 = 0;\r\n    constructor(clock: NES_clock, bus: NES_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n    }\r\n\r\n    @inline cycle(howmany: u32): void {}\r\n\r\n    @inline a12_watch(addr: u32): void {}\r\n\r\n    @inline PPU_read_effect(addr: u32): u32 {\r\n        if (addr < 0x2000)\r\n            return this.CHR_ROM[this.regs.chr_banks[addr >>> 10] + (addr & 0x3FF)];\r\n\r\n        return this.CIRAM[this.mirror_ppu_addr(addr)];\r\n    }\r\n\r\n    PPU_read_noeffect(addr: u32): u32 {\r\n        return this.PPU_read_effect(addr);\r\n    }\r\n\r\n    @inline PPU_write(addr: u32, val: u32): void {\r\n        if (addr < 0x2000) return;\r\n        this.CIRAM[this.mirror_ppu_addr(addr)] = <u8>val;\r\n    }\r\n\r\n    @inline CPU_write(addr: u32, val: u32): void {\r\n        if (addr < 0x2000) {\r\n            this.CPU_RAM[addr & 0x7FF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0x4000)\r\n            return this.bus.PPU_reg_write(addr, val);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_write(addr, val);\r\n\r\n        if ((addr < 0x8000) || (addr > 0xA000)) return;\r\n        switch(addr & 1) {\r\n            case 0: // 8000-FFFF even\r\n                this.regs.select = val & 7;\r\n                return;\r\n            case 1:\r\n                switch(this.regs.select) {\r\n                    case 0:\r\n                        return this.set_CHR_ROM_2k(0x0000, val & 0x3E);\r\n                    case 1:\r\n                        return this.set_CHR_ROM_2k(0x0800, val & 0x3E);\r\n                    case 2:\r\n                        return this.set_CHR_ROM_1k(0x1000, val & 0x3F);\r\n                    case 3:\r\n                        return this.set_CHR_ROM_1k(0x1400, val & 0x3F);\r\n                    case 4:\r\n                        return this.set_CHR_ROM_1k(0x1800, val & 0x3F);\r\n                    case 5:\r\n                        return this.set_CHR_ROM_1k(0x1C00, val & 0x3F);\r\n                    case 6:\r\n                        return this.set_PRG_ROM_8k(0x8000, val & 0x0F);\r\n                    case 7:\r\n                        return this.set_PRG_ROM_8k(0xA000, val & 0x0F);\r\n                }\r\n                return;\r\n        }\r\n    }\r\n\r\n    @inline CPU_read(addr: u32, val: u32, has_effect: u32): u32 {\r\n        if (addr < 0x2000)\r\n            return this.CPU_RAM[addr & 0x7FF];\r\n        if (addr < 0x4000)\r\n            return this.bus.PPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x4020)\r\n            return this.bus.CPU_reg_read(addr, val, has_effect);\r\n        if (addr < 0x8000) return val;\r\n        return this.PRG_ROM[this.regs.prg_banks[(addr - 0x8000) >>> 13] + (addr & 0x1FFF)];\r\n    }\r\n\r\n    set_PRG_ROM_8k(addr: u32, bank_num: u32): void {\r\n        this.regs.prg_banks[(addr === 0x8000) ? 0 : 1] = (bank_num % this.num_PRG_banks) * 8192;\r\n    }\r\n\r\n    set_CHR_ROM_2k(addr: u32, bank_num: u32): void {\r\n        let bn: u32 = (addr >>> 10);\r\n        bank_num = (bank_num % this.num_CHR_banks);\r\n        this.regs.chr_banks[bn] = bank_num * 1024;\r\n        this.regs.chr_banks[bn+1] = (bank_num+1) * 1024;\r\n    }\r\n\r\n    set_CHR_ROM_1k(addr: u32, bank_num: u32): void {\r\n        let bn: u32 = (addr >>> 10);\r\n        this.regs.chr_banks[bn] = (bank_num % this.num_CHR_banks) * 1024;\r\n    }\r\n\r\n    reset(): void {\r\n        this.remap(true);\r\n    }\r\n\r\n    remap(boot: bool = false): void {\r\n        if (boot) {\r\n            this.set_PRG_ROM_8k(0x8000, 0);\r\n            this.set_PRG_ROM_8k(0xA000, 1);\r\n            // 0xC000-0xFFFF fixed to last two banks\r\n            this.regs.prg_banks[2] = (this.num_PRG_banks - 2) * 8192;\r\n            this.regs.prg_banks[3] = (this.num_PRG_banks - 1) * 8192;\r\n\r\n            this.set_CHR_ROM_2k(0x0000, 0);\r\n            this.set_CHR_ROM_2k(0x0800, 2);\r\n            this.set_CHR_ROM_1k(0x1000, 4);\r\n            this.set_CHR_ROM_1k(0x1400, 5);\r\n            this.set_CHR_ROM_1k(0x1800, 6);\r\n            this.set_CHR_ROM_1k(0x1C00, 7);\r\n        }\r\n    }\r\n\r\n    set_mirroring(): void {\r\n        switch(this.ppu_mirror) {\r\n            case NES_PPU_mirror_modes.Vertical:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_vertical;\r\n                return;\r\n            case NES_PPU_mirror_modes.Horizontal:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_horizontal;\r\n                return;\r\n            case NES_PPU_mirror_modes.FourWay:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_four;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenAOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Aonly;\r\n                return;\r\n            case NES_PPU_mirror_modes.ScreenBOnly:\r\n                this.mirror_ppu_addr = NES_mirror_ppu_Bonly;\r\n                return;\r\n        }\r\n    }\r\n\r\n    set_cart(cart: NES_cart): void {\r\n        this.CHR_ROM = new StaticArray<u8>(cart.CHR_ROM.byteLength);\r\n        for (let i: u32 = 0, k: u32 = cart.CHR_ROM.byteLength; i < k; i++) {\r\n            this.CHR_ROM[i] = cart.CHR_ROM[i];\r\n        }\r\n        this.PRG_ROM = new StaticArray<u8>(cart.PRG_ROM.byteLength);\r\n        for (let i: u32 = 0, k: u32 = cart.PRG_ROM.byteLength; i < k; i++) {\r\n            this.PRG_ROM[i] = cart.PRG_ROM[i];\r\n        }\r\n\r\n        this.ppu_mirror = cart.header.mirroring;\r\n        this.set_mirroring();\r\n\r\n        this.num_PRG_banks = cart.PRG_ROM.byteLength / 8192;\r\n        this.num_CHR_banks = cart.CHR_ROM.byteLength / 1024;\r\n        this.remap(true);\r\n    }\r\n\r\n}","// Total tables size: ~5 kb (usually compressed to ~4 kb)\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/casemap.h\n\n// @ts-ignore: decorator\n@lazy @inline const TAB = memory.data<u8>([\n  7, 8, 9, 10, 11, 12, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  13, 6, 6, 14, 6, 6, 6, 6, 6, 6, 6, 6, 15, 16, 17, 18,\n  6, 19, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 20, 21, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 22, 23, 6, 6, 6, 24, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 25,\n  6, 6, 6, 6, 26, 6, 6, 6, 6, 6, 6, 6, 27, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 28, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 29, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36,\n  43, 43, 43, 43, 43, 43, 43, 43, 1, 0, 84, 86, 86, 86, 86, 86,\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 43, 43, 43, 43, 43, 43,\n  43, 7, 43, 43, 91, 86, 86, 86, 86, 86, 86, 86, 74, 86, 86, 5,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  36, 80, 121, 49, 80, 49, 80, 49, 56, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 78, 49, 2, 78, 13, 13, 78, 3,\n  78, 0, 36, 110, 0, 78, 49, 38, 110, 81, 78, 36, 80, 78, 57, 20,\n  129, 27, 29, 29, 83, 49, 80, 49, 80, 13, 49, 80, 49, 80, 49, 80,\n  27, 83, 36, 80, 49, 2, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123,\n  20, 121, 92, 123, 92, 123, 92, 45, 43, 73, 3, 72, 3, 120, 92, 123,\n  20, 0, 150, 10, 1, 43, 40, 6, 6, 0, 42, 6, 42, 42, 43, 7,\n  187, 181, 43, 30, 0, 43, 7, 43, 43, 43, 1, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 205, 70, 205, 43, 0, 37, 43, 7, 1, 6, 1, 85, 86, 86, 86,\n  86, 86, 85, 86, 86, 2, 36, 129, 129, 129, 129, 129, 21, 129, 129, 129,\n  0, 0, 43, 0, 178, 209, 178, 209, 178, 209, 178, 209, 0, 0, 205, 204,\n  1, 0, 215, 215, 215, 215, 215, 131, 129, 129, 129, 129, 129, 129, 129, 129,\n  129, 129, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 28, 0, 0, 0,\n  0, 0, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 2, 0, 0,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 78, 49, 80, 49, 80, 78, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 2, 135, 166, 135, 166, 135, 166, 135, 166,\n  135, 166, 135, 166, 135, 166, 135, 166, 42, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  12, 0, 12, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 7, 42, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 86, 86, 108, 129, 21, 0, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 7, 108, 3, 65, 43, 43, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 86, 86, 86, 44, 86, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 12, 108, 0, 0, 0, 0, 0, 6,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 86, 122, 158, 38, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 1, 43, 43, 79, 86,\n  86, 44, 43, 127, 86, 86, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\n  86, 44, 43, 127, 86, 86, 129, 55, 117, 91, 123, 92, 43, 43, 79, 86,\n  86, 2, 172, 4, 0, 0, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\n  86, 44, 43, 43, 86, 86, 50, 19, 129, 87, 0, 111, 129, 126, 201, 215,\n  126, 45, 129, 129, 14, 126, 57, 127, 111, 87, 0, 129, 129, 126, 21, 0,\n  126, 3, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 43,\n  36, 43, 151, 43, 43, 43, 43, 43, 43, 43, 43, 43, 42, 43, 43, 43,\n  43, 43, 86, 86, 86, 86, 86, 128, 129, 129, 129, 129, 57, 187, 42, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 1, 129, 129, 129, 129, 129, 129, 129, 129,\n  129, 129, 129, 129, 129, 129, 129, 201, 172, 172, 172, 172, 172, 172, 172, 172,\n  172, 172, 172, 172, 172, 172, 172, 208, 13, 0, 78, 49, 2, 180, 193, 193,\n  215, 215, 36, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 215, 215, 83, 193, 71, 212, 215, 215, 215, 5, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 1, 0, 1, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 13, 0, 0, 0, 0, 0, 36, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 121, 92, 123, 92, 123, 79, 123, 92, 123, 92, 123,\n  92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 45,\n  43, 43, 121, 20, 92, 123, 92, 45, 121, 42, 92, 39, 92, 123, 92, 123,\n  92, 123, 164, 0, 10, 180, 92, 123, 92, 123, 79, 3, 120, 56, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 79, 45, 43, 43, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 72, 86, 86, 86, 86,\n  86, 86, 86, 86, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 85, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 36, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 7, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 0,\n  0, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 86, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 86, 86,\n  86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 85,\n  86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const RULES = memory.data<i32>([\n  0x0, 0x2001, -0x2000, 0x1dbf00, 0x2e700, 0x7900,\n  0x2402, 0x101, -0x100, 0x0, 0x201, -0x200,\n  -0xc6ff, -0xe800, -0x78ff, -0x12c00, 0xc300, 0xd201,\n  0xce01, 0xcd01, 0x4f01, 0xca01, 0xcb01, 0xcf01,\n  0x6100, 0xd301, 0xd101, 0xa300, 0xd501, 0x8200,\n  0xd601, 0xda01, 0xd901, 0xdb01, 0x3800, 0x3,\n  -0x4f00, -0x60ff, -0x37ff, 0x242802, 0x0, 0x101,\n  -0x100, -0xcd00, -0xda00, -0x81ff, 0x2a2b01, -0xa2ff,\n  0x2a2801, 0x2a3f00, -0xc2ff, 0x4501, 0x4701, 0x2a1f00,\n  0x2a1c00, 0x2a1e00, -0xd200, -0xce00, -0xca00, -0xcb00,\n  0xa54f00, 0xa54b00, -0xcf00, 0xa52800, 0xa54400, -0xd100,\n  -0xd300, 0x29f700, 0xa54100, 0x29fd00, -0xd500, -0xd600,\n  0x29e700, 0xa54300, 0xa52a00, -0x4500, -0xd900, -0x4700,\n  -0xdb00, 0xa51500, 0xa51200, 0x4c2402, 0x0, 0x2001,\n  -0x2000, 0x101, -0x100, 0x5400, 0x7401, 0x2601,\n  0x2501, 0x4001, 0x3f01, -0x2600, -0x2500, -0x1f00,\n  -0x4000, -0x3f00, 0x801, -0x3e00, -0x3900, -0x2f00,\n  -0x3600, -0x800, -0x5600, -0x5000, 0x700, -0x7400,\n  -0x3bff, -0x6000, -0x6ff, 0x701a02, 0x101, -0x100,\n  0x2001, -0x2000, 0x5001, 0xf01, -0xf00, 0x0,\n  0x3001, -0x3000, 0x101, -0x100, 0x0, 0xbc000,\n  0x1c6001, 0x0, 0x97d001, 0x801, -0x800, 0x8a0502,\n  0x0, -0xbbfff, -0x186200, 0x89c200, -0x182500, -0x186e00,\n  -0x186d00, -0x186400, -0x186300, -0x185c00, 0x0, 0x8a3800,\n  0x8a0400, 0xee600, 0x101, -0x100, 0x0, -0x3b00,\n  -0x1dbeff, 0x8f1d02, 0x800, -0x7ff, 0x0, 0x5600,\n  -0x55ff, 0x4a00, 0x6400, 0x8000, 0x7000, 0x7e00,\n  0x900, -0x49ff, -0x8ff, -0x1c2500, -0x63ff, -0x6fff,\n  -0x7fff, -0x7dff, 0xac0502, 0x0, 0x1001, -0x1000,\n  0x1c01, 0x101, -0x1d5cff, -0x20beff, -0x2045ff, -0x1c00,\n  0xb10b02, 0x101, -0x100, 0x3001, -0x3000, 0x0,\n  -0x29f6ff, -0xee5ff, -0x29e6ff, -0x2a2b00, -0x2a2800, -0x2a1bff,\n  -0x29fcff, -0x2a1eff, -0x2a1dff, -0x2a3eff, 0x0, -0x1c6000,\n  0x0, 0x101, -0x100, 0xbc0c02, 0x0, 0x101,\n  -0x100, -0xa543ff, 0x3a001, -0x8a03ff, -0xa527ff, 0x3000,\n  -0xa54eff, -0xa54aff, -0xa540ff, -0xa511ff, -0xa529ff, -0xa514ff,\n  -0x2fff, -0xa542ff, -0x8a37ff, 0x0, -0x97d000, -0x3a000,\n  0x0, 0x2001, -0x2000, 0x0, 0x2801, -0x2800,\n  0x0, 0x4001, -0x4000, 0x0, 0x2001, -0x2000,\n  0x0, 0x2001, -0x2000, 0x0, 0x2201, -0x2200\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const RULE_BASES = memory.data<u8>([\n  0, 6, 39, 81, 111, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  124, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 131, 142, 146, 151,\n  0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 196, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 198, 201, 0, 0, 0, 219, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222,\n  0, 0, 0, 0, 225, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const EXCEPTIONS = memory.data<u8>([\n  48, 12,  49, 13,  120, 14,  127, 15,\n  128, 16,  129, 17,  134, 18,  137, 19,\n  138, 19,  142, 20,  143, 21,  144, 22,\n  147, 19,  148, 23,  149, 24,  150, 25,\n  151, 26,  154, 27,  156, 25,  157, 28,\n  158, 29,  159, 30,  166, 31,  169, 31,\n  174, 31,  177, 32,  178, 32,  183, 33,\n  191, 34,  197, 35,  200, 35,  203, 35,\n  221, 36,  242, 35,  246, 37,  247, 38,\n  32, 45,  58, 46,  61, 47,  62, 48,\n  63, 49,  64, 49,  67, 50,  68, 51,\n  69, 52,  80, 53,  81, 54,  82, 55,\n  83, 56,  84, 57,  89, 58,  91, 59,\n  92, 60,  97, 61,  99, 62,  101, 63,\n  102, 64,  104, 65,  105, 66,  106, 64,\n  107, 67,  108, 68,  111, 66,  113, 69,\n  114, 70,  117, 71,  125, 72,  130, 73,\n  135, 74,  137, 75,  138, 76,  139, 76,\n  140, 77,  146, 78,  157, 79,  158, 80,\n  69, 87,  123, 29,  124, 29,  125, 29,\n  127, 88,  134, 89,  136, 90,  137, 90,\n  138, 90,  140, 91,  142, 92,  143, 92,\n  172, 93,  173, 94,  174, 94,  175, 94,\n  194, 95,  204, 96,  205, 97,  206, 97,\n  207, 98,  208, 99,  209, 100,  213, 101,\n  214, 102,  215, 103,  240, 104,  241, 105,\n  242, 106,  243, 107,  244, 108,  245, 109,\n  249, 110,  253, 45,  254, 45,  255, 45,\n  80, 105,  81, 105,  82, 105,  83, 105,\n  84, 105,  85, 105,  86, 105,  87, 105,\n  88, 105,  89, 105,  90, 105,  91, 105,\n  92, 105,  93, 105,  94, 105,  95, 105,\n  130, 0,  131, 0,  132, 0,  133, 0,\n  134, 0,  135, 0,  136, 0,  137, 0,\n  192, 117,  207, 118,  128, 137,  129, 138,\n  130, 139,  133, 140,  134, 141,  112, 157,\n  113, 157,  118, 158,  119, 158,  120, 159,\n  121, 159,  122, 160,  123, 160,  124, 161,\n  125, 161,  179, 162,  186, 163,  187, 163,\n  188, 164,  190, 165,  195, 162,  204, 164,\n  218, 166,  219, 166,  229, 106,  234, 167,\n  235, 167,  236, 110,  243, 162,  248, 168,\n  249, 168,  250, 169,  251, 169,  252, 164,\n  38, 176,  42, 177,  43, 178,  78,  179,\n  132,  8,  98, 186,  99, 187,  100, 188,\n  101, 189,  102, 190,  109, 191,  110, 192,\n  111, 193,  112, 194,  126, 195,  127, 195,\n  125, 207,  141, 208,  148, 209,  171, 210,\n  172, 211,  173, 212,  176, 213,  177, 214,\n  178, 215,  196, 216,  197, 217,  198, 218\n]);\n\n/* Special Case Mappings\n * See: https://unicode.org/Public/UNIDATA/SpecialCasing.txt\n */\n\n/*\n@lazy @inline\nconst SPECIALS_LOWER: StaticArray<u16> = [\n  0x0130,  0x0069, 0x0307, 0x0000,\n];\n*/\n\n// @ts-ignore: decorator\n@lazy @inlne\nexport const SPECIALS_UPPER: StaticArray<u16> = [\n  // String#toUpperCase needs .length\n  0x00DF,  0x0053, 0x0053, 0x0000,\n  0x0149,  0x02BC, 0x004E, 0x0000,\n  0x01F0,  0x004A, 0x030C, 0x0000,\n  0x0390,  0x0399, 0x0308, 0x0301,\n  0x03B0,  0x03A5, 0x0308, 0x0301,\n  0x0587,  0x0535, 0x0552, 0x0000,\n  0x1E96,  0x0048, 0x0331, 0x0000,\n  0x1E97,  0x0054, 0x0308, 0x0000,\n  0x1E98,  0x0057, 0x030A, 0x0000,\n  0x1E99,  0x0059, 0x030A, 0x0000,\n  0x1E9A,  0x0041, 0x02BE, 0x0000,\n  0x1F50,  0x03A5, 0x0313, 0x0000,\n  0x1F52,  0x03A5, 0x0313, 0x0300,\n  0x1F54,  0x03A5, 0x0313, 0x0301,\n  0x1F56,  0x03A5, 0x0313, 0x0342,\n  0x1F80,  0x1F08, 0x0399, 0x0000,\n  0x1F81,  0x1F09, 0x0399, 0x0000,\n  0x1F82,  0x1F0A, 0x0399, 0x0000,\n  0x1F83,  0x1F0B, 0x0399, 0x0000,\n  0x1F84,  0x1F0C, 0x0399, 0x0000,\n  0x1F85,  0x1F0D, 0x0399, 0x0000,\n  0x1F86,  0x1F0E, 0x0399, 0x0000,\n  0x1F87,  0x1F0F, 0x0399, 0x0000,\n  0x1F88,  0x1F08, 0x0399, 0x0000,\n  0x1F89,  0x1F09, 0x0399, 0x0000,\n  0x1F8A,  0x1F0A, 0x0399, 0x0000,\n  0x1F8B,  0x1F0B, 0x0399, 0x0000,\n  0x1F8C,  0x1F0C, 0x0399, 0x0000,\n  0x1F8D,  0x1F0D, 0x0399, 0x0000,\n  0x1F8E,  0x1F0E, 0x0399, 0x0000,\n  0x1F8F,  0x1F0F, 0x0399, 0x0000,\n  0x1F90,  0x1F28, 0x0399, 0x0000,\n  0x1F91,  0x1F29, 0x0399, 0x0000,\n  0x1F92,  0x1F2A, 0x0399, 0x0000,\n  0x1F93,  0x1F2B, 0x0399, 0x0000,\n  0x1F94,  0x1F2C, 0x0399, 0x0000,\n  0x1F95,  0x1F2D, 0x0399, 0x0000,\n  0x1F96,  0x1F2E, 0x0399, 0x0000,\n  0x1F97,  0x1F2F, 0x0399, 0x0000,\n  0x1F98,  0x1F28, 0x0399, 0x0000,\n  0x1F99,  0x1F29, 0x0399, 0x0000,\n  0x1F9A,  0x1F2A, 0x0399, 0x0000,\n  0x1F9B,  0x1F2B, 0x0399, 0x0000,\n  0x1F9C,  0x1F2C, 0x0399, 0x0000,\n  0x1F9D,  0x1F2D, 0x0399, 0x0000,\n  0x1F9E,  0x1F2E, 0x0399, 0x0000,\n  0x1F9F,  0x1F2F, 0x0399, 0x0000,\n  0x1FA0,  0x1F68, 0x0399, 0x0000,\n  0x1FA1,  0x1F69, 0x0399, 0x0000,\n  0x1FA2,  0x1F6A, 0x0399, 0x0000,\n  0x1FA3,  0x1F6B, 0x0399, 0x0000,\n  0x1FA4,  0x1F6C, 0x0399, 0x0000,\n  0x1FA5,  0x1F6D, 0x0399, 0x0000,\n  0x1FA6,  0x1F6E, 0x0399, 0x0000,\n  0x1FA7,  0x1F6F, 0x0399, 0x0000,\n  0x1FA8,  0x1F68, 0x0399, 0x0000,\n  0x1FA9,  0x1F69, 0x0399, 0x0000,\n  0x1FAA,  0x1F6A, 0x0399, 0x0000,\n  0x1FAB,  0x1F6B, 0x0399, 0x0000,\n  0x1FAC,  0x1F6C, 0x0399, 0x0000,\n  0x1FAD,  0x1F6D, 0x0399, 0x0000,\n  0x1FAE,  0x1F6E, 0x0399, 0x0000,\n  0x1FAF,  0x1F6F, 0x0399, 0x0000,\n  0x1FB2,  0x1FBA, 0x0399, 0x0000,\n  0x1FB3,  0x0391, 0x0399, 0x0000,\n  0x1FB4,  0x0386, 0x0399, 0x0000,\n  0x1FB6,  0x0391, 0x0342, 0x0000,\n  0x1FB7,  0x0391, 0x0342, 0x0399,\n  0x1FBC,  0x0391, 0x0399, 0x0000,\n  0x1FC2,  0x1FCA, 0x0399, 0x0000,\n  0x1FC3,  0x0397, 0x0399, 0x0000,\n  0x1FC4,  0x0389, 0x0399, 0x0000,\n  0x1FC6,  0x0397, 0x0342, 0x0000,\n  0x1FC7,  0x0397, 0x0342, 0x0399,\n  0x1FCC,  0x0397, 0x0399, 0x0000,\n  0x1FD2,  0x0399, 0x0308, 0x0300,\n  0x1FD3,  0x0399, 0x0308, 0x0301,\n  0x1FD6,  0x0399, 0x0342, 0x0000,\n  0x1FD7,  0x0399, 0x0308, 0x0342,\n  0x1FE2,  0x03A5, 0x0308, 0x0300,\n  0x1FE3,  0x03A5, 0x0308, 0x0301,\n  0x1FE4,  0x03A1, 0x0313, 0x0000,\n  0x1FE6,  0x03A5, 0x0342, 0x0000,\n  0x1FE7,  0x03A5, 0x0308, 0x0342,\n  0x1FF2,  0x1FFA, 0x0399, 0x0000,\n  0x1FF3,  0x03A9, 0x0399, 0x0000,\n  0x1FF4,  0x038F, 0x0399, 0x0000,\n  0x1FF6,  0x03A9, 0x0342, 0x0000,\n  0x1FF7,  0x03A9, 0x0342, 0x0399,\n  0x1FFC,  0x03A9, 0x0399, 0x0000,\n  0xFB00,  0x0046, 0x0046, 0x0000,\n  0xFB01,  0x0046, 0x0049, 0x0000,\n  0xFB02,  0x0046, 0x004C, 0x0000,\n  0xFB03,  0x0046, 0x0046, 0x0049,\n  0xFB04,  0x0046, 0x0046, 0x004C,\n  0xFB05,  0x0053, 0x0054, 0x0000,\n  0xFB06,  0x0053, 0x0054, 0x0000,\n  0xFB13,  0x0544, 0x0546, 0x0000,\n  0xFB14,  0x0544, 0x0535, 0x0000,\n  0xFB15,  0x0544, 0x053B, 0x0000,\n  0xFB16,  0x054E, 0x0546, 0x0000,\n  0xFB17,  0x0544, 0x053D, 0x0000\n];\n\n// @ts-ignore: decorator\n@lazy @inline const MT = memory.data<i32>([\n  2048, 342, 57\n]);\n\n// Special binary search routine for Special Casing Tables\n// @ts-ignore: decorator\n@inline\nexport function bsearch(key: u32, ptr: usize, max: i32): i32 {\n  let min = 0;\n  while (min <= max) {\n    let mid = (min + max) >>> 3 << 2;\n    let cmp = load<u16>(ptr + (mid << alignof<u16>())) - key;\n    if (cmp == 0) return mid; // found\n    else if (cmp >>> 31) min = mid + 4; // < 0\n    else max = mid - 4; // > 0\n  }\n  return -1; // not found\n}\n\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/towctrans.c\nexport function casemap(c: u32, dir: i32): i32 {\n  // if (c >= 0x20000) return c;\n  let c0 = c as i32;\n  let b = c >> 8;\n  c &= 255;\n\n  let x = c / 3;\n  let y = c % 3;\n\n  /* lookup entry in two-level base-6 table */\n  // v = tab[(tab[b] as i32) * 86 + x] as u32;\n  let v = <usize>load<u8>(TAB + <usize>load<u8>(TAB + b) * 86 + x);\n  // v = (v * mt[y] >> 11) % 6;\n  v = (v * load<i32>(MT + (y << alignof<i32>())) >> 11) % 6;\n  /* use the bit vector out of the tables as an index into\n   * a block-specific set of rules and decode the rule into\n   * a type and a case-mapping delta. */\n  // r = rules[(ruleBases[b] as u32) + v];\n  let r = load<i32>(RULES + ((<usize>load<u8>(RULE_BASES + b) + v) << alignof<i32>()));\n  let rt: u32 = r & 255;\n  let rd: i32 = r >> 8;\n  /* rules 0/1 are simple lower/upper case with a delta.\n   * apply according to desired mapping direction. */\n  if (rt < 2) return c0 + (rd & -(rt ^ dir));\n  /* binary search. endpoints of the binary search for\n   * this block are stored in the rule delta field. */\n  let xn: u32 = rd & 0xff;\n  let xb: u32 = rd >>> 8;\n  while (xn) {\n    let h = xn >> 1;\n    // let t = exceptions[(xb + h) * 2 + 0] as u32;\n    let t = <u32>load<u8>(EXCEPTIONS + (xb + h) * 2, 0);\n    if (t == c) {\n      // r = rules[exceptions[(xb + h) * 2 + 1]];\n      r = load<i32>(RULES + <usize>(load<u8>(EXCEPTIONS + (xb + h) * 2, 1) << alignof<i32>()));\n      rt = r & 255;\n      rd = r >> 8;\n      if (rt < 2) return c0 + (rd & -(rt ^ dir));\n      /* Hard-coded for the four exceptional titlecase */\n      return c0 + 1 - (dir << 1); // (dir ? -1 : 1);\n    } else if (t > c) {\n      xn = h;\n    } else {\n      xb += h;\n      xn -= h;\n    }\n  }\n  return c0;\n}\n","import {GB_mapper} from \"./interface\";\r\nimport {GB_bus, GB_clock} from \"../gb\";\r\nimport {GB_cart} from \"../gb_cart\";\r\nimport {GB_variants} from \"../gb_common\";\r\n\r\nexport class GB_mapper_none implements GB_mapper{\r\n    clock: GB_clock\r\n    bus: GB_bus\r\n\r\n    ROM: StaticArray<u8> = new StaticArray<u8>(0)\r\n    cartRAM: StaticArray<u8> = new StaticArray<u8>(0)\r\n    WRAM: StaticArray<u8> = new StaticArray<u8>(8192*8)\r\n    HRAM: StaticArray<u8> = new StaticArray<u8>(128)\r\n    VRAM: StaticArray<u8> = new StaticArray<u8>(32768);\r\n    BIOS: StaticArray<u8> = new StaticArray<u8>(0);\r\n\r\n    BIOS_big: u32 = 0\r\n    ROM_bank_offset: u32 = 16384\r\n    VRAM_bank_offset: u32 = 0\r\n    WRAM_bank_offset: u32 = 0x1000;\r\n\r\n    RAM_mask: u32 = 0;\r\n    has_RAM: bool = false;\r\n\r\n    cart: GB_cart\r\n\r\n    constructor(clock: GB_clock, bus: GB_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n\r\n        //this.bus.CPU_read = this.CPU_read.bind(this);\r\n        //this.bus.CPU_write = this.CPU_write.bind(this);\r\n        //this.bus.PPU_read = this.PPU_read.bind(this);\r\n\r\n\r\n        //this.bus.mapper = this;\r\n\r\n        this.cart = new GB_cart(GB_variants.DMG, clock, bus)\r\n    }\r\n\r\n    reset(): void {\r\n        // This changes on other mappers for banking\r\n        this.ROM_bank_offset = 16384;\r\n        // This changes on CGB\r\n        this.VRAM_bank_offset = 0;\r\n        // This changes on CGB\r\n        this.WRAM_bank_offset = 0x1000;\r\n    }\r\n\r\n    CPU_read(addr: u32, val: u32): u32 {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (this.clock.bootROM_enabled) {\r\n            if (addr < 0x100) {\r\n                let r: u32 = this.BIOS[addr];\r\n                return r;\r\n            }\r\n            if (this.BIOS_big && (addr >= 0x200) && (addr < 0x900))\r\n                return this.BIOS[addr - 0x100];\r\n        }\r\n        if (addr < 0x4000) // ROM lo bank\r\n            return this.ROM[addr];\r\n        if (addr < 0x8000) // ROM hi bank\r\n            return this.ROM[(addr & 0x3FFF) + this.ROM_bank_offset];\r\n        if (addr < 0xA000) { // VRAM, banked\r\n            if (this.clock.CPU_can_VRAM)\r\n                return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n            return 0xFF;\r\n        } // cart RAM if it's there\r\n        if (addr < 0xC000) {\r\n            if (!this.has_RAM) return 0xFF;\r\n            return this.cartRAM[(addr - 0xA000) & this.RAM_mask];\r\n        }\r\n        // Adjust address for mirroring\r\n        if ((addr > 0xE000) && (addr < 0xFE00)) addr -= 0x2000;\r\n        if (addr < 0xD000) // WRAM lo bank\r\n            return this.WRAM[addr & 0xFFF];\r\n        if (addr < 0xE000) // WRAM hi bank\r\n            return this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset]\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.read_OAM(addr);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_read_IO(addr, val);\r\n        if (addr < 0xFFFF) // HRAM always accessible\r\n            return this.HRAM[addr - 0xFF80];\r\n        return this.bus.CPU_read_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    CPU_write(addr: u32, val: u32): void {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (addr < 0x8000) // ROMs\r\n            return;\r\n        if (addr < 0xA000) { // VRAM\r\n            if (this.clock.CPU_can_VRAM)\r\n                this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xC000) { // cart RAM\r\n            if (!this.has_RAM) return;\r\n            this.cartRAM[(addr - 0xA000) & this.RAM_mask] = <u8>val;\r\n            return;\r\n        }\r\n        // adjust address for mirroring\r\n        if ((addr > 0xE000) && (addr < 0xFE00)) addr -= 0x2000;\r\n\r\n        if (addr < 0xD000) { // WRAM lo bank\r\n            this.WRAM[addr & 0xFFF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xE000) { // WRAM hi bank\r\n            this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.write_OAM(addr, val);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_write_IO(addr, val);\r\n        if (addr < 0xFFFF) { // HRAM always accessible\r\n            this.HRAM[addr - 0xFF80] = <u8>val;\r\n            return;\r\n        }\r\n        this.bus.CPU_write_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    PPU_read(addr: u32): u32 {\r\n        if ((addr < 0x8000) || (addr > 0x9FFF)) return 0xFF;\r\n        return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n    }\r\n\r\n    set_cart(cart: GB_cart, BIOS: Uint8Array): void {\r\n        console.log('Loading GB cart with no mapper');\r\n        this.cart = cart;\r\n        this.BIOS = new StaticArray<u8>(BIOS.byteLength);\r\n        for (let i = 0, k = BIOS.byteLength; i < k; i++) {\r\n            this.BIOS[i] = BIOS[i];\r\n        }\r\n\r\n        this.BIOS_big = +(BIOS.byteLength > 256);\r\n\r\n        this.ROM = new StaticArray<u8>(cart.header.ROM_size);\r\n        for (let i: u32 = 0, k: u32 = cart.header.ROM_size; i < k; i++) {\r\n            this.ROM[i] = cart.ROM[i];\r\n        }\r\n\r\n        this.cartRAM = new StaticArray<u8>(cart.header.RAM_size);\r\n        this.RAM_mask = cart.header.RAM_mask;\r\n        this.has_RAM = cart.header.RAM_size > 0;\r\n    }\r\n}","import {GB_mapper} from \"./interface\";\r\nimport {GB_bus, GB_clock} from \"../gb\";\r\nimport {GB_cart} from \"../gb_cart\";\r\nimport {GB_variants} from \"../gb_common\";\r\nimport {hex4} from \"../../../helpers/helpers\";\r\n\r\nclass GB_mapper_MBC1_regs {\r\n    banking_mode: u32 = 0\r\n    BANK1: u32 = 1\r\n    BANK2: u32 = 0\r\n    cartRAM_bank: u32 = 0\r\n    ext_RAM_enable: u32 = 0\r\n}\r\n\r\nexport class GB_mapper_MBC1 implements GB_mapper {\r\n    clock: GB_clock\r\n    bus: GB_bus\r\n    ROM: StaticArray<u8> = new StaticArray<u8>(0)\r\n    cartRAM: StaticArray<u8> = new StaticArray<u8>(0)\r\n    WRAM: StaticArray<u8> = new StaticArray<u8>(8192 * 8)\r\n    HRAM: StaticArray<u8> = new StaticArray<u8>(128)\r\n    VRAM: StaticArray<u8> = new StaticArray<u8>(32768);\r\n    BIOS: StaticArray<u8> = new StaticArray<u8>(0);\r\n\r\n    BIOS_big: u32 = 0\r\n    ROM_bank_lo_offset: u32 = 0;\r\n    ROM_bank_hi_offset: u32 = 16384;\r\n    VRAM_bank_offset: u32 = 0;\r\n    WRAM_bank_offset: u32 = 0x1000;\r\n    RAM_mask: u32 = 0\r\n    has_RAM: bool = false\r\n    num_ROM_banks: u32 = 0;\r\n    num_RAM_banks: u32 = 1;\r\n    cartRAM_offset: u32 = 0;\r\n    regs: GB_mapper_MBC1_regs = new GB_mapper_MBC1_regs;\r\n\r\n    cart: GB_cart\r\n\r\n    constructor(clock: GB_clock, bus: GB_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n\r\n        // MMBC1-specific\r\n        this.cart = new GB_cart(GB_variants.DMG, clock, bus);\r\n        this.bus.mapper = this;\r\n    }\r\n\r\n    reset(): void {\r\n        // This changes on other mappers for banking\r\n        this.ROM_bank_lo_offset = 0;\r\n        this.ROM_bank_hi_offset = 16384;\r\n        this.cartRAM_offset = 0;\r\n        this.regs.BANK1 = 1;\r\n        this.regs.BANK2 = 0;\r\n        this.regs.banking_mode = 0;\r\n        this.regs.ext_RAM_enable = 0;\r\n        this.regs.cartRAM_bank = 0;\r\n        // This changes on CGB\r\n        this.VRAM_bank_offset = 0;\r\n        // This changes on CGB\r\n        this.WRAM_bank_offset = 0x1000;\r\n        this.update_banks();\r\n    }\r\n\r\n    CPU_read(addr: u32, val: u32): u32 {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (this.clock.bootROM_enabled) {\r\n            if (addr < 0x100)\r\n                return this.bus.BIOS[addr];\r\n            if (this.BIOS_big && (addr >= 0x200) && (addr < 0x900))\r\n                return this.bus.BIOS[addr - 0x100];\r\n        }\r\n        if (addr < 0x4000) // ROM lo bank\r\n            return this.ROM[addr + this.ROM_bank_lo_offset];\r\n        if (addr < 0x8000) // ROM hi bank\r\n            return this.ROM[(addr & 0x3FFF) + this.ROM_bank_hi_offset];\r\n        if (addr < 0xA000) { // VRAM, banked\r\n            if (this.clock.CPU_can_VRAM)\r\n                return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n            return 0xFF;\r\n        } // cart RAM if it's there\r\n        if (addr < 0xC000) {\r\n            if ((!this.has_RAM) || (!this.regs.ext_RAM_enable))\r\n                return 0xFF;\r\n            return this.cartRAM[((addr - 0xA000) & this.RAM_mask) + this.cartRAM_offset];\r\n        }\r\n        // Adjust address for mirroring\r\n        if ((addr > 0xE000) && (addr < 0xFE00)) return 0xFF; //addr -= 0x2000;\r\n        if (addr < 0xD000) // WRAM lo bank\r\n            return this.WRAM[addr & 0xFFF];\r\n        if (addr < 0xE000) // WRAM hi bank\r\n            return this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset];\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.read_OAM(addr);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_read_IO(addr, val);\r\n        if (addr < 0xFFFF) {// HRAM always accessible\r\n            return this.HRAM[addr - 0xFF80];\r\n        }\r\n        return this.bus.CPU_read_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    // Update ROM banks\r\n    update_banks(): void {\r\n        if (this.regs.banking_mode === 0) {\r\n            // Mode 0, easy-mode\r\n            this.ROM_bank_lo_offset = 0;\r\n            this.cartRAM_offset = 0;\r\n        } else {\r\n            // Mode 1, hard-mode!\r\n            this.ROM_bank_lo_offset = ((32 * this.regs.BANK2) % this.num_ROM_banks) * 16384;\r\n            if (this.num_RAM_banks > 0)\r\n                this.cartRAM_offset = (this.regs.BANK2 % this.num_RAM_banks) * 8192;\r\n        }\r\n        this.ROM_bank_hi_offset = (((this.regs.BANK2 << 5) | this.regs.BANK1) % this.num_ROM_banks) * 16384;\r\n    }\r\n\r\n    CPU_write(addr: u32, val: u32): void {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (addr < 0x8000) {\r\n            switch (addr & 0xE000) {\r\n                case 0x0000: // RAM write enable\r\n                    this.regs.ext_RAM_enable = +((val & 0x0F) === 0x0A);\r\n                    return;\r\n                case 0x2000: // ROM bank number\r\n                    val &= 0x1F; // 5 bits\r\n                    if (val === 0) val = 1; // can't be 0\r\n                    this.regs.BANK1 = val;\r\n                    this.update_banks();\r\n                    return;\r\n                case 0x4000: // RAM or ROM banks...\r\n                    this.regs.BANK2 = val & 3;\r\n                    this.update_banks();\r\n                    return;\r\n                case 0x6000: // Control\r\n                    this.regs.banking_mode = val & 1;\r\n                    this.update_banks();\r\n                    return;\r\n            }\r\n        }\r\n        if (addr < 0xA000) { // VRAM\r\n            if (this.clock.CPU_can_VRAM)\r\n                this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xC000) { // cart RAM\r\n            if ((!this.has_RAM) || (!this.regs.ext_RAM_enable)) return;\r\n            this.cartRAM[((addr - 0xA000) & this.RAM_mask) + this.cartRAM_offset] = <u8>val;\r\n            return;\r\n        }\r\n        // adjust address for mirroring\r\n        if ((addr > 0xE000) && (addr < 0xFE00)) return; //addr -= 0x2000;\r\n\r\n        if (addr < 0xD000) { // WRAM lo bank\r\n            this.WRAM[addr & 0xFFF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xE000) { // WRAM hi bank\r\n            this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.write_OAM(addr, val);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_write_IO(addr, val);\r\n        if (addr < 0xFFFF) { // HRAM always accessible\r\n            //console.log('WRITE', hex4(addr), hex2(val))\r\n            this.HRAM[addr - 0xFF80] = <u8>val;\r\n            return;\r\n        }\r\n        this.bus.CPU_write_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    PPU_read(addr: u32): u32 {\r\n        if ((addr < 0x8000) || (addr > 0x9FFF)) return 0xFF;\r\n        return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n    }\r\n\r\n    set_cart(cart: GB_cart, BIOS: Uint8Array): void {\r\n        console.log('Loading MBC1 cart')\r\n        this.cart = cart;\r\n        this.BIOS = new StaticArray<u8>(BIOS.byteLength);\r\n        for (let i = 0, k = BIOS.byteLength; i < k; i++) {\r\n            this.BIOS[i] = BIOS[i];\r\n        }\r\n\r\n        this.BIOS_big = +(BIOS.byteLength > 256);\r\n\r\n        this.ROM = new StaticArray<u8>(cart.header.ROM_size);\r\n        for (let i: u32 = 0, k: u32 = cart.header.ROM_size; i < k; i++) {\r\n            this.ROM[i] = cart.ROM[i];\r\n        }\r\n\r\n        this.cartRAM = new StaticArray<u8>(cart.header.RAM_size);\r\n        this.num_RAM_banks = (cart.header.RAM_size / 8192);\r\n        console.log('Cart RAM banks ' + this.num_RAM_banks.toString());\r\n        this.RAM_mask = cart.header.RAM_mask;\r\n        console.log('RAM mask ' + hex4(this.RAM_mask));\r\n        this.has_RAM = cart.header.RAM_size > 0;\r\n        this.num_ROM_banks = cart.header.ROM_size / 16384;\r\n        console.log('NUMBER OF ROM BANKS ' + this.num_ROM_banks.toString());\r\n    }\r\n}","import {GB_mapper} from \"./interface\";\r\nimport {GB_bus, GB_clock} from \"../gb\";\r\nimport {GB_cart} from \"../gb_cart\";\r\nimport {GB_variants} from \"../gb_common\";\r\n\r\nclass GB_mapper_MBC2_regs {\r\n    ROMB: u32 = 1\r\n    BANK1: u32 = 1;\r\n    BANK2: u32 = 0;\r\n    ext_RAM_enable: u32 = 0;\r\n    cartRAM_bank: u32 = 0;\r\n}\r\n\r\nexport class GB_mapper_MBC2 implements GB_mapper {\r\n    clock: GB_clock\r\n    bus: GB_bus\r\n    ROM: StaticArray<u8> = new StaticArray<u8>(0)\r\n    BIOS_big: u32 = 0;\r\n    ROM_bank_lo_offset: u32 = 0;\r\n    ROM_bank_hi_offset: u32 = 16384;\r\n    VRAM_bank_offset: u32 = 0;\r\n    WRAM_bank_offset: u32 = 0x1000;\r\n\r\n    cartRAM: StaticArray<u8> = new StaticArray<u8>(512)\r\n    cartRAM_offset: u32 = 0;\r\n    WRAM: StaticArray<u8> = new StaticArray<u8>(8192*8)\r\n    HRAM: StaticArray<u8> = new StaticArray<u8>(128)\r\n    VRAM: StaticArray<u8> = new StaticArray<u8>(32768);\r\n    BIOS: StaticArray<u8> = new StaticArray<u8>(0);\r\n    \r\n    cart: GB_cart\r\n    num_ROM_banks: u32 = 0;\r\n    regs: GB_mapper_MBC2_regs = new GB_mapper_MBC2_regs();\r\n\r\n    RAM_mask: u32 = 0x1FF\r\n\r\n    constructor(clock: GB_clock, bus: GB_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n\r\n        this.cart = new GB_cart(GB_variants.DMG, clock, bus);\r\n        this.bus.mapper = this;\r\n    }\r\n\r\n    reset(): void {\r\n        // This changes on other mappers for banking\r\n        this.ROM_bank_lo_offset = 0;\r\n        this.ROM_bank_hi_offset = 16384;\r\n        this.cartRAM_offset = 0;\r\n        this.regs.BANK1 = 1;\r\n        this.regs.BANK2 = 0;\r\n        this.regs.ext_RAM_enable = 0;\r\n        this.regs.cartRAM_bank = 0;\r\n        // This changes on CGB\r\n        this.VRAM_bank_offset = 0;\r\n        // This changes on CGB\r\n        this.WRAM_bank_offset = 0x1000;\r\n        this.update_banks();\r\n    }\r\n\r\n    CPU_read(addr: u32, val: u32): u32 {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (this.clock.bootROM_enabled) {\r\n            if (addr < 0x100)\r\n                return this.bus.BIOS[addr];\r\n            if (this.BIOS_big && (addr >= 0x200) && (addr < 0x900))\r\n                return this.bus.BIOS[addr - 0x100];\r\n        }\r\n        if (addr < 0x4000) // ROM lo bank\r\n            return this.ROM[addr + this.ROM_bank_lo_offset];\r\n        if (addr < 0x8000) // ROM hi bank\r\n            return this.ROM[(addr & 0x3FFF) + this.ROM_bank_hi_offset];\r\n        if (addr < 0xA000) { // VRAM, banked\r\n            if (this.clock.CPU_can_VRAM)\r\n                return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n            return 0xFF;\r\n        } // cart RAM if it's there\r\n        if (addr < 0xC000) {\r\n            if (!this.regs.ext_RAM_enable)\r\n                return 0xFF;\r\n            return this.cartRAM[addr & 0x1FF] | 0xF0;\r\n        }\r\n        // Adjust address for mirroring\r\n        //if ((addr > 0xE000) && (addr < 0xFE00)) return 0xFF; //addr -= 0x2000;\r\n\r\n        if (addr < 0xD000) // WRAM lo bank\r\n            return this.WRAM[addr & 0xFFF];\r\n        if (addr < 0xE000) // WRAM hi bank\r\n            return this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset];\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.read_OAM(addr);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_read_IO(addr, val);\r\n        if (addr < 0xFFFF) {// HRAM always accessible\r\n            return this.HRAM[addr - 0xFF80];\r\n        }\r\n        return this.bus.CPU_read_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    // Update ROM banks\r\n    update_banks(): void {\r\n        this.ROM_bank_lo_offset = 0;\r\n        this.ROM_bank_hi_offset = (this.regs.ROMB % this.num_ROM_banks) * 16384;\r\n    }\r\n\r\n    CPU_write(addr: u32, val: u32): void {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (addr < 0x4000) {\r\n            switch (addr & 0x100) {\r\n                case 0x0000: // RAM write enable\r\n                    this.regs.ext_RAM_enable = +((val & 0x0F) === 0x0A);\r\n                    return;\r\n                case 0x0100: // ROM bank number\r\n                    val &= 0x0F; // 5 bits\r\n                    if (val === 0) val = 1; // can't be 0\r\n                    this.regs.ROMB = val;\r\n                    this.update_banks();\r\n                    return;\r\n            }\r\n        }\r\n        if (addr < 0xA000) { // VRAM\r\n            if (this.clock.CPU_can_VRAM)\r\n                this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xC000) { // cart RAM\r\n            if (this.regs.ext_RAM_enable) this.cartRAM[addr & 0x1FF] = <u8>(val & 0x0F);\r\n            return;\r\n        }\r\n        // adjust address for mirroring\r\n        //if ((addr > 0xE000) && (addr < 0xFE00)) return; //addr -= 0x2000;\r\n\r\n        if (addr < 0xD000) { // WRAM lo bank\r\n            this.WRAM[addr & 0xFFF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xE000) { // WRAM hi bank\r\n            this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.write_OAM(addr, val);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_write_IO(addr, val);\r\n        if (addr < 0xFFFF) { // HRAM always accessible\r\n            this.HRAM[addr - 0xFF80] = <u8>val;\r\n            return;\r\n        }\r\n        this.bus.CPU_write_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    PPU_read(addr: u32): u32 {\r\n        if ((addr < 0x8000) || (addr > 0x9FFF)) return 0xFF;\r\n        return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n    }\r\n\r\n    set_cart(cart: GB_cart, BIOS: Uint8Array): void {\r\n        console.log('Loading MBC2 cart')\r\n        this.cart = cart;\r\n        this.BIOS = new StaticArray<u8>(BIOS.byteLength);\r\n        for (let i = 0, k = BIOS.byteLength; i < k; i++) {\r\n            this.BIOS[i] = BIOS[i];\r\n        }\r\n        this.BIOS_big = +(BIOS.byteLength > 256);\r\n        this.ROM = new StaticArray<u8>(cart.header.ROM_size);\r\n        for (let i: u32 = 0, k: u32 = cart.header.ROM_size; i < k; i++) {\r\n            this.ROM[i] = cart.ROM[i];\r\n        }\r\n        this.cartRAM = new StaticArray<u8>(cart.header.RAM_size);\r\n        this.num_ROM_banks = cart.header.ROM_size / 16384;\r\n        this.RAM_mask = 0x1FF;\r\n    }\r\n}\r\n","import {GB_mapper} from \"./interface\";\r\nimport {GB_bus, GB_clock} from \"../gb\";\r\nimport {GB_cart} from \"../gb_cart\";\r\nimport {GB_variants} from \"../gb_common\";\r\n\r\nclass GB_mapper_MBC5_regs {\r\n    ROMB0: u32 = 0\r\n    ROMB1: u32 = 0\r\n    RAMB: u32 = 0\r\n    ext_RAM_enable: u32 = 0\r\n}\r\n\r\nexport class GB_mapper_MBC5 implements GB_mapper {\r\n    clock: GB_clock\r\n    bus: GB_bus\r\n    ROM: StaticArray<u8> = new StaticArray<u8>(0)\r\n    BIOS_big: u32 = 0;\r\n\r\n    ROM_bank_lo_offset: u32 = 0;\r\n    ROM_bank_hi_offset: u32 = 16384;\r\n    VRAM_bank_offset: u32 = 0;\r\n    WRAM_bank_offset: u32 = 0x1000;\r\n\r\n    cartRAM: StaticArray<u8> = new StaticArray<u8>(0)\r\n    cartRAM_offset: u32 = 0;\r\n    WRAM: StaticArray<u8> = new StaticArray<u8>(8192*8)\r\n    HRAM: StaticArray<u8> = new StaticArray<u8>(128)\r\n    VRAM: StaticArray<u8> = new StaticArray<u8>(32768);\r\n    BIOS: StaticArray<u8> = new StaticArray<u8>(0);\r\n    has_RAM: bool = false\r\n    RAM_mask: u32 = 0\r\n\r\n    cart: GB_cart\r\n\r\n    num_ROM_banks: u32 = 0;\r\n    num_RAM_banks: u32 = 0;\r\n\r\n    regs: GB_mapper_MBC5_regs = new GB_mapper_MBC5_regs()\r\n\r\n    constructor(clock:GB_clock, bus: GB_bus) {\r\n        this.clock = clock;\r\n        this.bus = bus;\r\n\r\n        this.cart = new GB_cart(GB_variants.DMG, clock, bus);\r\n        this.bus.mapper = this;\r\n    }\r\n\r\n    reset(): void {\r\n        // This changes on other mappers for banking\r\n        this.ROM_bank_lo_offset = 0;\r\n        this.ROM_bank_hi_offset = 16384;\r\n        this.cartRAM_offset = 0;\r\n        this.regs.ROMB0 = 1;\r\n        this.regs.ROMB1 = 0;\r\n        this.regs.ext_RAM_enable = 0;\r\n        this.regs.RAMB = 0;\r\n        // This changes on CGB\r\n        this.VRAM_bank_offset = 0;\r\n        // This changes on CGB\r\n        this.WRAM_bank_offset = 0x1000;\r\n        this.update_banks();\r\n    }\r\n\r\n    CPU_read(addr: u32, val: u32): u32 {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (this.clock.bootROM_enabled) {\r\n            if (addr < 0x100)\r\n                return this.bus.BIOS[addr];\r\n            if (this.BIOS_big && (addr >= 0x200) && (addr < 0x900))\r\n                return this.bus.BIOS[addr - 0x100];\r\n        }\r\n        if (addr < 0x4000) // ROM lo bank\r\n            return this.ROM[addr + this.ROM_bank_lo_offset];\r\n        if (addr < 0x8000) // ROM hi bank\r\n            return this.ROM[(addr & 0x3FFF) + this.ROM_bank_hi_offset];\r\n        if (addr < 0xA000) { // VRAM, banked\r\n            if (this.clock.CPU_can_VRAM)\r\n                return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n            return 0xFF;\r\n        } // cart RAM if it's there\r\n        if (addr < 0xC000) {\r\n            if ((!this.has_RAM) || (!this.regs.ext_RAM_enable))\r\n                return 0xFF;\r\n            return this.cartRAM[((addr - 0xA000) & this.RAM_mask) + this.cartRAM_offset];\r\n        }\r\n        if (addr < 0xD000) // WRAM lo bank\r\n            return this.WRAM[addr & 0xFFF];\r\n        if (addr < 0xE000) // WRAM hi bank\r\n            return this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset];\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.read_OAM(addr);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_read_IO(addr, val);\r\n        if (addr < 0xFFFF) // HRAM always accessible\r\n            return this.HRAM[addr - 0xFF80];\r\n        return this.bus.CPU_read_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    // Update ROM banks\r\n    update_banks(): void {\r\n        if (this.num_RAM_banks > 0)\r\n            this.cartRAM_offset = (this.regs.RAMB % this.num_RAM_banks) * 8192;\r\n        this.ROM_bank_lo_offset = 0;\r\n        this.ROM_bank_hi_offset = (((this.regs.ROMB1 << 8) | this.regs.ROMB0) % this.num_ROM_banks) * 16384;\r\n    }\r\n\r\n    CPU_write(addr: u32, val: u32): void {\r\n        if ((addr >= 0xE000) && (addr < 0xFE00)) addr -= 0x2000; // WRAM mirror\r\n        if (addr < 0x8000) {\r\n            switch(addr & 0xF000) {\r\n                case 0x0000: // RAM write enable\r\n                case 0x1000:\r\n                    this.regs.ext_RAM_enable = +(val === 0x0A);\r\n                    return;\r\n                case 0x2000: // ROM bank number0\r\n                    this.regs.ROMB0 = val;\r\n                    this.update_banks();\r\n                    return;\r\n                case 0x3000: // ROM bank number1, 1 bit\r\n                    this.regs.ROMB1 = val & 1;\r\n                    this.update_banks();\r\n                    return;\r\n                case 0x4000: // RAMB bank number, 4 bits\r\n                case 0x5000:\r\n                    if (this.cart.header.rumble_present)\r\n                        this.regs.RAMB = val & 0x07;\r\n                    else\r\n                        this.regs.RAMB = val & 0x0F;\r\n                    this.update_banks();\r\n                    return;\r\n            }\r\n        }\r\n        if (addr < 0xA000) { // VRAM\r\n            if (this.clock.CPU_can_VRAM)\r\n                this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xC000) { // cart RAM\r\n            if (this.has_RAM && this.regs.ext_RAM_enable)\r\n                this.cartRAM[((addr - 0xA000) & this.RAM_mask) + this.cartRAM_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xD000) { // WRAM lo bank\r\n            this.WRAM[addr & 0xFFF] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xE000) { // WRAM hi bank\r\n            this.WRAM[(addr & 0xFFF) + this.WRAM_bank_offset] = <u8>val;\r\n            return;\r\n        }\r\n        if (addr < 0xFF00) // OAM\r\n            return this.bus.ppu!.write_OAM(addr, val);\r\n        if (addr < 0xFF80) // registers\r\n            return this.bus.CPU_write_IO(addr, val);\r\n        if (addr < 0xFFFF) { // HRAM always accessible\r\n            this.HRAM[addr - 0xFF80] = <u8>val;\r\n            return;\r\n        }\r\n        this.bus.CPU_write_IO(addr, val); // 0xFFFF register\r\n    }\r\n\r\n    PPU_read(addr: u32): u32 {\r\n        if ((addr < 0x8000) || (addr > 0x9FFF)) return 0xFF;\r\n        return this.VRAM[(addr & 0x1FFF) + this.VRAM_bank_offset];\r\n    }\r\n\r\n    set_cart(cart: GB_cart, BIOS: Uint8Array): void {\r\n        console.log('Loading MBC5 cart');\r\n        this.cart = cart;\r\n        this.BIOS = new StaticArray<u8>(BIOS.byteLength);\r\n        for (let i = 0, k = BIOS.byteLength; i < k; i++) {\r\n            this.BIOS[i] = BIOS[i];\r\n        }\r\n        this.BIOS_big = +(BIOS.byteLength > 256);\r\n        this.ROM = new StaticArray<u8>(cart.header.ROM_size);\r\n        for (let i: u32 = 0, k: u32 = cart.header.ROM_size; i < k; i++) {\r\n            this.ROM[i] = cart.ROM[i];\r\n        }\r\n        this.cartRAM = new StaticArray<u8>(cart.header.RAM_size);\r\n        this.num_RAM_banks = (cart.header.RAM_size / 8192);\r\n        this.num_ROM_banks = cart.header.ROM_size / 16384;\r\n        this.RAM_mask = cart.header.RAM_mask;\r\n        this.has_RAM = cart.header.RAM_size > 0;\r\n    }\r\n}\r\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}