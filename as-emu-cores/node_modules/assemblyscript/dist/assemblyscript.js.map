{
  "version": 3,
  "sources": ["../src/index-js.ts", "../std/portable/index.js", "../lib/binaryen.js", "../src/glue/binaryen.js", "../src/glue/js/float.js", "../src/glue/js/i64.js", "../src/glue/js/collections.js", "../std/assembly/shared/feature.ts", "../std/assembly/shared/target.ts", "../std/assembly/shared/runtime.ts", "../std/assembly/shared/typeinfo.ts", "../src/common.ts", "../src/diagnosticMessages.generated", "../src/util.ts", "../src/util/binary.ts", "../src/util/collections.ts", "../src/util/math.ts", "../src/util/text.ts", "../src/util/path.ts", "../src/util/terminal.ts", "../src/util/vector.ts", "../src/diagnostics.ts", "../src/ast.ts", "../src/tokenizer.ts", "../src/module.ts", "../src/flow.ts", "../src/resolver.ts", "../src/parser.ts", "../src/program.ts", "../src/types.ts", "../src/builtins.ts", "../src/passes/pass.ts", "../src/passes/rtrace.ts", "../src/passes/shadowstack.ts", "../src/bindings/util.ts", "../src/bindings/js.ts", "../src/compiler.ts", "../src/bindings/tsd.ts", "../src/index-wasm.ts", "../src/extra/ast.ts", "../src/index.ts"],
  "sourcesContent": ["import \"./glue/js/index\";\nexport * from \"./index-wasm\";\n\n// Full API\nexport * from \"./ast\";\nexport * from \"./common\";\nexport * from \"./compiler\";\nexport * from \"./bindings\";\nexport * from \"./diagnostics\";\nexport * from \"./flow\";\nexport * from \"./module\";\nexport * from \"./parser\";\nexport * from \"./program\";\nexport * from \"./resolver\";\nexport * from \"./tokenizer\";\nexport * from \"./types\";\nexport * from \"./extra/ast\";\nimport * as util from \"./util\";\nexport { util };\n", "/** @module std/portable *//***/\n\nlet globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\nif (typeof globalScope.ASC_TARGET === \"undefined\") {\n\n  globalScope.ASC_TARGET = 0; // Target.JS\n  globalScope.ASC_RUNTIME = 0; // Runtime.Stub\n  globalScope.ASC_NO_ASSERT = false;\n  globalScope.ASC_MEMORY_BASE = 0;\n  globalScope.ASC_OPTIMIZE_LEVEL = 3;\n  globalScope.ASC_SHRINK_LEVEL = 0;\n  globalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;\n  globalScope.ASC_FEATURE_SIGN_EXTENSION = false;\n  globalScope.ASC_FEATURE_BULK_MEMORY = false;\n  globalScope.ASC_FEATURE_SIMD = false;\n  globalScope.ASC_FEATURE_THREADS = false;\n\n  let F64 = new Float64Array(1);\n  let U64 = new Uint32Array(F64.buffer);\n\n  Object.defineProperties(\n    globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; },\n    {\n      \"MIN_VALUE\": { value: -128 },\n      \"MAX_VALUE\": { value:  127 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; },\n    {\n      \"MIN_VALUE\": { value: -32768 },\n      \"MAX_VALUE\": { value:  32767 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; },\n    {\n      \"MIN_VALUE\": { value: -2147483648 },\n      \"MAX_VALUE\": { value:  2147483647 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u8\"] = function u8(value) { return value & 0xff; },\n    {\n      \"MIN_VALUE\": { value:   0 },\n      \"MAX_VALUE\": { value: 255 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u16\"] = function u16(value) { return value & 0xffff; },\n    {\n      \"MIN_VALUE\": { value:     0 },\n      \"MAX_VALUE\": { value: 65535 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; },\n    {\n      \"MIN_VALUE\": { value:          0 },\n      \"MAX_VALUE\": { value: 4294967295 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"bool\"] = function bool(value) { return !!value; },\n    {\n      \"MIN_VALUE\": { value: false },\n      \"MAX_VALUE\": { value: true }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f32\"] = function f32(value) { return Math.fround(value); },\n    {\n      \"EPSILON\":   { value: 1.1920928955078125e-07 },\n      \"MIN_VALUE\": { value: 1.401298464324817e-45 },\n      \"MAX_VALUE\": { value: 3.4028234663852886e+38 },\n      \"MIN_NORMAL_VALUE\":  { value:  1.1754943508222875e-38 },\n      \"MIN_SAFE_INTEGER\":  { value: -16777215 },\n      \"MAX_SAFE_INTEGER\":  { value:  16777215 },\n      \"POSITIVE_INFINITY\": { value:  Infinity },\n      \"NEGATIVE_INFINITY\": { value: -Infinity },\n      \"NaN\": { value: NaN }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f64\"] = function f64(value) { return +value; },\n    {\n      \"EPSILON\":   { value: 2.2204460492503131e-016 },\n      \"MIN_VALUE\": { value:                  5e-324 },\n      \"MAX_VALUE\": { value: 1.7976931348623157e+308 },\n      \"MIN_NORMAL_VALUE\":  { value:  2.2250738585072014e-308 },\n      \"MIN_SAFE_INTEGER\":  { value: -9007199254740991 },\n      \"MAX_SAFE_INTEGER\":  { value:  9007199254740991 },\n      \"POSITIVE_INFINITY\": { value:  Infinity },\n      \"NEGATIVE_INFINITY\": { value: -Infinity },\n      \"NaN\": { value: NaN }\n    }\n  );\n\n  globalScope[\"clz\"] = Math.clz32;\n\n  globalScope[\"ctz\"] = function ctz(value) {\n    return 32 - Math.clz32(~value & (value - 1));\n  };\n\n  globalScope[\"popcnt\"] = function popcnt(value) {\n    value -= value >>> 1 & 0x55555555;\n    value = (value & 0x33333333) + (value >>> 2 & 0x33333333);\n    return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\n  };\n\n  globalScope[\"rotl\"] = function rotl(value, shift) {\n    shift &= 31;\n    return (value << shift) | (value >>> (32 - shift));\n  };\n\n  globalScope[\"rotr\"] = function rotr(value, shift) {\n    shift &= 31;\n    return (value >>> shift) | (value << (32 - shift));\n  };\n\n  globalScope[\"abs\"] = Math.abs;\n\n  globalScope[\"max\"] = Math.max;\n\n  globalScope[\"min\"] = Math.min;\n\n  globalScope[\"ceil\"] = Math.ceil;\n\n  globalScope[\"floor\"] = Math.floor;\n\n  globalScope[\"nearest\"] = function nearest(value) {\n    const INV_EPS64 = 4503599627370496.0;\n    const y = Math.abs(value);\n    return y < INV_EPS64\n      ? (y + INV_EPS64 - INV_EPS64) * Math.sign(value)\n      : value;\n  };\n\n  globalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\n    return condition ? ifTrue : ifFalse;\n  };\n\n  globalScope[\"sqrt\"] = Math.sqrt;\n\n  globalScope[\"trunc\"] = Math.trunc;\n\n  globalScope[\"copysign\"] = function copysign(x, y) {\n    return y\n      ? Math.abs(x) * Math.sign(y)\n      : (F64[0] = y, U64[1] >>> 31 ? -1 : 1); // +0, -0, -NaN, +NaN\n  };\n\n  globalScope[\"bswap\"] = function bswap(value) {\n    let a = value >> 8 & 0x00FF00FF;\n    let b = (value & 0x00FF00FF) << 8;\n    value = a | b;\n    a = value >> 16 & 0x0000FFFF;\n    b = (value & 0x0000FFFF) << 16;\n    return a | b;\n  };\n\n  function UnreachableError() {\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnreachableError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  UnreachableError.prototype = Object.create(Error.prototype);\n  UnreachableError.prototype.name = \"UnreachableError\";\n  UnreachableError.prototype.message = \"unreachable\";\n\n  globalScope[\"unreachable\"] = function unreachable() {\n    throw new UnreachableError();\n  };\n\n  function AssertionError(message) {\n    this.message = message || \"assertion failed\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  AssertionError.prototype = Object.create(Error.prototype);\n  AssertionError.prototype.name = \"AssertionError\";\n\n  globalScope[\"assert\"] = function assert(isTrueish, message) {\n    if (isTrueish) return isTrueish;\n    throw new AssertionError(message);\n  };\n\n  globalScope[\"changetype\"] = function changetype(value) {\n    return value;\n  };\n\n  String[\"fromCharCodes\"] = function fromCharCodes(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCharCode.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCharCode.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  String[\"fromCodePoints\"] = function fromCodePoints(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCodePoint.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCodePoint.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  if (!String.prototype.at) {\n    Object.defineProperty(String.prototype, \"at\", {\n      value: function at(index) {\n        return this.charAt(index >= 0 ? index : index + this.length);\n      },\n      configurable: true\n    });\n  }\n\n  if (!String.prototype.replaceAll) {\n    Object.defineProperty(String.prototype, \"replaceAll\", {\n      value: function replaceAll(search, replacment) {\n        let res = this.split(search).join(replacment);\n        if (!search.length) res = replacment + res + replacment;\n        return res;\n      },\n      configurable: true\n    });\n  }\n\n  function defaultComparator(a, b) {\n    if (a == b) {\n      if (a != 0) return 0;\n      a = 1 / a, b = 1 / b;\n    } else {\n      let nanA = a != a, nanB = b != b;\n      if (nanA | nanB) return nanA - nanB;\n      if (a == null) a = String(a);\n      if (b == null) b = String(b);\n    }\n    return a > b ? 1 : -1;\n  }\n\n  const arraySort = Array.prototype.sort;\n  Array.prototype.sort = function sort(comparator) {\n    return arraySort.call(this, comparator || defaultComparator);\n  };\n\n  [ Array,\n    Uint8ClampedArray,\n    Uint8Array, Int8Array,\n    Uint16Array, Int16Array,\n    Uint32Array, Int32Array,\n    Float32Array, Float64Array\n  ].forEach(Ctr => {\n    if (!Ctr.prototype.at) {\n      Object.defineProperty(Ctr.prototype, \"at\", {\n        value: function at(index) {\n          return this[index >= 0 ? index : index + this.length];\n        },\n        configurable: true\n      });\n    }\n\n    if (!Ctr.prototype.findLastIndex) {\n      Object.defineProperty(Ctr.prototype, \"findLastIndex\", {\n        value: function findLastIndex(fn) {\n          for (let i = this.length - 1; i >= 0; --i) {\n            if (fn(this[i], i, this)) return i;\n          }\n          return -1;\n        },\n        configurable: true\n      });\n    }\n\n    if (Ctr != Array) {\n      Object.defineProperty(Ctr, \"wrap\", {\n        value: function wrap(buffer, byteOffset, length) {\n          return new Ctr(buffer, byteOffset, length);\n        },\n        configurable: true\n      });\n    }\n  });\n\n  globalScope[\"isInteger\"] = Number.isInteger;\n\n  globalScope[\"isFloat\"] = function isFloat(arg) {\n    return typeof arg === \"number\";\n  };\n\n  globalScope[\"isNullable\"] = function isNullable(arg) {\n    return true;\n  };\n\n  globalScope[\"isReference\"] = function isReference(arg) {\n    return typeof arg === \"object\" || typeof arg === \"string\";\n  };\n\n  globalScope[\"isFunction\"] = function isFunction(arg) {\n    return typeof arg === \"function\";\n  };\n\n  globalScope[\"isString\"] = function isString(arg) {\n    return typeof arg === \"string\" || arg instanceof String;\n  };\n\n  globalScope[\"isArray\"] = Array.isArray;\n  globalScope[\"isArrayLike\"] = function isArrayLike(expr) {\n    return expr\n      && typeof expr === 'object'\n      && typeof expr.length === 'number'\n      && expr.length >= 0\n      && Math.trunc(expr.length) === expr.length;\n  };\n\n  globalScope[\"isDefined\"] = function isDefined(expr) {\n    return typeof expr !== \"undefined\";\n  };\n\n  globalScope[\"isConstant\"] = function isConstant(expr) {\n    return false;\n  };\n\n  globalScope[\"unchecked\"] = function unchecked(expr) {\n    return expr;\n  };\n\n  globalScope[\"fmod\"] = function fmod(x, y) {\n    return x % y;\n  };\n\n  globalScope[\"fmodf\"] = function fmodf(x, y) {\n    return Math.fround(x % y);\n  };\n\n  globalScope[\"JSMath\"] = Math;\n\n  Object.defineProperties(globalScope[\"JSMath\"], {\n    sincos_sin: { value: 0.0, writable: true },\n    sincos_cos: { value: 0.0, writable: true },\n    signbit: {\n      value: function signbit(x) {\n        F64[0] = x; return Boolean(U64[1] >>> 31);\n      }\n    },\n    sincos: {\n      value: function sincos(x) {\n        this.sincos_sin = Math.sin(x);\n        this.sincos_cos = Math.cos(x);\n      }\n    },\n    exp2: {\n      value: function exp2(x) {\n        return Math.pow(2, x);\n      }\n    }\n  });\n\n  globalScope[\"unmanaged\"] = function() { /* nop */ };\n\n  globalScope[\"trace\"] = function(message, n) {\n    if (n) message += Array.prototype.slice.call(arguments, 2, 2 + n);\n    console.error(\"trace: \" + message);\n  };\n} else {\n  console.warn(\"compiler mismatch: std/portable included twice\");\n}\n", "export * from \"binaryen\";\nexport { default } from \"binaryen\";\n", "/**\n * @fileoverview Binaryen glue code for JavaScript.\n * @license Apache-2.0\n */\n\nimport binaryen from \"../../lib/binaryen.js\";\n\nexport const {\n  _BinaryenTypeCreate,\n  _BinaryenTypeArity,\n  _BinaryenTypeExpand,\n  _BinaryenTypeGetHeapType,\n  _BinaryenTypeFromHeapType,\n  _BinaryenTypeIsNullable,\n\n  _BinaryenTypeFuncref,\n  _BinaryenTypeExternref,\n  _BinaryenTypeAnyref,\n  _BinaryenTypeEqref,\n  _BinaryenTypeI31ref,\n  _BinaryenTypeDataref,\n  _BinaryenTypeArrayref,\n  _BinaryenTypeStringref,\n  _BinaryenTypeStringviewWTF8,\n  _BinaryenTypeStringviewWTF16,\n  _BinaryenTypeStringviewIter,\n  _BinaryenTypeNullref,\n  _BinaryenTypeNullExternref,\n  _BinaryenTypeNullFuncref,\n\n  _BinaryenHeapTypeFunc,\n  _BinaryenHeapTypeExt,\n  _BinaryenHeapTypeAny,\n  _BinaryenHeapTypeEq,\n  _BinaryenHeapTypeI31,\n  _BinaryenHeapTypeData,\n  _BinaryenHeapTypeArray,\n  _BinaryenHeapTypeString,\n  _BinaryenHeapTypeStringviewWTF8,\n  _BinaryenHeapTypeStringviewWTF16,\n  _BinaryenHeapTypeStringviewIter,\n  _BinaryenHeapTypeNone,\n  _BinaryenHeapTypeNoext,\n  _BinaryenHeapTypeNofunc,\n\n  _BinaryenHeapTypeIsBasic,\n  _BinaryenHeapTypeIsSignature,\n  _BinaryenHeapTypeIsStruct,\n  _BinaryenHeapTypeIsArray,\n  _BinaryenHeapTypeIsBottom,\n  _BinaryenHeapTypeGetBottom,\n  _BinaryenHeapTypeIsSubType,\n  _BinaryenStructTypeGetNumFields,\n  _BinaryenStructTypeGetFieldType,\n  _BinaryenStructTypeGetFieldPackedType,\n  _BinaryenStructTypeIsFieldMutable,\n  _BinaryenArrayTypeGetElementType,\n  _BinaryenArrayTypeGetElementPackedType,\n  _BinaryenArrayTypeIsElementMutable,\n  _BinaryenSignatureTypeGetParams,\n  _BinaryenSignatureTypeGetResults,\n\n  _BinaryenModuleCreate,\n  _BinaryenModuleDispose,\n\n  _BinaryenSizeofLiteral,\n  _BinaryenLiteralInt32,\n  _BinaryenLiteralInt64,\n  _BinaryenLiteralFloat32,\n  _BinaryenLiteralFloat64,\n  _BinaryenLiteralVec128,\n  _BinaryenLiteralFloat32Bits,\n  _BinaryenLiteralFloat64Bits,\n\n  _BinaryenExpressionGetId,\n  _BinaryenExpressionGetType,\n  _BinaryenExpressionSetType,\n  _BinaryenExpressionPrint,\n  _BinaryenExpressionCopy,\n  _BinaryenExpressionFinalize,\n\n  _BinaryenBlock,\n  _BinaryenBlockGetName,\n  _BinaryenBlockSetName,\n  _BinaryenBlockGetNumChildren,\n  _BinaryenBlockGetChildAt,\n  _BinaryenBlockSetChildAt,\n  _BinaryenBlockAppendChild,\n  _BinaryenBlockInsertChildAt,\n  _BinaryenBlockRemoveChildAt,\n\n  _BinaryenIf,\n  _BinaryenIfGetCondition,\n  _BinaryenIfSetCondition,\n  _BinaryenIfGetIfTrue,\n  _BinaryenIfSetIfTrue,\n  _BinaryenIfGetIfFalse,\n  _BinaryenIfSetIfFalse,\n\n  _BinaryenLoop,\n  _BinaryenLoopGetName,\n  _BinaryenLoopSetName,\n  _BinaryenLoopGetBody,\n  _BinaryenLoopSetBody,\n\n  _BinaryenBreak,\n  _BinaryenBreakGetName,\n  _BinaryenBreakSetName,\n  _BinaryenBreakGetCondition,\n  _BinaryenBreakSetCondition,\n  _BinaryenBreakGetValue,\n  _BinaryenBreakSetValue,\n\n  _BinaryenSwitch,\n  _BinaryenSwitchGetNumNames,\n  _BinaryenSwitchGetNameAt,\n  _BinaryenSwitchSetNameAt,\n  _BinaryenSwitchAppendName,\n  _BinaryenSwitchInsertNameAt,\n  _BinaryenSwitchRemoveNameAt,\n  _BinaryenSwitchGetDefaultName,\n  _BinaryenSwitchSetDefaultName,\n  _BinaryenSwitchGetCondition,\n  _BinaryenSwitchSetCondition,\n  _BinaryenSwitchGetValue,\n  _BinaryenSwitchSetValue,\n\n  _BinaryenCall,\n  _BinaryenCallGetTarget,\n  _BinaryenCallSetTarget,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallSetOperandAt,\n  _BinaryenCallAppendOperand,\n  _BinaryenCallInsertOperandAt,\n  _BinaryenCallRemoveOperandAt,\n  _BinaryenCallIsReturn,\n  _BinaryenCallSetReturn,\n  _BinaryenReturnCall,\n\n  _BinaryenCallIndirect,\n  _BinaryenCallIndirectGetTable,\n  _BinaryenCallIndirectSetTable,\n  _BinaryenCallIndirectGetTarget,\n  _BinaryenCallIndirectSetTarget,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenCallIndirectAppendOperand,\n  _BinaryenCallIndirectInsertOperandAt,\n  _BinaryenCallIndirectRemoveOperandAt,\n  _BinaryenCallIndirectIsReturn,\n  _BinaryenCallIndirectSetReturn,\n  _BinaryenReturnCallIndirect,\n\n  _BinaryenLocalGet,\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalGetSetIndex,\n\n  _BinaryenLocalSet,\n  _BinaryenLocalSetIsTee,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenLocalSetSetIndex,\n  _BinaryenLocalSetGetValue,\n  _BinaryenLocalSetSetValue,\n  _BinaryenLocalTee,\n\n  _BinaryenGlobalGet,\n  _BinaryenGlobalGetGetName,\n  _BinaryenGlobalGetSetName,\n\n  _BinaryenGlobalSet,\n  _BinaryenGlobalSetGetName,\n  _BinaryenGlobalSetSetName,\n  _BinaryenGlobalSetGetValue,\n  _BinaryenGlobalSetSetValue,\n\n  _BinaryenMemorySize,\n\n  _BinaryenMemoryGrow,\n  _BinaryenMemoryGrowGetDelta,\n  _BinaryenMemoryGrowSetDelta,\n\n  _BinaryenLoad,\n  _BinaryenLoadIsAtomic,\n  _BinaryenLoadSetAtomic,\n  _BinaryenLoadIsSigned,\n  _BinaryenLoadSetSigned,\n  _BinaryenLoadGetOffset,\n  _BinaryenLoadSetOffset,\n  _BinaryenLoadGetBytes,\n  _BinaryenLoadSetBytes,\n  _BinaryenLoadGetAlign,\n  _BinaryenLoadSetAlign,\n  _BinaryenLoadGetPtr,\n  _BinaryenLoadSetPtr,\n  _BinaryenAtomicLoad,\n\n  _BinaryenStore,\n  _BinaryenStoreIsAtomic,\n  _BinaryenStoreSetAtomic,\n  _BinaryenStoreGetBytes,\n  _BinaryenStoreSetBytes,\n  _BinaryenStoreGetOffset,\n  _BinaryenStoreSetOffset,\n  _BinaryenStoreGetAlign,\n  _BinaryenStoreSetAlign,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreSetPtr,\n  _BinaryenStoreGetValue,\n  _BinaryenStoreSetValue,\n  _BinaryenStoreGetValueType,\n  _BinaryenStoreSetValueType,\n  _BinaryenAtomicStore,\n\n  _BinaryenConst,\n  _BinaryenConstGetValueI32,\n  _BinaryenConstSetValueI32,\n  _BinaryenConstGetValueI64Low,\n  _BinaryenConstSetValueI64Low,\n  _BinaryenConstGetValueI64High,\n  _BinaryenConstSetValueI64High,\n  _BinaryenConstGetValueF32,\n  _BinaryenConstSetValueF32,\n  _BinaryenConstGetValueF64,\n  _BinaryenConstSetValueF64,\n  _BinaryenConstGetValueV128,\n  _BinaryenConstSetValueV128,\n\n  _BinaryenUnary,\n  _BinaryenUnaryGetOp,\n  _BinaryenUnarySetOp,\n  _BinaryenUnaryGetValue,\n  _BinaryenUnarySetValue,\n\n  _BinaryenBinary,\n  _BinaryenBinaryGetOp,\n  _BinaryenBinarySetOp,\n  _BinaryenBinaryGetLeft,\n  _BinaryenBinarySetLeft,\n  _BinaryenBinaryGetRight,\n  _BinaryenBinarySetRight,\n\n  _BinaryenSelect,\n  _BinaryenSelectGetIfTrue,\n  _BinaryenSelectSetIfTrue,\n  _BinaryenSelectGetIfFalse,\n  _BinaryenSelectSetIfFalse,\n  _BinaryenSelectGetCondition,\n  _BinaryenSelectSetCondition,\n\n  _BinaryenDrop,\n  _BinaryenDropGetValue,\n  _BinaryenDropSetValue,\n\n  _BinaryenReturn,\n  _BinaryenReturnGetValue,\n  _BinaryenReturnSetValue,\n\n  _BinaryenNop,\n\n  _BinaryenUnreachable,\n\n  _BinaryenAtomicRMW,\n  _BinaryenAtomicRMWGetOp,\n  _BinaryenAtomicRMWSetOp,\n  _BinaryenAtomicRMWGetBytes,\n  _BinaryenAtomicRMWSetBytes,\n  _BinaryenAtomicRMWGetOffset,\n  _BinaryenAtomicRMWSetOffset,\n  _BinaryenAtomicRMWGetPtr,\n  _BinaryenAtomicRMWSetPtr,\n  _BinaryenAtomicRMWGetValue,\n  _BinaryenAtomicRMWSetValue,\n\n  _BinaryenAtomicCmpxchg,\n  _BinaryenAtomicCmpxchgGetBytes,\n  _BinaryenAtomicCmpxchgSetBytes,\n  _BinaryenAtomicCmpxchgGetOffset,\n  _BinaryenAtomicCmpxchgSetOffset,\n  _BinaryenAtomicCmpxchgGetPtr,\n  _BinaryenAtomicCmpxchgSetPtr,\n  _BinaryenAtomicCmpxchgGetExpected,\n  _BinaryenAtomicCmpxchgSetExpected,\n  _BinaryenAtomicCmpxchgGetReplacement,\n  _BinaryenAtomicCmpxchgSetReplacement,\n\n  _BinaryenAtomicWait,\n  _BinaryenAtomicWaitGetPtr,\n  _BinaryenAtomicWaitSetPtr,\n  _BinaryenAtomicWaitGetExpected,\n  _BinaryenAtomicWaitSetExpected,\n  _BinaryenAtomicWaitGetTimeout,\n  _BinaryenAtomicWaitSetTimeout,\n  _BinaryenAtomicWaitGetExpectedType,\n  _BinaryenAtomicWaitSetExpectedType,\n\n  _BinaryenAtomicNotify,\n  _BinaryenAtomicNotifyGetPtr,\n  _BinaryenAtomicNotifySetPtr,\n  _BinaryenAtomicNotifyGetNotifyCount,\n  _BinaryenAtomicNotifySetNotifyCount,\n\n  _BinaryenAtomicFence,\n  _BinaryenAtomicFenceGetOrder,\n  _BinaryenAtomicFenceSetOrder,\n\n  _BinaryenSIMDExtract,\n  _BinaryenSIMDExtractGetOp,\n  _BinaryenSIMDExtractSetOp,\n  _BinaryenSIMDExtractGetVec,\n  _BinaryenSIMDExtractSetVec,\n  _BinaryenSIMDExtractGetIndex,\n  _BinaryenSIMDExtractSetIndex,\n\n  _BinaryenSIMDReplace,\n  _BinaryenSIMDReplaceGetOp,\n  _BinaryenSIMDReplaceSetOp,\n  _BinaryenSIMDReplaceGetVec,\n  _BinaryenSIMDReplaceSetVec,\n  _BinaryenSIMDReplaceGetIndex,\n  _BinaryenSIMDReplaceSetIndex,\n  _BinaryenSIMDReplaceGetValue,\n  _BinaryenSIMDReplaceSetValue,\n\n  _BinaryenSIMDShuffle,\n  _BinaryenSIMDShuffleGetLeft,\n  _BinaryenSIMDShuffleSetLeft,\n  _BinaryenSIMDShuffleGetRight,\n  _BinaryenSIMDShuffleSetRight,\n  _BinaryenSIMDShuffleGetMask,\n  _BinaryenSIMDShuffleSetMask,\n\n  _BinaryenSIMDTernary,\n  _BinaryenSIMDTernaryGetOp,\n  _BinaryenSIMDTernarySetOp,\n  _BinaryenSIMDTernaryGetA,\n  _BinaryenSIMDTernarySetA,\n  _BinaryenSIMDTernaryGetB,\n  _BinaryenSIMDTernarySetB,\n  _BinaryenSIMDTernaryGetC,\n  _BinaryenSIMDTernarySetC,\n\n  _BinaryenSIMDShift,\n  _BinaryenSIMDShiftGetOp,\n  _BinaryenSIMDShiftSetOp,\n  _BinaryenSIMDShiftGetVec,\n  _BinaryenSIMDShiftSetVec,\n  _BinaryenSIMDShiftGetShift,\n  _BinaryenSIMDShiftSetShift,\n\n  _BinaryenSIMDLoad,\n  _BinaryenSIMDLoadGetOp,\n  _BinaryenSIMDLoadSetOp,\n  _BinaryenSIMDLoadGetOffset,\n  _BinaryenSIMDLoadSetOffset,\n  _BinaryenSIMDLoadGetAlign,\n  _BinaryenSIMDLoadSetAlign,\n  _BinaryenSIMDLoadGetPtr,\n  _BinaryenSIMDLoadSetPtr,\n\n  _BinaryenSIMDLoadStoreLane,\n  _BinaryenSIMDLoadStoreLaneGetOp,\n  _BinaryenSIMDLoadStoreLaneSetOp,\n  _BinaryenSIMDLoadStoreLaneGetOffset,\n  _BinaryenSIMDLoadStoreLaneSetOffset,\n  _BinaryenSIMDLoadStoreLaneGetAlign,\n  _BinaryenSIMDLoadStoreLaneSetAlign,\n  _BinaryenSIMDLoadStoreLaneGetIndex,\n  _BinaryenSIMDLoadStoreLaneSetIndex,\n  _BinaryenSIMDLoadStoreLaneGetPtr,\n  _BinaryenSIMDLoadStoreLaneSetPtr,\n  _BinaryenSIMDLoadStoreLaneGetVec,\n  _BinaryenSIMDLoadStoreLaneSetVec,\n  _BinaryenSIMDLoadStoreLaneIsStore,\n\n  _BinaryenMemoryInit,\n  _BinaryenMemoryInitGetSegment,\n  _BinaryenMemoryInitSetSegment,\n  _BinaryenMemoryInitGetDest,\n  _BinaryenMemoryInitSetDest,\n  _BinaryenMemoryInitGetOffset,\n  _BinaryenMemoryInitSetOffset,\n  _BinaryenMemoryInitGetSize,\n  _BinaryenMemoryInitSetSize,\n\n  _BinaryenDataDrop,\n  _BinaryenDataDropGetSegment,\n  _BinaryenDataDropSetSegment,\n\n  _BinaryenMemoryCopy,\n  _BinaryenMemoryCopyGetDest,\n  _BinaryenMemoryCopySetDest,\n  _BinaryenMemoryCopyGetSource,\n  _BinaryenMemoryCopySetSource,\n  _BinaryenMemoryCopyGetSize,\n  _BinaryenMemoryCopySetSize,\n\n  _BinaryenMemoryFill,\n  _BinaryenMemoryFillGetDest,\n  _BinaryenMemoryFillSetDest,\n  _BinaryenMemoryFillGetValue,\n  _BinaryenMemoryFillSetValue,\n  _BinaryenMemoryFillGetSize,\n  _BinaryenMemoryFillSetSize,\n\n  _BinaryenRefNull,\n\n  _BinaryenRefIs,\n  _BinaryenRefIsGetOp,\n  _BinaryenRefIsSetOp,\n  _BinaryenRefIsGetValue,\n  _BinaryenRefIsSetValue,\n\n  _BinaryenRefAs,\n  _BinaryenRefAsGetOp,\n  _BinaryenRefAsSetOp,\n  _BinaryenRefAsGetValue,\n  _BinaryenRefAsSetValue,\n\n  _BinaryenRefFunc,\n  _BinaryenRefFuncGetFunc,\n  _BinaryenRefFuncSetFunc,\n\n  _BinaryenRefEq,\n  _BinaryenRefEqGetLeft,\n  _BinaryenRefEqSetLeft,\n  _BinaryenRefEqGetRight,\n  _BinaryenRefEqSetRight,\n\n  _BinaryenTableGet,\n  _BinaryenTableGetGetTable,\n  _BinaryenTableGetSetTable,\n  _BinaryenTableGetGetIndex,\n  _BinaryenTableGetSetIndex,\n\n  _BinaryenTableSet,\n  _BinaryenTableSetGetTable,\n  _BinaryenTableSetSetTable,\n  _BinaryenTableSetGetIndex,\n  _BinaryenTableSetSetIndex,\n  _BinaryenTableSetGetValue,\n  _BinaryenTableSetSetValue,\n\n  _BinaryenTableSize,\n  _BinaryenTableSizeGetTable,\n  _BinaryenTableSizeSetTable,\n\n  _BinaryenTableGrow,\n  _BinaryenTableGrowGetTable,\n  _BinaryenTableGrowSetTable,\n  _BinaryenTableGrowGetValue,\n  _BinaryenTableGrowSetValue,\n  _BinaryenTableGrowGetDelta,\n  _BinaryenTableGrowSetDelta,\n\n  _BinaryenTry,\n  _BinaryenTryGetName,\n  _BinaryenTrySetName,\n  _BinaryenTryGetBody,\n  _BinaryenTrySetBody,\n  _BinaryenTryGetNumCatchTags,\n  _BinaryenTryGetNumCatchBodies,\n  _BinaryenTryGetCatchTagAt,\n  _BinaryenTrySetCatchTagAt,\n  _BinaryenTryAppendCatchTag,\n  _BinaryenTryInsertCatchTagAt,\n  _BinaryenTryRemoveCatchTagAt,\n  _BinaryenTryGetCatchBodyAt,\n  _BinaryenTrySetCatchBodyAt,\n  _BinaryenTryAppendCatchBody,\n  _BinaryenTryInsertCatchBodyAt,\n  _BinaryenTryRemoveCatchBodyAt,\n  _BinaryenTryHasCatchAll,\n  _BinaryenTryGetDelegateTarget,\n  _BinaryenTrySetDelegateTarget,\n  _BinaryenTryIsDelegate,\n\n  _BinaryenThrow,\n  _BinaryenThrowGetTag,\n  _BinaryenThrowSetTag,\n  _BinaryenThrowGetNumOperands,\n  _BinaryenThrowGetOperandAt,\n  _BinaryenThrowSetOperandAt,\n  _BinaryenThrowAppendOperand,\n  _BinaryenThrowInsertOperandAt,\n  _BinaryenThrowRemoveOperandAt,\n\n  _BinaryenRethrow,\n  _BinaryenRethrowGetTarget,\n  _BinaryenRethrowSetDepth,\n\n  _BinaryenTupleMake,\n  _BinaryenTupleMakeGetNumOperands,\n  _BinaryenTupleMakeGetOperandAt,\n  _BinaryenTupleMakeSetOperandAt,\n  _BinaryenTupleMakeAppendOperand,\n  _BinaryenTupleMakeInsertOperandAt,\n  _BinaryenTupleMakeRemoveOperandAt,\n\n  _BinaryenTupleExtract,\n  _BinaryenTupleExtractGetTuple,\n  _BinaryenTupleExtractSetTuple,\n  _BinaryenTupleExtractGetIndex,\n  _BinaryenTupleExtractSetIndex,\n\n  _BinaryenPop,\n\n  _BinaryenI31New,\n  _BinaryenI31NewGetValue,\n  _BinaryenI31NewSetValue,\n\n  _BinaryenI31Get,\n  _BinaryenI31GetGetI31,\n  _BinaryenI31GetSetI31,\n  _BinaryenI31GetIsSigned,\n  _BinaryenI31GetSetSigned,\n\n  _BinaryenCallRef,\n  _BinaryenCallRefGetNumOperands,\n  _BinaryenCallRefGetOperandAt,\n  _BinaryenCallRefSetOperandAt,\n  _BinaryenCallRefAppendOperand,\n  _BinaryenCallRefInsertOperandAt,\n  _BinaryenCallRefRemoveOperandAt,\n  _BinaryenCallRefGetTarget,\n  _BinaryenCallRefSetTarget,\n  _BinaryenCallRefIsReturn,\n  _BinaryenCallRefSetReturn,\n\n  _BinaryenRefTest,\n  _BinaryenRefTestGetRef,\n  _BinaryenRefTestSetRef,\n  _BinaryenRefTestGetIntendedType,\n  _BinaryenRefTestSetIntendedType,\n\n  _BinaryenRefCast,\n  _BinaryenRefCastGetRef,\n  _BinaryenRefCastSetRef,\n  _BinaryenRefCastGetIntendedType,\n  _BinaryenRefCastSetIntendedType,\n\n  _BinaryenBrOn,\n  _BinaryenBrOnGetOp,\n  _BinaryenBrOnSetOp,\n  _BinaryenBrOnGetName,\n  _BinaryenBrOnSetName,\n  _BinaryenBrOnGetRef,\n  _BinaryenBrOnSetRef,\n  _BinaryenBrOnGetIntendedType,\n  _BinaryenBrOnSetIntendedType,\n\n  _BinaryenStructNew,\n  _BinaryenStructNewGetNumOperands,\n  _BinaryenStructNewGetOperandAt,\n  _BinaryenStructNewSetOperandAt,\n  _BinaryenStructNewAppendOperand,\n  _BinaryenStructNewInsertOperandAt,\n  _BinaryenStructNewRemoveOperandAt,\n\n  _BinaryenStructGet,\n  _BinaryenStructGetGetIndex,\n  _BinaryenStructGetSetIndex,\n  _BinaryenStructGetGetRef,\n  _BinaryenStructGetSetRef,\n  _BinaryenStructGetIsSigned,\n  _BinaryenStructGetSetSigned,\n\n  _BinaryenStructSet,\n  _BinaryenStructSetGetIndex,\n  _BinaryenStructSetSetIndex,\n  _BinaryenStructSetGetRef,\n  _BinaryenStructSetSetRef,\n  _BinaryenStructSetGetValue,\n  _BinaryenStructSetSetValue,\n\n  _BinaryenArrayNew,\n  _BinaryenArrayNewGetInit,\n  _BinaryenArrayNewSetInit,\n  _BinaryenArrayNewGetSize,\n  _BinaryenArrayNewSetSize,\n\n  _BinaryenArrayInit,\n  _BinaryenArrayInitGetNumValues,\n  _BinaryenArrayInitGetValueAt,\n  _BinaryenArrayInitSetValueAt,\n  _BinaryenArrayInitAppendValue,\n  _BinaryenArrayInitInsertValueAt,\n  _BinaryenArrayInitRemoveValueAt,\n\n  _BinaryenArrayGet,\n  _BinaryenArrayGetGetRef,\n  _BinaryenArrayGetSetRef,\n  _BinaryenArrayGetGetIndex,\n  _BinaryenArrayGetSetIndex,\n  _BinaryenArrayGetIsSigned,\n  _BinaryenArrayGetSetSigned,\n\n  _BinaryenArraySet,\n  _BinaryenArraySetGetRef,\n  _BinaryenArraySetSetRef,\n  _BinaryenArraySetGetIndex,\n  _BinaryenArraySetSetIndex,\n  _BinaryenArraySetGetValue,\n  _BinaryenArraySetSetValue,\n\n  _BinaryenArrayLen,\n  _BinaryenArrayLenGetRef,\n  _BinaryenArrayLenSetRef,\n\n  _BinaryenArrayCopy,\n  _BinaryenArrayCopyGetDestRef,\n  _BinaryenArrayCopySetDestRef,\n  _BinaryenArrayCopyGetDestIndex,\n  _BinaryenArrayCopySetDestIndex,\n  _BinaryenArrayCopyGetSrcRef,\n  _BinaryenArrayCopySetSrcRef,\n  _BinaryenArrayCopyGetSrcIndex,\n  _BinaryenArrayCopySetSrcIndex,\n  _BinaryenArrayCopyGetLength,\n  _BinaryenArrayCopySetLength,\n\n  _BinaryenStringNew,\n  _BinaryenStringNewGetOp,\n  _BinaryenStringNewSetOp,\n  _BinaryenStringNewGetPtr,\n  _BinaryenStringNewSetPtr,\n  _BinaryenStringNewGetLength,\n  _BinaryenStringNewSetLength,\n  _BinaryenStringNewGetStart,\n  _BinaryenStringNewSetStart,\n  _BinaryenStringNewGetEnd,\n  _BinaryenStringNewSetEnd,\n\n  _BinaryenStringConst,\n  _BinaryenStringConstGetString,\n  _BinaryenStringConstSetString,\n\n  _BinaryenStringMeasure,\n  _BinaryenStringMeasureGetOp,\n  _BinaryenStringMeasureSetOp,\n  _BinaryenStringMeasureGetRef,\n  _BinaryenStringMeasureSetRef,\n\n  _BinaryenStringEncode,\n  _BinaryenStringEncodeGetOp,\n  _BinaryenStringEncodeSetOp,\n  _BinaryenStringEncodeGetRef,\n  _BinaryenStringEncodeSetRef,\n  _BinaryenStringEncodeGetPtr,\n  _BinaryenStringEncodeSetPtr,\n  _BinaryenStringEncodeGetStart,\n  _BinaryenStringEncodeSetStart,\n\n  _BinaryenStringConcat,\n  _BinaryenStringConcatGetLeft,\n  _BinaryenStringConcatSetLeft,\n  _BinaryenStringConcatGetRight,\n  _BinaryenStringConcatSetRight,\n\n  _BinaryenStringEq,\n  _BinaryenStringEqGetLeft,\n  _BinaryenStringEqSetLeft,\n  _BinaryenStringEqGetRight,\n  _BinaryenStringEqSetRight,\n\n  _BinaryenStringAs,\n  _BinaryenStringAsGetOp,\n  _BinaryenStringAsSetOp,\n  _BinaryenStringAsGetRef,\n  _BinaryenStringAsSetRef,\n\n  _BinaryenStringWTF8Advance,\n  _BinaryenStringWTF8AdvanceGetRef,\n  _BinaryenStringWTF8AdvanceSetRef,\n  _BinaryenStringWTF8AdvanceGetPos,\n  _BinaryenStringWTF8AdvanceSetPos,\n  _BinaryenStringWTF8AdvanceGetBytes,\n  _BinaryenStringWTF8AdvanceSetBytes,\n\n  _BinaryenStringWTF16Get,\n  _BinaryenStringWTF16GetGetRef,\n  _BinaryenStringWTF16GetSetRef,\n  _BinaryenStringWTF16GetGetPos,\n  _BinaryenStringWTF16GetSetPos,\n\n  _BinaryenStringIterNext,\n  _BinaryenStringIterNextGetRef,\n  _BinaryenStringIterNextSetRef,\n\n  _BinaryenStringIterMove,\n  _BinaryenStringIterMoveGetOp,\n  _BinaryenStringIterMoveSetOp,\n  _BinaryenStringIterMoveGetRef,\n  _BinaryenStringIterMoveSetRef,\n  _BinaryenStringIterMoveGetNum,\n  _BinaryenStringIterMoveSetNum,\n\n  _BinaryenStringSliceWTF,\n  _BinaryenStringSliceWTFGetOp,\n  _BinaryenStringSliceWTFSetOp,\n  _BinaryenStringSliceWTFGetRef,\n  _BinaryenStringSliceWTFSetRef,\n  _BinaryenStringSliceWTFGetStart,\n  _BinaryenStringSliceWTFSetStart,\n  _BinaryenStringSliceWTFGetEnd,\n  _BinaryenStringSliceWTFSetEnd,\n\n  _BinaryenStringSliceIter,\n  _BinaryenStringSliceIterGetRef,\n  _BinaryenStringSliceIterSetRef,\n  _BinaryenStringSliceIterGetNum,\n  _BinaryenStringSliceIterSetNum,\n\n  _BinaryenAddFunction,\n  _BinaryenGetFunction,\n  _BinaryenRemoveFunction,\n  _BinaryenGetNumFunctions,\n  _BinaryenGetFunctionByIndex,\n\n  _BinaryenFunctionGetName,\n  _BinaryenFunctionGetParams,\n  _BinaryenFunctionGetResults,\n  _BinaryenFunctionGetNumVars,\n  _BinaryenFunctionGetVar,\n  _BinaryenFunctionGetNumLocals,\n  _BinaryenFunctionHasLocalName,\n  _BinaryenFunctionGetLocalName,\n  _BinaryenFunctionSetLocalName,\n  _BinaryenFunctionGetBody,\n  _BinaryenFunctionSetBody,\n  _BinaryenFunctionOptimize,\n  _BinaryenFunctionRunPasses,\n  _BinaryenFunctionSetDebugLocation,\n\n  _BinaryenAddFunctionImport,\n  _BinaryenAddTableImport,\n  _BinaryenAddMemoryImport,\n  _BinaryenAddGlobalImport,\n  _BinaryenAddTagImport,\n\n  _BinaryenAddFunctionExport,\n  _BinaryenAddTableExport,\n  _BinaryenAddMemoryExport,\n  _BinaryenAddGlobalExport,\n  _BinaryenAddTagExport,\n  _BinaryenGetExport,\n  _BinaryenRemoveExport,\n  _BinaryenGetNumExports,\n  _BinaryenGetExportByIndex,\n  _BinaryenExportGetKind,\n  _BinaryenExportGetName,\n  _BinaryenExportGetValue,\n\n  _BinaryenAddGlobal,\n  _BinaryenGetGlobal,\n  _BinaryenRemoveGlobal,\n  _BinaryenGetNumGlobals,\n  _BinaryenGetGlobalByIndex,\n\n  _BinaryenGlobalGetName,\n  _BinaryenGlobalGetType,\n  _BinaryenGlobalIsMutable,\n  _BinaryenGlobalGetInitExpr,\n\n  _BinaryenAddTag,\n  _BinaryenGetTag,\n  _BinaryenRemoveTag,\n\n  _BinaryenTagGetName,\n  _BinaryenTagGetParams,\n  _BinaryenTagGetResults,\n\n  _BinaryenAddTable,\n  _BinaryenRemoveTable,\n  _BinaryenGetNumTables,\n  _BinaryenGetTable,\n  _BinaryenGetTableByIndex,\n\n  _BinaryenTableGetName,\n  _BinaryenTableSetName,\n  _BinaryenTableGetInitial,\n  _BinaryenTableSetInitial,\n  _BinaryenTableHasMax,\n  _BinaryenTableGetMax,\n  _BinaryenTableSetMax,\n\n  _BinaryenAddActiveElementSegment,\n  _BinaryenAddPassiveElementSegment,\n  _BinaryenRemoveElementSegment,\n  _BinaryenGetNumElementSegments,\n  _BinaryenGetElementSegment,\n  _BinaryenGetElementSegmentByIndex,\n\n  _BinaryenSetMemory,\n  _BinaryenGetNumMemorySegments,\n  _BinaryenGetMemorySegmentByteOffset,\n  _BinaryenGetMemorySegmentByteLength,\n  _BinaryenCopyMemorySegmentData,\n\n  _BinaryenSetStart,\n\n  _BinaryenModuleParse,\n  _BinaryenModulePrint,\n  _BinaryenModulePrintAsmjs,\n  _BinaryenModuleValidate,\n  _BinaryenModuleOptimize,\n  _BinaryenModuleRunPasses,\n  _BinaryenModuleAutoDrop,\n  _BinaryenSizeofAllocateAndWriteResult,\n  _BinaryenModuleAllocateAndWrite,\n  _BinaryenModuleAllocateAndWriteText,\n  _BinaryenModuleAllocateAndWriteStackIR,\n  _BinaryenModuleRead,\n  _BinaryenModuleInterpret,\n  _BinaryenModuleAddDebugInfoFileName,\n  _BinaryenModuleGetDebugInfoFileName,\n  _BinaryenModuleGetFeatures,\n  _BinaryenModuleSetFeatures,\n\n  _BinaryenAddCustomSection,\n\n  _BinaryenExpressionGetSideEffects,\n\n  _RelooperCreate,\n  _RelooperAddBlock,\n  _RelooperAddBranch,\n  _RelooperAddBlockWithSwitch,\n  _RelooperAddBranchForSwitch,\n  _RelooperRenderAndDispose,\n\n  _ExpressionRunnerCreate,\n  _ExpressionRunnerSetLocalValue,\n  _ExpressionRunnerSetGlobalValue,\n  _ExpressionRunnerRunAndDispose,\n\n  _TypeBuilderCreate,\n  _TypeBuilderGrow,\n  _TypeBuilderGetSize,\n  _TypeBuilderSetBasicHeapType,\n  _TypeBuilderSetSignatureType,\n  _TypeBuilderSetStructType,\n  _TypeBuilderSetArrayType,\n  _TypeBuilderIsBasic,\n  _TypeBuilderGetBasic,\n  _TypeBuilderGetTempHeapType,\n  _TypeBuilderGetTempTupleType,\n  _TypeBuilderGetTempRefType,\n  _TypeBuilderSetSubType,\n  _TypeBuilderCreateRecGroup,\n  _TypeBuilderBuildAndDispose,\n  _BinaryenModuleSetTypeName,\n  _BinaryenModuleSetFieldName,\n\n  _BinaryenGetOptimizeLevel,\n  _BinaryenSetOptimizeLevel,\n  _BinaryenGetShrinkLevel,\n  _BinaryenSetShrinkLevel,\n  _BinaryenGetDebugInfo,\n  _BinaryenSetDebugInfo,\n  _BinaryenGetLowMemoryUnused,\n  _BinaryenSetLowMemoryUnused,\n  _BinaryenGetZeroFilledMemory,\n  _BinaryenSetZeroFilledMemory,\n  _BinaryenGetFastMath,\n  _BinaryenSetFastMath,\n  _BinaryenGetPassArgument,\n  _BinaryenSetPassArgument,\n  _BinaryenClearPassArguments,\n  _BinaryenGetAlwaysInlineMaxSize,\n  _BinaryenSetAlwaysInlineMaxSize,\n  _BinaryenGetFlexibleInlineMaxSize,\n  _BinaryenSetFlexibleInlineMaxSize,\n  _BinaryenGetOneCallerInlineMaxSize,\n  _BinaryenSetOneCallerInlineMaxSize,\n  _BinaryenGetAllowInliningFunctionsWithLoops,\n  _BinaryenSetAllowInliningFunctionsWithLoops,\n  _BinaryenGetTypeSystem,\n  _BinaryenSetTypeSystem,\n\n  // Helpers\n\n  _malloc,\n  _free,\n  __i32_store8,\n  __i32_store16,\n  __i32_store,\n  __f32_store,\n  __f64_store,\n  __i32_load8_s,\n  __i32_load8_u,\n  __i32_load16_s,\n  __i32_load16_u,\n  __i32_load,\n  __f32_load,\n  __f64_load\n\n} = binaryen;\n\nexport default binaryen;\n", "/**\n * @fileoverview Floating point glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst F64 = new Float64Array(1);\nconst F32 = new Float32Array(F64.buffer);\nconst I32 = new Int32Array(F64.buffer);\n\nglobalThis.f32_as_i32 = function f32_as_i32(value) {\n  F32[0] = value;\n  return I32[0];\n};\n\nglobalThis.i32_as_f32 = function i32_as_f32(value) {\n  I32[0] = value;\n  return F32[0];\n};\n\nglobalThis.f64_as_i64 = function f64_as_i64(value) {\n  F64[0] = value;\n  return i64_new(I32[0], I32[1]);\n};\n\nglobalThis.i64_as_f64 = function i64_as_f64(value) {\n  I32[0] = i64_low(value);\n  I32[1] = i64_high(value);\n  return F64[0];\n};\n", "/**\n * @fileoverview 64-bit integer glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nimport Long from \"long\";\n\nglobalThis.i64_zero    = Long.ZERO;\nglobalThis.i64_one     = Long.ONE;\nglobalThis.i64_neg_one = Long.fromInt(-1);\nglobalThis.i64_minimum = Long.MIN_VALUE;\nglobalThis.i64_maximum = Long.MAX_VALUE;\n\nglobalThis.i64_is = function i64_is(value) {\n  return Long.isLong(value);\n};\n\nglobalThis.i64_new = function i64_new(lo, hi) {\n  return Long.fromBits(lo, hi);\n};\n\nglobalThis.i64_low = function i64_low(value) {\n  return value.low;\n};\n\nglobalThis.i64_high = function i64_high(value) {\n  return value.high;\n};\n\nglobalThis.i64_not = function i64_not(value) {\n  return value.not();\n};\n\nglobalThis.i64_neg = function i64_neg(value) {\n  return value.neg();\n};\n\nglobalThis.i64_clz = function i64_clz(value) {\n  return value.clz();\n};\n\nglobalThis.i64_ctz = function i64_ctz(value) {\n  return value.ctz();\n};\n\nglobalThis.i64_add = function i64_add(left, right) {\n  return left.add(right);\n};\n\nglobalThis.i64_sub = function i64_sub(left, right) {\n  return left.sub(right);\n};\n\nglobalThis.i64_mul = function i64_mul(left, right) {\n  return left.mul(right);\n};\n\nglobalThis.i64_pow = function i64_pow(left, right) {\n  let rightLo = right.low;\n  let rightHi = right.high;\n  if (rightHi <= 0) {\n    if (rightHi < 0) {\n      if (left.eq(globalThis.i64_neg_one)) {\n        return rightLo & 1 ? left : Long.ONE;\n      }\n      return left.eq(Long.ONE) ? left : Long.ZERO;\n    }\n    if (rightLo == 0) return Long.ONE;\n    if (rightLo == 1) return left;\n    if (rightLo == 2) return left.mul(left);\n  }\n  let result = Long.ONE;\n  while (rightLo | rightHi) {\n    if (rightLo & 1) result = result.mul(left);\n    right = right.shru(1);\n    left  = left.mul(left);\n    rightLo = right.low;\n    rightHi = right.high;\n  }\n  return result;\n};\n\nglobalThis.i64_div = function i64_div(left, right) {\n  return left.div(right);\n};\n\nglobalThis.i64_div_u = function i64_div_u(left, right) {\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\n};\n\nglobalThis.i64_rem = function i64_rem(left, right) {\n  return left.mod(right);\n};\n\nglobalThis.i64_rem_u = function i64_rem_u(left, right) {\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\n};\n\nglobalThis.i64_and = function i64_and(left, right) {\n  return left.and(right);\n};\n\nglobalThis.i64_or = function i64_or(left, right) {\n  return left.or(right);\n};\n\nglobalThis.i64_xor = function i64_xor(left, right) {\n  return left.xor(right);\n};\n\nglobalThis.i64_shl = function i64_shl(left, right) {\n  return left.shl(right);\n};\n\nglobalThis.i64_shr = function i64_shr(left, right) {\n  return left.shr(right);\n};\n\nglobalThis.i64_shr_u = function i64_shr_u(left, right) {\n  return left.shru(right);\n};\n\nglobalThis.i64_eq = function i64_eq(left, right) {\n  return left.eq(right);\n};\n\nglobalThis.i64_ne = function i64_ne(left, right) {\n  return left.ne(right);\n};\n\nglobalThis.i64_ge = function i64_ge(left, right) {\n  return left.ge(right);\n};\n\nglobalThis.i64_ge_u = function i64_ge_u(left, right) {\n  return left.toUnsigned().ge(right.toUnsigned());\n};\n\nglobalThis.i64_gt = function i64_gt(left, right) {\n  return left.gt(right);\n};\n\nglobalThis.i64_gt_u = function i64_gt_u(left, right) {\n  return left.toUnsigned().gt(right.toUnsigned());\n};\n\nglobalThis.i64_le = function i64_le(left, right) {\n  return left.le(right);\n};\n\nglobalThis.i64_le_u = function i64_le_u(left, right) {\n  return left.toUnsigned().le(right.toUnsigned());\n};\n\nglobalThis.i64_lt = function i64_lt(left, right) {\n  return left.lt(right);\n};\n\nglobalThis.i64_lt_u = function i64_lt_u(left, right) {\n  return left.toUnsigned().lt(right.toUnsigned());\n};\n\nglobalThis.i64_align = function i64_align(value, alignment) {\n  assert(alignment && (alignment & (alignment - 1)) == 0);\n  let mask = Long.fromInt(alignment - 1);\n  return value.add(mask).and(mask.not());\n};\n\nglobalThis.i64_signbit = function i64_signbit(value) {\n  return Boolean(value.high >>> 31);\n};\n\nglobalThis.i64_is_i8 = function i64_is_i8(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\n};\n\nglobalThis.i64_is_i16 = function i64_is_i16(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\n};\n\nglobalThis.i64_is_i32 = function i64_is_i32(value) {\n  return (value.high === 0 && value.low >= 0)\n      || (value.high === -1 && value.low < 0);\n};\n\nglobalThis.i64_is_u8 = function i64_is_u8(value) {\n  return value.high === 0 && (value.low >>> 0) <= u8.MAX_VALUE;\n};\n\nglobalThis.i64_is_u16 = function i64_is_u16(value) {\n  return value.high === 0 && (value.low >>> 0) <= u16.MAX_VALUE;\n};\n\nglobalThis.i64_is_u32 = function i64_is_u32(value) {\n  return value.high === 0;\n};\n\nglobalThis.i64_is_bool = function i64_is_bool(value) {\n  return (value.high | (value.low & ~1)) === 0;\n};\n\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\n\nglobalThis.i64_is_f32 = function i64_is_f32(value) {\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\n};\n\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\n\nglobalThis.i64_is_f64 = function i64_is_f64(value) {\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\n};\n\nglobalThis.i64_to_f32 = function i64_to_f32(value) {\n  return globalThis.Math.fround(value.toNumber());\n};\n\nglobalThis.i64_to_f64 = function i64_to_f64(value) {\n  return value.toNumber();\n};\n\nglobalThis.i64_to_string = function i64_to_string(value, unsigned) {\n  return unsigned ? value.toUnsigned().toString() : value.toString();\n};\n\nglobalThis.i64_clone = function i64_clone(value) {\n  return Long.fromBits(value.low, value.high, value.unsigned);\n};\n", "/**\n * @fileoverview Collections glue code for JavaScript.\n * @license Apache-2.0\n */\n\nglobalThis.Map_keys = function Map_keys(map) {\n  return Array.from(map.keys());\n};\n\nglobalThis.Map_values = function Map_values(map) {\n  return Array.from(map.values());\n};\n\nglobalThis.Set_values = function Set_values(set) {\n  return Array.from(set.values());\n};\n", "// This file is shared with the compiler and must remain portable\n\n/** Indicates specific features to activate. */\nexport const enum Feature {\n  /** No additional features. */\n  None = 0,\n  /** Sign extension operations. */\n  SignExtension = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\n  /** Mutable global imports and exports. */\n  MutableGlobals = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\n  /** Non-trapping float to integer operations. */\n  NontrappingF2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  /** Bulk memory operations. */\n  BulkMemory = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\n  /** SIMD types and operations. */\n  Simd = 1 << 4, // see: https://github.com/WebAssembly/simd\n  /** Threading and atomic operations. */\n  Threads = 1 << 5, // see: https://github.com/WebAssembly/threads\n  /** Exception handling operations. */\n  ExceptionHandling = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\n  /** Tail call operations. */\n  TailCalls = 1 << 7, // see: https://github.com/WebAssembly/tail-call\n  /** Reference types. */\n  ReferenceTypes = 1 << 8, // see: https://github.com/WebAssembly/reference-types\n  /** Multi value types. */\n  MultiValue = 1 << 9, // see: https://github.com/WebAssembly/multi-value\n  /** Garbage collection. */\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\n  /** Memory64. */\n  Memory64 = 1 << 11, // see: https://github.com/WebAssembly/memory64\n  /** Relaxed SIMD. */\n  RelaxedSimd = 1 << 12, // see: https://github.com/WebAssembly/relaxed-simd\n  /** Extended const expressions. */\n  ExtendedConst = 1 << 13, // see: https://github.com/WebAssembly/extended-const\n  /** Reference typed strings. */\n  Stringref = 1 << 14, // see: https://github.com/WebAssembly/stringref\n}\n\n/** Gets the name of the specified feature one would specify on the command line. */\nexport function featureToString(feature: Feature): string {\n  switch (feature) {\n    case Feature.SignExtension: return \"sign-extension\";\n    case Feature.MutableGlobals: return \"mutable-globals\";\n    case Feature.NontrappingF2I: return \"nontrapping-f2i\";\n    case Feature.BulkMemory: return \"bulk-memory\";\n    case Feature.Simd: return \"simd\";\n    case Feature.Threads: return \"threads\";\n    case Feature.ExceptionHandling: return \"exception-handling\";\n    case Feature.TailCalls: return \"tail-calls\";\n    case Feature.ReferenceTypes: return \"reference-types\";\n    case Feature.MultiValue: return \"multi-value\";\n    case Feature.GC: return \"gc\";\n    case Feature.Memory64: return \"memory64\";\n    case Feature.RelaxedSimd: return \"relaxed-simd\";\n    case Feature.ExtendedConst: return \"extended-const\";\n    case Feature.Stringref: return \"stringref\";\n  }\n  assert(false);\n  return \"\";\n}\n", "// This file is shared with the compiler and must remain portable\n\n/** Compilation target. */\nexport enum Target {\n  /** Portable. */\n  Js = 0,\n  /** WebAssembly with 32-bit pointers. */\n  Wasm32 = 1,\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\n  Wasm64 = 2,\n}\n", "// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n", "// This file is shared with the compiler and must remain portable\n\n// \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Typeinfo interpretation \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \u251C\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2524 \u25C4\u2500 __rtti_base\n// \u2502                             count                             \u2502\n// \u255E\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2510\n// \u2502                      Typeinfo#flags [id=0]                    \u2502 id < count\n// \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n// \u2502                              ...                              \u2502\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n", "/**\n * @fileoverview Common constants used by various parts of the compiler.\n * @license Apache-2.0\n */\n\n/** Indicates traits of a {@link Node} or {@link Element}. */\nexport const enum CommonFlags {\n  /** No flags set. */\n  None = 0,\n\n  // Basic modifiers\n\n  /** Has an `import` modifier. */\n  Import = 1 << 0,\n  /** Has an `export` modifier. */\n  Export = 1 << 1,\n  /** Has a `declare` modifier. */\n  Declare = 1 << 2,\n  /** Has a `const` modifier. */\n  Const = 1 << 3,\n  /** Has a `let` modifier. */\n  Let = 1 << 4,\n  /** Has a `static` modifier. */\n  Static = 1 << 5,\n  /** Has a `readonly` modifier. */\n  Readonly = 1 << 6,\n  /** Has an `abstract` modifier. */\n  Abstract = 1 << 7,\n  /** Has a `public` modifier. */\n  Public = 1 << 8,\n  /** Has a `private` modifier. */\n  Private = 1 << 9,\n  /** Has a `protected` modifier. */\n  Protected = 1 << 10,\n  /** Has a `get` modifier. */\n  Get = 1 << 11,\n  /** Has a `set` modifier. */\n  Set = 1 << 12,\n  /** Has a `override` modifier.  */\n  Override = 1 << 13,\n\n  /** Has a definite assignment assertion `!` as in `x!: i32;`. */\n  DefinitelyAssigned = 1 << 14,\n\n  // Extended modifiers usually derived from basic modifiers\n\n  /** Is ambient, that is either declared or nested in a declared element. */\n  Ambient = 1 << 15,\n  /** Is generic. */\n  Generic = 1 << 16,\n  /** Is part of a generic context. */\n  GenericContext = 1 << 17,\n  /** Is an instance member. */\n  Instance = 1 << 18,\n  /** Is a constructor. */\n  Constructor = 1 << 19,\n  /** Is a module export. */\n  ModuleExport = 1 << 20,\n  /** Is a module import. */\n  ModuleImport = 1 << 21,\n\n  // Compilation states\n\n  /** Is resolved. */\n  Resolved = 1 << 22,\n  /** Is compiled. */\n  Compiled = 1 << 23,\n  /** Did error. */\n  Errored = 1 << 24,\n  /** Has a constant value and is therefore inlined. */\n  Inlined = 1 << 25,\n  /** Is scoped. */\n  Scoped = 1 << 26,\n  /** Is a stub. */\n  Stub = 1 << 27,\n  /** Is an overridden method. */\n  Overridden = 1 << 28,\n  /** Is (part of) a closure. */\n  Closure = 1 << 29,\n\n  // Other\n\n  /** Is quoted. */\n  Quoted = 1 << 30\n}\n\n/** Path delimiter inserted between file system levels. */\nexport const PATH_DELIMITER = \"/\";\n/** Substitution used to indicate the parent directory. */\nexport const PARENT_SUBST = \"..\";\n/** Function name prefix used for getters. */\nexport const GETTER_PREFIX = \"get:\";\n/** Function name prefix used for setters. */\nexport const SETTER_PREFIX = \"set:\";\n/** Delimiter used between class names and instance members. */\nexport const INSTANCE_DELIMITER = \"#\";\n/** Delimiter used between class and namespace names and static members. */\nexport const STATIC_DELIMITER = \".\";\n/** Delimiter used between a function and its inner elements. */\nexport const INNER_DELIMITER = \"~\";\n/** Substitution used to indicate a library directory. */\nexport const LIBRARY_SUBST = \"~lib\";\n/** Library directory prefix. */\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\n/** Path index suffix. */\nexport const INDEX_SUFFIX = PATH_DELIMITER + \"index\";\n/** Stub function delimiter. */\nexport const STUB_DELIMITER = \"@\";\n\n/** Common names. */\nexport namespace CommonNames {\n  // special\n  export const Empty = \"\";\n  // types\n  export const i8 = \"i8\";\n  export const i16 = \"i16\";\n  export const i32 = \"i32\";\n  export const i64 = \"i64\";\n  export const isize = \"isize\";\n  export const u8 = \"u8\";\n  export const u16 = \"u16\";\n  export const u32 = \"u32\";\n  export const u64 = \"u64\";\n  export const usize = \"usize\";\n  export const bool = \"bool\";\n  export const f32 = \"f32\";\n  export const f64 = \"f64\";\n  export const v128 = \"v128\";\n  export const funcref = \"funcref\";\n  export const externref = \"externref\";\n  export const anyref = \"anyref\";\n  export const eqref = \"eqref\";\n  export const i31ref = \"i31ref\";\n  export const dataref = \"dataref\";\n  export const arrayref = \"arrayref\";\n  export const stringref = \"stringref\";\n  export const stringview_wtf8 = \"stringview_wtf8\";\n  export const stringview_wtf16 = \"stringview_wtf16\";\n  export const stringview_iter = \"stringview_iter\";\n  export const i8x16 = \"i8x16\";\n  export const u8x16 = \"u8x16\";\n  export const i16x8 = \"i16x8\";\n  export const u16x8 = \"u16x8\";\n  export const i32x4 = \"i32x4\";\n  export const u32x4 = \"u32x4\";\n  export const i64x2 = \"i64x2\";\n  export const u64x2 = \"u64x2\";\n  export const f32x4 = \"f32x4\";\n  export const f64x2 = \"f64x2\";\n  export const void_ = \"void\";\n  export const number = \"number\";\n  export const boolean = \"boolean\";\n  export const string = \"string\";\n  export const native = \"native\";\n  export const indexof = \"indexof\";\n  export const valueof = \"valueof\";\n  export const returnof = \"returnof\";\n  export const nonnull = \"nonnull\";\n  // aliases\n  export const null_ = \"null\";\n  export const true_ = \"true\";\n  export const false_ = \"false\";\n  // objects\n  export const this_ = \"this\";\n  export const super_ = \"super\";\n  export const constructor = \"constructor\";\n  // constants\n  export const ASC_TARGET = \"ASC_TARGET\";\n  export const ASC_RUNTIME = \"ASC_RUNTIME\";\n  export const ASC_NO_ASSERT = \"ASC_NO_ASSERT\";\n  export const ASC_MEMORY_BASE = \"ASC_MEMORY_BASE\";\n  export const ASC_TABLE_BASE = \"ASC_TABLE_BASE\";\n  export const ASC_OPTIMIZE_LEVEL = \"ASC_OPTIMIZE_LEVEL\";\n  export const ASC_SHRINK_LEVEL = \"ASC_SHRINK_LEVEL\";\n  export const ASC_LOW_MEMORY_LIMIT = \"ASC_LOW_MEMORY_LIMIT\";\n  export const ASC_EXPORT_RUNTIME = \"ASC_EXPORT_RUNTIME\";\n  export const ASC_FEATURE_SIGN_EXTENSION = \"ASC_FEATURE_SIGN_EXTENSION\";\n  export const ASC_FEATURE_MUTABLE_GLOBALS = \"ASC_FEATURE_MUTABLE_GLOBALS\";\n  export const ASC_FEATURE_NONTRAPPING_F2I = \"ASC_FEATURE_NONTRAPPING_F2I\";\n  export const ASC_FEATURE_BULK_MEMORY = \"ASC_FEATURE_BULK_MEMORY\";\n  export const ASC_FEATURE_SIMD = \"ASC_FEATURE_SIMD\";\n  export const ASC_FEATURE_THREADS = \"ASC_FEATURE_THREADS\";\n  export const ASC_FEATURE_EXCEPTION_HANDLING = \"ASC_FEATURE_EXCEPTION_HANDLING\";\n  export const ASC_FEATURE_TAIL_CALLS = \"ASC_FEATURE_TAIL_CALLS\";\n  export const ASC_FEATURE_REFERENCE_TYPES = \"ASC_FEATURE_REFERENCE_TYPES\";\n  export const ASC_FEATURE_MULTI_VALUE = \"ASC_FEATURE_MULTI_VALUE\";\n  export const ASC_FEATURE_GC = \"ASC_FEATURE_GC\";\n  export const ASC_FEATURE_MEMORY64 = \"ASC_FEATURE_MEMORY64\";\n  export const ASC_FEATURE_RELAXED_SIMD = \"ASC_FEATURE_RELAXED_SIMD\";\n  export const ASC_FEATURE_EXTENDED_CONST = \"ASC_FEATURE_EXTENDED_CONST\";\n  export const ASC_FEATURE_STRINGREF = \"ASC_FEATURE_STRINGREF\";\n  export const ASC_VERSION_MAJOR = \"ASC_VERSION_MAJOR\";\n  export const ASC_VERSION_MINOR = \"ASC_VERSION_MINOR\";\n  export const ASC_VERSION_PATCH = \"ASC_VERSION_PATCH\";\n  // classes\n  export const I8 = \"I8\";\n  export const I16 = \"I16\";\n  export const I32 = \"I32\";\n  export const I64 = \"I64\";\n  export const Isize = \"Isize\";\n  export const U8 = \"U8\";\n  export const U16 = \"U16\";\n  export const U32 = \"U32\";\n  export const U64 = \"U64\";\n  export const Usize = \"Usize\";\n  export const Bool = \"Bool\";\n  export const F32 = \"F32\";\n  export const F64 = \"F64\";\n  export const V128 = \"V128\";\n  export const Funcref = \"Funcref\";\n  export const Externref = \"Externref\";\n  export const Anyref = \"Anyref\";\n  export const Eqref = \"Eqref\";\n  export const I31ref = \"I31ref\";\n  export const Dataref = \"Dataref\";\n  export const Arrayref = \"Arrayref\";\n  export const String = \"String\";\n  export const RegExp = \"RegExp\";\n  export const Object = \"Object\";\n  export const Array = \"Array\";\n  export const StaticArray = \"StaticArray\";\n  export const Set = \"Set\";\n  export const Map = \"Map\";\n  export const Function = \"Function\";\n  export const ArrayBufferView = \"ArrayBufferView\";\n  export const ArrayBuffer = \"ArrayBuffer\";\n  export const Math = \"Math\";\n  export const Mathf = \"Mathf\";\n  export const NativeMath = \"NativeMath\";\n  export const NativeMathf = \"NativeMathf\";\n  export const Int8Array = \"Int8Array\";\n  export const Int16Array = \"Int16Array\";\n  export const Int32Array = \"Int32Array\";\n  export const Int64Array = \"Int64Array\";\n  export const Uint8Array = \"Uint8Array\";\n  export const Uint8ClampedArray = \"Uint8ClampedArray\";\n  export const Uint16Array = \"Uint16Array\";\n  export const Uint32Array = \"Uint32Array\";\n  export const Uint64Array = \"Uint64Array\";\n  export const Float32Array = \"Float32Array\";\n  export const Float64Array = \"Float64Array\";\n  export const TemplateStringsArray = \"TemplateStringsArray\";\n  export const Error = \"Error\";\n  // runtime\n  export const abort = \"abort\";\n  export const trace = \"trace\";\n  export const seed = \"seed\";\n  export const pow = \"pow\";\n  export const ipow32 = \"ipow32\";\n  export const ipow64 = \"ipow64\";\n  export const mod = \"mod\";\n  export const alloc = \"__alloc\";\n  export const realloc = \"__realloc\";\n  export const free = \"__free\";\n  export const new_ = \"__new\";\n  export const renew = \"__renew\";\n  export const link = \"__link\";\n  export const collect = \"__collect\";\n  export const visit = \"__visit\";\n  export const newBuffer = \"__newBuffer\";\n  export const newArray = \"__newArray\";\n  export const BLOCK = \"~lib/rt/common/BLOCK\";\n  export const OBJECT = \"~lib/rt/common/OBJECT\";\n  // memory & table\n  export const DefaultMemory = \"0\";\n  export const DefaultTable = \"0\";\n}\n\n// shared\nexport { Feature, featureToString } from \"../std/assembly/shared/feature\";\nexport { Target } from \"../std/assembly/shared/target\";\nexport { Runtime } from \"../std/assembly/shared/runtime\";\nexport { Typeinfo, TypeinfoFlags } from \"../std/assembly/shared/typeinfo\";\n", "// GENERATED FILE. DO NOT EDIT.\n\n/** Enum of available diagnostic codes. */\nexport enum DiagnosticCode {\n  Not_implemented_0 = 100,\n  Operation_is_unsafe = 101,\n  User_defined_0 = 102,\n  Feature_0_is_not_enabled = 103,\n  Low_memory_limit_exceeded_by_static_data_0_1 = 104,\n  Module_requires_at_least_0_pages_of_initial_memory = 105,\n  Module_requires_at_least_0_pages_of_maximum_memory = 106,\n  Shared_memory_requires_maximum_memory_to_be_defined = 107,\n  Shared_memory_requires_feature_threads_to_be_enabled = 108,\n  Transform_0_1 = 109,\n  Start_function_name_0_is_invalid_or_conflicts_with_another_export = 110,\n  Element_0_not_found = 111,\n  Exchange_of_0_values_is_not_supported_by_all_embeddings = 112,\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\n  Type_0_cannot_be_changed_to_type_1 = 202,\n  Operation_0_cannot_be_applied_to_type_1 = 203,\n  Type_0_cannot_be_nullable = 204,\n  Mutable_value_cannot_be_inlined = 206,\n  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,\n  Unmanaged_classes_cannot_implement_interfaces = 208,\n  Invalid_regular_expression_flags = 209,\n  Expression_is_never_null = 210,\n  Class_0_is_final_and_cannot_be_extended = 211,\n  Decorator_0_is_not_valid_here = 212,\n  Duplicate_decorator = 213,\n  Type_0_is_illegal_in_this_context = 214,\n  Optional_parameter_must_have_an_initializer = 215,\n  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,\n  Function_0_cannot_be_inlined_into_itself = 217,\n  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,\n  Optional_properties_are_not_supported = 219,\n  Expression_must_be_a_compile_time_constant = 220,\n  Type_0_is_not_a_function_index_or_function_reference = 221,\n  _0_must_be_a_value_between_1_and_2_inclusive = 222,\n  _0_must_be_a_power_of_two = 223,\n  _0_is_not_a_valid_operator = 224,\n  Expression_cannot_be_represented_by_a_type = 225,\n  Expression_resolves_to_unusual_type_0 = 226,\n  Array_literal_expected = 227,\n  Function_0_is_virtual_and_will_not_be_inlined = 228,\n  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,\n  _0_keyword_cannot_be_used_here = 230,\n  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,\n  Property_0_is_always_assigned_before_being_used = 233,\n  Expression_does_not_compile_to_a_value_at_runtime = 234,\n  Only_variables_functions_and_enums_become_WebAssembly_module_exports = 235,\n  Literal_0_does_not_fit_into_i64_or_u64_types = 236,\n  Index_signature_accessors_in_type_0_differ_in_types = 237,\n  Initializer_definitive_assignment_or_nullable_type_expected = 238,\n  Definitive_assignment_has_no_effect_on_local_variables = 239,\n  Importing_the_table_disables_some_indirect_call_optimizations = 901,\n  Exporting_the_table_disables_some_indirect_call_optimizations = 902,\n  Expression_compiles_to_a_dynamic_check_at_runtime = 903,\n  Indexed_access_may_involve_bounds_checking = 904,\n  Explicitly_returning_constructor_drops_this_allocation = 905,\n  Unnecessary_definite_assignment = 906,\n  _NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead = 907,\n  Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters = 908,\n  Unterminated_string_literal = 1002,\n  Identifier_expected = 1003,\n  _0_expected = 1005,\n  A_file_cannot_have_a_reference_to_itself = 1006,\n  Trailing_comma_not_allowed = 1009,\n  Unexpected_token = 1012,\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\n  _0_modifier_cannot_appear_on_class_elements_of_this_kind = 1031,\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\n  _0_modifier_cannot_be_used_here = 1042,\n  A_rest_parameter_cannot_be_optional = 1047,\n  A_rest_parameter_cannot_have_an_initializer = 1048,\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\n  A_get_accessor_cannot_have_parameters = 1054,\n  Enum_member_must_have_initializer = 1061,\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\n  An_accessor_cannot_have_type_parameters = 1094,\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\n  Type_parameter_list_cannot_be_empty = 1098,\n  Type_argument_list_cannot_be_empty = 1099,\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\n  Expression_expected = 1109,\n  Type_expected = 1110,\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\n  Duplicate_label_0 = 1114,\n  An_export_assignment_cannot_have_modifiers = 1120,\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\n  Digit_expected = 1124,\n  Hexadecimal_digit_expected = 1125,\n  Unexpected_end_of_text = 1126,\n  Invalid_character = 1127,\n  _case_or_default_expected = 1130,\n  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,\n  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,\n  Type_argument_expected = 1140,\n  String_literal_expected = 1141,\n  Line_break_not_permitted_here = 1142,\n  Declaration_expected = 1146,\n  _const_declarations_must_be_initialized = 1155,\n  Unterminated_regular_expression_literal = 1161,\n  Declarations_with_initializers_cannot_also_have_definite_assignment_assertions = 1263,\n  Interface_declaration_cannot_have_implements_clause = 1176,\n  Binary_digit_expected = 1177,\n  Octal_digit_expected = 1178,\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\n  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\n  Unterminated_Unicode_escape_sequence = 1199,\n  Decorators_are_not_valid_here = 1206,\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\n  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,\n  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,\n  A_class_may_only_extend_another_class = 1311,\n  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,\n  A_default_export_can_only_be_used_in_a_module = 1319,\n  An_expression_of_type_0_cannot_be_tested_for_truthiness = 1345,\n  An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = 1351,\n  Duplicate_identifier_0 = 2300,\n  Cannot_find_name_0 = 2304,\n  Module_0_has_no_exported_member_1 = 2305,\n  An_interface_can_only_extend_an_interface = 2312,\n  Generic_type_0_requires_1_type_argument_s = 2314,\n  Type_0_is_not_generic = 2315,\n  Type_0_is_not_assignable_to_type_1 = 2322,\n  Property_0_is_private_in_type_1_but_not_in_type_2 = 2325,\n  Index_signature_is_missing_in_type_0 = 2329,\n  _this_cannot_be_referenced_in_current_location = 2332,\n  _this_cannot_be_referenced_in_constructor_arguments = 2333,\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\n  _super_cannot_be_referenced_in_constructor_arguments = 2336,\n  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,\n  Property_0_does_not_exist_on_type_1 = 2339,\n  Property_0_is_private_and_only_accessible_within_class_1 = 2341,\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\n  This_expression_is_not_constructable = 2351,\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\n  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,\n  Constructors_for_derived_classes_must_contain_a_super_call = 2377,\n  Getter_and_setter_accessors_do_not_agree_in_visibility = 2379,\n  _get_and_set_accessor_must_have_the_same_type = 2380,\n  Overload_signatures_must_all_be_public_private_or_protected = 2385,\n  Constructor_implementation_is_missing = 2390,\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\n  Multiple_constructor_implementations_are_not_allowed = 2392,\n  Duplicate_function_implementation = 2393,\n  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,\n  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,\n  Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2 = 2416,\n  A_class_can_only_implement_an_interface = 2422,\n  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,\n  Types_have_separate_declarations_of_a_private_property_0 = 2442,\n  Property_0_is_protected_in_type_1_but_public_in_type_2 = 2444,\n  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,\n  Variable_0_used_before_its_declaration = 2448,\n  Cannot_redeclare_block_scoped_variable_0 = 2451,\n  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,\n  Variable_0_is_used_before_being_assigned = 2454,\n  Type_alias_0_circularly_references_itself = 2456,\n  Type_0_has_no_property_1 = 2460,\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\n  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\n  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,\n  Cannot_create_an_instance_of_an_abstract_class = 2511,\n  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,\n  Object_is_possibly_null = 2531,\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\n  Index_signature_in_type_0_only_permits_reading = 2542,\n  Expected_0_arguments_but_got_1 = 2554,\n  Expected_at_least_0_arguments_but_got_1 = 2555,\n  Expected_0_type_arguments_but_got_1 = 2558,\n  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,\n  Property_0_is_used_before_being_assigned = 2565,\n  _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property = 2610,\n  _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor = 2611,\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\n  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,\n  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,\n  Cannot_extend_a_class_0_Class_constructor_is_marked_as_private = 2675,\n  The_this_types_of_each_signature_are_incompatible = 2685,\n  Namespace_0_has_no_exported_member_1 = 2694,\n  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,\n  Duplicate_property_0 = 2718,\n  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,\n  Type_0_has_no_call_signatures = 2757,\n  This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0 = 4117,\n  File_0_not_found = 6054,\n  Numeric_separators_are_not_allowed_here = 6188,\n  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,\n  This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without = 6234,\n  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,\n  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011\n}\n\n/** Translates a diagnostic code to its respective string. */\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n    case 100: return \"Not implemented: {0}\";\n    case 101: return \"Operation is unsafe.\";\n    case 102: return \"User-defined: {0}\";\n    case 103: return \"Feature '{0}' is not enabled.\";\n    case 104: return \"Low memory limit exceeded by static data: {0} > {1}\";\n    case 105: return \"Module requires at least '{0}' pages of initial memory.\";\n    case 106: return \"Module requires at least '{0}' pages of maximum memory.\";\n    case 107: return \"Shared memory requires maximum memory to be defined.\";\n    case 108: return \"Shared memory requires feature 'threads' to be enabled.\";\n    case 109: return \"Transform '{0}': {1}\";\n    case 110: return \"Start function name '{0}' is invalid or conflicts with another export.\";\n    case 111: return \"Element '{0}' not found.\";\n    case 112: return \"Exchange of '{0}' values is not supported by all embeddings\";\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\n    case 203: return \"Operation '{0}' cannot be applied to type '{1}'.\";\n    case 204: return \"Type '{0}' cannot be nullable.\";\n    case 206: return \"Mutable value cannot be inlined.\";\n    case 207: return \"Unmanaged classes cannot extend managed classes and vice-versa.\";\n    case 208: return \"Unmanaged classes cannot implement interfaces.\";\n    case 209: return \"Invalid regular expression flags.\";\n    case 210: return \"Expression is never 'null'.\";\n    case 211: return \"Class '{0}' is final and cannot be extended.\";\n    case 212: return \"Decorator '{0}' is not valid here.\";\n    case 213: return \"Duplicate decorator.\";\n    case 214: return \"Type '{0}' is illegal in this context.\";\n    case 215: return \"Optional parameter must have an initializer.\";\n    case 216: return \"Class '{0}' cannot declare a constructor when instantiated from an object literal.\";\n    case 217: return \"Function '{0}' cannot be inlined into itself.\";\n    case 218: return \"Cannot access method '{0}' without calling it as it requires 'this' to be set.\";\n    case 219: return \"Optional properties are not supported.\";\n    case 220: return \"Expression must be a compile-time constant.\";\n    case 221: return \"Type '{0}' is not a function index or function reference.\";\n    case 222: return \"'{0}' must be a value between '{1}' and '{2}' inclusive.\";\n    case 223: return \"'{0}' must be a power of two.\";\n    case 224: return \"'{0}' is not a valid operator.\";\n    case 225: return \"Expression cannot be represented by a type.\";\n    case 226: return \"Expression resolves to unusual type '{0}'.\";\n    case 227: return \"Array literal expected.\";\n    case 228: return \"Function '{0}' is virtual and will not be inlined.\";\n    case 229: return \"Property '{0}' only has a setter and is missing a getter.\";\n    case 230: return \"'{0}' keyword cannot be used here.\";\n    case 231: return \"A class with a constructor explicitly returning something else than 'this' must be '@final'.\";\n    case 233: return \"Property '{0}' is always assigned before being used.\";\n    case 234: return \"Expression does not compile to a value at runtime.\";\n    case 235: return \"Only variables, functions and enums become WebAssembly module exports.\";\n    case 236: return \"Literal '{0}' does not fit into 'i64' or 'u64' types.\";\n    case 237: return \"Index signature accessors in type '{0}' differ in types.\";\n    case 238: return \"Initializer, definitive assignment or nullable type expected.\";\n    case 239: return \"Definitive assignment has no effect on local variables.\";\n    case 901: return \"Importing the table disables some indirect call optimizations.\";\n    case 902: return \"Exporting the table disables some indirect call optimizations.\";\n    case 903: return \"Expression compiles to a dynamic check at runtime.\";\n    case 904: return \"Indexed access may involve bounds checking.\";\n    case 905: return \"Explicitly returning constructor drops 'this' allocation.\";\n    case 906: return \"Unnecessary definite assignment.\";\n    case 907: return \"'NaN' does not compare equal to any other value including itself. Use isNaN(x) instead.\";\n    case 908: return \"Comparison with -0.0 is sign insensitive. Use Object.is(x, -0.0) if the sign matters.\";\n    case 1002: return \"Unterminated string literal.\";\n    case 1003: return \"Identifier expected.\";\n    case 1005: return \"'{0}' expected.\";\n    case 1006: return \"A file cannot have a reference to itself.\";\n    case 1009: return \"Trailing comma not allowed.\";\n    case 1012: return \"Unexpected token.\";\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\n    case 1031: return \"'{0}' modifier cannot appear on class elements of this kind.\";\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\n    case 1042: return \"'{0}' modifier cannot be used here.\";\n    case 1047: return \"A rest parameter cannot be optional.\";\n    case 1048: return \"A rest parameter cannot have an initializer.\";\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\n    case 1061: return \"Enum member must have initializer.\";\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\n    case 1094: return \"An accessor cannot have type parameters.\";\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\n    case 1098: return \"Type parameter list cannot be empty.\";\n    case 1099: return \"Type argument list cannot be empty.\";\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\n    case 1109: return \"Expression expected.\";\n    case 1110: return \"Type expected.\";\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\n    case 1114: return \"Duplicate label '{0}'.\";\n    case 1120: return \"An export assignment cannot have modifiers.\";\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\n    case 1124: return \"Digit expected.\";\n    case 1125: return \"Hexadecimal digit expected.\";\n    case 1126: return \"Unexpected end of text.\";\n    case 1127: return \"Invalid character.\";\n    case 1130: return \"'case' or 'default' expected.\";\n    case 1034: return \"'super' must be followed by an argument list or member access.\";\n    case 1038: return \"A 'declare' modifier cannot be used in an already ambient context.\";\n    case 1140: return \"Type argument expected.\";\n    case 1141: return \"String literal expected.\";\n    case 1142: return \"Line break not permitted here.\";\n    case 1146: return \"Declaration expected.\";\n    case 1155: return \"'const' declarations must be initialized.\";\n    case 1161: return \"Unterminated regular expression literal.\";\n    case 1263: return \"Declarations with initializers cannot also have definite assignment assertions.\";\n    case 1176: return \"Interface declaration cannot have 'implements' clause.\";\n    case 1177: return \"Binary digit expected.\";\n    case 1178: return \"Octal digit expected.\";\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\n    case 1190: return \"The variable declaration of a 'for...of' statement cannot have an initializer.\";\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\n    case 1199: return \"Unterminated Unicode escape sequence.\";\n    case 1206: return \"Decorators are not valid here.\";\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\n    case 1245: return \"Method '{0}' cannot have an implementation because it is marked abstract.\";\n    case 1255: return \"A definite assignment assertion '!' is not permitted in this context.\";\n    case 1311: return \"A class may only extend another class.\";\n    case 1317: return \"A parameter property cannot be declared using a rest parameter.\";\n    case 1319: return \"A default export can only be used in a module.\";\n    case 1345: return \"An expression of type '{0}' cannot be tested for truthiness.\";\n    case 1351: return \"An identifier or keyword cannot immediately follow a numeric literal.\";\n    case 2300: return \"Duplicate identifier '{0}'.\";\n    case 2304: return \"Cannot find name '{0}'.\";\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\n    case 2312: return \"An interface can only extend an interface.\";\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\n    case 2315: return \"Type '{0}' is not generic.\";\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\n    case 2325: return \"Property '{0}' is private in type '{1}' but not in type '{2}'.\";\n    case 2329: return \"Index signature is missing in type '{0}'.\";\n    case 2332: return \"'this' cannot be referenced in current location.\";\n    case 2333: return \"'this' cannot be referenced in constructor arguments.\";\n    case 2335: return \"'super' can only be referenced in a derived class.\";\n    case 2336: return \"'super' cannot be referenced in constructor arguments.\";\n    case 2337: return \"Super calls are not permitted outside constructors or in nested functions inside constructors.\";\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\n    case 2341: return \"Property '{0}' is private and only accessible within class '{1}'.\";\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\n    case 2351: return \"This expression is not constructable.\";\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\n    case 2376: return \"A 'super' call must be the first statement in the constructor.\";\n    case 2377: return \"Constructors for derived classes must contain a 'super' call.\";\n    case 2379: return \"Getter and setter accessors do not agree in visibility.\";\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\n    case 2385: return \"Overload signatures must all be public, private or protected.\";\n    case 2390: return \"Constructor implementation is missing.\";\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\n    case 2393: return \"Duplicate function implementation.\";\n    case 2394: return \"This overload signature is not compatible with its implementation signature.\";\n    case 2395: return \"Individual declarations in merged declaration '{0}' must be all exported or all local.\";\n    case 2416: return \"Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'.\";\n    case 2422: return \"A class can only implement an interface.\";\n    case 2434: return \"A namespace declaration cannot be located prior to a class or function with which it is merged.\";\n    case 2442: return \"Types have separate declarations of a private property '{0}'.\";\n    case 2444: return \"Property '{0}' is protected in type '{1}' but public in type '{2}'.\";\n    case 2445: return \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\";\n    case 2448: return \"Variable '{0}' used before its declaration.\";\n    case 2451: return \"Cannot redeclare block-scoped variable '{0}'\";\n    case 2453: return \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\";\n    case 2454: return \"Variable '{0}' is used before being assigned.\";\n    case 2456: return \"Type alias '{0}' circularly references itself.\";\n    case 2460: return \"Type '{0}' has no property '{1}'.\";\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\n    case 2474: return \"In 'const' enum declarations member initializer must be constant expression.\";\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\n    case 2506: return \"'{0}' is referenced directly or indirectly in its own base expression.\";\n    case 2511: return \"Cannot create an instance of an abstract class.\";\n    case 2515: return \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.\";\n    case 2531: return \"Object is possibly 'null'.\";\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\n    case 2564: return \"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.\";\n    case 2565: return \"Property '{0}' is used before being assigned.\";\n    case 2610: return \"'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property.\";\n    case 2611: return \"'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor.\";\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\n    case 2673: return \"Constructor of class '{0}' is private and only accessible within the class declaration.\";\n    case 2674: return \"Constructor of class '{0}' is protected and only accessible within the class declaration.\";\n    case 2675: return \"Cannot extend a class '{0}'. Class constructor is marked as private.\";\n    case 2685: return \"The 'this' types of each signature are incompatible.\";\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\n    case 2706: return \"Required type parameters may not follow optional type parameters.\";\n    case 2718: return \"Duplicate property '{0}'.\";\n    case 2741: return \"Property '{0}' is missing in type '{1}' but required in type '{2}'.\";\n    case 2757: return \"Type '{0}' has no call signatures.\";\n    case 4117: return \"This member cannot have an 'override' modifier because it is not declared in the base class '{0}'.\";\n    case 6054: return \"File '{0}' not found.\";\n    case 6188: return \"Numeric separators are not allowed here.\";\n    case 6189: return \"Multiple consecutive numeric separators are not permitted.\";\n    case 6234: return \"This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?\";\n    case 17009: return \"'super' must be called before accessing 'this' in the constructor of a derived class.\";\n    case 17011: return \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\";\n    default: return \"\";\n  }\n}\n", "/**\n * @fileoverview Various utility.\n * @license Apache-2.0\n */\n\nexport * from \"./util/binary\";\nexport * from \"./util/collections\";\nexport * from \"./util/math\";\nexport * from \"./util/path\";\nexport * from \"./util/terminal\";\nexport * from \"./util/text\";\nexport * from \"./util/vector\";\n", "/**\n * @fileoverview Various binary reading and writing utility.\n * @license Apache-2.0\n */\n\n/** Reads an 8-bit integer from the specified buffer. */\nexport function readI8(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset];\n}\n\n/** Writes an 8-bit integer to the specified buffer. */\nexport function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset] = value;\n}\n\n/** Reads a 16-bit integer from the specified buffer. */\nexport function readI16(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8;\n}\n\n/** Writes a 16-bit integer to the specified buffer. */\nexport function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n}\n\n/** Reads a 32-bit integer from the specified buffer. */\nexport function readI32(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8\n       | i32(buffer[offset + 2]) << 16\n       | i32(buffer[offset + 3]) << 24;\n}\n\n/** Writes a 32-bit integer to the specified buffer. */\nexport function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n  buffer[offset + 2] = value >>> 16;\n  buffer[offset + 3] = value >>> 24;\n}\n\n/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */\nexport function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  writeI32(value, buffer, offset);\n  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);\n}\n\n/** Reads a 64-bit integer from the specified buffer. */\nexport function readI64(buffer: Uint8Array, offset: i32): i64 {\n  let lo = readI32(buffer, offset);\n  let hi = readI32(buffer, offset + 4);\n  return i64_new(lo, hi);\n}\n\n/** Writes a 64-bit integer to the specified buffer. */\nexport function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {\n  writeI32(i64_low(value), buffer, offset);\n  writeI32(i64_high(value), buffer, offset + 4);\n}\n\n/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */\nexport function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));\n  writeI32(i64_low(value), buffer, offset);\n}\n\n/** Reads a 32-bit float from the specified buffer. */\nexport function readF32(buffer: Uint8Array, offset: i32): f32 {\n  return i32_as_f32(readI32(buffer, offset));\n}\n\n/** Writes a 32-bit float to the specified buffer. */\nexport function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {\n  writeI32(f32_as_i32(value), buffer, offset);\n}\n\n/** Reads a 64-bit float from the specified buffer. */\nexport function readF64(buffer: Uint8Array, offset: i32): f64 {\n  return i64_as_f64(readI64(buffer, offset));\n}\n\n/** Writes a 64-bit float to the specified buffer. */\nexport function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {\n  let valueI64 = f64_as_i64(value);\n  writeI32(i64_low(valueI64), buffer, offset);\n  writeI32(i64_high(valueI64), buffer, offset + 4);\n}\n\n/** Reads a 128-bit vector from the specified buffer. */\nexport function readV128(buffer: Uint8Array, offset: i32): Uint8Array {\n  return buffer.slice(offset, offset + 16);\n}\n\n/** Writes a 128-bit vector to the specified buffer. */\nexport function writeV128(value: Uint8Array, buffer: Uint8Array, offset: i32): void {\n  assert(value.length == 16);\n  buffer.set(value, offset);\n}\n", "/**\n * @fileoverview Various collections utility.\n * @license Apache-2.0\n */\n\n/** Clone map. Typically used to track contextual type arguments. */\nexport function cloneMap<K,V>(map: Map<K,V> | null): Map<K,V> {\n  if (!ASC_TARGET) { // JS\n    // fast path for js target\n    return new Map<K,V>(map);\n  } else {\n    let out = new Map<K,V>();\n    if (map) {\n      // TODO: for (let [k, v] of map) {\n      for (let _keys = Map_keys(map), i = 0, k = _keys.length; i < k; ++i) {\n        let k = unchecked(_keys[i]);\n        let v = assert(map.get(k));\n        out.set(k, v);\n      }\n    }\n    return out;\n  }\n}\n\n/** Merge two maps in into new one. */\nexport function mergeMaps<K,V>(map1: Map<K,V>, map2: Map<K,V>): Map<K,V> {\n  if (!ASC_TARGET) { // JS\n    let out = new Map<K,V>(map1);\n    map2.forEach((v, k) => out.set(k, v));\n    return out;\n  } else {\n    let out = new Map<K,V>();\n    // TODO: for (let [k, v] of map1) {\n    for (let _keys = Map_keys(map1), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(map1.get(k));\n      out.set(k, v);\n    }\n    // TODO: for (let [k, v] of map2) {\n    for (let _keys = Map_keys(map2), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(map2.get(k));\n      out.set(k, v);\n    }\n    return out;\n  }\n}\n\n/** BitSet represent growable sequence of N bits. It's faster alternative of Set<i32> when elements\n * are not too much sparsed. Also it's more memory and cache efficient than Array<bool>.\n * The best way to use it for short bit sequences (less than 32*(2**16)).\n */\nexport class BitSet {\n  words!: Uint32Array;\n\n  constructor() {\n    this.clear();\n  }\n\n  get size(): i32 {\n    let count = 0;\n    let words = this.words;\n    for (let i = 0, len = words.length; i < len; i++) {\n      let word = unchecked(words[i]);\n      if (word) count += popcnt(word);\n    }\n    return count;\n  }\n\n  add(index: i32): this {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) { // resize\n      this.words = new Uint32Array(idx + 16);\n      this.words.set(words);\n      words = this.words;\n    }\n    unchecked(words[idx] |= 1 << index);\n    return this;\n  }\n\n  delete(index: i32): void {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) return;\n    unchecked(words[idx] &= ~(1 << index));\n  }\n\n  has(index: i32): bool {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) return false;\n    return (unchecked(words[index >>> 5]) & (1 << index)) !== 0;\n  }\n\n  clear(): void {\n    this.words = new Uint32Array(16);\n  }\n\n  toArray(): i32[] {\n    let res = new Array<i32>(this.size);\n    for (let i = 0, p = 0, len = this.words.length; i < len; ++i) {\n      let word = unchecked(this.words[i]);\n      while (word) {\n        let mask = word & -word;\n        unchecked(res[p++] = (i << 5) + popcnt(mask - 1));\n        word ^= mask;\n      }\n    }\n    return res;\n  }\n\n  toString(): string {\n    return `BitSet { ${this.toArray()} }`;\n  }\n}\n", "/**\n * @fileoverview Various math utility.\n * @license Apache-2.0\n */\n\n/** Tests if `x` is a power of two. */\nexport function isPowerOf2(x: i32): bool {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n\nexport function accuratePow64(x: f64, y: f64): f64 {\n  if (!ASC_TARGET) { // ASC_TARGET == JS\n    // Engines like V8, WebKit and SpiderMonkey uses powi fast path if exponent is integer\n    // This speculative optimization leads to loose precisions like 10 ** 208 != 1e208\n    // or/and 10 ** -5 != 1e-5 anymore. For avoid this behaviour we are forcing exponent\n    // to fractional form and compensate this afterwards.\n    if (isFinite(y) && Math.abs(y) >= 2 && Math.trunc(y) == y) {\n      if (y < 0) {\n        return Math.pow(x, y + 0.5) / Math.pow(x, 0.5);\n      } else {\n        return Math.pow(x, y - 0.5) * Math.pow(x, 0.5);\n      }\n    }\n  }\n  return Math.pow(x, y);\n}\n", "/**\n * @fileoverview Various character and text utility.\n * @license Apache-2.0\n */\n\n/** An enum of named character codes. */\nexport const enum CharCode {\n\n  Null = 0,\n  LineFeed = 0x0A,\n  CarriageReturn = 0x0D,\n  LineSeparator = 0x2028,\n  ParagraphSeparator = 0x2029,\n  NextLine = 0x0085,\n\n  Space = 0x20,\n  NonBreakingSpace = 0xA0,\n  EnQuad = 0x2000,\n  EmQuad = 0x2001,\n  EnSpace = 0x2002,\n  EmSpace = 0x2003,\n  ThreePerEmSpace = 0x2004,\n  FourPerEmSpace = 0x2005,\n  SixPerEmSpace = 0x2006,\n  FigureSpace = 0x2007,\n  PunctuationSpace = 0x2008,\n  ThinSpace = 0x2009,\n  HairSpace = 0x200A,\n  ZeroWidthSpace = 0x200B,\n  NarrowNoBreakSpace = 0x202F,\n  IdeographicSpace = 0x3000,\n  MathematicalSpace = 0x205F,\n  Ogham = 0x1680,\n\n  _ = 0x5F,\n\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n\n  a = 0x61,\n  b = 0x62,\n  c = 0x63,\n  d = 0x64,\n  e = 0x65,\n  f = 0x66,\n  g = 0x67,\n  h = 0x68,\n  i = 0x69,\n  j = 0x6A,\n  k = 0x6B,\n  l = 0x6C,\n  m = 0x6D,\n  n = 0x6E,\n  o = 0x6F,\n  p = 0x70,\n  q = 0x71,\n  r = 0x72,\n  s = 0x73,\n  t = 0x74,\n  u = 0x75,\n  v = 0x76,\n  w = 0x77,\n  x = 0x78,\n  y = 0x79,\n  z = 0x7A,\n\n  A = 0x41,\n  B = 0x42,\n  C = 0x43,\n  D = 0x44,\n  E = 0x45,\n  F = 0x46,\n  G = 0x47,\n  H = 0x48,\n  I = 0x49,\n  J = 0x4A,\n  K = 0x4B,\n  L = 0x4C,\n  M = 0x4D,\n  N = 0x4E,\n  O = 0x4F,\n  P = 0x50,\n  Q = 0x51,\n  R = 0x52,\n  S = 0x53,\n  T = 0x54,\n  U = 0x55,\n  V = 0x56,\n  W = 0x57,\n  X = 0x58,\n  Y = 0x59,\n  Z = 0x5a,\n\n  Ampersand = 0x26,\n  Asterisk = 0x2A,\n  At = 0x40,\n  Backslash = 0x5C,\n  Backtick = 0x60,\n  Bar = 0x7C,\n  Caret = 0x5E,\n  CloseBrace = 0x7D,\n  CloseBracket = 0x5D,\n  CloseParen = 0x29,\n  Colon = 0x3A,\n  Comma = 0x2C,\n  Dollar = 0x24,\n  Dot = 0x2E,\n  DoubleQuote = 0x22,\n  Equals = 0x3D,\n  Exclamation = 0x21,\n  GreaterThan = 0x3E,\n  Hash = 0x23,\n  LessThan = 0x3C,\n  Minus = 0x2D,\n  OpenBrace = 0x7B,\n  OpenBracket = 0x5B,\n  OpenParen = 0x28,\n  Percent = 0x25,\n  Plus = 0x2B,\n  Question = 0x3F,\n  Semicolon = 0x3B,\n  SingleQuote = 0x27,\n  Slash = 0x2F,\n  Tilde = 0x7E,\n\n  Backspace = 0x08,\n  FormFeed = 0x0C,\n  ByteOrderMark = 0xFEFF,\n  Tab = 0x09,\n  VerticalTab = 0x0B\n}\n\n/** Tests if the specified character code is some sort of line break. */\nexport function isLineBreak(c: i32): bool {\n  switch (c) {\n    case CharCode.LineFeed:\n    case CharCode.CarriageReturn:\n    case CharCode.LineSeparator:\n    case CharCode.ParagraphSeparator: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/** Tests if the specified character code is some sort of white space. */\nexport function isWhiteSpace(c: i32): bool {\n  // NOTE: Calling code assumes that there are no supplementary whitespaces.\n  // If Unicode ever adds one, uses of this function must be updated to\n  // conditionally advance by two code units, i.e. using `numCodeUnits`.\n  switch (c) {\n    case CharCode.Space:\n    case CharCode.Tab:\n    case CharCode.VerticalTab:\n    case CharCode.FormFeed:\n    case CharCode.NonBreakingSpace:\n    case CharCode.NextLine:\n    case CharCode.Ogham:\n    case CharCode.NarrowNoBreakSpace:\n    case CharCode.MathematicalSpace:\n    case CharCode.IdeographicSpace:\n    case CharCode.ByteOrderMark: {\n      return true;\n    }\n    default: {\n      return c >= CharCode.EnQuad && c <= CharCode.ZeroWidthSpace;\n    }\n  }\n}\n\n/** First high (lead) surrogate. */\nexport const SURROGATE_HIGH = 0xD800;\n\n/** First low (trail) surrogate. */\nexport const SURROGATE_LOW = 0xDC00;\n\n/** Tests if a code unit or code point is a surrogate. */\nexport function isSurrogate(c: i32): bool {\n  // F800: 11111 0 0000000000 Mask\n  // D800: 11011 X XXXXXXXXXX Any surrogate\n  return (c & 0xF800) == SURROGATE_HIGH;\n}\n\n/** Tests if a surrogate is a high (lead) surrogate. */\nexport function isSurrogateHigh(c: i32): bool {\n  // D800-DBFF\n  return c < SURROGATE_LOW;\n}\n\n/** Tests if a surrogate is a low (trail) surrogate. */\nexport function isSurrogateLow(c: i32): bool {\n  // DC00-DFFF\n  return c >= SURROGATE_LOW;\n}\n\n/** Tests if a code unit or code point is a high (lead) surrogate. */\nexport function isHighSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // D800: 11011 0 XXXXXXXXXX High/Lead surrogate\n  return (c & 0xFC00) == SURROGATE_HIGH;\n}\n\n/** Tests if a code unit or code point is a low (trail) surrogate. */\nexport function isLowSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // DC00: 11011 1 XXXXXXXXXX Low/Trail surrogate\n  return (c & 0xFC00) == SURROGATE_LOW;\n}\n\n/** Converts a surrogate pair to its respective code point. */\nexport function combineSurrogates(hi: i32, lo: i32): i32 {\n  return 0x10000 + ((hi & 0x3FF) << 10) | (lo & 0x3FF);\n}\n\n/** Gets the number of UTF-16 code units of the specified code point. */\nexport function numCodeUnits(cp: i32): i32 {\n  return 1 + i32(cp > 0xffff);\n}\n\nexport function isAlpha(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z;\n}\n\n/** Tests if the specified character code is a valid decimal digit. */\nexport function isDecimal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid octal digit. */\nexport function isOctal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._7;\n}\n\n/** Tests if the specified character code is a valid hexadecimal symbol [a-f]. */\nexport function isHexBase(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - f|F\n  return c0 >= CharCode.a && c0 <= CharCode.f;\n}\n\n/** Tests if the specified character code is a valid hexadecimal digit. */\nexport function isHexOrDecimal(c: i32): bool {\n  return isDecimal(c) || isHexBase(c);\n}\n\n/** Tests if the specified character code is trivially alphanumeric. */\nexport function isAlphaOrDecimal(c: i32): bool {\n  return isAlpha(c) || isDecimal(c);\n}\n\n/** Tests if the specified code point is a valid start of an identifier. */\nexport function isIdentifierStart(cp: i32): bool {\n  return isAlpha(cp)\n      || cp == CharCode._\n      || cp == CharCode.Dollar\n      || cp >= unicodeIdentifierStartMin && cp <= unicodeIdentifierStartMax\n         && lookupInUnicodeMap(cp, unicodeIdentifierStart);\n}\n\n/** Tests if the specified code point is a valid part of an identifier. */\nexport function isIdentifierPart(cp: i32): bool {\n  return isAlphaOrDecimal(cp)\n      || cp == CharCode._\n      || cp == CharCode.Dollar\n      || cp >= unicodeIdentifierPartMin && cp <= unicodeIdentifierPartMax\n         && lookupInUnicodeMap(cp, unicodeIdentifierPart);\n}\n\n/** Tests if the specified string is a valid identifer. */\nexport function isIdentifier(str: string): bool {\n  let len = str.length;\n  if (!len) return false;\n  let cp = <i32>str.codePointAt(0);\n  if (!isIdentifierStart(cp)) return false;\n  let i = numCodeUnits(cp);\n  while (i < len) {\n    cp = <i32>str.codePointAt(i);\n    if (!isIdentifierPart(cp)) return false;\n    i += numCodeUnits(cp);\n  }\n  return true;\n}\n\n/** Unicode 14.0 ID_Start/Other_ID_Start ranges */\nconst unicodeIdentifierStart: i32[] = [/*\n| from  ...  to | from  ...  to | from  ...  to | from  ...  to |*/\n  170   , 170   , 181   , 181   , 186   , 186   , 192   , 214   ,\n  216   , 246   , 248   , 705   , 710   , 721   , 736   , 740   ,\n  748   , 748   , 750   , 750   , 880   , 884   , 886   , 887   ,\n  890   , 893   , 895   , 895   , 902   , 902   , 904   , 906   ,\n  908   , 908   , 910   , 929   , 931   , 1013  , 1015  , 1153  ,\n  1162  , 1327  , 1329  , 1366  , 1369  , 1369  , 1376  , 1416  ,\n  1488  , 1514  , 1519  , 1522  , 1568  , 1610  , 1646  , 1647  ,\n  1649  , 1747  , 1749  , 1749  , 1765  , 1766  , 1774  , 1775  ,\n  1786  , 1788  , 1791  , 1791  , 1808  , 1808  , 1810  , 1839  ,\n  1869  , 1957  , 1969  , 1969  , 1994  , 2026  , 2036  , 2037  ,\n  2042  , 2042  , 2048  , 2069  , 2074  , 2074  , 2084  , 2084  ,\n  2088  , 2088  , 2112  , 2136  , 2144  , 2154  , 2160  , 2183  ,\n  2185  , 2190  , 2208  , 2249  , 2308  , 2361  , 2365  , 2365  ,\n  2384  , 2384  , 2392  , 2401  , 2417  , 2432  , 2437  , 2444  ,\n  2447  , 2448  , 2451  , 2472  , 2474  , 2480  , 2482  , 2482  ,\n  2486  , 2489  , 2493  , 2493  , 2510  , 2510  , 2524  , 2525  ,\n  2527  , 2529  , 2544  , 2545  , 2556  , 2556  , 2565  , 2570  ,\n  2575  , 2576  , 2579  , 2600  , 2602  , 2608  , 2610  , 2611  ,\n  2613  , 2614  , 2616  , 2617  , 2649  , 2652  , 2654  , 2654  ,\n  2674  , 2676  , 2693  , 2701  , 2703  , 2705  , 2707  , 2728  ,\n  2730  , 2736  , 2738  , 2739  , 2741  , 2745  , 2749  , 2749  ,\n  2768  , 2768  , 2784  , 2785  , 2809  , 2809  , 2821  , 2828  ,\n  2831  , 2832  , 2835  , 2856  , 2858  , 2864  , 2866  , 2867  ,\n  2869  , 2873  , 2877  , 2877  , 2908  , 2909  , 2911  , 2913  ,\n  2929  , 2929  , 2947  , 2947  , 2949  , 2954  , 2958  , 2960  ,\n  2962  , 2965  , 2969  , 2970  , 2972  , 2972  , 2974  , 2975  ,\n  2979  , 2980  , 2984  , 2986  , 2990  , 3001  , 3024  , 3024  ,\n  3077  , 3084  , 3086  , 3088  , 3090  , 3112  , 3114  , 3129  ,\n  3133  , 3133  , 3160  , 3162  , 3165  , 3165  , 3168  , 3169  ,\n  3200  , 3200  , 3205  , 3212  , 3214  , 3216  , 3218  , 3240  ,\n  3242  , 3251  , 3253  , 3257  , 3261  , 3261  , 3293  , 3294  ,\n  3296  , 3297  , 3313  , 3314  , 3332  , 3340  , 3342  , 3344  ,\n  3346  , 3386  , 3389  , 3389  , 3406  , 3406  , 3412  , 3414  ,\n  3423  , 3425  , 3450  , 3455  , 3461  , 3478  , 3482  , 3505  ,\n  3507  , 3515  , 3517  , 3517  , 3520  , 3526  , 3585  , 3632  ,\n  3634  , 3635  , 3648  , 3654  , 3713  , 3714  , 3716  , 3716  ,\n  3718  , 3722  , 3724  , 3747  , 3749  , 3749  , 3751  , 3760  ,\n  3762  , 3763  , 3773  , 3773  , 3776  , 3780  , 3782  , 3782  ,\n  3804  , 3807  , 3840  , 3840  , 3904  , 3911  , 3913  , 3948  ,\n  3976  , 3980  , 4096  , 4138  , 4159  , 4159  , 4176  , 4181  ,\n  4186  , 4189  , 4193  , 4193  , 4197  , 4198  , 4206  , 4208  ,\n  4213  , 4225  , 4238  , 4238  , 4256  , 4293  , 4295  , 4295  ,\n  4301  , 4301  , 4304  , 4346  , 4348  , 4680  , 4682  , 4685  ,\n  4688  , 4694  , 4696  , 4696  , 4698  , 4701  , 4704  , 4744  ,\n  4746  , 4749  , 4752  , 4784  , 4786  , 4789  , 4792  , 4798  ,\n  4800  , 4800  , 4802  , 4805  , 4808  , 4822  , 4824  , 4880  ,\n  4882  , 4885  , 4888  , 4954  , 4992  , 5007  , 5024  , 5109  ,\n  5112  , 5117  , 5121  , 5740  , 5743  , 5759  , 5761  , 5786  ,\n  5792  , 5866  , 5870  , 5880  , 5888  , 5905  , 5919  , 5937  ,\n  5952  , 5969  , 5984  , 5996  , 5998  , 6000  , 6016  , 6067  ,\n  6103  , 6103  , 6108  , 6108  , 6176  , 6264  , 6272  , 6312  ,\n  6314  , 6314  , 6320  , 6389  , 6400  , 6430  , 6480  , 6509  ,\n  6512  , 6516  , 6528  , 6571  , 6576  , 6601  , 6656  , 6678  ,\n  6688  , 6740  , 6823  , 6823  , 6917  , 6963  , 6981  , 6988  ,\n  7043  , 7072  , 7086  , 7087  , 7098  , 7141  , 7168  , 7203  ,\n  7245  , 7247  , 7258  , 7293  , 7296  , 7304  , 7312  , 7354  ,\n  7357  , 7359  , 7401  , 7404  , 7406  , 7411  , 7413  , 7414  ,\n  7418  , 7418  , 7424  , 7615  , 7680  , 7957  , 7960  , 7965  ,\n  7968  , 8005  , 8008  , 8013  , 8016  , 8023  , 8025  , 8025  ,\n  8027  , 8027  , 8029  , 8029  , 8031  , 8061  , 8064  , 8116  ,\n  8118  , 8124  , 8126  , 8126  , 8130  , 8132  , 8134  , 8140  ,\n  8144  , 8147  , 8150  , 8155  , 8160  , 8172  , 8178  , 8180  ,\n  8182  , 8188  , 8305  , 8305  , 8319  , 8319  , 8336  , 8348  ,\n  8450  , 8450  , 8455  , 8455  , 8458  , 8467  , 8469  , 8469  ,\n  8472  , 8477  , 8484  , 8484  , 8486  , 8486  , 8488  , 8488  ,\n  8490  , 8505  , 8508  , 8511  , 8517  , 8521  , 8526  , 8526  ,\n  8544  , 8584  , 11264 , 11492 , 11499 , 11502 , 11506 , 11507 ,\n  11520 , 11557 , 11559 , 11559 , 11565 , 11565 , 11568 , 11623 ,\n  11631 , 11631 , 11648 , 11670 , 11680 , 11686 , 11688 , 11694 ,\n  11696 , 11702 , 11704 , 11710 , 11712 , 11718 , 11720 , 11726 ,\n  11728 , 11734 , 11736 , 11742 , 12293 , 12295 , 12321 , 12329 ,\n  12337 , 12341 , 12344 , 12348 , 12353 , 12438 , 12443 , 12447 ,\n  12449 , 12538 , 12540 , 12543 , 12549 , 12591 , 12593 , 12686 ,\n  12704 , 12735 , 12784 , 12799 , 13312 , 19903 , 19968 , 42124 ,\n  42192 , 42237 , 42240 , 42508 , 42512 , 42527 , 42538 , 42539 ,\n  42560 , 42606 , 42623 , 42653 , 42656 , 42735 , 42775 , 42783 ,\n  42786 , 42888 , 42891 , 42954 , 42960 , 42961 , 42963 , 42963 ,\n  42965 , 42969 , 42994 , 43009 , 43011 , 43013 , 43015 , 43018 ,\n  43020 , 43042 , 43072 , 43123 , 43138 , 43187 , 43250 , 43255 ,\n  43259 , 43259 , 43261 , 43262 , 43274 , 43301 , 43312 , 43334 ,\n  43360 , 43388 , 43396 , 43442 , 43471 , 43471 , 43488 , 43492 ,\n  43494 , 43503 , 43514 , 43518 , 43520 , 43560 , 43584 , 43586 ,\n  43588 , 43595 , 43616 , 43638 , 43642 , 43642 , 43646 , 43695 ,\n  43697 , 43697 , 43701 , 43702 , 43705 , 43709 , 43712 , 43712 ,\n  43714 , 43714 , 43739 , 43741 , 43744 , 43754 , 43762 , 43764 ,\n  43777 , 43782 , 43785 , 43790 , 43793 , 43798 , 43808 , 43814 ,\n  43816 , 43822 , 43824 , 43866 , 43868 , 43881 , 43888 , 44002 ,\n  44032 , 55203 , 55216 , 55238 , 55243 , 55291 , 63744 , 64109 ,\n  64112 , 64217 , 64256 , 64262 , 64275 , 64279 , 64285 , 64285 ,\n  64287 , 64296 , 64298 , 64310 , 64312 , 64316 , 64318 , 64318 ,\n  64320 , 64321 , 64323 , 64324 , 64326 , 64433 , 64467 , 64829 ,\n  64848 , 64911 , 64914 , 64967 , 65008 , 65019 , 65136 , 65140 ,\n  65142 , 65276 , 65313 , 65338 , 65345 , 65370 , 65382 , 65470 ,\n  65474 , 65479 , 65482 , 65487 , 65490 , 65495 , 65498 , 65500 ,\n  65536 , 65547 , 65549 , 65574 , 65576 , 65594 , 65596 , 65597 ,\n  65599 , 65613 , 65616 , 65629 , 65664 , 65786 , 65856 , 65908 ,\n  66176 , 66204 , 66208 , 66256 , 66304 , 66335 , 66349 , 66378 ,\n  66384 , 66421 , 66432 , 66461 , 66464 , 66499 , 66504 , 66511 ,\n  66513 , 66517 , 66560 , 66717 , 66736 , 66771 , 66776 , 66811 ,\n  66816 , 66855 , 66864 , 66915 , 66928 , 66938 , 66940 , 66954 ,\n  66956 , 66962 , 66964 , 66965 , 66967 , 66977 , 66979 , 66993 ,\n  66995 , 67001 , 67003 , 67004 , 67072 , 67382 , 67392 , 67413 ,\n  67424 , 67431 , 67456 , 67461 , 67463 , 67504 , 67506 , 67514 ,\n  67584 , 67589 , 67592 , 67592 , 67594 , 67637 , 67639 , 67640 ,\n  67644 , 67644 , 67647 , 67669 , 67680 , 67702 , 67712 , 67742 ,\n  67808 , 67826 , 67828 , 67829 , 67840 , 67861 , 67872 , 67897 ,\n  67968 , 68023 , 68030 , 68031 , 68096 , 68096 , 68112 , 68115 ,\n  68117 , 68119 , 68121 , 68149 , 68192 , 68220 , 68224 , 68252 ,\n  68288 , 68295 , 68297 , 68324 , 68352 , 68405 , 68416 , 68437 ,\n  68448 , 68466 , 68480 , 68497 , 68608 , 68680 , 68736 , 68786 ,\n  68800 , 68850 , 68864 , 68899 , 69248 , 69289 , 69296 , 69297 ,\n  69376 , 69404 , 69415 , 69415 , 69424 , 69445 , 69488 , 69505 ,\n  69552 , 69572 , 69600 , 69622 , 69635 , 69687 , 69745 , 69746 ,\n  69749 , 69749 , 69763 , 69807 , 69840 , 69864 , 69891 , 69926 ,\n  69956 , 69956 , 69959 , 69959 , 69968 , 70002 , 70006 , 70006 ,\n  70019 , 70066 , 70081 , 70084 , 70106 , 70106 , 70108 , 70108 ,\n  70144 , 70161 , 70163 , 70187 , 70272 , 70278 , 70280 , 70280 ,\n  70282 , 70285 , 70287 , 70301 , 70303 , 70312 , 70320 , 70366 ,\n  70405 , 70412 , 70415 , 70416 , 70419 , 70440 , 70442 , 70448 ,\n  70450 , 70451 , 70453 , 70457 , 70461 , 70461 , 70480 , 70480 ,\n  70493 , 70497 , 70656 , 70708 , 70727 , 70730 , 70751 , 70753 ,\n  70784 , 70831 , 70852 , 70853 , 70855 , 70855 , 71040 , 71086 ,\n  71128 , 71131 , 71168 , 71215 , 71236 , 71236 , 71296 , 71338 ,\n  71352 , 71352 , 71424 , 71450 , 71488 , 71494 , 71680 , 71723 ,\n  71840 , 71903 , 71935 , 71942 , 71945 , 71945 , 71948 , 71955 ,\n  71957 , 71958 , 71960 , 71983 , 71999 , 71999 , 72001 , 72001 ,\n  72096 , 72103 , 72106 , 72144 , 72161 , 72161 , 72163 , 72163 ,\n  72192 , 72192 , 72203 , 72242 , 72250 , 72250 , 72272 , 72272 ,\n  72284 , 72329 , 72349 , 72349 , 72368 , 72440 , 72704 , 72712 ,\n  72714 , 72750 , 72768 , 72768 , 72818 , 72847 , 72960 , 72966 ,\n  72968 , 72969 , 72971 , 73008 , 73030 , 73030 , 73056 , 73061 ,\n  73063 , 73064 , 73066 , 73097 , 73112 , 73112 , 73440 , 73458 ,\n  73648 , 73648 , 73728 , 74649 , 74752 , 74862 , 74880 , 75075 ,\n  77712 , 77808 , 77824 , 78894 , 82944 , 83526 , 92160 , 92728 ,\n  92736 , 92766 , 92784 , 92862 , 92880 , 92909 , 92928 , 92975 ,\n  92992 , 92995 , 93027 , 93047 , 93053 , 93071 , 93760 , 93823 ,\n  93952 , 94026 , 94032 , 94032 , 94099 , 94111 , 94176 , 94177 ,\n  94179 , 94179 , 94208 , 100343, 100352, 101589, 101632, 101640,\n  110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882,\n  110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770,\n  113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892,\n  119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974,\n  119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003,\n  120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092,\n  120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134,\n  120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538,\n  120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654,\n  120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770,\n  120772, 120779, 122624, 122654, 123136, 123180, 123191, 123197,\n  123214, 123214, 123536, 123565, 123584, 123627, 124896, 124902,\n  124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124,\n  125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495,\n  126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514,\n  126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530,\n  126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543,\n  126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553,\n  126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562,\n  126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583,\n  126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619,\n  126625, 126627, 126629, 126633, 126635, 126651, 131072, 173791,\n  173824, 177976, 177984, 178205, 178208, 183969, 183984, 191456,\n  194560, 195101, 196608, 201546,\n];\nconst unicodeIdentifierStartMin = 170;\nconst unicodeIdentifierStartMax = 201546;\n\n/** Unicode 14.0 ID_Continue/Other_ID_Continue + ID_Start/Other_ID_Start ranges*/\nconst unicodeIdentifierPart: i32[] = [/*\n| from  ...  to | from  ...  to | from  ...  to | from  ...  to |*/\n  170   , 170   , 181   , 181   , 183   , 183   , 186   , 186   ,\n  192   , 214   , 216   , 246   , 248   , 705   , 710   , 721   ,\n  736   , 740   , 748   , 748   , 750   , 750   , 768   , 884   ,\n  886   , 887   , 890   , 893   , 895   , 895   , 902   , 906   ,\n  908   , 908   , 910   , 929   , 931   , 1013  , 1015  , 1153  ,\n  1155  , 1159  , 1162  , 1327  , 1329  , 1366  , 1369  , 1369  ,\n  1376  , 1416  , 1425  , 1469  , 1471  , 1471  , 1473  , 1474  ,\n  1476  , 1477  , 1479  , 1479  , 1488  , 1514  , 1519  , 1522  ,\n  1552  , 1562  , 1568  , 1641  , 1646  , 1747  , 1749  , 1756  ,\n  1759  , 1768  , 1770  , 1788  , 1791  , 1791  , 1808  , 1866  ,\n  1869  , 1969  , 1984  , 2037  , 2042  , 2042  , 2045  , 2045  ,\n  2048  , 2093  , 2112  , 2139  , 2144  , 2154  , 2160  , 2183  ,\n  2185  , 2190  , 2200  , 2273  , 2275  , 2403  , 2406  , 2415  ,\n  2417  , 2435  , 2437  , 2444  , 2447  , 2448  , 2451  , 2472  ,\n  2474  , 2480  , 2482  , 2482  , 2486  , 2489  , 2492  , 2500  ,\n  2503  , 2504  , 2507  , 2510  , 2519  , 2519  , 2524  , 2525  ,\n  2527  , 2531  , 2534  , 2545  , 2556  , 2556  , 2558  , 2558  ,\n  2561  , 2563  , 2565  , 2570  , 2575  , 2576  , 2579  , 2600  ,\n  2602  , 2608  , 2610  , 2611  , 2613  , 2614  , 2616  , 2617  ,\n  2620  , 2620  , 2622  , 2626  , 2631  , 2632  , 2635  , 2637  ,\n  2641  , 2641  , 2649  , 2652  , 2654  , 2654  , 2662  , 2677  ,\n  2689  , 2691  , 2693  , 2701  , 2703  , 2705  , 2707  , 2728  ,\n  2730  , 2736  , 2738  , 2739  , 2741  , 2745  , 2748  , 2757  ,\n  2759  , 2761  , 2763  , 2765  , 2768  , 2768  , 2784  , 2787  ,\n  2790  , 2799  , 2809  , 2815  , 2817  , 2819  , 2821  , 2828  ,\n  2831  , 2832  , 2835  , 2856  , 2858  , 2864  , 2866  , 2867  ,\n  2869  , 2873  , 2876  , 2884  , 2887  , 2888  , 2891  , 2893  ,\n  2901  , 2903  , 2908  , 2909  , 2911  , 2915  , 2918  , 2927  ,\n  2929  , 2929  , 2946  , 2947  , 2949  , 2954  , 2958  , 2960  ,\n  2962  , 2965  , 2969  , 2970  , 2972  , 2972  , 2974  , 2975  ,\n  2979  , 2980  , 2984  , 2986  , 2990  , 3001  , 3006  , 3010  ,\n  3014  , 3016  , 3018  , 3021  , 3024  , 3024  , 3031  , 3031  ,\n  3046  , 3055  , 3072  , 3084  , 3086  , 3088  , 3090  , 3112  ,\n  3114  , 3129  , 3132  , 3140  , 3142  , 3144  , 3146  , 3149  ,\n  3157  , 3158  , 3160  , 3162  , 3165  , 3165  , 3168  , 3171  ,\n  3174  , 3183  , 3200  , 3203  , 3205  , 3212  , 3214  , 3216  ,\n  3218  , 3240  , 3242  , 3251  , 3253  , 3257  , 3260  , 3268  ,\n  3270  , 3272  , 3274  , 3277  , 3285  , 3286  , 3293  , 3294  ,\n  3296  , 3299  , 3302  , 3311  , 3313  , 3314  , 3328  , 3340  ,\n  3342  , 3344  , 3346  , 3396  , 3398  , 3400  , 3402  , 3406  ,\n  3412  , 3415  , 3423  , 3427  , 3430  , 3439  , 3450  , 3455  ,\n  3457  , 3459  , 3461  , 3478  , 3482  , 3505  , 3507  , 3515  ,\n  3517  , 3517  , 3520  , 3526  , 3530  , 3530  , 3535  , 3540  ,\n  3542  , 3542  , 3544  , 3551  , 3558  , 3567  , 3570  , 3571  ,\n  3585  , 3642  , 3648  , 3662  , 3664  , 3673  , 3713  , 3714  ,\n  3716  , 3716  , 3718  , 3722  , 3724  , 3747  , 3749  , 3749  ,\n  3751  , 3773  , 3776  , 3780  , 3782  , 3782  , 3784  , 3789  ,\n  3792  , 3801  , 3804  , 3807  , 3840  , 3840  , 3864  , 3865  ,\n  3872  , 3881  , 3893  , 3893  , 3895  , 3895  , 3897  , 3897  ,\n  3902  , 3911  , 3913  , 3948  , 3953  , 3972  , 3974  , 3991  ,\n  3993  , 4028  , 4038  , 4038  , 4096  , 4169  , 4176  , 4253  ,\n  4256  , 4293  , 4295  , 4295  , 4301  , 4301  , 4304  , 4346  ,\n  4348  , 4680  , 4682  , 4685  , 4688  , 4694  , 4696  , 4696  ,\n  4698  , 4701  , 4704  , 4744  , 4746  , 4749  , 4752  , 4784  ,\n  4786  , 4789  , 4792  , 4798  , 4800  , 4800  , 4802  , 4805  ,\n  4808  , 4822  , 4824  , 4880  , 4882  , 4885  , 4888  , 4954  ,\n  4957  , 4959  , 4969  , 4977  , 4992  , 5007  , 5024  , 5109  ,\n  5112  , 5117  , 5121  , 5740  , 5743  , 5759  , 5761  , 5786  ,\n  5792  , 5866  , 5870  , 5880  , 5888  , 5909  , 5919  , 5940  ,\n  5952  , 5971  , 5984  , 5996  , 5998  , 6000  , 6002  , 6003  ,\n  6016  , 6099  , 6103  , 6103  , 6108  , 6109  , 6112  , 6121  ,\n  6155  , 6157  , 6159  , 6169  , 6176  , 6264  , 6272  , 6314  ,\n  6320  , 6389  , 6400  , 6430  , 6432  , 6443  , 6448  , 6459  ,\n  6470  , 6509  , 6512  , 6516  , 6528  , 6571  , 6576  , 6601  ,\n  6608  , 6618  , 6656  , 6683  , 6688  , 6750  , 6752  , 6780  ,\n  6783  , 6793  , 6800  , 6809  , 6823  , 6823  , 6832  , 6845  ,\n  6847  , 6862  , 6912  , 6988  , 6992  , 7001  , 7019  , 7027  ,\n  7040  , 7155  , 7168  , 7223  , 7232  , 7241  , 7245  , 7293  ,\n  7296  , 7304  , 7312  , 7354  , 7357  , 7359  , 7376  , 7378  ,\n  7380  , 7418  , 7424  , 7957  , 7960  , 7965  , 7968  , 8005  ,\n  8008  , 8013  , 8016  , 8023  , 8025  , 8025  , 8027  , 8027  ,\n  8029  , 8029  , 8031  , 8061  , 8064  , 8116  , 8118  , 8124  ,\n  8126  , 8126  , 8130  , 8132  , 8134  , 8140  , 8144  , 8147  ,\n  8150  , 8155  , 8160  , 8172  , 8178  , 8180  , 8182  , 8188  ,\n  8255  , 8256  , 8276  , 8276  , 8305  , 8305  , 8319  , 8319  ,\n  8336  , 8348  , 8400  , 8412  , 8417  , 8417  , 8421  , 8432  ,\n  8450  , 8450  , 8455  , 8455  , 8458  , 8467  , 8469  , 8469  ,\n  8472  , 8477  , 8484  , 8484  , 8486  , 8486  , 8488  , 8488  ,\n  8490  , 8505  , 8508  , 8511  , 8517  , 8521  , 8526  , 8526  ,\n  8544  , 8584  , 11264 , 11492 , 11499 , 11507 , 11520 , 11557 ,\n  11559 , 11559 , 11565 , 11565 , 11568 , 11623 , 11631 , 11631 ,\n  11647 , 11670 , 11680 , 11686 , 11688 , 11694 , 11696 , 11702 ,\n  11704 , 11710 , 11712 , 11718 , 11720 , 11726 , 11728 , 11734 ,\n  11736 , 11742 , 11744 , 11775 , 12293 , 12295 , 12321 , 12335 ,\n  12337 , 12341 , 12344 , 12348 , 12353 , 12438 , 12441 , 12447 ,\n  12449 , 12538 , 12540 , 12543 , 12549 , 12591 , 12593 , 12686 ,\n  12704 , 12735 , 12784 , 12799 , 13312 , 19903 , 19968 , 42124 ,\n  42192 , 42237 , 42240 , 42508 , 42512 , 42539 , 42560 , 42607 ,\n  42612 , 42621 , 42623 , 42737 , 42775 , 42783 , 42786 , 42888 ,\n  42891 , 42954 , 42960 , 42961 , 42963 , 42963 , 42965 , 42969 ,\n  42994 , 43047 , 43052 , 43052 , 43072 , 43123 , 43136 , 43205 ,\n  43216 , 43225 , 43232 , 43255 , 43259 , 43259 , 43261 , 43309 ,\n  43312 , 43347 , 43360 , 43388 , 43392 , 43456 , 43471 , 43481 ,\n  43488 , 43518 , 43520 , 43574 , 43584 , 43597 , 43600 , 43609 ,\n  43616 , 43638 , 43642 , 43714 , 43739 , 43741 , 43744 , 43759 ,\n  43762 , 43766 , 43777 , 43782 , 43785 , 43790 , 43793 , 43798 ,\n  43808 , 43814 , 43816 , 43822 , 43824 , 43866 , 43868 , 43881 ,\n  43888 , 44010 , 44012 , 44013 , 44016 , 44025 , 44032 , 55203 ,\n  55216 , 55238 , 55243 , 55291 , 63744 , 64109 , 64112 , 64217 ,\n  64256 , 64262 , 64275 , 64279 , 64285 , 64296 , 64298 , 64310 ,\n  64312 , 64316 , 64318 , 64318 , 64320 , 64321 , 64323 , 64324 ,\n  64326 , 64433 , 64467 , 64829 , 64848 , 64911 , 64914 , 64967 ,\n  65008 , 65019 , 65024 , 65039 , 65056 , 65071 , 65075 , 65076 ,\n  65101 , 65103 , 65136 , 65140 , 65142 , 65276 , 65296 , 65305 ,\n  65313 , 65338 , 65343 , 65343 , 65345 , 65370 , 65382 , 65470 ,\n  65474 , 65479 , 65482 , 65487 , 65490 , 65495 , 65498 , 65500 ,\n  65536 , 65547 , 65549 , 65574 , 65576 , 65594 , 65596 , 65597 ,\n  65599 , 65613 , 65616 , 65629 , 65664 , 65786 , 65856 , 65908 ,\n  66045 , 66045 , 66176 , 66204 , 66208 , 66256 , 66272 , 66272 ,\n  66304 , 66335 , 66349 , 66378 , 66384 , 66426 , 66432 , 66461 ,\n  66464 , 66499 , 66504 , 66511 , 66513 , 66517 , 66560 , 66717 ,\n  66720 , 66729 , 66736 , 66771 , 66776 , 66811 , 66816 , 66855 ,\n  66864 , 66915 , 66928 , 66938 , 66940 , 66954 , 66956 , 66962 ,\n  66964 , 66965 , 66967 , 66977 , 66979 , 66993 , 66995 , 67001 ,\n  67003 , 67004 , 67072 , 67382 , 67392 , 67413 , 67424 , 67431 ,\n  67456 , 67461 , 67463 , 67504 , 67506 , 67514 , 67584 , 67589 ,\n  67592 , 67592 , 67594 , 67637 , 67639 , 67640 , 67644 , 67644 ,\n  67647 , 67669 , 67680 , 67702 , 67712 , 67742 , 67808 , 67826 ,\n  67828 , 67829 , 67840 , 67861 , 67872 , 67897 , 67968 , 68023 ,\n  68030 , 68031 , 68096 , 68099 , 68101 , 68102 , 68108 , 68115 ,\n  68117 , 68119 , 68121 , 68149 , 68152 , 68154 , 68159 , 68159 ,\n  68192 , 68220 , 68224 , 68252 , 68288 , 68295 , 68297 , 68326 ,\n  68352 , 68405 , 68416 , 68437 , 68448 , 68466 , 68480 , 68497 ,\n  68608 , 68680 , 68736 , 68786 , 68800 , 68850 , 68864 , 68903 ,\n  68912 , 68921 , 69248 , 69289 , 69291 , 69292 , 69296 , 69297 ,\n  69376 , 69404 , 69415 , 69415 , 69424 , 69456 , 69488 , 69509 ,\n  69552 , 69572 , 69600 , 69622 , 69632 , 69702 , 69734 , 69749 ,\n  69759 , 69818 , 69826 , 69826 , 69840 , 69864 , 69872 , 69881 ,\n  69888 , 69940 , 69942 , 69951 , 69956 , 69959 , 69968 , 70003 ,\n  70006 , 70006 , 70016 , 70084 , 70089 , 70092 , 70094 , 70106 ,\n  70108 , 70108 , 70144 , 70161 , 70163 , 70199 , 70206 , 70206 ,\n  70272 , 70278 , 70280 , 70280 , 70282 , 70285 , 70287 , 70301 ,\n  70303 , 70312 , 70320 , 70378 , 70384 , 70393 , 70400 , 70403 ,\n  70405 , 70412 , 70415 , 70416 , 70419 , 70440 , 70442 , 70448 ,\n  70450 , 70451 , 70453 , 70457 , 70459 , 70468 , 70471 , 70472 ,\n  70475 , 70477 , 70480 , 70480 , 70487 , 70487 , 70493 , 70499 ,\n  70502 , 70508 , 70512 , 70516 , 70656 , 70730 , 70736 , 70745 ,\n  70750 , 70753 , 70784 , 70853 , 70855 , 70855 , 70864 , 70873 ,\n  71040 , 71093 , 71096 , 71104 , 71128 , 71133 , 71168 , 71232 ,\n  71236 , 71236 , 71248 , 71257 , 71296 , 71352 , 71360 , 71369 ,\n  71424 , 71450 , 71453 , 71467 , 71472 , 71481 , 71488 , 71494 ,\n  71680 , 71738 , 71840 , 71913 , 71935 , 71942 , 71945 , 71945 ,\n  71948 , 71955 , 71957 , 71958 , 71960 , 71989 , 71991 , 71992 ,\n  71995 , 72003 , 72016 , 72025 , 72096 , 72103 , 72106 , 72151 ,\n  72154 , 72161 , 72163 , 72164 , 72192 , 72254 , 72263 , 72263 ,\n  72272 , 72345 , 72349 , 72349 , 72368 , 72440 , 72704 , 72712 ,\n  72714 , 72758 , 72760 , 72768 , 72784 , 72793 , 72818 , 72847 ,\n  72850 , 72871 , 72873 , 72886 , 72960 , 72966 , 72968 , 72969 ,\n  72971 , 73014 , 73018 , 73018 , 73020 , 73021 , 73023 , 73031 ,\n  73040 , 73049 , 73056 , 73061 , 73063 , 73064 , 73066 , 73102 ,\n  73104 , 73105 , 73107 , 73112 , 73120 , 73129 , 73440 , 73462 ,\n  73648 , 73648 , 73728 , 74649 , 74752 , 74862 , 74880 , 75075 ,\n  77712 , 77808 , 77824 , 78894 , 82944 , 83526 , 92160 , 92728 ,\n  92736 , 92766 , 92768 , 92777 , 92784 , 92862 , 92864 , 92873 ,\n  92880 , 92909 , 92912 , 92916 , 92928 , 92982 , 92992 , 92995 ,\n  93008 , 93017 , 93027 , 93047 , 93053 , 93071 , 93760 , 93823 ,\n  93952 , 94026 , 94031 , 94087 , 94095 , 94111 , 94176 , 94177 ,\n  94179 , 94180 , 94192 , 94193 , 94208 , 100343, 100352, 101589,\n  101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590,\n  110592, 110882, 110928, 110930, 110948, 110951, 110960, 111355,\n  113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817,\n  113821, 113822, 118528, 118573, 118576, 118598, 119141, 119145,\n  119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213,\n  119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967,\n  119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993,\n  119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074,\n  120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126,\n  120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485,\n  120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596,\n  120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712,\n  120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831,\n  121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476,\n  121499, 121503, 121505, 121519, 122624, 122654, 122880, 122886,\n  122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922,\n  123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214,\n  123536, 123566, 123584, 123641, 124896, 124902, 124904, 124907,\n  124909, 124910, 124912, 124926, 124928, 125124, 125136, 125142,\n  125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495,\n  126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514,\n  126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530,\n  126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543,\n  126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553,\n  126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562,\n  126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583,\n  126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619,\n  126625, 126627, 126629, 126633, 126635, 126651, 130032, 130041,\n  131072, 173791, 173824, 177976, 177984, 178205, 178208, 183969,\n  183984, 191456, 194560, 195101, 196608, 201546, 917760, 917999,\n];\nconst unicodeIdentifierPartMin = 170;\nconst unicodeIdentifierPartMax = 917999;\n\nfunction lookupInUnicodeMap(code: i32, map: i32[]): bool {\n  let lo = 0;\n  let hi = map.length;\n  while (lo + 1 < hi) {\n    let mid = lo + ((hi - lo) >>> 1);\n    mid -= (mid & 1);\n    let midVal = map[mid];\n    if (midVal <= code && code <= map[mid + 1]) {\n      return true;\n    }\n    if (code < midVal) {\n      hi = mid;\n    } else {\n      lo = mid + 2;\n    }\n  }\n  return false;\n}\n\n/** Creates an indentation matching the number of specified levels. */\nconst indentX1 = \"  \";\nconst indentX2 = \"    \";\nconst indentX3 = \"      \";\nconst indentX4 = \"        \";\nconst indentCache = new Map<i32,string>();\n\nexport function indent(sb: string[], level: i32): void {\n  if (level <= 4) {\n    switch (level) {\n      case 1: sb.push(indentX1); break;\n      case 2: sb.push(indentX2); break;\n      case 3: sb.push(indentX3); break;\n      case 4: sb.push(indentX4); break;\n    }\n  } else {\n    let indents: string;\n    // Limit number of indent entries to 1024 for avoiding unnecessary\n    // memory consumetion\n    if (indentCache.size <= 1024) {\n      if (indentCache.has(level)) {\n        indents = assert(indentCache.get(level));\n      } else {\n        indentCache.set(level, (indents = indentX1.repeat(level)));\n      }\n    } else {\n      indents = indentX1.repeat(level);\n    }\n    sb.push(indents);\n  }\n}\n\n/** Escapes a string using the specified kind of quote. */\nexport function escapeString(str: string, quote: CharCode): string {\n  let sb = new Array<string>();\n  let off = 0;\n  let i = 0;\n  for (let k = str.length; i < k;) {\n    switch (str.charCodeAt(i)) {\n      case CharCode.Null: {\n        if (i > off) sb.push(str.substring(off, off = i + 1));\n        sb.push(\"\\\\0\");\n        off = ++i;\n        break;\n      }\n      case CharCode.Backspace: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\b\");\n        break;\n      }\n      case CharCode.Tab: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\t\");\n        break;\n      }\n      case CharCode.LineFeed: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\n\");\n        break;\n      }\n      case CharCode.VerticalTab: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\v\");\n        break;\n      }\n      case CharCode.FormFeed: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\f\");\n        break;\n      }\n      case CharCode.CarriageReturn: {\n        if (i > off) sb.push(str.substring(off, i));\n        sb.push(\"\\\\r\");\n        off = ++i;\n        break;\n      }\n      case CharCode.DoubleQuote: {\n        if (quote == CharCode.DoubleQuote) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\\\\"\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      case CharCode.SingleQuote: {\n        if (quote == CharCode.SingleQuote) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\'\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      case CharCode.Backslash: {\n        if (i > off) sb.push(str.substring(off, i));\n        sb.push(\"\\\\\\\\\");\n        off = ++i;\n        break;\n      }\n      case CharCode.Backtick: {\n        if (quote == CharCode.Backtick) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\`\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      default: {\n        ++i;\n        break;\n      }\n    }\n  }\n  if (i > off) sb.push(str.substring(off, i));\n  return sb.join(\"\");\n}\n", "/**\n * @fileoverview Various file path utility.\n * @license Apache-2.0\n */\n\nimport {\n  CharCode\n} from \"./text\";\n\nimport {\n  PATH_DELIMITER\n} from \"../common\";\n\nconst separator = CharCode.Slash;\n\n/**\n * Normalizes the specified path, removing interior placeholders.\n * Expects a posix-compatible relative path (not Windows compatible).\n */\nexport function normalizePath(path: string): string {\n  let pos = 0;\n  let len = path.length;\n\n  // trim leading './'\n  while (pos + 1 < len &&\n    path.charCodeAt(pos) == CharCode.Dot &&\n    path.charCodeAt(pos + 1) == separator\n  ) {\n    pos += 2;\n  }\n\n  if (pos > 0 || len < path.length) {\n    path = path.substring(pos, len);\n    len -= pos;\n    pos = 0;\n  }\n\n  let atEnd: bool;\n  while (pos + 1 < len) {\n    atEnd = false;\n\n    // we are only interested in '/.' sequences ...\n    if (\n      path.charCodeAt(pos) == separator &&\n      path.charCodeAt(pos + 1) == CharCode.Dot\n    ) {\n      // '/.' ( '/' | $ )\n      atEnd = pos + 2 == len;\n      if (atEnd ||\n        pos + 2 < len &&\n        path.charCodeAt(pos + 2) == separator\n      ) {\n        path = atEnd\n          ? path.substring(0, pos)\n          : path.substring(0, pos) + path.substring(pos + 2);\n        len -= 2;\n        continue;\n      }\n\n      // '/.' ( './' | '.' $ )\n      atEnd = pos + 3 == len;\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.Dot ||\n        pos + 3 < len &&\n        path.charCodeAt(pos + 2) == CharCode.Dot &&\n        path.charCodeAt(pos + 3) == separator\n      ) {\n        // find preceeding '/'\n        let ipos = pos;\n        while (--ipos >= 0) {\n          if (path.charCodeAt(ipos) == separator) {\n            if (pos - ipos != 3 ||\n              path.charCodeAt(ipos + 1) != CharCode.Dot ||\n              path.charCodeAt(ipos + 2) != CharCode.Dot\n            ) { // exclude '..' itself\n              path = atEnd\n                ? path.substring(0, ipos)\n                : path.substring(0, ipos) + path.substring(pos + 3);\n              len -= pos + 3 - ipos;\n              pos = ipos - 1; // incremented again at end of loop\n            }\n            break;\n          }\n        }\n\n        // if there's no preceeding '/', trim start if non-empty\n        if (ipos < 0 && pos > 0) {\n          if (pos != 2 ||\n            path.charCodeAt(0) != CharCode.Dot ||\n            path.charCodeAt(1) != CharCode.Dot\n          ) { // exclude '..' itself\n            path = path.substring(pos + 4);\n            len = path.length;\n            continue;\n          }\n        }\n      }\n    }\n    pos++;\n  }\n  return len > 0 ? path : \".\";\n}\n\n/** Resolves the specified path relative to the specified origin. */\nexport function resolvePath(normalizedPath: string, origin: string): string {\n  if (normalizedPath.startsWith(\"std/\")) {\n    return normalizedPath;\n  }\n  return normalizePath(\n    dirname(origin) + PATH_DELIMITER + normalizedPath\n  );\n}\n\n/** Obtains the directory portion of a normalized path. */\nexport function dirname(normalizedPath: string): string {\n  let pos = normalizedPath.length;\n  if (pos <= 1) {\n    if (pos == 0) return \".\";\n    if (normalizedPath.charCodeAt(0) == separator) {\n      return normalizedPath;\n    }\n  }\n  while (--pos > 0) {\n    if (normalizedPath.charCodeAt(pos) == separator) {\n      return normalizedPath.substring(0, pos);\n    }\n  }\n  return \".\";\n}\n", "/**\n * @fileoverview Terminal utility.\n * @license Apache-2.0\n */\n\n/** Gray terminal color code. */\nexport const COLOR_GRAY = \"\\u001b[90m\";\n/** Red terminal color code. */\nexport const COLOR_RED = \"\\u001b[91m\";\n/** Green terminal color code. */\nexport const COLOR_GREEN = \"\\u001b[92m\";\n/** Yellow terminal color code. */\nexport const COLOR_YELLOW = \"\\u001b[93m\";\n/** Blue terminal color code. */\nexport const COLOR_BLUE = \"\\u001b[94m\";\n/** Magenta terminal color code. */\nexport const COLOR_MAGENTA = \"\\u001b[95m\";\n/** Cyan terminal color code. */\nexport const COLOR_CYAN = \"\\u001b[96m\";\n/** White terminal color code. */\nexport const COLOR_WHITE = \"\\u001b[97m\";\n/** Terminal color reset code. */\nexport const COLOR_RESET = \"\\u001b[0m\";\n\n/** Whether terminal colors are enabled or not. */\nlet colorsEnabled = true;\n\n/** Checks whether terminal colors are enabled or not. */\nexport function isColorsEnabled(): bool {\n  return colorsEnabled;\n}\n\n/** Sets whether terminal colors are enabled or not. */\nexport function setColorsEnabled(isEnabled: bool): bool {\n  let wasEnabled = isEnabled;\n  colorsEnabled = isEnabled;\n  return wasEnabled;\n}\n\n/** Wraps the specified text in the specified terminal color code. */\nexport function colorize(text: string, color: string): string {\n  return colorsEnabled ? color + text + COLOR_RESET : text;\n}\n", "/**\n * @fileoverview Various vector utility.\n * @license Apache-2.0\n */\n\n/** v128 zero constant. */\nexport const v128_zero = new Uint8Array(16);\n/** v128 all ones constant. */\nexport const v128_ones = new Uint8Array(16).fill(0xFF);\n", "/**\n * @fileoverview Shared diagnostic handling.\n * @license Apache-2.0\n */\n\nimport {\n  Source\n} from \"./ast\";\n\nimport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\nimport {\n  isLineBreak,\n  isWhiteSpace,\n  COLOR_CYAN,\n  COLOR_YELLOW,\n  COLOR_RED,\n  COLOR_MAGENTA,\n  COLOR_RESET,\n  isColorsEnabled,\n  setColorsEnabled,\n  CharCode\n} from \"./util\";\n\nexport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\n/** Indicates the category of a {@link DiagnosticMessage}. */\nexport const enum DiagnosticCategory {\n  /** Overly pedantic message. */\n  Pedantic,\n  /** Informatory message. */\n  Info,\n  /** Warning message. */\n  Warning,\n  /** Error message. */\n  Error\n}\n\nexport class Range {\n\n  source!: Source;\n  debugInfoRef: usize = 0;\n\n  constructor(public start: i32, public end: i32) {}\n\n  static join(a: Range, b: Range): Range {\n    if (a.source != b.source) throw new Error(\"source mismatch\");\n    let range = new Range(\n      a.start < b.start ? a.start : b.start,\n      a.end > b.end ? a.end : b.end\n    );\n    range.source = a.source;\n    return range;\n  }\n\n  equals(other: Range): bool {\n    return (\n      this.source == other.source &&\n      this.start == other.start &&\n      this.end == other.end\n    );\n  }\n\n  get atStart(): Range {\n    let range = new Range(this.start, this.start);\n    range.source = this.source;\n    return range;\n  }\n\n  get atEnd(): Range {\n    let range = new Range(this.end, this.end);\n    range.source = this.source;\n    return range;\n  }\n\n  toString(): string {\n    return this.source.text.substring(this.start, this.end);\n  }\n}\n\n/** Returns the string representation of the specified diagnostic category. */\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.Pedantic: return \"PEDANTIC\";\n    case DiagnosticCategory.Info: return \"INFO\";\n    case DiagnosticCategory.Warning: return \"WARNING\";\n    case DiagnosticCategory.Error: return \"ERROR\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Returns the ANSI escape sequence for the specified category. */\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.Pedantic: return COLOR_MAGENTA;\n    case DiagnosticCategory.Info: return COLOR_CYAN;\n    case DiagnosticCategory.Warning: return COLOR_YELLOW;\n    case DiagnosticCategory.Error: return COLOR_RED;\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Represents a diagnostic message. */\nexport class DiagnosticMessage {\n\n  /** Message code. */\n  code: i32;\n  /** Message category. */\n  category: DiagnosticCategory;\n  /** Message text. */\n  message: string;\n  /** Respective source range, if any. */\n  range: Range | null = null;\n  /** Related range, if any. */\n  relatedRange: Range | null = null; // TODO: Make this a related message for chains?\n\n  /** Constructs a new diagnostic message. */\n  private constructor(code: i32, category: DiagnosticCategory, message: string) {\n    this.code = code;\n    this.category = category;\n    this.message = message;\n  }\n\n  /** Creates a new diagnostic message of the specified category. */\n  static create(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): DiagnosticMessage {\n    let message = diagnosticCodeToString(code);\n    if (arg0 != null) message = message.replace(\"{0}\", arg0);\n    if (arg1 != null) message = message.replace(\"{1}\", arg1);\n    if (arg2 != null) message = message.replace(\"{2}\", arg2);\n    return new DiagnosticMessage(code, category, message);\n  }\n\n  /** Tests if this message equals the specified. */\n  equals(other: DiagnosticMessage): bool {\n    if (this.code != other.code) return false;\n    let thisRange = this.range;\n    let otherRange = other.range;\n    if (thisRange) {\n      if (!otherRange || !thisRange.equals(otherRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    let thisRelatedRange = this.relatedRange;\n    let otherRelatedRange = other.relatedRange;\n    if (thisRelatedRange) {\n      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;\n    } else if (otherRelatedRange) {\n      return false;\n    }\n    return this.message == other.message;\n  }\n\n  /** Adds a source range to this message. */\n  withRange(range: Range): this {\n    this.range = range;\n    return this;\n  }\n\n  /** Adds a related source range to this message. */\n  withRelatedRange(range: Range): this {\n    this.relatedRange = range;\n    return this;\n  }\n\n  /** Converts this message to a string. */\n  toString(): string {\n    let category = diagnosticCategoryToString(this.category);\n    let range = this.range;\n    let code = this.code;\n    let message = this.message;\n    if (range) {\n      let source = range.source;\n      let path = source.normalizedPath;\n      let line = source.lineAt(range.start);\n      let column = source.columnAt();\n      let len = range.end - range.start;\n      return `${category} ${code}: \"${message}\" in ${path}(${line},${column}+${len})`;\n    }\n    return `${category} ${code}: ${message}`;\n  }\n}\n\n/** Formats a diagnostic message, optionally with terminal colors and source context. */\nexport function formatDiagnosticMessage(\n  message: DiagnosticMessage,\n  useColors: bool = false,\n  showContext: bool = false\n): string {\n  let wasColorsEnabled = setColorsEnabled(useColors);\n\n  // general information\n  let sb: string[] = [];\n  if (isColorsEnabled()) sb.push(diagnosticCategoryToColor(message.category));\n  sb.push(diagnosticCategoryToString(message.category));\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\n  sb.push(message.code.toString());\n  sb.push(\": \");\n  sb.push(message.message);\n\n  // include range information if available\n  let range = message.range;\n  if (range) {\n    let source = range.source;\n    let relatedRange = message.relatedRange;\n    let minLine = 0;\n    if (relatedRange) {\n      // Justify context indentation when multiple ranges are present\n      minLine = max(source.lineAt(range.start), relatedRange.source.lineAt(relatedRange.start));\n    }\n\n    // include context information if requested\n    if (showContext) {\n      sb.push(\"\\n\");\n      sb.push(formatDiagnosticContext(range, minLine));\n    } else {\n      sb.push(\"\\n in \");\n      sb.push(source.normalizedPath);\n    }\n    sb.push(\"(\");\n    sb.push(source.lineAt(range.start).toString());\n    sb.push(\",\");\n    sb.push(source.columnAt().toString());\n    sb.push(\")\");\n\n    if (relatedRange) {\n      let relatedSource = relatedRange.source;\n      if (showContext) {\n        sb.push(\"\\n\");\n        sb.push(formatDiagnosticContext(relatedRange, minLine));\n      } else {\n        sb.push(\"\\n in \");\n        sb.push(relatedSource.normalizedPath);\n      }\n      sb.push(\"(\");\n      sb.push(relatedSource.lineAt(relatedRange.start).toString());\n      sb.push(\",\");\n      sb.push(relatedSource.columnAt().toString());\n      sb.push(\")\");\n    }\n  }\n  setColorsEnabled(wasColorsEnabled);\n  return sb.join(\"\");\n}\n\n/** Formats the diagnostic context for the specified range, optionally with terminal colors. */\nfunction formatDiagnosticContext(range: Range, minLine: i32 = 0): string {\n  let source = range.source;\n  let text = source.text;\n  let len = text.length;\n  let start = range.start;\n  let end = start;\n  let lineNumber = source.lineAt(start).toString();\n  let lineNumberLength = minLine\n    ? max(minLine.toString().length, lineNumber.length)\n    : lineNumber.length;\n  let lineSpace = \" \".repeat(lineNumberLength);\n  // Find preceeding line break\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;\n  // Skip leading whitespace (assume no supplementary whitespaces)\n  while (start < len && isWhiteSpace(text.charCodeAt(start))) start++;\n  // Find next line break\n  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;\n  let sb: string[] = [\n    lineSpace,\n    \"  :\\n \",\n    \" \".repeat(lineNumberLength - lineNumber.length),\n    lineNumber,\n    \" \u2502 \",\n    text.substring(start, end).replaceAll(\"\\t\", \"  \"),\n    \"\\n \",\n    lineSpace,\n    \" \u2502 \"\n  ];\n  while (start < range.start) {\n    if (text.charCodeAt(start) == CharCode.Tab) {\n      sb.push(\"  \");\n      start += 2;\n    } else {\n      sb.push(\" \");\n      start++;\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RED);\n  if (range.start == range.end) {\n    sb.push(\"^\");\n  } else {\n    while (start++ < range.end) {\n      let cc = text.charCodeAt(start);\n      if (cc == CharCode.Tab) {\n        sb.push(\"~~\");\n      } else if (isLineBreak(cc)) {\n        sb.push(start == range.start + 1 ? \"^\" : \"~\");\n        break;\n      } else {\n        sb.push(\"~\");\n      }\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(\"\\n \");\n  sb.push(lineSpace);\n  sb.push(\" \u2514\u2500 in \");\n  sb.push(source.normalizedPath);\n  return sb.join(\"\");\n}\n\n/** Base class of all diagnostic emitters. */\nexport abstract class DiagnosticEmitter {\n\n  /** Diagnostic messages emitted so far. */\n  diagnostics: DiagnosticMessage[];\n  /** Diagnostic messages already seen, by range. */\n  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();\n\n  /** Initializes this diagnostic emitter. */\n  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n  }\n\n  /** Emits a diagnostic message of the specified category. */\n  emitDiagnostic(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    range: Range | null,\n    relatedRange: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    let message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);\n    if (range) message = message.withRange(range);\n    if (relatedRange) message.relatedRange = relatedRange;\n    // It is possible that the same diagnostic is emitted twice, for example\n    // when compiling generics with different types or when recompiling a loop\n    // because our initial assumptions didn't hold. It is even possible to get\n    // multiple instances of the same range during parsing. Deduplicate these.\n    if (range) {\n      let seen = this.seen;\n      if (seen.has(range.source)) {\n        let seenInSource = assert(seen.get(range.source));\n        if (seenInSource.has(range.start)) {\n          let seenMessagesAtPos = assert(seenInSource.get(range.start));\n          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {\n            if (seenMessagesAtPos[i].equals(message)) return;\n          }\n          seenMessagesAtPos.push(message);\n        } else {\n          seenInSource.set(range.start, [ message ]);\n        }\n      } else {\n        let seenInSource = new Map<i32,DiagnosticMessage[]>();\n        seenInSource.set(range.start, [ message ]);\n        seen.set(range.source, seenInSource);\n      }\n    }\n    this.diagnostics.push(message);\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\n    // console.log(<string>new Error(\"stack\").stack);\n  }\n\n  /** Emits an overly pedantic diagnostic message. */\n  pedantic(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Pedantic, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an overly pedantic diagnostic message with a related range. */\n  pedanticRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Pedantic, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message. */\n  info(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Info, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message with a related range. */\n  infoRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Info, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message. */\n  warning(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Warning, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message with a related range. */\n  warningRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Warning, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message. */\n  error(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Error, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message with a related range. */\n  errorRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Error, range, relatedRange, arg0, arg1, arg2);\n  }\n}\n", "/**\n * @fileoverview Abstract syntax tree representing a source file once parsed.\n *\n * Each node in the AST is represented by an instance of a subclass of `Node`,\n * with its `Node#kind` represented by one of the `NodeKind` constants, which\n * dependent code typically switches over. The intended way to create a node\n * is to use the respective `Node.createX` method instead of its constructor.\n *\n * Note that the AST does not contain any type information except type names.\n *\n * @license Apache-2.0\n */\n\n// TODO: Make the AST more easily serializable by refactoring `Node#range` so\n// it doesn't reference the non-serializable `Source` object.\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  LIBRARY_PREFIX,\n  LIBRARY_SUBST\n} from \"./common\";\n\nimport {\n  Range\n} from \"./diagnostics\";\n\nimport {\n  Token\n} from \"./tokenizer\";\n\nimport {\n  normalizePath,\n  resolvePath,\n  CharCode\n} from \"./util\";\n\nimport {\n  ExpressionRef\n} from \"./module\";\n\nimport {\n  Type\n} from \"./types\";\n\n/** Indicates the kind of a node. */\nexport const enum NodeKind {\n\n  Source,\n\n  // types\n  NamedType,\n  FunctionType,\n  TypeName,\n  TypeParameter,\n  Parameter,\n\n  // expressions\n  Identifier,\n  Assertion,\n  Binary,\n  Call,\n  Class,\n  Comma,\n  ElementAccess,\n  False,\n  Function,\n  InstanceOf,\n  Literal,\n  New,\n  Null,\n  Omitted,\n  Parenthesized,\n  PropertyAccess,\n  Ternary,\n  Super,\n  This,\n  True,\n  Constructor,\n  UnaryPostfix,\n  UnaryPrefix,\n  Compiled,\n\n  // statements\n  Block,\n  Break,\n  Continue,\n  Do,\n  Empty,\n  Export,\n  ExportDefault,\n  ExportImport,\n  Expression,\n  For,\n  ForOf,\n  If,\n  Import,\n  Return,\n  Switch,\n  Throw,\n  Try,\n  Variable,\n  Void,\n  While,\n  Module,\n\n  // declaration statements\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  // special\n  Decorator,\n  ExportMember,\n  SwitchCase,\n  IndexSignature,\n  Comment\n}\n\n/** Base class of all nodes. */\nexport abstract class Node {\n  constructor(\n    /** Kind of this node. */\n    public kind: NodeKind,\n    /** Source range. */\n    public range: Range\n  ) {}\n\n  // types\n\n  static createSimpleTypeName(\n    name: string,\n    range: Range\n  ): TypeName {\n    return new TypeName(Node.createIdentifierExpression(name, range), null, range);\n  }\n\n  static createNamedType(\n    name: TypeName,\n    typeArguments: TypeNode[] | null,\n    isNullable: bool,\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(name, typeArguments, isNullable, range);\n  }\n\n  static createFunctionType(\n    parameters: ParameterNode[],\n    returnType: TypeNode,\n    explicitThisType: NamedTypeNode | null,\n    isNullable: bool,\n    range: Range\n  ): FunctionTypeNode {\n    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);\n  }\n\n  static createOmittedType(\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(Node.createSimpleTypeName(\"\", range), null, false, range);\n  }\n\n  static createTypeParameter(\n    name: IdentifierExpression,\n    extendsType: NamedTypeNode | null,\n    defaultType: NamedTypeNode | null,\n    range: Range\n  ): TypeParameterNode {\n    return new TypeParameterNode(name, extendsType, defaultType, range);\n  }\n\n  static createParameter(\n    parameterKind: ParameterKind,\n    name: IdentifierExpression,\n    type: TypeNode,\n    initializer: Expression | null,\n    range: Range\n  ): ParameterNode {\n    return new ParameterNode(parameterKind, name, type, initializer, range);\n  }\n\n  // special\n\n  static createDecorator(\n    name: Expression,\n    args: Expression[] | null,\n    range: Range\n  ): DecoratorNode {\n    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);\n  }\n\n  static createComment(\n    commentKind: CommentKind,\n    text: string,\n    range: Range\n  ): CommentNode {\n    return new CommentNode(commentKind, text, range);\n  }\n\n  // expressions\n\n  static createIdentifierExpression(\n    text: string,\n    range: Range,\n    isQuoted: bool = false\n  ): IdentifierExpression {\n    return new IdentifierExpression(text, isQuoted, range);\n  }\n\n  static createEmptyIdentifierExpression(\n    range: Range\n  ): IdentifierExpression {\n    return new IdentifierExpression(\"\", false, range);\n  }\n\n  static createArrayLiteralExpression(\n    elementExpressions: Expression[],\n    range: Range\n  ): ArrayLiteralExpression {\n    return new ArrayLiteralExpression(elementExpressions, range);\n  }\n\n  static createAssertionExpression(\n    assertionKind: AssertionKind,\n    expression: Expression,\n    toType: TypeNode | null,\n    range: Range\n  ): AssertionExpression {\n    return new AssertionExpression(assertionKind, expression, toType, range);\n  }\n\n  static createBinaryExpression(\n    operator: Token,\n    left: Expression,\n    right: Expression,\n    range: Range\n  ): BinaryExpression {\n    return new BinaryExpression(operator, left, right, range);\n  }\n\n  static createCallExpression(\n    expression: Expression,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): CallExpression {\n    return new CallExpression(expression, typeArguments, args, range);\n  }\n\n  static createClassExpression(\n    declaration: ClassDeclaration\n  ): ClassExpression {\n    return new ClassExpression(declaration);\n  }\n\n  static createCommaExpression(\n    expressions: Expression[],\n    range: Range\n  ): CommaExpression {\n    return new CommaExpression(expressions, range);\n  }\n\n  static createConstructorExpression(\n    range: Range\n  ): ConstructorExpression {\n    return new ConstructorExpression(range);\n  }\n\n  static createElementAccessExpression(\n    expression: Expression,\n    elementExpression: Expression,\n    range: Range\n  ): ElementAccessExpression {\n    return new ElementAccessExpression(expression, elementExpression, range);\n  }\n\n  static createFalseExpression(\n    range: Range\n  ): FalseExpression {\n    return new FalseExpression(range);\n  }\n\n  static createFloatLiteralExpression(\n    value: f64,\n    range: Range\n  ): FloatLiteralExpression {\n    return new FloatLiteralExpression(value, range);\n  }\n\n  static createFunctionExpression(\n    declaration: FunctionDeclaration\n  ): FunctionExpression {\n    return new FunctionExpression(declaration);\n  }\n\n  static createInstanceOfExpression(\n    expression: Expression,\n    isType: TypeNode,\n    range: Range\n  ): InstanceOfExpression {\n    return new InstanceOfExpression(expression, isType, range);\n  }\n\n  static createIntegerLiteralExpression(\n    value: i64,\n    range: Range\n  ): IntegerLiteralExpression {\n    return new IntegerLiteralExpression(value, range);\n  }\n\n  static createNewExpression(\n    typeName: TypeName,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): NewExpression {\n    return new NewExpression(typeName, typeArguments, args, range);\n  }\n\n  static createNullExpression(\n    range: Range\n  ): NullExpression {\n    return new NullExpression(range);\n  }\n\n  static createObjectLiteralExpression(\n    names: IdentifierExpression[],\n    values: Expression[],\n    range: Range\n  ): ObjectLiteralExpression {\n    return new ObjectLiteralExpression(names, values, range);\n  }\n\n  static createOmittedExpression(\n    range: Range\n  ): OmittedExpression {\n    return new OmittedExpression(range);\n  }\n\n  static createParenthesizedExpression(\n    expression: Expression,\n    range: Range\n  ): ParenthesizedExpression {\n    return new ParenthesizedExpression(expression, range);\n  }\n\n  static createPropertyAccessExpression(\n    expression: Expression,\n    property: IdentifierExpression,\n    range: Range\n  ): PropertyAccessExpression {\n    return new PropertyAccessExpression(expression, property, range);\n  }\n\n  static createRegexpLiteralExpression(\n    pattern: string,\n    patternFlags: string,\n    range: Range\n  ): RegexpLiteralExpression {\n    return new RegexpLiteralExpression(pattern, patternFlags, range);\n  }\n\n  static createTernaryExpression(\n    condition: Expression,\n    ifThen: Expression,\n    ifElse: Expression,\n    range: Range\n  ): TernaryExpression {\n    return new TernaryExpression(condition, ifThen, ifElse, range);\n  }\n\n  static createStringLiteralExpression(\n    value: string,\n    range: Range\n  ): StringLiteralExpression {\n    return new StringLiteralExpression(value, range);\n  }\n\n  static createSuperExpression(\n    range: Range\n  ): SuperExpression {\n    return new SuperExpression(range);\n  }\n\n  static createTemplateLiteralExpression(\n    tag: Expression | null,\n    parts: string[],\n    rawParts: string[],\n    expressions: Expression[],\n    range: Range\n  ): TemplateLiteralExpression {\n    return new TemplateLiteralExpression(tag, parts, rawParts, expressions, range);\n  }\n\n  static createThisExpression(\n    range: Range\n  ): ThisExpression {\n    return new ThisExpression(range);\n  }\n\n  static createTrueExpression(\n    range: Range\n  ): TrueExpression {\n    return new TrueExpression(range);\n  }\n\n  static createUnaryPostfixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPostfixExpression {\n    return new UnaryPostfixExpression(operator, operand, range);\n  }\n\n  static createUnaryPrefixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPrefixExpression {\n    return new UnaryPrefixExpression(operator, operand, range);\n  }\n\n  static createCompiledExpression(\n    expr: ExpressionRef,\n    type: Type,\n    range: Range\n  ): Expression {\n    return new CompiledExpression(expr, type, range);\n  }\n\n  // statements\n\n  static createBlockStatement(\n    statements: Statement[],\n    range: Range\n  ): BlockStatement {\n    return new BlockStatement(statements, range);\n  }\n\n  static createBreakStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): BreakStatement {\n    return new BreakStatement(label, range);\n  }\n\n  static createClassDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): ClassDeclaration {\n    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createContinueStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): ContinueStatement {\n    return new ContinueStatement(label, range);\n  }\n\n  static createDoStatement(\n    body: Statement,\n    condition: Expression,\n    range: Range\n  ): DoStatement {\n    return new DoStatement(body, condition, range);\n  }\n\n  static createEmptyStatement(\n    range: Range\n  ): EmptyStatement {\n    return new EmptyStatement(range);\n  }\n\n  static createEnumDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    values: EnumValueDeclaration[],\n    range: Range\n  ): EnumDeclaration {\n    return new EnumDeclaration(name, decorators, flags, values, range);\n  }\n\n  static createEnumValueDeclaration(\n    name: IdentifierExpression,\n    flags: CommonFlags,\n    initializer: Expression | null,\n    range: Range\n  ): EnumValueDeclaration {\n    return new EnumValueDeclaration(name, flags, initializer, range);\n  }\n\n  static createExportStatement(\n    members: ExportMember[] | null,\n    path: StringLiteralExpression | null,\n    isDeclare: bool,\n    range: Range\n  ): ExportStatement {\n    return new ExportStatement(members, path, isDeclare, range);\n  }\n\n  static createExportDefaultStatement(\n    declaration: DeclarationStatement,\n    range: Range\n  ): ExportDefaultStatement {\n    return new ExportDefaultStatement(declaration, range);\n  }\n\n  static createExportImportStatement(\n    name: IdentifierExpression,\n    externalName: IdentifierExpression,\n    range: Range\n  ): ExportImportStatement {\n    return new ExportImportStatement(name, externalName, range);\n  }\n\n  static createExportMember(\n    localName: IdentifierExpression,\n    exportedName: IdentifierExpression | null,\n    range: Range\n  ): ExportMember {\n    if (!exportedName) exportedName = localName;\n    return new ExportMember(localName, exportedName, range);\n  }\n\n  static createExpressionStatement(\n    expression: Expression\n  ): ExpressionStatement {\n    return new ExpressionStatement(expression);\n  }\n\n  static createIfStatement(\n    condition: Expression,\n    ifTrue: Statement,\n    ifFalse: Statement | null,\n    range: Range\n  ): IfStatement {\n    return new IfStatement(condition, ifTrue, ifFalse, range);\n  }\n\n  static createImportStatement(\n    declarations: ImportDeclaration[] | null,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(declarations, null, path, range);\n  }\n\n  static createWildcardImportStatement(\n    namespaceName: IdentifierExpression,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(null, namespaceName, path, range);\n  }\n\n  static createImportDeclaration(\n    foreignName: IdentifierExpression,\n    name: IdentifierExpression | null,\n    range: Range\n  ): ImportDeclaration {\n    if (!name) name = foreignName;\n    return new ImportDeclaration(name, foreignName, range);\n  }\n\n  static createInterfaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): InterfaceDeclaration {\n    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createFieldDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): FieldDeclaration {\n    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);\n  }\n\n  static createForStatement(\n    initializer: Statement | null,\n    condition: Expression | null,\n    incrementor: Expression | null,\n    body: Statement,\n    range: Range\n  ): ForStatement {\n    return new ForStatement(initializer, condition, incrementor, body, range);\n  }\n\n  static createForOfStatement(\n    variable: Statement,\n    iterable: Expression,\n    body: Statement,\n    range: Range\n  ): ForOfStatement {\n    return new ForOfStatement(variable, iterable, body, range);\n  }\n\n  static createFunctionDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    arrowKind: ArrowKind,\n    range: Range\n  ): FunctionDeclaration {\n    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);\n  }\n\n  static createIndexSignature(\n    keyType: NamedTypeNode,\n    valueType: TypeNode,\n    flags: CommonFlags,\n    range: Range\n  ): IndexSignatureNode {\n    return new IndexSignatureNode(keyType, valueType, flags, range);\n  }\n\n  static createMethodDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    range: Range\n  ): MethodDeclaration {\n    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);\n  }\n\n  static createNamespaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    members: Statement[],\n    range: Range\n  ): NamespaceDeclaration {\n    return new NamespaceDeclaration(name, decorators, flags, members, range);\n  }\n\n  static createReturnStatement(\n    value: Expression | null,\n    range: Range\n  ): ReturnStatement {\n    return new ReturnStatement(value, range);\n  }\n\n  static createSwitchStatement(\n    condition: Expression,\n    cases: SwitchCase[],\n    range: Range\n  ): SwitchStatement {\n    return new SwitchStatement(condition, cases, range);\n  }\n\n  static createSwitchCase(\n    label: Expression | null,\n    statements: Statement[],\n    range: Range\n  ): SwitchCase {\n    return new SwitchCase(label, statements, range);\n  }\n\n  static createThrowStatement(\n    value: Expression,\n    range: Range\n  ): ThrowStatement {\n    return new ThrowStatement(value, range);\n  }\n\n  static createTryStatement(\n    bodyStatements: Statement[],\n    catchVariable: IdentifierExpression | null,\n    catchStatements: Statement[] | null,\n    finallyStatements: Statement[] | null,\n    range: Range\n  ): TryStatement {\n    return new TryStatement(bodyStatements, catchVariable, catchStatements, finallyStatements, range);\n  }\n\n  static createTypeDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    type: TypeNode,\n    range: Range\n  ): TypeDeclaration {\n    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);\n  }\n\n  static createModuleDeclaration(\n    name: string,\n    flags: CommonFlags,\n    range: Range\n  ): ModuleDeclaration {\n    return new ModuleDeclaration(name, flags, range);\n  }\n\n  static createVariableStatement(\n    decorators: DecoratorNode[] | null,\n    declarations: VariableDeclaration[],\n    range: Range\n  ): VariableStatement {\n    return new VariableStatement(decorators, declarations, range);\n  }\n\n  static createVariableDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): VariableDeclaration {\n    return new VariableDeclaration(name, decorators, flags, type, initializer, range);\n  }\n\n  static createVoidStatement(\n    expression: Expression,\n    range: Range\n  ): VoidStatement {\n    return new VoidStatement(expression, range);\n  }\n\n  static createWhileStatement(\n    condition: Expression,\n    statement: Statement,\n    range: Range\n  ): WhileStatement {\n    return new WhileStatement(condition, statement, range);\n  }\n\n  /** Tests if this node is a literal of the specified kind. */\n  isLiteralKind(literalKind: LiteralKind): bool {\n    return this.kind == NodeKind.Literal\n        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS\n  }\n\n  /** Tests if this node is a literal of a numeric kind (float or integer). */\n  get isNumericLiteral(): bool {\n    if (this.kind == NodeKind.Literal) {\n      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n        case LiteralKind.Float:\n        case LiteralKind.Integer: return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests whether this node is guaranteed to compile to a constant value. */\n  get compilesToConst(): bool {\n    switch (this.kind) {\n      case NodeKind.Literal: {\n        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n          case LiteralKind.Float:\n          case LiteralKind.Integer:\n          case LiteralKind.String: return true;\n        }\n        break;\n      }\n      case NodeKind.Null:\n      case NodeKind.True:\n      case NodeKind.False: return true;\n    }\n    return false;\n  }\n\n  private isAccessOn(kind: NodeKind): bool {\n    let node = changetype<Node>(this);\n    if (node.kind == NodeKind.Call) {\n      node = (<CallExpression>node).expression;\n    }\n    if (node.kind == NodeKind.PropertyAccess) {\n      let target = (<PropertyAccessExpression>node).expression;\n      if (target.kind == kind) return true;\n    }\n    return false;\n  }\n\n  /** Checks if this node accesses a method or property on `this`. */\n  get isAccessOnThis(): bool {\n    return this.isAccessOn(NodeKind.This);\n  }\n\n  /** Checks if this node accesses a method or property on `super`. */\n  get isAccessOnSuper(): bool {\n    return this.isAccessOn(NodeKind.Super);\n  }\n\n  get isEmpty(): bool {\n    return this.kind == NodeKind.Empty;\n  }\n}\n\n// types\n\nexport abstract class TypeNode extends Node {\n  constructor(\n    /** Kind of the type node. */\n    kind: NodeKind,\n    /** Whether nullable or not. */\n    public isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this type has a generic component matching one of the given type parameters. */\n  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {\n    if (this.kind == NodeKind.NamedType) {\n      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS\n      if (!namedTypeNode.name.next) {\n        let typeArgumentNodes = namedTypeNode.typeArguments;\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {\n            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;\n          }\n        } else {\n          let name = namedTypeNode.name.identifier.text;\n          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {\n            if (typeParameterNodes[i].name.text == name) return true;\n          }\n        }\n      }\n    } else if (this.kind == NodeKind.FunctionType) {\n      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS\n      let parameterNodes = functionTypeNode.parameters;\n      for (let i = 0, k = parameterNodes.length; i < k; ++i) {\n        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;\n      }\n      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;\n      let explicitThisType = functionTypeNode.explicitThisType;\n      if (explicitThisType && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;\n    } else {\n      assert(false);\n    }\n    return false;\n  }\n}\n\n/** Represents a type name. */\nexport class TypeName extends Node {\n  constructor(\n    /** Identifier of this part. */\n    public identifier: IdentifierExpression,\n    /** Next part of the type name or `null` if this is the last part. */\n    public next: TypeName | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeName, range);\n  }\n}\n\n/** Represents a named type. */\nexport class NamedTypeNode extends TypeNode {\n  constructor(\n    /** Type name. */\n    public name: TypeName,\n    /** Type argument references. */\n    public typeArguments: TypeNode[] | null,\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NamedType, isNullable, range);\n  }\n\n  /** Checks if this type node has type arguments. */\n  get hasTypeArguments(): bool {\n    let typeArguments = this.typeArguments;\n    return typeArguments != null && typeArguments.length > 0;\n  }\n}\n\n/** Represents a function type. */\nexport class FunctionTypeNode extends TypeNode {\n  constructor(\n    /** Function parameters. */\n    public parameters: ParameterNode[],\n    /** Return type. */\n    public returnType: TypeNode,\n    /** Explicitly provided this type, if any. */\n    public explicitThisType: NamedTypeNode | null, // can't be a function\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FunctionType, isNullable, range);\n  }\n}\n\n/** Represents a type parameter. */\nexport class TypeParameterNode extends Node {\n  constructor(\n    /** Identifier reference. */\n    public name: IdentifierExpression,\n    /** Extended type reference, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Default type if omitted, if any. */\n    public defaultType: NamedTypeNode | null, // can't be a function\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeParameter, range);\n  }\n}\n\n/** Represents the kind of a parameter. */\nexport const enum ParameterKind {\n  /** No specific flags. */\n  Default,\n  /** Is an optional parameter. */\n  Optional,\n  /** Is a rest parameter. */\n  Rest\n}\n\n/** Represents a function parameter. */\nexport class ParameterNode extends Node {\n  constructor(\n    /** Parameter kind. */\n    public parameterKind: ParameterKind,\n    /** Parameter name. */\n    public name: IdentifierExpression,\n    /** Parameter type. */\n    public type: TypeNode,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Parameter, range);\n  }\n\n  /** Implicit field declaration, if applicable. */\n  implicitFieldDeclaration: FieldDeclaration | null = null;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.None;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n// special\n\n/** Built-in decorator kinds. */\nexport enum DecoratorKind {\n  Custom,\n  Global,\n  Operator,\n  OperatorBinary,\n  OperatorPrefix,\n  OperatorPostfix,\n  Unmanaged,\n  Final,\n  Inline,\n  External,\n  ExternalJs,\n  Builtin,\n  Lazy,\n  Unsafe\n}\n\nexport namespace DecoratorKind {\n\n  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */\n  export function fromNode(nameNode: Expression): DecoratorKind {\n    if (nameNode.kind == NodeKind.Identifier) {\n      let nameStr = (<IdentifierExpression>nameNode).text;\n      assert(nameStr.length);\n      switch (nameStr.charCodeAt(0)) {\n        case CharCode.b: {\n          if (nameStr == \"builtin\") return DecoratorKind.Builtin;\n          break;\n        }\n        case CharCode.e: {\n          if (nameStr == \"external\") return DecoratorKind.External;\n          break;\n        }\n        case CharCode.f: {\n          if (nameStr == \"final\") return DecoratorKind.Final;\n          break;\n        }\n        case CharCode.g: {\n          if (nameStr == \"global\") return DecoratorKind.Global;\n          break;\n        }\n        case CharCode.i: {\n          if (nameStr == \"inline\") return DecoratorKind.Inline;\n          break;\n        }\n        case CharCode.l: {\n          if (nameStr == \"lazy\") return DecoratorKind.Lazy;\n          break;\n        }\n        case CharCode.o: {\n          if (nameStr == \"operator\") return DecoratorKind.Operator;\n          break;\n        }\n        case CharCode.u: {\n          if (nameStr == \"unmanaged\") return DecoratorKind.Unmanaged;\n          if (nameStr == \"unsafe\") return DecoratorKind.Unsafe;\n          break;\n        }\n      }\n    } else if (nameNode.kind == NodeKind.PropertyAccess) {\n      let propertyAccessNode = <PropertyAccessExpression>nameNode;\n      let expression = propertyAccessNode.expression;\n      if (expression.kind == NodeKind.Identifier) {\n        let nameStr = (<IdentifierExpression>expression).text;\n        assert(nameStr.length);\n        let propStr = propertyAccessNode.property.text;\n        assert(propStr.length);\n        if (nameStr == \"operator\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.b: {\n              if (propStr == \"binary\") return DecoratorKind.OperatorBinary;\n              break;\n            }\n            case CharCode.p: {\n              if (propStr == \"prefix\") return DecoratorKind.OperatorPrefix;\n              if (propStr == \"postfix\") return DecoratorKind.OperatorPostfix;\n              break;\n            }\n          }\n        } else if (nameStr == \"external\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.j: {\n              if (propStr == \"js\") return DecoratorKind.ExternalJs;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return DecoratorKind.Custom;\n  }\n}\n\n/** Represents a decorator. */\nexport class DecoratorNode extends Node {\n  constructor(\n    /** Built-in decorator kind, or custom. */\n    public decoratorKind: DecoratorKind,\n    /** Name expression. */\n    public name: Expression,\n    /** Argument expressions. */\n    public args: Expression[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Decorator, range);\n  }\n}\n\n/** Comment kinds. */\nexport const enum CommentKind {\n  /** Line comment. */\n  Line,\n  /** Triple-slash line comment. */\n  Triple,\n  /** Block comment. */\n  Block\n}\n\n/** Represents a comment. */\nexport class CommentNode extends Node {\n  constructor(\n    /** Comment kind. */\n    public commentKind: CommentKind,\n    /** Comment text. */\n    public text: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Comment, range);\n  }\n}\n\n// expressions\n\n/** Base class of all expression nodes. */\nexport abstract class Expression extends Node { }\n\n/** Represents an identifier expression. */\nexport class IdentifierExpression extends Expression {\n  constructor(\n    /** Textual name. */\n    public text: string,\n    /** Whether quoted or not. */\n    public isQuoted: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Identifier, range);\n  }\n}\n\n/** Indicates the kind of a literal. */\nexport const enum LiteralKind {\n  Float,\n  Integer,\n  String,\n  Template,\n  RegExp,\n  Array,\n  Object\n}\n\n/** Base class of all literal expressions. */\nexport abstract class LiteralExpression extends Expression {\n  constructor(\n    /** Specific literal kind. */\n    public literalKind: LiteralKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Literal, range);\n  }\n}\n\n/** Represents an `[]` literal expression. */\nexport class ArrayLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Nested element expressions. */\n    public elementExpressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Array, range);\n  }\n}\n\n/** Indicates the kind of an assertion. */\nexport const enum AssertionKind {\n  /** A prefix assertion, i.e. `<T>expr`. */\n  Prefix,\n  /** An as assertion, i.e. `expr as T`. */\n  As,\n  /** A non-null assertion, i.e. `!expr`. */\n  NonNull,\n  /** A const assertion, i.e. `expr as const`. */\n  Const\n}\n\n/** Represents an assertion expression. */\nexport class AssertionExpression extends Expression {\n  constructor(\n    /** Specific kind of this assertion. */\n    public assertionKind: AssertionKind,\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Target type, if applicable. */\n    public toType: TypeNode | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Assertion, range);\n  }\n}\n\n/** Represents a binary expression. */\nexport class BinaryExpression extends Expression {\n  constructor(\n    /** Operator token. */\n    public operator: Token,\n    /** Left-hand side expression */\n    public left: Expression,\n    /** Right-hand side expression. */\n    public right: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Binary, range);\n  }\n}\n\n/** Represents a call expression. */\nexport class CallExpression extends Expression {\n  constructor(\n    /** Called expression. Usually an identifier or property access expression. */\n    public expression: Expression,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Call, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    let typeArguments = this.typeArguments;\n    let numTypeArguments: i32;\n    if (typeArguments) {\n      if (numTypeArguments = typeArguments.length) {\n        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n      }\n    }\n    return this.expression.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    let args = this.args;\n    let numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.expression.range;\n  }\n}\n\n/** Represents a class expression using the 'class' keyword. */\nexport class ClassExpression extends Expression {\n  constructor(\n    /** Inline class declaration. */\n    public declaration: ClassDeclaration\n  ) {\n    super(NodeKind.Class, declaration.range);\n  }\n}\n\n/** Represents a comma expression composed of multiple expressions. */\nexport class CommaExpression extends Expression {\n  constructor(\n    /** Sequential expressions. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Comma, range);\n  }\n}\n\n/** Represents a `constructor` expression. */\nexport class ConstructorExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"constructor\", false, range);\n    this.kind = NodeKind.Constructor;\n  }\n}\n\n/** Represents an element access expression, e.g., array access. */\nexport class ElementAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Element of the expression being accessed. */\n    public elementExpression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ElementAccess, range);\n  }\n}\n\n/** Represents a float literal expression. */\nexport class FloatLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Float value. */\n    public value: f64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Float, range);\n  }\n}\n\n/** Represents a function expression using the 'function' keyword. */\nexport class FunctionExpression extends Expression {\n  constructor(\n    /** Inline function declaration. */\n    public declaration: FunctionDeclaration\n  ) {\n    super(NodeKind.Function, declaration.range);\n  }\n}\n\n/** Represents an `instanceof` expression. */\nexport class InstanceOfExpression extends Expression {\n  constructor(\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Type to test for. */\n    public isType: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.InstanceOf, range);\n  }\n}\n\n/** Represents an integer literal expression. */\nexport class IntegerLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Integer value. */\n    public value: i64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Integer, range);\n  }\n}\n\n/** Represents a `new` expression. Like a call but with its own kind. */\nexport class NewExpression extends Expression {\n  constructor(\n    /** Type being constructed. */\n    public typeName: TypeName,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.New, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    let typeArguments = this.typeArguments;\n    let numTypeArguments: i32;\n    if (typeArguments && (numTypeArguments = typeArguments.length) > 0) {\n      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    let args = this.args;\n    let numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n}\n\n/** Represents a `null` expression. */\nexport class NullExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"null\", false, range);\n    this.kind = NodeKind.Null;\n  }\n}\n\n/** Represents an object literal expression. */\nexport class ObjectLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Field names. */\n    public names: IdentifierExpression[],\n    /** Field values. */\n    public values: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Object, range);\n  }\n}\n\n/** Represents an omitted expression, e.g. within an array literal. */\nexport class OmittedExpression extends Expression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Omitted, range);\n  }\n}\n\n/** Represents a parenthesized expression. */\nexport class ParenthesizedExpression extends Expression {\n  constructor(\n    /** Expression in parenthesis. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Parenthesized, range);\n  }\n}\n\n/** Represents a property access expression. */\nexport class PropertyAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Property of the expression being accessed. */\n    public property: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PropertyAccess, range);\n  }\n}\n\n/** Represents a regular expression literal expression. */\nexport class RegexpLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Regular expression pattern. */\n    public pattern: string,\n    /** Regular expression flags. */\n    public patternFlags: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.RegExp, range);\n  }\n}\n\n/** Represents a ternary expression, i.e., short if notation. */\nexport class TernaryExpression extends Expression {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Expression executed when condition is `true`. */\n    public ifThen: Expression,\n    /** Expression executed when condition is `false`. */\n    public ifElse: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Ternary, range);\n  }\n}\n\n/** Represents a string literal expression. */\nexport class StringLiteralExpression extends LiteralExpression {\n  constructor(\n    /** String value without quotes. */\n    public value: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.String, range);\n  }\n}\n\n/** Represents a `super` expression. */\nexport class SuperExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"super\", false, range);\n    this.kind = NodeKind.Super;\n  }\n}\n\n/** Represents a template literal expression. */\nexport class TemplateLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Tag expression, if any. */\n    public tag: Expression | null,\n    /** String parts. */\n    public parts: string[],\n    /** Raw string parts. */\n    public rawParts: string[],\n    /** Expression parts. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Template, range);\n  }\n}\n\n/** Represents a `this` expression. */\nexport class ThisExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"this\", false, range);\n    this.kind = NodeKind.This;\n  }\n}\n\n/** Represents a `true` expression. */\nexport class TrueExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"true\", false, range);\n    this.kind = NodeKind.True;\n  }\n}\n\n/** Represents a `false` expression. */\nexport class FalseExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"false\", false, range);\n    this.kind = NodeKind.False;\n  }\n}\n\n/** Base class of all unary expressions. */\nexport abstract class UnaryExpression extends Expression {\n  constructor(\n    /** Unary expression kind. */\n    kind: NodeKind,\n    /** Operator token. */\n    public operator: Token,\n    /** Operand expression. */\n    public operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n}\n\n/** Represents a unary postfix expression, e.g. a postfix increment. */\nexport class UnaryPostfixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UnaryPostfix, operator, operand, range);\n  }\n}\n\n/** Represents a unary prefix expression, e.g. a negation. */\nexport class UnaryPrefixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UnaryPrefix, operator, operand, range);\n  }\n}\n\n/** Represents a special pre-compiled expression. If the expression has side-effects, special care has to be taken. */\nexport class CompiledExpression extends Expression {\n  constructor(\n    /** Compiled expression. */\n    public expr: ExpressionRef,\n    /** Type of the compiled expression. */\n    public type: Type,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Compiled, range);\n  }\n}\n\n// statements\n\n/** Base class of all statement nodes. */\nexport abstract class Statement extends Node { }\n\n/** Indicates the specific kind of a source. */\nexport const enum SourceKind {\n  /** User-provided file. */\n  User = 0,\n  /** User-provided entry file. */\n  UserEntry = 1,\n  /** Library-provided file. */\n  Library = 2,\n  /** Library-provided entry file. */\n  LibraryEntry = 3\n}\n\n/** A top-level source node. */\nexport class Source extends Node {\n\n  /** Gets the special native source. */\n  static get native(): Source {\n    let source = Source._native;\n    if (!source) Source._native = source = new Source(SourceKind.LibraryEntry, LIBRARY_PREFIX + \"native.ts\", \"[native code]\");\n    return source;\n  }\n  private static _native: Source | null = null;\n\n  constructor(\n    /** Source kind. */\n    public sourceKind: SourceKind,\n    /** Normalized path with file extension. */\n    public normalizedPath: string,\n    /** Full source text. */\n    public text: string\n  ) {\n    super(NodeKind.Source, new Range(0, text.length));\n    let internalPath = mangleInternalPath(normalizedPath);\n    this.internalPath = internalPath;\n    let pos = internalPath.lastIndexOf(PATH_DELIMITER);\n    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;\n    this.range.source = this;\n  }\n\n  /** Path used internally. */\n  internalPath: string;\n  /** Simple path (last part without extension). */\n  simplePath: string;\n  /** Contained statements. */\n  statements: Statement[] = new Array();\n  /** Source map index. */\n  debugInfoIndex: i32 = -1;\n  /** Re-exported sources. */\n  exportPaths: string[] | null = null;\n\n  /** Checks if this source represents native code. */\n  get isNative(): bool {\n    return this.internalPath == LIBRARY_SUBST;\n  }\n\n  /** Checks if this source is part of the (standard) library. */\n  get isLibrary(): bool {\n    let kind = this.sourceKind;\n    return kind == SourceKind.Library || kind == SourceKind.LibraryEntry;\n  }\n\n  /** Cached line starts. */\n  private lineCache: i32[] | null = null;\n\n  /** Remembered column number. */\n  private lineColumn: i32 = 1;\n\n  /** Determines the line number at the specified position. Starts at `1`. */\n  lineAt(pos: i32): i32 {\n    assert(pos >= 0 && pos < 0x7fffffff);\n    let lineCache = this.lineCache;\n    if (!lineCache) {\n      this.lineCache = lineCache = [0];\n      let text = this.text;\n      let off = 0;\n      let end = text.length;\n      while (off < end) {\n        if (text.charCodeAt(off++) == CharCode.LineFeed) lineCache.push(off);\n      }\n      lineCache.push(0x7fffffff);\n    }\n    let l = 0;\n    let r = lineCache.length - 1;\n    while (l < r) {\n      let m = l + ((r - l) >> 1);\n      let s = unchecked(lineCache[m]);\n      if (pos < s) r = m;\n      else if (pos < unchecked(lineCache[m + 1])) {\n        this.lineColumn = pos - s + 1;\n        return m + 1;\n      }\n      else l = m + 1;\n    }\n    return assert(0);\n  }\n\n  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */\n  columnAt(): i32 {\n    return this.lineColumn;\n  }\n}\n\n/** Base class of all declaration statements. */\nexport abstract class DeclarationStatement extends Statement {\n  constructor(\n    /** Declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    public name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    public decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n  /** Overridden module name from preceeding `module` statement. */\n  public overriddenModuleName: string | null = null;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n/** Represents an index signature. */\nexport class IndexSignatureNode extends Node {\n  constructor(\n    /** Key type. */\n    public keyType: NamedTypeNode,\n    /** Value type. */\n    public valueType: TypeNode,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IndexSignature, range);\n  }\n}\n\n/** Base class of all variable-like declaration statements. */\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\n  constructor(\n    /** Variable-like declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    public type: TypeNode | null,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, name, decorators, flags, range);\n  }\n}\n\n/** Represents a block statement. */\nexport class BlockStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Block, range);\n  }\n}\n\n/** Represents a `break` statement. */\nexport class BreakStatement extends Statement {\n  constructor(\n    /** Target label, if any. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Break, range);\n  }\n}\n\n/** Represents a `class` declaration. */\nexport class ClassDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    public implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    public members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ClassDeclaration, name, decorators, flags, range);\n  }\n\n  /** Index signature, if present. */\n  indexSignature: IndexSignatureNode | null = null;\n\n  get isGeneric(): bool {\n    let typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n}\n\n/** Represents a `continue` statement. */\nexport class ContinueStatement extends Statement {\n  constructor(\n    /** Target label, if applicable. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Continue, range);\n  }\n}\n\n/** Represents a `do` statement. */\nexport class DoStatement extends Statement {\n  constructor(\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Condition when to repeat. */\n    public condition: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Do, range);\n  }\n}\n\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\nexport class EmptyStatement extends Statement {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Empty, range);\n  }\n}\n\n/** Represents an `enum` declaration. */\nexport class EnumDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Enum value declarations. */\n    public values: EnumValueDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EnumDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a value of an `enum` declaration. */\nexport class EnumValueDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EnumValueDeclaration, name, null, flags, null, initializer, range);\n  }\n}\n\n/** Represents an `export import` statement of an interface. */\nexport class ExportImportStatement extends Statement {\n  constructor(\n    /** Identifier being imported. */\n    public name: IdentifierExpression,\n    /** Identifier being exported. */\n    public externalName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportImport, range);\n  }\n}\n\n/** Represents a member of an `export` statement. */\nexport class ExportMember extends Node {\n  constructor(\n    /** Local identifier. */\n    public localName: IdentifierExpression,\n    /** Exported identifier. */\n    public exportedName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportMember, range);\n  }\n}\n\n/** Represents an `export` statement. */\nexport class ExportStatement extends Statement {\n  constructor(\n    /** Array of members if a set of named exports, or `null` if a file export. */\n    public members: ExportMember[] | null,\n    /** Path being exported from, if applicable. */\n    public path: StringLiteralExpression | null,\n    /** Whether this is a declared export. */\n    public isDeclare: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Export, range);\n    if (path) {\n      let normalizedPath = normalizePath(path.value);\n      if (path.value.startsWith(\".\")) { // relative\n        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n      } else { // absolute\n        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n      }\n      this.internalPath = normalizedPath;\n    } else {\n      this.internalPath = null;\n    }\n  }\n\n  /** Internal path being referenced, if `path` is set. */\n  internalPath: string | null;\n}\n\n/** Represents an `export default` statement. */\nexport class ExportDefaultStatement extends Statement {\n  constructor(\n    /** Declaration being exported as default. */\n    public declaration: DeclarationStatement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportDefault, range);\n  }\n}\n\n/** Represents an expression that is used as a statement. */\nexport class ExpressionStatement extends Statement {\n  constructor(\n    /** Expression being used as a statement.*/\n    public expression: Expression\n  ) {\n    super(NodeKind.Expression, expression.range);\n  }\n}\n\n/** Represents a field declaration within a `class`. */\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */\n    public parameterIndex: i32,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FieldDeclaration, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a `for` statement. */\nexport class ForStatement extends Statement {\n  constructor(\n    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */\n    public initializer: Statement | null,\n    /** Condition expression, if present. */\n    public condition: Expression | null,\n    /** Incrementor expression, if present. */\n    public incrementor: Expression | null,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.For, range);\n  }\n}\n\n/** Represents a `for..of` statement. */\nexport class ForOfStatement extends Statement {\n  constructor(\n    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */\n    public variable: Statement,\n    /** Iterable expression being iterated. */\n    public iterable: Expression,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ForOf, range);\n  }\n}\n\n/** Indicates the kind of an array function. */\nexport const enum ArrowKind {\n  /** Not an arrow function. */\n  None,\n  /** Parenthesized parameter list. */\n  Parenthesized,\n  /** Single parameter without parenthesis. */\n  Single\n}\n\n/** Represents a `function` declaration. */\nexport class FunctionDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    public signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    public body: Statement | null,\n    /** Arrow function kind, if applicable. */\n    public arrowKind: ArrowKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FunctionDeclaration, name, decorators, flags, range);\n  }\n\n  /** Gets if this function is generic. */\n  get isGeneric(): bool {\n    let typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n\n  /** Clones this function declaration. */\n  clone(): FunctionDeclaration {\n    return new FunctionDeclaration(\n      this.name,\n      this.decorators,\n      this.flags,\n      this.typeParameters,\n      this.signature,\n      this.body,\n      this.arrowKind,\n      this.range\n    );\n  }\n}\n\n/** Represents an `if` statement. */\nexport class IfStatement extends Statement {\n  constructor(\n    /** Condition. */\n    public condition: Expression,\n    /** Statement executed when condition is `true`. */\n    public ifTrue: Statement,\n    /** Statement executed when condition is `false`. */\n    public ifFalse: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.If, range);\n  }\n}\n\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\nexport class ImportDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Identifier being imported. */\n    public foreignName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ImportDeclaration, name, null, CommonFlags.None, range);\n  }\n}\n\n/** Represents an `import` statement. */\nexport class ImportStatement extends Statement {\n  constructor(\n    /** Array of member declarations or `null` if an asterisk import. */\n    public declarations: ImportDeclaration[] | null,\n    /** Name of the local namespace, if an asterisk import. */\n    public namespaceName: IdentifierExpression | null,\n    /** Path being imported from. */\n    public path: StringLiteralExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Import, range);\n    let normalizedPath = normalizePath(path.value);\n    if (path.value.startsWith(\".\")) { // relative in project\n      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n    } else { // absolute in library\n      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n    }\n    this.internalPath = mangleInternalPath(normalizedPath);\n  }\n\n  /** Internal path being referenced. */\n  internalPath: string;\n}\n\n/** Represents an `interfarce` declaration. */\nexport class InterfaceDeclaration extends ClassDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n    this.kind = NodeKind.InterfaceDeclaration;\n  }\n}\n\n/** Represents a method declaration within a `class`. */\nexport class MethodDeclaration extends FunctionDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    body: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.None, range);\n    this.kind = NodeKind.MethodDeclaration;\n  }\n}\n\n/** Represents a `namespace` declaration. */\nexport class NamespaceDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Array of namespace members. */\n    public members: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NamespaceDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a `return` statement. */\nexport class ReturnStatement extends Statement {\n  constructor(\n    /** Value expression being returned, if present. */\n    public value: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Return, range);\n  }\n}\n\n/** Represents a single `case` within a `switch` statement. */\nexport class SwitchCase extends Node {\n  constructor(\n    /** Label expression. `null` indicates the default case. */\n    public label: Expression | null,\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SwitchCase, range);\n  }\n\n  get isDefault(): bool {\n    return this.label == null;\n  }\n}\n\n/** Represents a `switch` statement. */\nexport class SwitchStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Contained cases. */\n    public cases: SwitchCase[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Switch, range);\n  }\n}\n\n/** Represents a `throw` statement. */\nexport class ThrowStatement extends Statement {\n  constructor(\n    /** Value expression being thrown. */\n    public value: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Throw, range);\n  }\n}\n\n/** Represents a `try` statement. */\nexport class TryStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public bodyStatements: Statement[],\n    /** Exception variable name, if a `catch` clause is present. */\n    public catchVariable: IdentifierExpression | null,\n    /** Statements being executed on catch, if a `catch` clause is present. */\n    public catchStatements: Statement[] | null,\n    /** Statements being executed afterwards, if a `finally` clause is present. */\n    public finallyStatements: Statement[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Try, range);\n  }\n}\n\n/** Represents a `module` statement. */\nexport class ModuleDeclaration extends Statement {\n  constructor(\n    /** Module name. */\n    public moduleName: string,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Module, range);\n  }\n}\n\n/** Represents a `type` declaration. */\nexport class TypeDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Type being aliased. */\n    public type: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a variable declaration part of a {@link VariableStatement}. */\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VariableDeclaration, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\nexport class VariableStatement extends Statement {\n  constructor(\n    /** Array of decorators. */\n    public decorators: DecoratorNode[] | null,\n    /** Array of member declarations. */\n    public declarations: VariableDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Variable, range);\n  }\n}\n\n/** Represents a void statement dropping an expression's value. */\nexport class VoidStatement extends Statement {\n  constructor(\n    /** Expression being dropped. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Void, range);\n  }\n}\n\n/** Represents a `while` statement. */\nexport class WhileStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.While, range);\n  }\n}\n\n/** Finds the first decorator matching the specified kind. */\nexport function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {\n  if (decorators) {\n    for (let i = 0, k = decorators.length; i < k; ++i) {\n      let decorator = decorators[i];\n      if (decorator.decoratorKind == kind) return decorator;\n    }\n  }\n  return null;\n}\n\n/** Mangles an external to an internal path. */\nexport function mangleInternalPath(path: string): string {\n  if (path.endsWith(\"/\")) {\n    path += \"index\";\n  } else if (path.endsWith(\".ts\")) {\n    path = path.substring(0, path.length - 3);\n  }\n  return path;\n}\n\n/** Tests if the specified type node represents an omitted type. */\nexport function isTypeOmitted(type: TypeNode): bool {\n  if (type.kind == NodeKind.NamedType) {\n    let name = (<NamedTypeNode>type).name;\n    return !(name.next || name.identifier.text.length > 0);\n  }\n  return false;\n}\n", "/**\n * @fileoverview A TypeScript tokenizer modified for AssemblyScript.\n *\n * The `Tokenizer` scans over a source file and returns one syntactic token\n * at a time that the parser will combine to an abstract syntax tree.\n *\n * It skips over trivia like comments and whitespace and provides a general\n * mark/reset mechanism for the parser to utilize on ambiguous tokens, with\n * one token of lookahead otherwise.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Source,\n  CommentKind\n} from \"./ast\";\n\nimport {\n  CharCode,\n  isLineBreak,\n  isWhiteSpace,\n  isIdentifierStart,\n  isIdentifierPart,\n  isDecimal,\n  isOctal,\n  isHexBase,\n  isHighSurrogate,\n  combineSurrogates,\n  numCodeUnits\n} from \"./util\";\n\n/** Named token types. */\nexport const enum Token {\n\n  // keywords\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\n\n  Abstract,\n  As,\n  Async,\n  Await,        // ES2017\n  Break,        // ES2017\n  Case,         // ES2017\n  Catch,        // ES2017\n  Class,        // ES2017\n  Const,        // ES2017\n  Continue,     // ES2017\n  Constructor,\n  Debugger,     // ES2017\n  Declare,\n  Default,      // ES2017\n  Delete,       // ES2017\n  Do,           // ES2017\n  Else,         // ES2017\n  Enum,         // ES2017 future\n  Export,       // ES2017\n  Extends,      // ES2017\n  False,        // ES\n  Finally,      // ES2017\n  For,          // ES2017\n  From,         // AS possible identifier\n  Function,     // ES2017\n  Get,\n  If,           // ES2017\n  Implements,   // ES2017 non-lexical\n  Import,       // ES2017\n  In,           // ES2017\n  InstanceOf,   // ES2017\n  Interface,    // ES2017 non-lexical\n  Is,\n  KeyOf,\n  Let,          // ES2017 non-lexical\n  Module,       // AS possible identifier\n  Namespace,    // AS possible identifier\n  New,          // ES2017\n  Null,         // ES\n  Of,\n  Override,\n  Package,      // ES2017 non-lexical\n  Private,      // ES2017 non-lexical\n  Protected,    // ES2017 non-lexical\n  Public,       // ES2017 non-lexical\n  Readonly,\n  Return,       // ES2017\n  Set,\n  Static,       // ES2017 non-lexical\n  Super,        // ES2017\n  Switch,       // ES2017\n  This,         // ES2017\n  Throw,        // ES2017\n  True,         // ES\n  Try,          // ES2017\n  Type,         // AS possible identifier\n  TypeOf,       // ES2017\n  Var,          // ES2017\n  Void,         // ES2017\n  While,        // ES2017\n  With,         // ES2017\n  Yield,        // ES2017\n\n  // punctuation\n\n  OpenBrace,\n  CloseBrace,\n  OpenParen,\n  CloseParen,\n  OpenBracket,\n  CloseBracket,\n  Dot,\n  Dot_Dot_Dot,\n  Semicolon,\n  Comma,\n  LessThan,\n  GreaterThan,\n  LessThan_Equals,\n  GreaterThan_Equals,\n  Equals_Equals,\n  Exclamation_Equals,\n  Equals_Equals_Equals,\n  Exclamation_Equals_Equals,\n  Equals_GreaterThan,\n  Plus,\n  Minus,\n  Asterisk_Asterisk,\n  Asterisk,\n  Slash,\n  Percent,\n  Plus_Plus,\n  Minus_Minus,\n  LessThan_LessThan,\n  GreaterThan_GreaterThan,\n  GreaterThan_GreaterThan_GreaterThan,\n  Ampersand,\n  Bar,\n  Caret,\n  Exclamation,\n  Tilde,\n  Ampersand_Ampersand,\n  Bar_Bar,\n  Question,\n  Colon,\n  Equals,\n  Plus_Equals,\n  Minus_Equals,\n  Asterisk_Equals,\n  Asterisk_Asterisk_Equals,\n  Slash_Equals,\n  Percent_Equals,\n  LessThan_LessThan_Equals,\n  GreaterThan_GreaterThan_Equals,\n  GreaterThan_GreaterThan_GreaterThan_Equals,\n  Ampersand_Equals,\n  Bar_Equals,\n  Caret_Equals,\n  At,\n\n  // literals\n\n  Identifier,\n  StringLiteral,\n  IntegerLiteral,\n  FloatLiteral,\n  TemplateLiteral,\n\n  // meta\n\n  Invalid,\n  EndOfFile\n}\n\nexport const enum IdentifierHandling {\n  Default,\n  Prefer,\n  Always\n}\n\nexport function tokenFromKeyword(text: string): Token {\n  let len = text.length;\n  assert(len);\n  switch (text.charCodeAt(0)) {\n    case CharCode.a: {\n      if (len == 5) {\n        if (text == \"async\") return Token.Async;\n        if (text == \"await\") return Token.Await;\n        break;\n      }\n      if (text == \"as\") return Token.As;\n      if (text == \"abstract\") return Token.Abstract;\n      break;\n    }\n    case CharCode.b: {\n      if (text == \"break\") return Token.Break;\n      break;\n    }\n    case CharCode.c: {\n      if (len == 5) {\n        if (text == \"const\") return Token.Const;\n        if (text == \"class\") return Token.Class;\n        if (text == \"catch\") return Token.Catch;\n        break;\n      }\n      if (text == \"case\") return Token.Case;\n      if (text == \"continue\") return Token.Continue;\n      if (text == \"constructor\") return Token.Constructor;\n      break;\n    }\n    case CharCode.d: {\n      if (len == 7) {\n        if (text == \"default\") return Token.Default;\n        if (text == \"declare\") return Token.Declare;\n        break;\n      }\n      if (text == \"do\") return Token.Do;\n      if (text == \"delete\") return Token.Delete;\n      if (text == \"debugger\") return Token.Debugger;\n      break;\n    }\n    case CharCode.e: {\n      if (len == 4) {\n        if (text == \"else\") return Token.Else;\n        if (text == \"enum\") return Token.Enum;\n        break;\n      }\n      if (text == \"export\") return Token.Export;\n      if (text == \"extends\") return Token.Extends;\n      break;\n    }\n    case CharCode.f: {\n      if (len <= 5) {\n        if (text == \"false\") return Token.False;\n        if (text == \"for\") return Token.For;\n        if (text == \"from\") return Token.From;\n        break;\n      }\n      if (text == \"function\") return Token.Function;\n      if (text == \"finally\") return Token.Finally;\n      break;\n    }\n    case CharCode.g: {\n      if (text == \"get\") return Token.Get;\n      break;\n    }\n    case CharCode.i: {\n      if (len == 2) {\n        if (text == \"if\") return Token.If;\n        if (text == \"in\") return Token.In;\n        if (text == \"is\") return Token.Is;\n        break;\n      }\n      switch (text.charCodeAt(3)) {\n        case CharCode.l: {\n          if (text == \"implements\") return Token.Implements;\n          break;\n        }\n        case CharCode.o: {\n          if (text == \"import\") return Token.Import;\n          break;\n        }\n        case CharCode.t: {\n          if (text == \"instanceof\") return Token.InstanceOf;\n          break;\n        }\n        case CharCode.e: {\n          if (text == \"interface\") return Token.Interface;\n          break;\n        }\n      }\n      break;\n    }\n    case CharCode.k: {\n      if (text == \"keyof\") return Token.KeyOf;\n      break;\n    }\n    case CharCode.l: {\n      if (text == \"let\") return Token.Let;\n      break;\n    }\n    case CharCode.m: {\n      if (text == \"module\") return Token.Module;\n      break;\n    }\n    case CharCode.n: {\n      if (text == \"new\") return Token.New;\n      if (text == \"null\") return Token.Null;\n      if (text == \"namespace\") return Token.Namespace;\n      break;\n    }\n    case CharCode.o: {\n      if (text == \"of\") return Token.Of;\n      if (text == \"override\") return Token.Override;\n      break;\n    }\n    case CharCode.p: {\n      if (len == 7) {\n        if (text == \"private\") return Token.Private;\n        if (text == \"package\") return Token.Package;\n        break;\n      }\n      if (text == \"public\") return Token.Public;\n      if (text == \"protected\") return Token.Protected;\n      break;\n    }\n    case CharCode.r: {\n      if (text == \"return\") return Token.Return;\n      if (text == \"readonly\") return Token.Readonly;\n      break;\n    }\n    case CharCode.s: {\n      if (len == 6) {\n        if (text == \"switch\") return Token.Switch;\n        if (text == \"static\") return Token.Static;\n        break;\n      }\n      if (text == \"set\") return Token.Set;\n      if (text == \"super\") return Token.Super;\n      break;\n    }\n    case CharCode.t: {\n      if (len == 4) {\n        if (text == \"true\") return Token.True;\n        if (text == \"this\") return Token.This;\n        if (text == \"type\") return Token.Type;\n        break;\n      }\n      if (text == \"try\") return Token.Try;\n      if (text == \"throw\") return Token.Throw;\n      if (text == \"typeof\") return Token.TypeOf;\n      break;\n    }\n    case CharCode.v: {\n      if (text == \"var\") return Token.Var;\n      if (text == \"void\") return Token.Void;\n      break;\n    }\n    case CharCode.w: {\n      if (text == \"while\") return Token.While;\n      if (text == \"with\") return Token.With;\n      break;\n    }\n    case CharCode.y: {\n      if (text == \"yield\") return Token.Yield;\n      break;\n    }\n  }\n  return Token.Invalid;\n}\n\nexport function tokenIsAlsoIdentifier(token: Token): bool {\n  switch (token) {\n    case Token.Abstract:\n    case Token.As:\n    case Token.Constructor:\n    case Token.Declare:\n    case Token.Delete:\n    case Token.From:\n    case Token.For:\n    case Token.Get:\n    case Token.InstanceOf:\n    case Token.Is:\n    case Token.KeyOf:\n    case Token.Module:\n    case Token.Namespace:\n    case Token.Null:\n    case Token.Readonly:\n    case Token.Set:\n    case Token.Type:\n    case Token.Void: return true;\n    default: return false;\n  }\n}\n\nexport function isIllegalVariableIdentifier(name: string): bool {\n  assert(name.length);\n  switch (name.charCodeAt(0)) {\n    case CharCode.d: return name == \"delete\";\n    case CharCode.f: return name == \"for\";\n    case CharCode.i: return name == \"instanceof\";\n    case CharCode.n: return name == \"null\";\n    case CharCode.v: return name == \"void\";\n  }\n  return false;\n}\n\nexport function operatorTokenToString(token: Token): string {\n  switch (token) {\n    case Token.Delete: return \"delete\";\n    case Token.In: return \"in\";\n    case Token.InstanceOf: return \"instanceof\";\n    case Token.New: return \"new\";\n    case Token.TypeOf: return \"typeof\";\n    case Token.Void: return \"void\";\n    case Token.Yield: return \"yield\";\n    case Token.Dot_Dot_Dot: return \"...\";\n    case Token.Comma: return \",\";\n    case Token.LessThan: return \"<\";\n    case Token.GreaterThan: return \">\";\n    case Token.LessThan_Equals: return \"<=\";\n    case Token.GreaterThan_Equals: return \">=\";\n    case Token.Equals_Equals: return \"==\";\n    case Token.Exclamation_Equals: return \"!=\";\n    case Token.Equals_Equals_Equals: return \"===\";\n    case Token.Exclamation_Equals_Equals: return \"!==\";\n    case Token.Plus: return \"+\";\n    case Token.Minus: return \"-\";\n    case Token.Asterisk_Asterisk: return \"**\";\n    case Token.Asterisk: return \"*\";\n    case Token.Slash: return \"/\";\n    case Token.Percent: return \"%\";\n    case Token.Plus_Plus: return \"++\";\n    case Token.Minus_Minus: return \"--\";\n    case Token.LessThan_LessThan: return \"<<\";\n    case Token.GreaterThan_GreaterThan: return \">>\";\n    case Token.GreaterThan_GreaterThan_GreaterThan: return \">>>\";\n    case Token.Ampersand: return \"&\";\n    case Token.Bar: return \"|\";\n    case Token.Caret: return \"^\";\n    case Token.Exclamation: return \"!\";\n    case Token.Tilde: return \"~\";\n    case Token.Ampersand_Ampersand: return \"&&\";\n    case Token.Bar_Bar: return \"||\";\n    case Token.Equals: return \"=\";\n    case Token.Plus_Equals: return \"+=\";\n    case Token.Minus_Equals: return \"-=\";\n    case Token.Asterisk_Equals: return \"*=\";\n    case Token.Asterisk_Asterisk_Equals: return \"**=\";\n    case Token.Slash_Equals: return \"/=\";\n    case Token.Percent_Equals: return \"%=\";\n    case Token.LessThan_LessThan_Equals: return \"<<=\";\n    case Token.GreaterThan_GreaterThan_Equals: return \">>=\";\n    case Token.GreaterThan_GreaterThan_GreaterThan_Equals: return \">>>=\";\n    case Token.Ampersand_Equals: return \"&=\";\n    case Token.Bar_Equals: return \"|=\";\n    case Token.Caret_Equals: return \"^=\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Handler for intercepting comments while tokenizing. */\nexport type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;\n\n/** Tokenizes a source to individual {@link Token}s. */\nexport class Tokenizer extends DiagnosticEmitter {\n\n  source: Source;\n  end: i32 = 0;\n\n  pos: i32 = 0;\n  token: Token = -1;\n  tokenPos: i32 = 0;\n\n  nextToken: Token = -1;\n  nextTokenPos: i32 = 0;\n  nextTokenOnNewLine: bool = false;\n\n  onComment: CommentHandler | null = null;\n\n  /** Constructs a new tokenizer. */\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\n    super(diagnostics);\n\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n    this.source = source;\n\n    let text = source.text;\n    let end = text.length;\n    let pos = 0;\n    // skip bom\n    if (\n      pos < end &&\n      text.charCodeAt(pos) == CharCode.ByteOrderMark\n    ) {\n      ++pos;\n    }\n\n    // skip shebang\n    if (\n      pos + 1 < end &&\n      text.charCodeAt(pos) == CharCode.Hash &&\n      text.charCodeAt(pos + 1) == CharCode.Exclamation\n    ) {\n      pos += 2;\n      while (\n        pos < end &&\n        text.charCodeAt(pos) != CharCode.LineFeed\n      ) {\n        ++pos;\n      }\n      // 'next' now starts at lf or eof\n    }\n    this.pos = pos;\n    this.end = end;\n  }\n\n  next(identifierHandling: IdentifierHandling = IdentifierHandling.Default): Token {\n    this.nextToken = -1;\n    let token: Token;\n    do token = this.unsafeNext(identifierHandling);\n    while (token == Token.Invalid);\n    this.token = token;\n    return token;\n  }\n\n  private unsafeNext(\n    identifierHandling: IdentifierHandling = IdentifierHandling.Default,\n    maxTokenLength: i32 = i32.MAX_VALUE\n  ): Token {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    while (pos < end) {\n      this.tokenPos = pos;\n      let c = text.charCodeAt(pos);\n      switch (c) {\n        case CharCode.CarriageReturn: {\n          if (!(\n            ++pos < end &&\n            text.charCodeAt(pos) == CharCode.LineFeed\n          )) break;\n          // otherwise fall-through\n        }\n        case CharCode.LineFeed:\n        case CharCode.Tab:\n        case CharCode.VerticalTab:\n        case CharCode.FormFeed:\n        case CharCode.Space: {\n          ++pos;\n          break;\n        }\n        case CharCode.Exclamation: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            ++pos;\n            if (\n              maxTokenLength > 2 && pos < end &&\n              text.charCodeAt(pos) == CharCode.Equals\n            ) {\n              this.pos = pos + 1;\n              return Token.Exclamation_Equals_Equals;\n            }\n            this.pos = pos;\n            return Token.Exclamation_Equals;\n          }\n          this.pos = pos;\n          return Token.Exclamation;\n        }\n        case CharCode.DoubleQuote:\n        case CharCode.SingleQuote: {\n          this.pos = pos;\n          return Token.StringLiteral;\n        }\n        case CharCode.Backtick: {\n          this.pos = pos;\n          return Token.TemplateLiteral;\n        }\n        case CharCode.Percent: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            this.pos = pos + 1;\n            return Token.Percent_Equals;\n          }\n          this.pos = pos;\n          return Token.Percent;\n        }\n        case CharCode.Ampersand: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Ampersand) {\n              this.pos = pos + 1;\n              return Token.Ampersand_Ampersand;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Ampersand_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Ampersand;\n        }\n        case CharCode.OpenParen: {\n          this.pos = pos + 1;\n          return Token.OpenParen;\n        }\n        case CharCode.CloseParen: {\n          this.pos = pos + 1;\n          return Token.CloseParen;\n        }\n        case CharCode.Asterisk: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Asterisk_Equals;\n            }\n            if (chr == CharCode.Asterisk) {\n              ++pos;\n              if (\n                maxTokenLength > 2 && pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.Asterisk_Asterisk_Equals;\n              }\n              this.pos = pos;\n              return Token.Asterisk_Asterisk;\n            }\n          }\n          this.pos = pos;\n          return Token.Asterisk;\n        }\n        case CharCode.Plus: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Plus) {\n              this.pos = pos + 1;\n              return Token.Plus_Plus;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Plus_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Plus;\n        }\n        case CharCode.Comma: {\n          this.pos = pos + 1;\n          return Token.Comma;\n        }\n        case CharCode.Minus: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Minus) {\n              this.pos = pos + 1;\n              return Token.Minus_Minus;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Minus_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Minus;\n        }\n        case CharCode.Dot: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (isDecimal(chr)) {\n              this.pos = pos - 1;\n              return Token.FloatLiteral; // expects a call to readFloat\n            }\n            if (\n              maxTokenLength > 2 && pos + 1 < end &&\n              chr == CharCode.Dot &&\n              text.charCodeAt(pos + 1) == CharCode.Dot\n            ) {\n              this.pos = pos + 2;\n              return Token.Dot_Dot_Dot;\n            }\n          }\n          this.pos = pos;\n          return Token.Dot;\n        }\n        case CharCode.Slash: {\n          let commentStartPos = pos;\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Slash) { // single-line\n              let commentKind = CommentKind.Line;\n              if (\n                pos + 1 < end &&\n                text.charCodeAt(pos + 1) == CharCode.Slash\n              ) {\n                ++pos;\n                commentKind = CommentKind.Triple;\n              }\n              while (++pos < end) {\n                if (text.charCodeAt(pos) == CharCode.LineFeed) {\n                  ++pos;\n                  break;\n                }\n              }\n              if (this.onComment) {\n                this.onComment(\n                  commentKind,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.Asterisk) { // multi-line\n              let closed = false;\n              while (++pos < end) {\n                c = text.charCodeAt(pos);\n                if (\n                  c == CharCode.Asterisk &&\n                  pos + 1 < end &&\n                  text.charCodeAt(pos + 1) == CharCode.Slash\n                ) {\n                  pos += 2;\n                  closed = true;\n                  break;\n                }\n              }\n              if (!closed) {\n                this.error(\n                  DiagnosticCode._0_expected,\n                  this.range(pos), \"*/\"\n                );\n              } else if (this.onComment) {\n                this.onComment(\n                  CommentKind.Block,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Slash_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Slash;\n        }\n        case CharCode._0:\n        case CharCode._1:\n        case CharCode._2:\n        case CharCode._3:\n        case CharCode._4:\n        case CharCode._5:\n        case CharCode._6:\n        case CharCode._7:\n        case CharCode._8:\n        case CharCode._9: {\n          this.pos = pos;\n          return this.testInteger()\n            ? Token.IntegerLiteral // expects a call to readInteger\n            : Token.FloatLiteral;  // expects a call to readFloat\n        }\n        case CharCode.Colon: {\n          this.pos = pos + 1;\n          return Token.Colon;\n        }\n        case CharCode.Semicolon: {\n          this.pos = pos + 1;\n          return Token.Semicolon;\n        }\n        case CharCode.LessThan: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.LessThan) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.LessThan_LessThan_Equals;\n              }\n              this.pos = pos;\n              return Token.LessThan_LessThan;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.LessThan_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.LessThan;\n        }\n        case CharCode.Equals: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Equals) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.Equals_Equals_Equals;\n              }\n              this.pos = pos;\n              return Token.Equals_Equals;\n            }\n            if (chr == CharCode.GreaterThan) {\n              this.pos = pos + 1;\n              return Token.Equals_GreaterThan;\n            }\n          }\n          this.pos = pos;\n          return Token.Equals;\n        }\n        case CharCode.GreaterThan: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.GreaterThan) {\n              ++pos;\n              if (maxTokenLength > 2 && pos < end) {\n                chr = text.charCodeAt(pos);\n                if (chr == CharCode.GreaterThan) {\n                  ++pos;\n                  if (\n                    maxTokenLength > 3 && pos < end &&\n                    text.charCodeAt(pos) == CharCode.Equals\n                  ) {\n                    this.pos = pos + 1;\n                    return Token.GreaterThan_GreaterThan_GreaterThan_Equals;\n                  }\n                  this.pos = pos;\n                  return Token.GreaterThan_GreaterThan_GreaterThan;\n                }\n                if (chr == CharCode.Equals) {\n                  this.pos = pos + 1;\n                  return Token.GreaterThan_GreaterThan_Equals;\n                }\n              }\n              this.pos = pos;\n              return Token.GreaterThan_GreaterThan;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.GreaterThan_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.GreaterThan;\n        }\n        case CharCode.Question: {\n          this.pos = pos + 1;\n          return Token.Question;\n        }\n        case CharCode.OpenBracket: {\n          this.pos = pos + 1;\n          return Token.OpenBracket;\n        }\n        case CharCode.CloseBracket: {\n          this.pos = pos + 1;\n          return Token.CloseBracket;\n        }\n        case CharCode.Caret: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            this.pos = pos + 1;\n            return Token.Caret_Equals;\n          }\n          this.pos = pos;\n          return Token.Caret;\n        }\n        case CharCode.OpenBrace: {\n          this.pos = pos + 1;\n          return Token.OpenBrace;\n        }\n        case CharCode.Bar: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Bar) {\n              this.pos = pos + 1;\n              return Token.Bar_Bar;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Bar_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Bar;\n        }\n        case CharCode.CloseBrace: {\n          this.pos = pos + 1;\n          return Token.CloseBrace;\n        }\n        case CharCode.Tilde: {\n          this.pos = pos + 1;\n          return Token.Tilde;\n        }\n        case CharCode.At: {\n          this.pos = pos + 1;\n          return Token.At;\n        }\n        default: {\n          // Unicode-aware from here on\n          if (isHighSurrogate(c) && pos + 1 < end) {\n            c = combineSurrogates(c, text.charCodeAt(pos + 1));\n          }\n          if (isIdentifierStart(c)) {\n            let posBefore = pos;\n            while (\n              (pos += numCodeUnits(c)) < end &&\n              isIdentifierPart(c = <i32>text.codePointAt(pos))\n            ) { /* nop */ }\n            if (identifierHandling != IdentifierHandling.Always) {\n              let maybeKeywordToken = tokenFromKeyword(text.substring(posBefore, pos));\n              if (\n                maybeKeywordToken != Token.Invalid &&\n                !(\n                  identifierHandling == IdentifierHandling.Prefer &&\n                  tokenIsAlsoIdentifier(maybeKeywordToken)\n                )\n              ) {\n                this.pos = pos;\n                return maybeKeywordToken;\n              }\n            }\n            this.pos = posBefore;\n            return Token.Identifier;\n          } else if (isWhiteSpace(c)) {\n            ++pos; // assume no supplementary whitespaces\n            break;\n          }\n          let start = pos;\n          pos += numCodeUnits(c);\n          this.error(\n            DiagnosticCode.Invalid_character,\n            this.range(start, pos)\n          );\n          this.pos = pos;\n          return Token.Invalid;\n        }\n      }\n    }\n    this.pos = pos;\n    return Token.EndOfFile;\n  }\n\n  peek(\n    checkOnNewLine: bool = false,\n    identifierHandling: IdentifierHandling = IdentifierHandling.Default,\n    maxCompoundLength: i32 = i32.MAX_VALUE\n  ): Token {\n    let text = this.source.text;\n    if (this.nextToken < 0) {\n      let posBefore = this.pos;\n      let tokenBefore = this.token;\n      let tokenPosBefore = this.tokenPos;\n      let nextToken: Token;\n      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n      while (nextToken == Token.Invalid);\n      this.nextToken = nextToken;\n      this.nextTokenPos = this.tokenPos;\n      if (checkOnNewLine) {\n        this.nextTokenOnNewLine = false;\n        for (let pos = posBefore, end = this.nextTokenPos; pos < end; ++pos) {\n          if (isLineBreak(text.charCodeAt(pos))) {\n            this.nextTokenOnNewLine = true;\n            break;\n          }\n        }\n      }\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n    }\n    return this.nextToken;\n  }\n\n  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.Prefer): bool {\n    return this.skip(Token.Identifier, identifierHandling);\n  }\n\n  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.Default): bool {\n    let posBefore = this.pos;\n    let tokenBefore = this.token;\n    let tokenPosBefore = this.tokenPos;\n    let maxCompoundLength = i32.MAX_VALUE;\n    if (token == Token.GreaterThan) {  // where parsing type arguments\n      maxCompoundLength = 1;\n    }\n    let nextToken: Token;\n    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n    while (nextToken == Token.Invalid);\n    if (nextToken == token) {\n      this.token = token;\n      this.nextToken = -1;\n      return true;\n    } else {\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n      return false;\n    }\n  }\n\n  mark(): State {\n    let state = reusableState;\n    if (state) {\n      reusableState = null;\n      state.pos = this.pos;\n      state.token = this.token;\n      state.tokenPos = this.tokenPos;\n    } else {\n      state = new State(this.pos, this.token, this.tokenPos);\n    }\n    return state;\n  }\n\n  discard(state: State): void {\n    reusableState = state;\n  }\n\n  reset(state: State): void {\n    this.pos = state.pos;\n    this.token = state.token;\n    this.tokenPos = state.tokenPos;\n    this.nextToken = -1;\n  }\n\n  range(start: i32 = -1, end: i32 = -1): Range {\n    if (start < 0) {\n      start = this.tokenPos;\n      end = this.pos;\n    } else if (end < 0) {\n      end = start;\n    }\n    let range = new Range(start, end);\n    range.source = this.source;\n    return range;\n  }\n\n  readIdentifier(): string {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    let start = pos;\n    let c = <i32>text.codePointAt(pos);\n    assert(isIdentifierStart(c));\n    while (\n      (pos += numCodeUnits(c)) < end &&\n      isIdentifierPart(c = <i32>text.codePointAt(pos))\n    );\n    this.pos = pos;\n    return text.substring(start, pos);\n  }\n\n  readingTemplateString: bool = false;\n  readStringStart: i32 = 0;\n  readStringEnd: i32 = 0;\n\n  readString(quote: i32 = 0, isTaggedTemplate: bool = false): string {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    if (!quote) quote = text.charCodeAt(pos++);\n    let start = pos;\n    this.readStringStart = start;\n    let result = \"\";\n\n    while (true) {\n      if (pos >= end) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, end)\n        );\n        this.readStringEnd = end;\n        break;\n      }\n      let c = text.charCodeAt(pos);\n      if (c == quote) {\n        this.readStringEnd = pos;\n        result += text.substring(start, pos++);\n        break;\n      }\n      if (c == CharCode.Backslash) {\n        result += text.substring(start, pos);\n        this.pos = pos; // save\n        result += this.readEscapeSequence(isTaggedTemplate);\n        pos = this.pos; // restore\n        start = pos;\n        continue;\n      }\n      if (quote == CharCode.Backtick) {\n        if (c == CharCode.Dollar && pos + 1 < end && text.charCodeAt(pos + 1) == CharCode.OpenBrace) {\n          result += text.substring(start, pos);\n          this.readStringEnd = pos;\n          this.pos = pos + 2;\n          this.readingTemplateString = true;\n          return result;\n        }\n      } else if (isLineBreak(c)) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, pos)\n        );\n        this.readStringEnd = pos;\n        break;\n      }\n      ++pos;\n    }\n    this.pos = pos;\n    this.readingTemplateString = false;\n    return result;\n  }\n\n  readEscapeSequence(isTaggedTemplate: bool = false): string {\n    // for context on isTaggedTemplate, see: https://tc39.es/proposal-template-literal-revision/\n    let start = this.pos;\n    let end = this.end;\n    if (++this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(end)\n      );\n      return \"\";\n    }\n\n    let text = this.source.text;\n    let c = text.charCodeAt(this.pos++);\n    switch (c) {\n      case CharCode._0: {\n        if (isTaggedTemplate && this.pos < end && isDecimal(text.charCodeAt(this.pos))) {\n          ++this.pos;\n          return text.substring(start, this.pos);\n        }\n        return \"\\0\";\n      }\n      case CharCode.b: return \"\\b\";\n      case CharCode.t: return \"\\t\";\n      case CharCode.n: return \"\\n\";\n      case CharCode.v: return \"\\v\";\n      case CharCode.f: return \"\\f\";\n      case CharCode.r: return \"\\r\";\n      case CharCode.SingleQuote: return \"'\";\n      case CharCode.DoubleQuote: return \"\\\"\";\n      case CharCode.u: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.OpenBrace\n        ) {\n          ++this.pos;\n          return this.readExtendedUnicodeEscape(isTaggedTemplate ? start : -1); // \\u{DDDDDDDD}\n        }\n        return this.readUnicodeEscape(isTaggedTemplate ? start : -1); // \\uDDDD\n      }\n      case CharCode.x: {\n        return this.readHexadecimalEscape(2, isTaggedTemplate ? start : - 1); // \\xDD\n      }\n      case CharCode.CarriageReturn: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.LineFeed\n        ) {\n          ++this.pos;\n        }\n        // fall through\n      }\n      case CharCode.LineFeed:\n      case CharCode.LineSeparator:\n      case CharCode.ParagraphSeparator: return \"\";\n      default: return String.fromCodePoint(c);\n    }\n  }\n\n  readRegexpPattern(): string {\n    let text = this.source.text;\n    let start = this.pos;\n    let end = this.end;\n    let escaped = false;\n    while (true) {\n      if (this.pos >= end) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, end)\n        );\n        break;\n      }\n      if (text.charCodeAt(this.pos) == CharCode.Backslash) {\n        ++this.pos;\n        escaped = true;\n        continue;\n      }\n      let c = text.charCodeAt(this.pos);\n      if (!escaped && c == CharCode.Slash) break;\n      if (isLineBreak(c)) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, this.pos)\n        );\n        break;\n      }\n      ++this.pos;\n      escaped = false;\n    }\n    return text.substring(start, this.pos);\n  }\n\n  readRegexpFlags(): string {\n    let text = this.source.text;\n    let start = this.pos;\n    let end = this.end;\n    let flags = 0;\n    while (this.pos < end) {\n      let c: i32 = text.charCodeAt(this.pos);\n      if (!isIdentifierPart(c)) break;\n      ++this.pos;\n\n      // make sure each supported flag is unique\n      switch (c) {\n        case CharCode.g: {\n          flags |= flags & 1 ? -1 : 1;\n          break;\n        }\n        case CharCode.i: {\n          flags |= flags & 2 ? -1 : 2;\n          break;\n        }\n        case CharCode.m: {\n          flags |= flags & 4 ? -1 : 4;\n          break;\n        }\n        default: {\n          flags = -1;\n          break;\n        }\n      }\n    }\n    if (flags == -1) {\n      this.error(\n        DiagnosticCode.Invalid_regular_expression_flags,\n        this.range(start, this.pos)\n      );\n    }\n    return text.substring(start, this.pos);\n  }\n\n  testInteger(): bool {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 2) | 32) {\n        case CharCode.x:\n        case CharCode.b:\n        case CharCode.o: return true;\n      }\n    }\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode.Dot || (c | 32) == CharCode.e) return false;\n      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;\n      // does not validate separator placement (this is done in readXYInteger)\n      pos++;\n    }\n    return true;\n  }\n\n  readInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 1) | 32) {\n        case CharCode.x: {\n          this.pos = pos + 2;\n          return this.readHexInteger();\n        }\n        case CharCode.b: {\n          this.pos = pos + 2;\n          return this.readBinaryInteger();\n        }\n        case CharCode.o: {\n          this.pos = pos + 2;\n          return this.readOctalInteger();\n        }\n      }\n      if (isOctal(text.charCodeAt(pos + 1))) {\n        let start = pos;\n        this.pos = pos + 1;\n        let value = this.readOctalInteger();\n        this.error(\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\n          this.range(start, this.pos)\n        );\n        return value;\n      }\n    }\n    return this.readDecimalInteger();\n  }\n\n  readHexInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_4 = i64_new(4);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isDecimal(c)) {\n        // (value << 4) + c - CharCode._0\n        nextValue = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(c - CharCode._0)\n        );\n      } else if (isHexBase(c)) {\n        // (value << 4) + (c | 32) + (10 - CharCode.a)\n        nextValue = i64_add(\n          i64_shl(value, i64_4),\n          i64_new((c | 32) + (10 - CharCode.a))\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Hexadecimal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readDecimalInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_10 = i64_new(10);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isDecimal(c)) {\n        // value = value * 10 + c - CharCode._0;\n        nextValue = i64_add(\n          i64_mul(value, i64_10),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start, pos),\n        this.source.text.substring(start, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readOctalInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_3 = i64_new(3);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isOctal(c)) {\n        // (value << 3) + c - CharCode._0\n        nextValue = i64_add(\n          i64_shl(value, i64_3),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Octal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readBinaryInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode._0) {\n        // value << 1 | 0\n        nextValue = i64_shl(value, i64_one);\n      } else if (c == CharCode._1) {\n        // value << 1 | 1\n        nextValue = i64_or(\n          i64_shl(value, i64_one),\n          i64_one\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt(value, nextValue)) {\n        // Overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Binary_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readFloat(): f64 {\n    // let text = this.source.text;\n    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\n    //   switch (text.charCodeAt(this.pos + 1)) {\n    //     case CharCode.X:\n    //     case CharCode.x: {\n    //       this.pos += 2;\n    //       return this.readHexFloat();\n    //     }\n    //   }\n    // }\n    return this.readDecimalFloat();\n  }\n\n  readDecimalFloat(): f64 {\n    let text = this.source.text;\n    let end = this.end;\n    let start = this.pos;\n    let sepCount = this.readDecimalFloatPartial(false);\n    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.Dot) {\n      ++this.pos;\n      sepCount += this.readDecimalFloatPartial();\n    }\n    if (this.pos < end) {\n      let c = text.charCodeAt(this.pos);\n      if ((c | 32) == CharCode.e) {\n        if (\n          ++this.pos < end &&\n          (c = text.charCodeAt(this.pos)) == CharCode.Minus || c == CharCode.Plus &&\n          isDecimal(text.charCodeAt(this.pos + 1))\n        ) {\n          ++this.pos;\n        }\n        sepCount += this.readDecimalFloatPartial();\n      }\n    }\n    let result = text.substring(start, this.pos);\n    if (sepCount) result = result.replaceAll(\"_\", \"\");\n    return parseFloat(result);\n  }\n\n  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */\n  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let start = pos;\n    let end = this.end;\n    let sepEnd = start;\n    let sepCount = 0;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n\n      if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n        ++sepCount;\n      } else if (!isDecimal(c)) {\n        break;\n      }\n      ++pos;\n    }\n\n    if (pos != start && sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n\n    this.pos = pos;\n    return sepCount;\n  }\n\n  readHexFloat(): f64 {\n    throw new Error(\"not implemented\"); // TBD\n  }\n\n  readHexadecimalEscape(remain: i32 = 2, startIfTaggedTemplate: i32 = -1): string {\n    let value = 0;\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    while (pos < end) {\n      let c = text.charCodeAt(pos++);\n      if (isDecimal(c)) {\n        value = (value << 4) + c - CharCode._0;\n      } else if (isHexBase(c)) {\n        value = (value << 4) + (c | 32) + (10 - CharCode.a);\n      } else if (~startIfTaggedTemplate) {\n        this.pos = --pos;\n        return text.substring(startIfTaggedTemplate, pos);\n      } else {\n        this.pos = pos;\n        this.error(\n          DiagnosticCode.Hexadecimal_digit_expected,\n          this.range(pos - 1, pos)\n        );\n        return \"\";\n      }\n      if (--remain == 0) break;\n    }\n    if (remain) { // invalid\n      this.pos = pos;\n      if (~startIfTaggedTemplate) {\n        return text.substring(startIfTaggedTemplate, pos);\n      }\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(pos)\n      );\n      return \"\";\n    }\n    this.pos = pos;\n    return String.fromCodePoint(value);\n  }\n\n  checkForIdentifierStartAfterNumericLiteral(): void {\n    // TODO: BigInt n\n    let pos = this.pos;\n    if (pos < this.end && isIdentifierStart(this.source.text.charCodeAt(pos))) {\n      this.error(\n        DiagnosticCode.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal,\n        this.range(pos)\n      );\n    }\n  }\n\n  readUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    return this.readHexadecimalEscape(4, startIfTaggedTemplate);\n  }\n\n  private readExtendedUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    let start = this.pos;\n    let value = this.readHexInteger();\n    let value32 = i64_low(value);\n    let invalid = false;\n\n    assert(!i64_high(value));\n    if (value32 > 0x10FFFF) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    let end = this.end;\n    let text = this.source.text;\n    if (this.pos >= end) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unexpected_end_of_text,\n          this.range(start, end)\n        );\n      }\n      invalid = true;\n    } else if (text.charCodeAt(this.pos) == CharCode.CloseBrace) {\n      ++this.pos;\n    } else {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unterminated_Unicode_escape_sequence,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    if (invalid) {\n      return ~startIfTaggedTemplate\n        ? text.substring(startIfTaggedTemplate, this.pos)\n        : \"\";\n    }\n    return String.fromCodePoint(value32);\n  }\n}\n\n/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */\nexport class State {\n  constructor(\n    /** Current position. */\n    public pos: i32,\n    /** Current token. */\n    public token: Token,\n    /** Current token's position. */\n    public tokenPos: i32\n  ) {}\n}\n\n// Reusable state object to reduce allocations\nlet reusableState: State | null = null;\n", "/**\n * @fileoverview A thin wrapper around Binaryen's C-API.\n *\n * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even\n * though it currently imports binaryen.js, none of the JS APIs it\n * provides are used.\n *\n * @license Apache-2.0\n */\n\nimport { BuiltinNames } from \"./builtins\";\nimport { CommonNames, Target } from \"./common\";\nimport {\n  isHighSurrogate,\n  isLowSurrogate,\n  combineSurrogates,\n  SURROGATE_HIGH,\n  SURROGATE_LOW\n} from \"./util\";\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\nimport {\n  ElementKind,\n  PropertyPrototype\n} from \"./program\";\nimport * as binaryen from \"./glue/binaryen\";\n\n/** A Binaryen-compatible index. */\nexport type Index = binaryen.Index;\n/** Reference to a Binaryen-compatible string. */\nexport type StringRef = binaryen.StringRef;\n/** Reference to a Binaryen module. */\nexport type ModuleRef = binaryen.ModuleRef;\n/** Reference to a Binaryen function. */\nexport type FunctionRef = binaryen.FunctionRef;\n/** Reference to a Binaryen expression. */\nexport type ExpressionRef = binaryen.ExpressionRef;\n/** Reference to a Binaryen global. */\nexport type GlobalRef = binaryen.GlobalRef;\n/** Reference to a Binaryen tag. */\nexport type TagRef = binaryen.TagRef;\n/** Reference to a Binaryen import. */\nexport type ImportRef = binaryen.ImportRef;\n/** Reference to a Binaryen export. */\nexport type ExportRef = binaryen.ExportRef;\n/** Reference to a Binaryen relooper. */\nexport type RelooperRef = binaryen.RelooperRef;\n/** Reference to a Binaryen relooper block. */\nexport type RelooperBlockRef = binaryen.RelooperBlockRef;\n\n// The following constants must be updated by running scripts/update-constants.\n// This is necessary because the functions are not yet callable with Binaryen\n// compiled to WebAssembly, requiring awaiting the ready promise first. Note\n// that this essentially fixes the compiler to specific versions of Binaryen\n// sometimes, because these constants can differ between Binaryen versions.\n\n/** Reference to a Binaryen type. */\nexport type TypeRef = binaryen.TypeRef;\nexport namespace TypeRef {\n  // special types\n  export const None: TypeRef = 0 /* _BinaryenTypeNone */;\n  export const Unreachable: TypeRef = 1 /* _BinaryenTypeUnreachable */;\n  // value types\n  export const I32: TypeRef = 2 /* _BinaryenTypeInt32 */;\n  export const I64: TypeRef = 3 /* _BinaryenTypeInt64 */;\n  export const F32: TypeRef = 4 /* _BinaryenTypeFloat32 */;\n  export const F64: TypeRef = 5 /* _BinaryenTypeFloat64 */;\n  export const V128: TypeRef = 6 /* _BinaryenTypeVec128 */;\n  // reference/gc types\n  export const Funcref = binaryen._BinaryenTypeFuncref();\n  export const Externref = binaryen._BinaryenTypeExternref();\n  export const Anyref = binaryen._BinaryenTypeAnyref();\n  export const Eqref = binaryen._BinaryenTypeEqref();\n  export const I31ref = binaryen._BinaryenTypeI31ref();\n  export const Dataref = binaryen._BinaryenTypeDataref();\n  export const Arrayref = binaryen._BinaryenTypeArrayref();\n  export const Stringref = binaryen._BinaryenTypeStringref();\n  export const StringviewWTF8 = binaryen._BinaryenTypeStringviewWTF8();\n  export const StringviewWTF16 = binaryen._BinaryenTypeStringviewWTF16();\n  export const StringviewIter = binaryen._BinaryenTypeStringviewIter();\n  export const Noneref = binaryen._BinaryenTypeNullref();\n  export const Nofuncref = binaryen._BinaryenTypeNullFuncref();\n  export const Noexternref = binaryen._BinaryenTypeNullExternref();\n}\n\n/** Reference to a Binaryen heap type. */\nexport type HeapTypeRef = binaryen.HeapTypeRef;\nexport namespace HeapTypeRef {\n\n  //        any                  extern      func\n  //         |                      |          |\n  //     __ eq __          ?     noextern    (...)\n  //    /    |   \\         |                   |\n  // i31  struct  array  string              nofunc\n  //  |      |      |      |\n  // none  (...)  (...)    ?\n  //         |      |\n  //        none   none\n  //\n  // where (...) represents the concrete subtypes\n\n  export const Extern: HeapTypeRef = 0 /* _BinaryenHeapTypeExt */;\n  export const Func: HeapTypeRef = 1 /* _BinaryenHeapTypeFunc */;\n  export const Any: HeapTypeRef = 2 /* _BinaryenHeapTypeAny */;\n  export const Eq: HeapTypeRef = 3 /* _BinaryenHeapTypeEq */;\n  export const I31: HeapTypeRef = 4 /* _BinaryenHeapTypeI31 */;\n  export const Data: HeapTypeRef = 5 /* _BinaryenHeapTypeData */;\n  export const Array: HeapTypeRef = 6 /* _BinaryenHeapTypeArray */;\n  export const String: HeapTypeRef = 7 /* _BinaryenHeapTypeString */;\n  export const StringviewWTF8: HeapTypeRef = 8 /* _BinaryenHeapTypeStringviewWTF8 */;\n  export const StringviewWTF16: HeapTypeRef = 9 /* _BinaryenHeapTypeStringviewWTF16 */;\n  export const StringviewIter: HeapTypeRef = 10 /* _BinaryenHeapTypeStringviewIter */;\n  export const None: HeapTypeRef = 11 /* _BinaryenHeapTypeNone */;\n  export const Noextern: HeapTypeRef = 12 /* _BinaryenHeapTypeNoext */;\n  export const Nofunc: HeapTypeRef = 13 /* _BinaryenHeapTypeNofunc */;\n\n  export function isBottom(ht: HeapTypeRef): bool {\n    return binaryen._BinaryenHeapTypeIsBottom(ht);\n  }\n\n  export function getBottom(ht: HeapTypeRef): HeapTypeRef {\n    return binaryen._BinaryenHeapTypeGetBottom(ht);\n  }\n\n  export function isSubtype(ht: HeapTypeRef, superHt: HeapTypeRef): bool {\n    return binaryen._BinaryenHeapTypeIsSubType(ht, superHt);\n  }\n}\n\n/** Packed array element respectively struct field types. */\nexport type PackedType = binaryen.PackedType;\nexport namespace PackedType {\n  export const NotPacked: PackedType = 0 /* _BinaryenPackedTypeNotPacked */;\n  export const I8: PackedType = 1 /* _BinaryenPackedTypeInt8 */;\n  export const I16: PackedType = 2 /* _BinaryenPackedTypeInt16 */;\n}\n\n/** Type builder error reasons. */\nexport type TypeBuilderErrorReason = binaryen.TypeBuilderErrorReason;\nexport namespace TypeBuilderErrorReason {\n  /** Indicates a cycle in the supertype relation. */\n  export const SelfSupertype: TypeBuilderErrorReason = 0 /* _TypeBuilderErrorReasonSelfSupertype */;\n  /** Indicates that the declared supertype of a type is invalid. */\n  export const InvalidSupertype: TypeBuilderErrorReason = 1 /* _TypeBuilderErrorReasonInvalidSupertype */;\n  /** Indicates that the declared supertype is an invalid forward reference. */\n  export const ForwardSupertypeReference: TypeBuilderErrorReason = 2 /* _TypeBuilderErrorReasonForwardSupertypeReference */;\n  /** Indicates that a child of a type is an invalid forward reference. */\n  export const ForwardChildReference: TypeBuilderErrorReason = 3 /* _TypeBuilderErrorReasonForwardChildReference */;\n  /** Converts a type builder error reason to a string. */\n  export function toString(reason: TypeBuilderErrorReason): string {\n    switch (reason) {\n      case SelfSupertype: return \"SelfSupertype\";\n      case InvalidSupertype: return \"InvalidSupertype\";\n      case ForwardSupertypeReference: return \"ForwardSupertypeReference\";\n      case ForwardChildReference: return \"ForwardChildReference\";\n    }\n    assert(false);\n    return \"\";\n  }\n}\n\n/** Type system constants. */\nexport type TypeSystem = binaryen.TypeSystem;\nexport namespace TypeSystem {\n  export const Equirecursive: TypeSystem = 0 /* _BinaryenTypeSystemEquirecursive */;\n  export const Nominal: TypeSystem = 1 /* _BinaryenTypeSystemNominal */;\n  export const Isorecursive: TypeSystem = 2 /* _BinaryenTypeSystemIsorecursive */;\n}\n\n/** Binaryen feature constants. */\nexport const enum FeatureFlags {\n  MVP = 0 /* _BinaryenFeatureMVP */,\n  Atomics = 1 /* _BinaryenFeatureAtomics */,\n  MutableGlobals = 2 /* _BinaryenFeatureMutableGlobals */,\n  TruncSat = 4 /* _BinaryenFeatureNontrappingFPToInt */,\n  SIMD = 8 /* _BinaryenFeatureSIMD128 */,\n  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,\n  SignExt = 32 /* _BinaryenFeatureSignExt */,\n  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,\n  TailCall = 128 /* _BinaryenFeatureTailCall */,\n  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,\n  MultiValue = 512 /* _BinaryenFeatureMultivalue */,\n  GC = 1024 /* _BinaryenFeatureGC */,\n  Memory64 = 2048 /* _BinaryenFeatureMemory64 */,\n  RelaxedSIMD = 8192 /* _BinaryenFeatureRelaxedSIMD */,\n  ExtendedConst = 16384 /* _BinaryenFeatureExtendedConst */,\n  Stringref = 32768 /* _BinaryenFeatureStrings */,\n  MultiMemory = 65536 /* _BinaryenFeatureMultiMemories */,\n  All = 126975 /* _BinaryenFeatureAll */\n}\n\n/** Binaryen expression id constants. */\nexport const enum ExpressionId {\n  Invalid = 0 /* _BinaryenInvalidId */,\n  Block = 1 /* _BinaryenBlockId */,\n  If = 2 /* _BinaryenIfId */,\n  Loop = 3 /* _BinaryenLoopId */,\n  Break = 4 /* _BinaryenBreakId */,\n  Switch = 5 /* _BinaryenSwitchId */,\n  Call = 6 /* _BinaryenCallId */,\n  CallIndirect = 7 /* _BinaryenCallIndirectId */,\n  LocalGet = 8 /* _BinaryenLocalGetId */,\n  LocalSet = 9 /* _BinaryenLocalSetId */,\n  GlobalGet = 10 /* _BinaryenGlobalGetId */,\n  GlobalSet = 11 /* _BinaryenGlobalSetId */,\n  Load = 12 /* _BinaryenLoadId */,\n  Store = 13 /* _BinaryenStoreId */,\n  Const = 14 /* _BinaryenConstId */,\n  Unary = 15 /* _BinaryenUnaryId */,\n  Binary = 16 /* _BinaryenBinaryId */,\n  Select = 17 /* _BinaryenSelectId */,\n  Drop = 18 /* _BinaryenDropId */,\n  Return = 19 /* _BinaryenReturnId */,\n  MemorySize = 20 /* _BinaryenMemorySizeId */,\n  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,\n  Nop = 22 /* _BinaryenNopId */,\n  Unreachable = 23 /* _BinaryenUnreachableId */,\n  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,\n  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,\n  AtomicWait = 26 /* _BinaryenAtomicWaitId */,\n  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,\n  AtomicFence = 28 /* _BinaryenAtomicFenceId */,\n  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,\n  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,\n  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,\n  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,\n  SIMDShift = 33 /* _BinaryenSIMDShiftId */,\n  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,\n  SIMDLoadStoreLane = 35 /* _BinaryenSIMDLoadStoreLaneId */,\n  MemoryInit = 36 /* _BinaryenMemoryInitId */,\n  DataDrop = 37 /* _BinaryenDataDropId */,\n  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,\n  MemoryFill = 39 /* _BinaryenMemoryFillId */,\n  Pop = 40 /* _BinaryenPopId */,\n  RefNull = 41 /* _BinaryenRefNullId */,\n  RefIs = 42 /* _BinaryenRefIsId */,\n  RefFunc = 43 /* _BinaryenRefFuncId */,\n  RefEq = 44 /* _BinaryenRefEqId */,\n  TableGet = 45 /* _BinaryenTableGetId */,\n  TableSet = 46 /* _BinaryenTableSetId */,\n  TableSize = 47 /* _BinaryenTableSizeId */,\n  TableGrow = 48 /* _BinaryenTableGrowId */,\n  Try = 49 /* _BinaryenTryId */,\n  Throw = 50 /* _BinaryenThrowId */,\n  Rethrow = 51 /* _BinaryenRethrowId */,\n  TupleMake = 52 /* _BinaryenTupleMakeId */,\n  TupleExtract = 53 /* _BinaryenTupleExtractId */,\n  I31New = 54 /* _BinaryenI31NewId */,\n  I31Get = 55 /* _BinaryenI31GetId */,\n  CallRef = 56 /* _BinaryenCallRefId */,\n  RefTest = 57 /* _BinaryenRefTestId */,\n  RefCast = 58 /* _BinaryenRefCastId */,\n  BrOn = 59 /* _BinaryenBrOnId */,\n  StructNew = 60 /* _BinaryenStructNewId */,\n  StructGet = 61 /* _BinaryenStructGetId */,\n  StructSet = 62 /* _BinaryenStructSetId */,\n  ArrayNew = 63 /* _BinaryenArrayNewId */,\n  ArrayInit = 64 /* _BinaryenArrayInitId */,\n  ArrayGet = 65 /* _BinaryenArrayGetId */,\n  ArraySet = 66 /* _BinaryenArraySetId */,\n  ArrayLen = 67 /* _BinaryenArrayLenId */,\n  ArrayCopy = 68 /* _BinaryenArrayCopyId */,\n  RefAs = 69 /* _BinaryenRefAsId */,\n  StringNew = 70 /* _BinaryenStringNewId */,\n  StringConst = 71 /* _BinaryenStringConstId */,\n  StringMeasure = 72 /* _BinaryenStringMeasureId */,\n  StringEncode = 73 /* _BinaryenStringEncodeId */,\n  StringConcat = 74 /* _BinaryenStringConcatId */,\n  StringEq = 75 /* _BinaryenStringEqId */,\n  StringAs = 76 /* _BinaryenStringAsId */,\n  StringWTF8Advance = 77 /* _BinaryenStringWTF8AdvanceId */,\n  StringWTF16Get = 78 /* _BinaryenStringWTF16GetId */,\n  StringIterNext = 79 /* _BinaryenStringIterNextId */,\n  StringIterMove = 80 /* _BinaryenStringIterMoveId */,\n  StringSliceWTF = 81 /* _BinaryenStringSliceWTFId */,\n  StringSliceIter = 82 /* _BinaryenStringSliceIterId */\n}\n\n/** Binaryen external kind constants. */\nexport const enum ExternalKind {\n  Function = 0 /* _BinaryenExternalFunction */,\n  Table = 1 /* _BinaryenExternalTable */,\n  Memory = 2 /* _BinaryenExternalMemory */,\n  Global = 3 /* _BinaryenExternalGlobal */,\n  Tag = 4 /* _BinaryenExternalTag */\n}\n\n/** Binaryen unary operation constants. */\nexport const enum UnaryOp {\n  /** i32.clz */\n  ClzI32 = 0 /* _BinaryenClzInt32 */,\n  /** i64.clz */\n  ClzI64 = 1 /* _BinaryenClzInt64 */,\n  /** i32.ctz */\n  CtzI32 = 2 /* _BinaryenCtzInt32 */,\n  /** i64.ctz */\n  CtzI64 = 3 /* _BinaryenCtzInt64 */,\n  /** i32.popcnt */\n  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,\n  /** i64.popcnt */\n  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,\n  /** f32.neg */\n  NegF32 = 6 /* _BinaryenNegFloat32 */,\n  /** f64.neg */\n  NegF64 = 7 /* _BinaryenNegFloat64 */,\n  /** f32.abs */\n  AbsF32 = 8 /* _BinaryenAbsFloat32 */,\n  /** f64.abs */\n  AbsF64 = 9 /* _BinaryenAbsFloat64 */,\n  /** f32.ceil */\n  CeilF32 = 10 /* _BinaryenCeilFloat32 */,\n  /** f64.ceil */\n  CeilF64 = 11 /* _BinaryenCeilFloat64 */,\n  /** f32.floor */\n  FloorF32 = 12 /* _BinaryenFloorFloat32 */,\n  /** f64.floor */\n  FloorF64 = 13 /* _BinaryenFloorFloat64 */,\n  /** f32.trunc */\n  TruncF32 = 14 /* _BinaryenTruncFloat32 */,\n  /** f64.trunc */\n  TruncF64 = 15 /* _BinaryenTruncFloat64 */,\n  /** f32.nearest */\n  NearestF32 = 16 /* _BinaryenNearestFloat32 */,\n  /** f64.nearest */\n  NearestF64 = 17 /* _BinaryenNearestFloat64 */,\n  /** f32.sqrt */\n  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,\n  /** f64.sqrt */\n  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,\n  /** i32.eqz */\n  EqzI32 = 20 /* _BinaryenEqZInt32 */,\n  /** i64.eqz */\n  EqzI64 = 21 /* _BinaryenEqZInt64 */,\n  /** i64.extend_i32_s */\n  ExtendI32ToI64 = 22 /* _BinaryenExtendSInt32 */,\n  /** i64.extend_i32_u */\n  ExtendU32ToU64 = 23 /* _BinaryenExtendUInt32 */,\n  /** i32.wrap_i64 */\n  WrapI64ToI32 = 24 /* _BinaryenWrapInt64 */,\n  /** i32.trunc_f32_s */\n  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,\n  /** i64.trunc_f32_s */\n  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,\n  /** i32.trunc_f32_u */\n  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,\n  /** i64.trunc_f32_u */\n  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,\n  /** i32.trunc_f64_s */\n  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,\n  /** i64.trunc_f64_s */\n  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,\n  /** i32.trunc_f64_u */\n  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,\n  /** i64.trunc_f64_u */\n  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,\n  /** i32.reinterpret_f32 */\n  ReinterpretF32ToI32 = 33 /* _BinaryenReinterpretFloat32 */,\n  /** i64.reinterpret_f64 */\n  ReinterpretF64ToI64 = 34 /* _BinaryenReinterpretFloat64 */,\n  /** f32.convert_i32_s */\n  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,\n  /** f64.convert_i32_s */\n  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,\n  /** f32.convert_i32_u */\n  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,\n  /** f64.convert_i32_u */\n  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,\n  /** f32.convert_i64_s */\n  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,\n  /** f64.convert_i64_s */\n  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,\n  /** f32.convert_i64_u */\n  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,\n  /** f64.convert_i64_u */\n  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,\n  /** f64.promote.f32 */\n  PromoteF32ToF64 = 43 /* _BinaryenPromoteFloat32 */,\n  /** f32.demote_f64 */\n  DemoteF64ToF32 = 44 /* _BinaryenDemoteFloat64 */,\n  /** f32.reinterpret_i32 */\n  ReinterpretI32ToF32 = 45 /* _BinaryenReinterpretInt32 */,\n  /** f64.reinterpret_i64 */\n  ReinterpretI64ToF64 = 46 /* _BinaryenReinterpretInt64 */,\n\n  // see: https://github.com/WebAssembly/sign-extension-ops\n\n  /** i32.extend8_s */\n  Extend8I32 = 47 /* _BinaryenExtendS8Int32 */,\n  /** i32.extend16_s */\n  Extend16I32 = 48 /* _BinaryenExtendS16Int32 */,\n  /** i64.extend8_s */\n  Extend8I64 = 49 /* _BinaryenExtendS8Int64 */,\n  /** i64.extend16_s */\n  Extend16I64 = 50 /* _BinaryenExtendS16Int64 */,\n  /** i64.extend32_s (i64 in, i64 out) */\n  Extend32I64 = 51 /* _BinaryenExtendS32Int64 */,\n\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n\n  /** i32.trunc_sat_f32_s */\n  TruncSatF32ToI32 = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,\n  /** i32.trunc_sat_f32_u */\n  TruncSatF32ToU32 = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,\n  /** i32.trunc_sat_f64_s */\n  TruncSatF64ToI32 = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,\n  /** i32.trunc_sat_f64_u */\n  TruncSatF64ToU32 = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,\n  /** i64.trunc_sat_f32_s */\n  TruncSatF32ToI64 = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,\n  /** i64.trunc_sat_f32_u */\n  TruncSatF32ToU64 = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,\n  /** i64.trunc_sat_f64_s */\n  TruncSatF64ToI64 = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,\n  /** i64.trunc_sat_f64_u */\n  TruncSatF64ToU64 = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.splat */\n  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,\n  /** i16x8.splat */\n  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,\n  /** i32x4.splat */\n  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,\n  /** i64x2.splat */\n  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,\n  /** f32x4.splat */\n  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,\n  /** f64x2.splat */\n  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,\n  /** v128.not */\n  NotV128 = 66 /* _BinaryenNotVec128 */,\n  /** v128.any_true */\n  AnyTrueV128 = 67 /* _BinaryenAnyTrueVec128 */,\n  /** i8x16.abs */\n  AbsI8x16 = 68 /* _BinaryenAbsVecI8x16 */,\n  /** i8x16.neg */\n  NegI8x16 = 69 /* _BinaryenNegVecI8x16 */,\n  /** i8x16.all_true */\n  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,\n  /** i8x16.bitmask */\n  BitmaskI8x16 = 71 /* _BinaryenBitmaskVecI8x16 */,\n  /** i8x16.popcnt */\n  PopcntI8x16 = 72 /* _BinaryenPopcntVecI8x16 */,\n  /** i16x8.abs */\n  AbsI16x8 = 73 /* _BinaryenAbsVecI16x8 */,\n  /** i16x8.neg */\n  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,\n  /** i16x8.all_true */\n  AllTrueI16x8 = 75 /* _BinaryenAllTrueVecI16x8 */,\n  /** i16x8.bitmask */\n  BitmaskI16x8 = 76 /* _BinaryenBitmaskVecI16x8 */,\n  /** i32x4.abs */\n  AbsI32x4 = 77 /* _BinaryenAbsVecI32x4 */,\n  /** i32x4.neg */\n  NegI32x4 = 78 /* _BinaryenNegVecI32x4 */,\n  /** i32x4.all_true */\n  AllTrueI32x4 = 79 /* _BinaryenAllTrueVecI32x4 */,\n  /** i32x4.bitmask */\n  BitmaskI32x4 = 80 /* _BinaryenBitmaskVecI32x4 */,\n  /** i64x2.abs */\n  AbsI64x2 = 81 /* _BinaryenAbsVecI64x2 */,\n  /** i64x2.neg */\n  NegI64x2 = 82 /* _BinaryenNegVecI64x2 */,\n  /** i64x2.all_true */\n  AllTrueI64x2 = 83 /* _BinaryenAllTrueVecI64x2 */,\n  /** i64x2.bitmask */\n  BitmaskI64x2 = 84 /* _BinaryenBitmaskVecI64x2 */,\n  /** f32x4.abs */\n  AbsF32x4 = 85 /* _BinaryenAbsVecF32x4 */,\n  /** f32x4.neg */\n  NegF32x4 = 86 /* _BinaryenNegVecF32x4 */,\n  /** f32x4.sqrt */\n  SqrtF32x4 = 87 /* _BinaryenSqrtVecF32x4 */,\n  /** f32x4.ceil */\n  CeilF32x4 = 88 /* _BinaryenCeilVecF32x4 */,\n  /** f32x4.floor */\n  FloorF32x4 = 89 /* _BinaryenFloorVecF32x4 */,\n  /** f32x4.trunc */\n  TruncF32x4 = 90 /* BinaryenTruncVecF32x4 */,\n  /** f32x4.nearest */\n  NearestF32x4 = 91 /* BinaryenNearestVecF32x4 */,\n  /** f64x2.abs */\n  AbsF64x2 = 92 /* _BinaryenAbsVecF64x2 */,\n  /** f64x2.neg */\n  NegF64x2 = 93 /* _BinaryenNegVecF64x2 */,\n  /** f64x2.sqrt */\n  SqrtF64x2 = 94 /* _BinaryenSqrtVecF64x2 */,\n  /** f64x2.ceil */\n  CeilF64x2 = 95 /* _BinaryenCeilVecF64x2 */,\n  /** f64x2.floor */\n  FloorF64x2 = 96 /* _BinaryenFloorVecF64x2 */,\n  /** f64x2.trunc */\n  TruncF64x2 = 97 /* _BinaryenTruncVecF64x2 */,\n  /** f64x2.nearest */\n  NearestF64x2 = 98 /* _BinaryenNearestVecF64x2 */,\n  /** i16x8.extadd_pairwise_i8x16_s */\n  ExtaddPairwiseI8x16ToI16x8 = 99 /* _BinaryenExtAddPairwiseSVecI8x16ToI16x8 */,\n  /** i16x8.extadd_pairwise.i8x16_u */\n  ExtaddPairwiseU8x16ToU16x8 = 100 /* _BinaryenExtAddPairwiseUVecI8x16ToI16x8 */,\n  /** i32x4.extadd_pairwise.i16x8_s */\n  ExtaddPairwiseI16x8ToI32x4 = 101 /* _BinaryenExtAddPairwiseSVecI16x8ToI32x4 */,\n  /** i32x4.extadd_pairwise.i64x8_u */\n  ExtaddPairwiseU16x8ToU32x4 = 102 /* _BinaryenExtAddPairwiseUVecI16x8ToI32x4 */,\n  /** i32x4.trunc_sat_f32x4_s */\n  TruncSatF32x4ToI32x4 = 103 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,\n  /** i32x4.trunc_sat_f32x4_u */\n  TruncSatF32x4ToU32x4 = 104 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertI32x4ToF32x4 = 105 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertU32x4ToF32x4 = 106 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,\n  /** i16x8.extend_low_i8x16_s */\n  ExtendLowI8x16ToI16x8 = 107 /* _BinaryenExtendLowSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_s */\n  ExtendHighI8x16ToI16x8 = 108 /* _BinaryenExtendHighSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_low_i8x16_u */\n  ExtendLowU8x16ToU16x8 = 109 /* _BinaryenExtendLowUVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_u */\n  ExtendHighU8x16ToU16x8 = 110 /* _BinaryenExtendHighUVecI8x16ToVecI16x8 */,\n  /** i32x4.extend_low_i16x8_s */\n  ExtendLowI16x8ToI32x4 = 111 /* _BinaryenExtendLowSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_s */\n  ExtendHighI16x8ToI32x4 = 112 /* _BinaryenExtendHighSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_low_i16x8_u */\n  ExtendLowU16x8ToU32x4 = 113 /* _BinaryenExtendLowUVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_u */\n  ExtendHighU16x8ToU32x4 = 114 /* _BinaryenExtendHighUVecI16x8ToVecI32x4 */,\n  /** i64x2.extend_low_i32x4_s */\n  ExtendLowI32x4ToI64x2 = 115 /* _BinaryenExtendLowSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_s */\n  ExtendHighI32x4ToI64x2 = 116 /* _BinaryenExtendHighSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_low_i32x4_u */\n  ExtendLowU32x4ToU64x2 = 117 /* _BinaryenExtendLowUVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_u */\n  ExtendHighU32x4ToU64x2 = 118 /* _BinaryenExtendHighUVecI32x4ToVecI64x2 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertLowI32x4ToF64x2 = 119 /* _BinaryenConvertLowSVecI32x4ToVecF64x2 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertLowU32x4ToF64x2 = 120 /* _BinaryenConvertLowUVecI32x4ToVecF64x2 */,\n  /** i32x4.trunc_sat_f64x2_s_zero */\n  TruncSatF64x2ToI32x4Zero = 121 /* _BinaryenTruncSatZeroSVecF64x2ToVecI32x4 */,\n  /** i32x4.trunc_sat_f64x2_u_zero */\n  TruncSatF64x2ToU32x4Zero = 122 /* _BinaryenTruncSatZeroUVecF64x2ToVecI32x4 */,\n  /** f32x4.demote_f64x2_zero */\n  DemoteZeroF64x2ToF32x4 = 123 /* _BinaryenDemoteZeroVecF64x2ToVecF32x4 */,\n  /** f64x2.promote_low_f32x4 */\n  PromoteLowF32x4ToF64x2 = 124 /* _BinaryenPromoteLowVecF32x4ToVecF64x2 */,\n\n  _last = PromoteLowF32x4ToF64x2,\n\n  // Target dependent\n\n  /** i32.clz or i64.clz, depending on target word size */\n  ClzSize,\n  /** i32.ctz or i64.ctz, depending on target word size */\n  CtzSize,\n  /** i32.popcnt or i64.popcnt, depending on target word size */\n  PopcntSize,\n  /** i32.eqz or i64.eqz, depending on target word size */\n  EqzSize\n}\n\n/** Binaryen binary operation constants. */\nexport const enum BinaryOp {\n  /** i32.add */\n  AddI32 = 0 /* _BinaryenAddInt32 */,\n  /** i32.sub */\n  SubI32 = 1 /* _BinaryenSubInt32 */,\n  /** i32.mul */\n  MulI32 = 2 /* _BinaryenMulInt32 */,\n  /** i32.div_s */\n  DivI32 = 3 /* _BinaryenDivSInt32 */,\n  /** i32.div_u */\n  DivU32 = 4 /* _BinaryenDivUInt32 */,\n  /** i32.rem_s */\n  RemI32 = 5 /* _BinaryenRemSInt32 */,\n  /** i32.rem_u */\n  RemU32 = 6 /* _BinaryenRemUInt32 */,\n  /** i32.and */\n  AndI32 = 7 /* _BinaryenAndInt32 */,\n  /** i32.or */\n  OrI32 = 8 /* _BinaryenOrInt32 */,\n  /** i32.xor */\n  XorI32 = 9 /* _BinaryenXorInt32 */,\n  /** i32.shl */\n  ShlI32 = 10 /* _BinaryenShlInt32 */,\n  /** i32.shr_s */\n  ShrI32 = 11 /* _BinaryenShrSInt32 */,\n  /** i32.shr_u */\n  ShrU32 = 12 /* _BinaryenShrUInt32 */,\n  /** i32.rotl */\n  RotlI32 = 13 /* _BinaryenRotLInt32 */,\n  /** i32.rotr */\n  RotrI32 = 14 /* _BinaryenRotRInt32 */,\n  /** i32.eq */\n  EqI32 = 15 /* _BinaryenEqInt32 */,\n  /** i32.ne */\n  NeI32 = 16 /* _BinaryenNeInt32 */,\n  /** i32.lt_s */\n  LtI32 = 17 /* _BinaryenLtSInt32 */,\n  /** i32.lt_u */\n  LtU32 = 18 /* _BinaryenLtUInt32 */,\n  /** i32.le_s */\n  LeI32 = 19 /* _BinaryenLeSInt32 */,\n  /** i32.le_u */\n  LeU32 = 20 /* _BinaryenLeUInt32 */,\n  /** i32.gt_s */\n  GtI32 = 21 /* _BinaryenGtSInt32 */,\n  /** i32.gt_u */\n  GtU32 = 22 /* _BinaryenGtUInt32 */,\n  /** i32.ge_s */\n  GeI32 = 23 /* _BinaryenGeSInt32 */,\n  /** i32.ge_u */\n  GeU32 = 24 /* _BinaryenGeUInt32 */,\n  /** i64.add */\n  AddI64 = 25 /* _BinaryenAddInt64 */,\n  /** i64.sub */\n  SubI64 = 26 /* _BinaryenSubInt64 */,\n  /** i64.mul */\n  MulI64 = 27 /* _BinaryenMulInt64 */,\n  /** i64.div_s */\n  DivI64 = 28 /* _BinaryenDivSInt64 */,\n  /** i64.div_u */\n  DivU64 = 29 /* _BinaryenDivUInt64 */,\n  /** i64.rem_s */\n  RemI64 = 30 /* _BinaryenRemSInt64 */,\n  /** i64.rem_u */\n  RemU64 = 31 /* _BinaryenRemUInt64 */,\n  /** i64.and */\n  AndI64 = 32 /* _BinaryenAndInt64 */,\n  /** i64.or */\n  OrI64 = 33 /* _BinaryenOrInt64 */,\n  /** i64.xor */\n  XorI64 = 34 /* _BinaryenXorInt64 */,\n  /** i64.shl */\n  ShlI64 = 35 /* _BinaryenShlInt64 */,\n  /** i64.shr_s */\n  ShrI64 = 36 /* _BinaryenShrSInt64 */,\n  /** i64.shr_u */\n  ShrU64 = 37 /* _BinaryenShrUInt64 */,\n  /** i64.rotl */\n  RotlI64 = 38 /* _BinaryenRotLInt64 */,\n  /** i64.rotr */\n  RotrI64 = 39 /* _BinaryenRotRInt64 */,\n  /** i64.eq */\n  EqI64 = 40 /* _BinaryenEqInt64 */,\n  /** i64.ne */\n  NeI64 = 41 /* _BinaryenNeInt64 */,\n  /** i64.lt_s */\n  LtI64 = 42 /* _BinaryenLtSInt64 */,\n  /** i64.lt_u */\n  LtU64 = 43 /* _BinaryenLtUInt64 */,\n  /** i64.le_s */\n  LeI64 = 44 /* _BinaryenLeSInt64 */,\n  /** i64.le_u */\n  LeU64 = 45 /* _BinaryenLeUInt64 */,\n  /** i64.gt_s */\n  GtI64 = 46 /* _BinaryenGtSInt64 */,\n  /** i64.gt_u */\n  GtU64 = 47 /* _BinaryenGtUInt64 */,\n  /** i64.ge_s */\n  GeI64 = 48 /* _BinaryenGeSInt64 */,\n  /** i64.ge_u */\n  GeU64 = 49 /* _BinaryenGeUInt64 */,\n  /** f32.add */\n  AddF32 = 50 /* _BinaryenAddFloat32 */,\n  /** f32.sub */\n  SubF32 = 51 /* _BinaryenSubFloat32 */,\n  /** f32.mul */\n  MulF32 = 52 /* _BinaryenMulFloat32 */,\n  /** f32.div */\n  DivF32 = 53 /* _BinaryenDivFloat32 */,\n  /** f32.copysign */\n  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,\n  /** f32.min */\n  MinF32 = 55 /* _BinaryenMinFloat32 */,\n  /** f32.max */\n  MaxF32 = 56 /* _BinaryenMaxFloat32 */,\n  /** f32.eq */\n  EqF32 = 57 /* _BinaryenEqFloat32 */,\n  /** f32.ne */\n  NeF32 = 58 /* _BinaryenNeFloat32 */,\n  /** f32.lt */\n  LtF32 = 59 /* _BinaryenLtFloat32 */,\n  /** f32.le */\n  LeF32 = 60 /* _BinaryenLeFloat32 */,\n  /** f32.gt */\n  GtF32 = 61 /* _BinaryenGtFloat32 */,\n  /** f32.ge */\n  GeF32 = 62 /* _BinaryenGeFloat32 */,\n  /** f64.add */\n  AddF64 = 63 /* _BinaryenAddFloat64 */,\n  /** f64.sub */\n  SubF64 = 64 /* _BinaryenSubFloat64 */,\n  /** f64.mul */\n  MulF64 = 65 /* _BinaryenMulFloat64 */,\n  /** f64.div */\n  DivF64 = 66 /* _BinaryenDivFloat64 */,\n  /** f64.copysign */\n  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,\n  /** f64.min */\n  MinF64 = 68 /* _BinaryenMinFloat64 */,\n  /** f64.max */\n  MaxF64 = 69 /* _BinaryenMaxFloat64 */,\n  /** f64.eq */\n  EqF64 = 70 /* _BinaryenEqFloat64 */,\n  /** f64.ne */\n  NeF64 = 71 /* _BinaryenNeFloat64 */,\n  /** f64.lt */\n  LtF64 = 72 /* _BinaryenLtFloat64 */,\n  /** f64.le */\n  LeF64 = 73 /* _BinaryenLeFloat64 */,\n  /** f64.gt */\n  GtF64 = 74 /* _BinaryenGtFloat64 */,\n  /** f64.ge */\n  GeF64 = 75 /* _BinaryenGeFloat64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.eq */\n  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,\n  /** i8x16.he */\n  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,\n  /** i8x16.lt_s */\n  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,\n  /** i8x16.lt_u */\n  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,\n  /** i8x16.gt_s */\n  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,\n  /** i8x16.gt_u */\n  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,\n  /** i8x16.le_s */\n  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,\n  /** i8x16.le_u */\n  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,\n  /** i8x16.ge_s */\n  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,\n  /** i8x16.ge_u */\n  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,\n  /** i16x8.eq */\n  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,\n  /** i16x8.ne */\n  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,\n  /** i16x8.lt_s */\n  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,\n  /** i16x8.lt_u */\n  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,\n  /** i16x8.gt_s */\n  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,\n  /** i16x8.gt_u */\n  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,\n  /** i16x8.le_s */\n  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,\n  /** i16x8.le_u */\n  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,\n  /** i16x8.ge_s */\n  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,\n  /** i16x8.ge_u */\n  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,\n  /** i32x4.eq */\n  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,\n  /** i32x4.ne */\n  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,\n  /** i32x4.lt_s */\n  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,\n  /** i32x4.lt_u */\n  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,\n  /** i32x4.gt_s */\n  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,\n  /** i32x4.gt_u */\n  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,\n  /** i32x4.le_s */\n  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,\n  /** i32x4.le_u */\n  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,\n  /** i32x4.ge_s */\n  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,\n  /** i32x4.ge_u */\n  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,\n  /** i64x2.eq */\n  EqI64x2 = 106 /* _BinaryenEqVecI64x2 */,\n  /** i64x2.ne */\n  NeI64x2 = 107 /* _BinaryenNeVecI64x2 */,\n  /** i64x2.lt_s */\n  LtI64x2 = 108 /* _BinaryenLtSVecI64x2 */,\n  /** i64x2.gt_s */\n  GtI64x2 = 109 /* _BinaryenGtSVecI64x2 */,\n  /** i64x2.le_s */\n  LeI64x2 = 110 /* _BinaryenLeSVecI64x2 */,\n  /** i64x2.ge_s */\n  GeI64x2 = 111 /* _BinaryenGeSVecI64x2 */,\n  /** f32x4.eq */\n  EqF32x4 = 112 /* _BinaryenEqVecF32x4 */,\n  /** f32x4.ne */\n  NeF32x4 = 113 /* _BinaryenNeVecF32x4 */,\n  /** f32x4.lt */\n  LtF32x4 = 114 /* _BinaryenLtVecF32x4 */,\n  /** f32x4.gt */\n  GtF32x4 = 115 /* _BinaryenGtVecF32x4 */,\n  /** f32x4.le */\n  LeF32x4 = 116 /* _BinaryenLeVecF32x4 */,\n  /** f32x4.ge */\n  GeF32x4 = 117 /* _BinaryenGeVecF32x4 */,\n  /** f64x2.eq */\n  EqF64x2 = 118 /* _BinaryenEqVecF64x2 */,\n  /** f64x2.ne */\n  NeF64x2 = 119 /* _BinaryenNeVecF64x2 */,\n  /** f64x2.lt */\n  LtF64x2 = 120 /* _BinaryenLtVecF64x2 */,\n  /** f64x2.gt */\n  GtF64x2 = 121 /* _BinaryenGtVecF64x2 */,\n  /** f64x2.le */\n  LeF64x2 = 122 /* _BinaryenLeVecF64x2 */,\n  /** f64x2.ge */\n  GeF64x2 = 123 /* _BinaryenGeVecF64x2 */,\n  /** v128.and */\n  AndV128 = 124 /* _BinaryenAndVec128 */,\n  /** v128.or */\n  OrV128 = 125 /* _BinaryenOrVec128 */,\n  /** v128.xor */\n  XorV128 = 126 /* _BinaryenXorVec128 */,\n  /** v128.andnot */\n  AndnotV128 = 127 /* _BinaryenAndNotVec128 */,\n  /** i8x16.add */\n  AddI8x16 = 128 /* _BinaryenAddVecI8x16 */,\n  /** i8x16.add_sat_s */\n  AddSatI8x16 = 129 /* _BinaryenAddSatSVecI8x16 */,\n  /** i8x16.add_sat_u */\n  AddSatU8x16 = 130 /* _BinaryenAddSatUVecI8x16 */,\n  /** i8x16.sub */\n  SubI8x16 = 131 /* _BinaryenSubVecI8x16 */,\n  /** i8x16.sub_sat_s */\n  SubSatI8x16 = 132 /* _BinaryenSubSatSVecI8x16 */,\n  /** i8x16.sub_sat_u */\n  SubSatU8x16 = 133 /* _BinaryenSubSatUVecI8x16 */,\n  /** i8x16.min_s */\n  MinI8x16 = 134 /* _BinaryenMinSVecI8x16 */,\n  /** i8x16.min_u */\n  MinU8x16 = 135 /* _BinaryenMinUVecI8x16 */,\n  /** i8x16.max_s */\n  MaxI8x16 = 136 /* _BinaryenMaxSVecI8x16 */,\n  /** i8x16.max_u */\n  MaxU8x16 = 137 /* _BinaryenMaxUVecI8x16 */,\n  /** i8x16.avgr_u */\n  AvgrU8x16 = 138 /* _BinaryenAvgrUVecI8x16 */,\n  /** i16x8.add */\n  AddI16x8 = 139 /* _BinaryenAddVecI16x8 */,\n  /** i16x8.add_sat_s */\n  AddSatI16x8 = 140 /* _BinaryenAddSatSVecI16x8 */,\n  /** i16x8.add_sat_u */\n  AddSatU16x8 = 141 /* _BinaryenAddSatUVecI16x8 */,\n  /** i16x8.sub */\n  SubI16x8 = 142 /* _BinaryenSubVecI16x8 */,\n  /** i16x8.sub_sat_s */\n  SubSatI16x8 = 143 /* _BinaryenSubSatSVecI16x8 */,\n  /** i16x8.sub_sat_u */\n  SubSatU16x8 = 144 /* _BinaryenSubSatUVecI16x8 */,\n  /** i16x8.mul */\n  MulI16x8 = 145 /* _BinaryenMulVecI16x8 */,\n  /** i16x8.min_s */\n  MinI16x8 = 146 /* _BinaryenMinSVecI16x8 */,\n  /** i16x8.min_u */\n  MinU16x8 = 147 /* _BinaryenMinUVecI16x8 */,\n  /** i16x8.max_s */\n  MaxI16x8 = 148 /* _BinaryenMaxSVecI16x8 */,\n  /** i16x8.max_u */\n  MaxU16x8 = 149 /* _BinaryenMaxUVecI16x8 */,\n  /** i16x8.avgr_u */\n  AvgrU16x8 = 150 /* _BinaryenAvgrUVecI16x8 */,\n  /** i16x8.q15mulr_sat_s */\n  Q15mulrSatI16x8 = 151 /* _BinaryenQ15MulrSatSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_s */\n  ExtmulLowI16x8 = 152 /* _BinaryenExtMulLowSVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_s */\n  ExtmulHighI16x8 = 153 /* _BinaryenExtMulHighSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_u */\n  ExtmulLowU16x8 = 154 /* _BinaryenExtMulLowUVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_u */\n  ExtmulHighU16x8 = 155 /* _BinaryenExtMulHighUVecI16x8 */,\n  /** i32x4.add */\n  AddI32x4 = 156 /* _BinaryenAddVecI32x4 */,\n  /** i32x4.sub */\n  SubI32x4 = 157 /* _BinaryenSubVecI32x4 */,\n  /** i32x4.mul */\n  MulI32x4 = 158 /* _BinaryenMulVecI32x4 */,\n  /** i32x4.min_s */\n  MinI32x4 = 159 /* _BinaryenMinSVecI32x4 */,\n  /** i32x4.min_u */\n  MinU32x4 = 160 /* _BinaryenMinUVecI32x4 */,\n  /** i32x4.max_s */\n  MaxI32x4 = 161 /* _BinaryenMaxSVecI32x4 */,\n  /** i32x4.max_u */\n  MaxU32x4 = 162 /* _BinaryenMaxUVecI32x4 */,\n  /** i32x4.dot_i16x8_s */\n  DotI16x8 = 163 /* _BinaryenDotSVecI16x8ToVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_s */\n  ExtmulLowI32x4 = 164 /* _BinaryenExtMulLowSVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_s */\n  ExtmulHighI32x4 = 165 /* _BinaryenExtMulHighSVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_u */\n  ExtmulLowU32x4 = 166 /* _BinaryenExtMulLowUVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_u */\n  ExtmulHighU32x4 = 167 /* _BinaryenExtMulHighUVecI32x4 */,\n  /** i64x2.add */\n  AddI64x2 = 168 /* _BinaryenAddVecI64x2 */,\n  /** i64x2.sub */\n  SubI64x2 = 169 /* _BinaryenSubVecI64x2 */,\n  /** i64x2.mul */\n  MulI64x2 = 170 /* _BinaryenMulVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_s */\n  ExtmulLowI64x2 = 171 /* _BinaryenExtMulLowSVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_s */\n  ExtmulHighI64x2 = 172 /* _BinaryenExtMulHighSVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_u */\n  ExtmulLowU64x2 = 173 /* _BinaryenExtMulLowUVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_u */\n  ExtmulHighU64x2 = 174 /* _BinaryenExtMulHighUVecI64x2 */,\n  /** f32x4.add */\n  AddF32x4 = 175 /* _BinaryenAddVecF32x4 */,\n  /** f32x4.sub */\n  SubF32x4 = 176 /* _BinaryenSubVecF32x4 */,\n  /** f32x4.mul */\n  MulF32x4 = 177 /* _BinaryenMulVecF32x4 */,\n  /** f32x4.div */\n  DivF32x4 = 178 /* _BinaryenDivVecF32x4 */,\n  /** f32x4.min */\n  MinF32x4 = 179 /* _BinaryenMinVecF32x4 */,\n  /** f32x4.max */\n  MaxF32x4 = 180 /* _BinaryenMaxVecF32x4 */,\n  /** f32x4.pmin */\n  PminF32x4 = 181 /* _BinaryenPMinVecF32x4 */,\n  /** f32x4.pmax */\n  PmaxF32x4 = 182 /* _BinaryenPMaxVecF32x4 */,\n  /** f64x2.add */\n  AddF64x2 = 183 /* _BinaryenAddVecF64x2 */,\n  /** f64x2.sub */\n  SubF64x2 = 184 /* _BinaryenSubVecF64x2 */,\n  /** f64x2.mul */\n  MulF64x2 = 185 /* _BinaryenMulVecF64x2 */,\n  /** f64x2.div */\n  DivF64x2 = 186 /* _BinaryenDivVecF64x2 */,\n  /** f64x2.min */\n  MinF64x2 = 187 /* _BinaryenMinVecF64x2 */,\n  /** f64x2.max */\n  MaxF64x2 = 188 /* _BinaryenMaxVecF64x2 */,\n  /** f64x2.pmin */\n  PminF64x2 = 189 /* _BinaryenPMinVecF64x2 */,\n  /** f64x2.pmax */\n  PmaxF64x2 = 190 /* _BinaryenPMaxVecF64x2 */,\n  /** i8x16.narrow_i16x8_s */\n  NarrowI16x8ToI8x16 = 191 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,\n  /** i8x16.narrow_i16x8_u */\n  NarrowU16x8ToU8x16 = 192 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,\n  /** i16x8.narrow_i32x4_s */\n  NarrowI32x4ToI16x8 = 193 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,\n  /** i16x8.narrow_i32x4_u */\n  NarrowU32x4ToU16x8 = 194 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,\n  /** i8x16.swizzle */\n  SwizzleI8x16 = 195 /* _BinaryenSwizzleVecI8x16 */,\n\n  _last = SwizzleI8x16,\n\n  // Target dependent\n\n  /** i32.add or i64.add, depending on target word size */\n  AddSize,\n  /** i32.sub or i64.sub, depending on target word size */\n  SubSize,\n  /** i32.mul or i64.mul, depending on target word size */\n  MulSize,\n  /** i32.div_s or i64.div_s, depending on target word size */\n  DivISize,\n  /** i32.div_u or i64.div_u, depending on target word size */\n  DivUSize,\n  /** i32.rem_s or i64.rem_s, depending on target word size */\n  RemISize,\n  /** i32.rem_u or i64.rem_u, depending on target word size */\n  RemUSize,\n  /** i32.and or i64.and, depending on target word size */\n  AndSize,\n  /** i32.or or i64.or, depending on target word size */\n  OrSize,\n  /** i32.xor or i64.xor, depending on target word size */\n  XorSize,\n  /** i32.shl or i64.shl, depending on target word size */\n  ShlSize,\n  /** i32.shr_s or i64.shr_s, depending on target word size */\n  ShrISize,\n  /** i32.shr_u or i64.shr_u, depending on target word size */\n  ShrUSize,\n  /** i32.rotl or i64.rotl, depending on target word size */\n  RotlSize,\n  /** i32.rotr or i64.rotr, depending on target word size */\n  RotrSize,\n  /** i32.eq or i64.eq, depending on target word size */\n  EqSize,\n  /** i32.ne or i64.ne, depending on target word size */\n  NeSize,\n  /** i32.lt_s or i64.lt_s, depending on target word size */\n  LtISize,\n  /** i32.lt_u or i64.lt_u, depending on target word size */\n  LtUSize,\n  /** i32.le_s or i64.le_s, depending on target word size */\n  LeISize,\n  /** i32.le_u or i64.le_u, depending on target word size */\n  LeUSize,\n  /** i32.gt_s or i64.gt_s, depending on target word size */\n  GtISize,\n  /** i32.gt_u or i64.gt_u, depending on target word size */\n  GtUSize,\n  /** i32.ge_s or i64.ge_s, depending on target word size */\n  GeISize,\n  /** i32.ge_u or i64.ge_u, depending on target word size */\n  GeUSize\n}\n\n/** Binaryen atomic read-modify-write operation constants. */\nexport const enum AtomicRMWOp {\n  /** i32.atomic.rmw.add, i32.atomic.rmw8.add_u, i32.atomic.rmw16.add_u, i64.atomic.rmw.add, i64.atomic.rmw8.add_u, i64.atomic.rmw16.add_u, i64.atomic.rmw32.add_u */\n  Add = 0 /* _BinaryenAtomicRMWAdd */,\n  /** i32.atomic.rmw.sub, i32.atomic.rmw8.sub_u, i32.atomic.rmw16.sub_u, i64.atomic.rmw.sub, i64.atomic.rmw8.sub_u, i64.atomic.rmw16.sub_u, i64.atomic.rmw32.sub_u */\n  Sub = 1 /* _BinaryenAtomicRMWSub */,\n  /** i32.atomic.rmw.and, i32.atomic.rmw8.and_u, i32.atomic.rmw16.and_u, i64.atomic.rmw.and, i64.atomic.rmw8.and_u, i64.atomic.rmw16.and_u, i64.atomic.rmw32.and_u */\n  And = 2 /* _BinaryenAtomicRMWAnd */,\n  /** i32.atomic.rmw.or, i32.atomic.rmw8.or_u, i32.atomic.rmw16.or_u, i64.atomic.rmw.or, i64.atomic.rmw8.or_u, i64.atomic.rmw16.or_u, i64.atomic.rmw32.or_u */\n  Or = 3 /* _BinaryenAtomicRMWOr */,\n  /** i32.atomic.rmw.xor, i32.atomic.rmw8.xor_u, i32.atomic.rmw16.xor_u, i64.atomic.rmw.xor, i64.atomic.rmw8.xor_u, i64.atomic.rmw16.xor_u, i64.atomic.rmw32.xor_u */\n  Xor = 4 /* _BinaryenAtomicRMWXor */,\n  /** i32.atomic.rmw.xchg, i32.atomic.rmw8.xchg_u, i32.atomic.rmw16.xchg_u, i64.atomic.rmw.xchg, i64.atomic.rmw8.xchg_u, i64.atomic.rmw16.xchg_u, i64.atomic.rmw32.xchg_u */\n  Xchg = 5 /* _BinaryenAtomicRMWXchg */\n}\n\n/** Binaryen SIMD extract operation constants. */\nexport const enum SIMDExtractOp {\n  /** i8x16.extract_lane_s */\n  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,\n  /** i8x16.extract_lane_u */\n  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,\n  /** i16x8.extract_lane_s */\n  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,\n  /** i16x8.extract_lane_u */\n  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,\n  /** i32x4.extract_lane_s */\n  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,\n  /** i32x4.extract_lane_u */\n  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,\n  /** i64x2.extract_lane_s */\n  ExtractLaneF32x4 = 6 /* _BinaryenExtractLaneVecF32x4 */,\n  /** i64x2.extract_lane_u */\n  ExtractLaneF64x2 = 7 /* _BinaryenExtractLaneVecF64x2 */,\n}\n\n/** Binaryen SIMD replace operation constants. */\nexport const enum SIMDReplaceOp {\n  /** i8x16.replace_lane */\n  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,\n  /** i16x8.replace_lane */\n  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,\n  /** i32x4.replace_lane */\n  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,\n  /** i64x2.replace_lane */\n  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,\n  /** f32x4.replace_lane */\n  ReplaceLaneF32x4 = 4 /* _BinaryenReplaceLaneVecF32x4 */,\n  /** f64x2.replace_lane */\n  ReplaceLaneF64x2 = 5 /* _BinaryenReplaceLaneVecF64x2 */\n}\n\n/** Binaryen SIMD shift operation constants. */\nexport const enum SIMDShiftOp {\n  /** i8x16.shl */\n  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,\n  /** i8x16.shr_s */\n  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,\n  /** i8x16.shr_u */\n  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,\n  /** i16x8.shl */\n  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,\n  /** i16x8.shr_s */\n  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,\n  /** i16x8.shr_u */\n  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,\n  /** i16x8.shl */\n  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,\n  /** i32x4.shr_s */\n  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,\n  /** i32x4.shr_u */\n  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,\n  /** i64x2.shl */\n  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */\n}\n\n/** Binaryen SIMD load operation constants. */\nexport const enum SIMDLoadOp {\n  /** v128.load8_splat */\n  Load8Splat = 0 /* _BinaryenLoad8SplatVec128 */,\n  /** v128.load16_splat */\n  Load16Splat = 1 /* _BinaryenLoad16SplatVec128 */,\n  /** v128.load32_splat */\n  Load32Splat = 2 /* _BinaryenLoad32SplatVec128 */,\n  /** v128.load64_splat */\n  Load64Splat = 3 /* _BinaryenLoad64SplatVec128 */,\n  /** v128.load8x8_s */\n  Load8x8S = 4 /* _BinaryenLoad8x8SVec128 */,\n  /** v128.load8x8_u */\n  Load8x8U = 5 /* _BinaryenLoad8x8UVec128 */,\n  /** v128.load16x4_s */\n  Load16x4S = 6 /* _BinaryenLoad16x4SVec128 */,\n  /** v128.load16x4_u */\n  Load16x4U = 7 /* _BinaryenLoad16x4UVec128 */,\n  /** v128.load32x2_s */\n  Load32x2S = 8 /* _BinaryenLoad32x2SVec128 */,\n  /** v128.load32x2_u */\n  Load32x2U = 9 /* _BinaryenLoad32x2UVec128 */,\n  /** v128.load32_zero */\n  Load32Zero = 10 /* _BinaryenLoad32ZeroVec128 */,\n  /** v128.load64_zero */\n  Load64Zero = 11 /* _BinaryenLoad64ZeroVec128 */,\n}\n\n/** Binaryen SIMD load/store lane operation constants. */\nexport const enum SIMDLoadStoreLaneOp {\n  /** v128.load8_lane */\n  Load8Lane = 0 /* _BinaryenLoad8LaneVec128 */,\n  /** v128.load16_lane */\n  Load16Lane = 1 /* _BinaryenLoad16LaneVec128 */,\n  /** v128.load32_lane */\n  Load32Lane = 2 /* _BinaryenLoad32LaneVec128 */,\n  /** v128.load64_lane */\n  Load64Lane = 3 /* _BinaryenLoad64LaneVec128 */,\n  /** v128.store8_lane */\n  Store8Lane = 4 /* _BinaryenStore8LaneVec128 */,\n  /** v128.store16_lane */\n  Store16Lane = 5 /* _BinaryenStore16LaneVec128 */,\n  /** v128.store32_lane */\n  Store32Lane = 6 /* _BinaryenStore32LaneVec128 */,\n  /** v128.store64_lane */\n  Store64Lane = 7 /* _BinaryenStore64LaneVec128 */,\n}\n\n/** Binaryen SIMD ternary operation constants. */\nexport const enum SIMDTernaryOp {\n  /** v128.bitselect */\n  Bitselect = 0 /* _BinaryenBitselectVec128 */\n}\n\n/** Binaryen RefIs operation constants. */\nexport const enum RefIsOp {\n  /** ref.is_null */\n  Null = 0 /* _BinaryenRefIsNull */,\n  /** ref.is_func */\n  Func = 1 /* _BinaryenRefIsFunc */,\n  /** ref.is_data */\n  Data = 2 /* _BinaryenRefIsData */,\n  /** ref.is_i31 */\n  I31 = 3 /* _BinaryenRefIsI31 */\n}\n\n/** Binaryen RefAs operation constants. */\nexport const enum RefAsOp {\n  /** ref.as_non_null */\n  NonNull = 0 /* _BinaryenRefAsNonNull */,\n  /** ref.as_func */\n  Func = 1 /* _BinaryenRefAsFunc */,\n  /** ref.as_data */\n  Data = 2 /* _BinaryenRefAsData */,\n  /** ref.as_i31 */\n  I31 = 3 /* _BinaryenRefAsI31 */,\n  /** extern.internalize */\n  ExternInternalize = 4 /* _BinaryenRefAsExternInternalize */,\n  /** extern.externalize */\n  ExternExternalize = 5 /* _BinaryenRefAsExternExternalize */\n}\n\n/** Binaryen BrOn operation constants. */\nexport const enum BrOnOp {\n  /** br_on_null */\n  Null = 0 /* _BinaryenBrOnNull */,\n  /** br_on_non_null */\n  NonNull = 1 /* _BinaryenBrOnNonNull */,\n  /** br_on_cast */\n  Cast = 2 /* _BinaryenBrOnCast */,\n  /** br_on_cast_fail */\n  CastFail = 3 /* _BinaryenBrOnCastFail */,\n  /** br_on_func */\n  Func = 4 /* _BinaryenBrOnFunc */,\n  /** br_on_non_func */\n  NonFunc = 5 /* _BinaryenBrOnNonFunc */,\n  /** br_on_data */\n  Data = 6 /* _BinaryenBrOnData */,\n  /** br_on_non_data */\n  NonData = 7 /* _BinaryenBrOnNonData */,\n  /** br_on_i31 */\n  I31 = 8 /* _BinaryenBrOnI31 */,\n  /** br_on_non_i32 */\n  NonI31 = 9 /* _BinaryenBrOnNonI31 */\n}\n\n/** Binaryen StringNew operation constants. */\nexport const enum StringNewOp {\n  /** string.new_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringNewUTF8 */,\n  /** string.new_wtf8 wtf8 */\n  WTF8 = 1 /* _BinaryenStringNewWTF8 */,\n  /** string.new_wtf8 replace */\n  Replace = 2 /* _BinaryenStringNewReplace */,\n  /** string.new_wtf16 */\n  WTF16 = 3 /* _BinaryenStringNewWTF16 */,\n  /** string.new_wtf8_array utf8 */\n  UTF8Array = 4 /* _BinaryenStringNewUTF8Array */,\n  /** string.new_wtf8_array wtf8 */\n  WTF8Array = 5 /* _BinaryenStringNewWTF8Array */,\n  /** string.new_wtf8_array replace */\n  ReplaceArray = 6 /* _BinaryenStringNewReplaceArray */,\n  /** string.new_wtf16_array */\n  WTF16Array = 7 /* _BinaryenStringNewWTF16Array */\n}\n\n/** Binaryen StringMeasure operation constants. */\nexport const enum StringMeasureOp {\n  /** string.measure_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringMeasureUTF8 */,\n  /** string.measure_wtf8 wtf8 */\n  WTF8 = 1 /* _BinaryenStringMeasureWTF8 */,\n  /** string.measure_wtf16 */\n  WTF16 = 2 /* _BinaryenStringMeasureWTF16 */,\n  /** string.is_usv_sequence */\n  IsUSV = 3 /* _BinaryenStringMeasureIsUSV */,\n  /** stringview_wtf16.length */\n  WTF16View = 4 /* _BinaryenStringMeasureWTF16View */\n}\n\n/** Binaryen StringEncode operation constants. */\nexport const enum StringEncodeOp {\n  /** string.encode_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringEncodeUTF8 */,\n  /** string.encode_wtf8 wtf8 */\n  WTF8 = 1 /* _BinaryenStringEncodeWTF8 */,\n  /** string.encode_wtf16 */\n  WTF16 = 2 /* _BinaryenStringEncodeWTF16 */,\n  /** string.encode_wtf8_array utf8 */\n  UTF8Array = 3 /* _BinaryenStringEncodeUTF8Array */,\n  /** string.encode_wtf8_array wtf8 */\n  WTF8Array = 4 /* _BinaryenStringEncodeWTF8Array */,\n  /** string.encode_wtf16_array */\n  WTF16Array = 5 /* _BinaryenStringEncodeWTF16Array */\n}\n\n/** Binaryen StringAs operation constants. */\nexport const enum StringAsOp {\n  /** string.as_wtf8 */\n  WTF8 = 0 /* _BinaryenStringAsWTF8 */,\n  /** string.as_wtf16 */\n  WTF16 = 1 /* _BinaryenStringAsWTF16 */,\n  /** string.as_iter */\n  Iter = 2 /* _BinaryenStringAsIter */\n}\n\n/** Binaryen StringIterMove operation constants. */\nexport const enum StringIterMoveOp {\n  /** stringview_iter.advance */\n  Advance = 0 /* _BinaryenStringIterMoveAdvance */,\n  /** stringview_iter.rewind */\n  Rewind = 1 /* _BinaryenStringIterMoveRewind */\n}\n\n/** Binaryen StringSlice operation constants. */\nexport const enum StringSliceWTFOp {\n  /** stringview_wtf8.slice */\n  WTF8 = 0 /* _BinaryenStringSliceWTF8 */,\n  /** stringview_wtf16.slice */\n  WTF16 = 1 /* _BinaryenStringSliceWTF16 */\n}\n\n/** Binaryen expression runner flags. */\nexport const enum ExpressionRunnerFlags {\n  Default = 0 /* _ExpressionRunnerFlagsDefault */,\n  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */,\n  TraverseCalls = 2 /* _ExpressionRunnerFlagsTraverseCalls */\n}\n\nexport class MemorySegment {\n  constructor(\n    /** Segment data. */\n    public buffer: Uint8Array,\n    /** Segment offset. */\n    public offset: i64\n  ) {}\n}\n\nexport class Module {\n  constructor(\n    /** Binaryen module reference. */\n    public ref: ModuleRef,\n    /** Whether a shadow stack is used. */\n    public useShadowStack: bool,\n    /** Architecture-dependent size type. */\n    public sizeType: TypeRef\n  ) {\n    assert(sizeType == TypeRef.I32 || sizeType == TypeRef.I64);\n    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());\n    binaryen._BinaryenSetTypeSystem(TypeSystem.Nominal);\n  }\n\n  private lit: usize;\n\n  static create(useShadowStack: bool, sizeType: TypeRef): Module {\n    return new Module(binaryen._BinaryenModuleCreate(), useShadowStack, sizeType);\n  }\n\n  static createFrom(buffer: Uint8Array, useShadowStack: bool, sizeType: TypeRef): Module {\n    let cArr = allocU8Array(buffer);\n    let module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length), useShadowStack, sizeType);\n    binaryen._free(changetype<usize>(cArr));\n    return module;\n  }\n\n  // constants\n\n  i32(value: i32): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralInt32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  // isize<T>(value: T): ExpressionRef {\n  //   if (i64_is(value)) {\n  //     if (this.sizeType == TypeRef.I64) {\n  //       return this.i64(i64_low(value), i64_high(value));\n  //     }\n  //     assert(i64_is_i32(value));\n  //     return this.i32(i64_low(value));\n  //   }\n  //   return this.sizeType == TypeRef.I64\n  //     ? this.i64(i32(value), i32(value) < 0 ? -1 : 0)\n  //     : this.i32(i32(value));\n  // }\n\n  usize<T>(value: T): ExpressionRef {\n    if (i64_is(value)) {\n      if (this.sizeType == TypeRef.I64) {\n        return this.i64(i64_low(value), i64_high(value));\n      }\n      assert(i64_is_u32(value));\n      return this.i32(i64_low(value));\n    }\n    return this.sizeType == TypeRef.I64\n      ? this.i64(i32(value))\n      : this.i32(i32(value));\n  }\n\n  f32(value: f32): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralFloat32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f64(value: f64): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralFloat64(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  v128(bytes: Uint8Array): ExpressionRef {\n    assert(bytes.length == 16);\n    let out = this.lit;\n    for (let i = 0; i < 16; ++i) {\n      binaryen.__i32_store8(out + i, unchecked(bytes[i]));\n    }\n    binaryen._BinaryenLiteralVec128(out, out);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  ref_null(type: TypeRef): ExpressionRef {\n    // TODO: Provide the desired bottom type directly? Currently, Binaryen does\n    // this under the hood, but this API could change to take a heap type.\n    // type = binaryen._BinaryenTypeFromHeapType(\n    //   binaryen._BinaryenHeapTypeGetBottom(\n    //     binaryen._BinaryenTypeGetHeapType(type)\n    //   ),\n    //   true\n    // );\n    return binaryen._BinaryenRefNull(this.ref, type);\n  }\n\n  ref_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenRefEq(this.ref, left, right);\n  }\n\n  string_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenStringEq(this.ref, left, right);\n  }\n\n  // expressions\n\n  unary(\n    op: UnaryOp,\n    value: ExpressionRef\n  ): ExpressionRef {\n    if (op > UnaryOp._last) {\n      let isWam64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case UnaryOp.ClzSize:    op = isWam64 ? UnaryOp.ClzI64    : UnaryOp.ClzI32; break;\n        case UnaryOp.CtzSize:    op = isWam64 ? UnaryOp.CtzI64    : UnaryOp.CtzI32; break;\n        case UnaryOp.PopcntSize: op = isWam64 ? UnaryOp.PopcntI64 : UnaryOp.PopcntI32; break;\n        case UnaryOp.EqzSize:    op = isWam64 ? UnaryOp.EqzI64    : UnaryOp.EqzI32; break;\n        default: assert(false);\n      }\n    }\n    return binaryen._BinaryenUnary(this.ref, op, value);\n  }\n\n  binary(\n    op: BinaryOp,\n    left: ExpressionRef,\n    right: ExpressionRef\n  ): ExpressionRef {\n    if (op > BinaryOp._last) {\n      let isWasm64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case BinaryOp.AddSize:  op = isWasm64 ? BinaryOp.AddI64  : BinaryOp.AddI32; break;\n        case BinaryOp.SubSize:  op = isWasm64 ? BinaryOp.SubI64  : BinaryOp.SubI32; break;\n        case BinaryOp.MulSize:  op = isWasm64 ? BinaryOp.MulI64  : BinaryOp.MulI32; break;\n        case BinaryOp.DivISize: op = isWasm64 ? BinaryOp.DivI64  : BinaryOp.DivI32; break;\n        case BinaryOp.DivUSize: op = isWasm64 ? BinaryOp.DivU64  : BinaryOp.DivU32; break;\n        case BinaryOp.RemISize: op = isWasm64 ? BinaryOp.RemI64  : BinaryOp.RemI32; break;\n        case BinaryOp.RemUSize: op = isWasm64 ? BinaryOp.RemU64  : BinaryOp.RemU32; break;\n        case BinaryOp.AndSize:  op = isWasm64 ? BinaryOp.AndI64  : BinaryOp.AndI32; break;\n        case BinaryOp.OrSize:   op = isWasm64 ? BinaryOp.OrI64   : BinaryOp.OrI32; break;\n        case BinaryOp.XorSize:  op = isWasm64 ? BinaryOp.XorI64  : BinaryOp.XorI32; break;\n        case BinaryOp.ShlSize:  op = isWasm64 ? BinaryOp.ShlI64  : BinaryOp.ShlI32; break;\n        case BinaryOp.ShrISize: op = isWasm64 ? BinaryOp.ShrI64  : BinaryOp.ShrI32; break;\n        case BinaryOp.ShrUSize: op = isWasm64 ? BinaryOp.ShrU64  : BinaryOp.ShrU32; break;\n        case BinaryOp.RotlSize: op = isWasm64 ? BinaryOp.RotlI64 : BinaryOp.RotlI32; break;\n        case BinaryOp.RotrSize: op = isWasm64 ? BinaryOp.RotrI64 : BinaryOp.RotrI32; break;\n        case BinaryOp.EqSize:   op = isWasm64 ? BinaryOp.EqI64   : BinaryOp.EqI32; break;\n        case BinaryOp.NeSize:   op = isWasm64 ? BinaryOp.NeI64   : BinaryOp.NeI32; break;\n        case BinaryOp.LtISize:  op = isWasm64 ? BinaryOp.LtI64   : BinaryOp.LtI32; break;\n        case BinaryOp.LtUSize:  op = isWasm64 ? BinaryOp.LtU64   : BinaryOp.LtU32; break;\n        case BinaryOp.LeISize:  op = isWasm64 ? BinaryOp.LeI64   : BinaryOp.LeI32; break;\n        case BinaryOp.LeUSize:  op = isWasm64 ? BinaryOp.LeU64   : BinaryOp.LeU32; break;\n        case BinaryOp.GtISize:  op = isWasm64 ? BinaryOp.GtI64   : BinaryOp.GtI32; break;\n        case BinaryOp.GtUSize:  op = isWasm64 ? BinaryOp.GtU64   : BinaryOp.GtU32; break;\n        case BinaryOp.GeISize:  op = isWasm64 ? BinaryOp.GeI64   : BinaryOp.GeI32; break;\n        case BinaryOp.GeUSize:  op = isWasm64 ? BinaryOp.GeU64   : BinaryOp.GeU32; break;\n        default: assert(false);\n      }\n    }\n    return binaryen._BinaryenBinary(this.ref, op, left, right);\n  }\n\n  memory_size(name: string = CommonNames.DefaultMemory, is64: bool = false): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemorySize(this.ref, cStr, is64);\n  }\n\n  memory_grow(delta: ExpressionRef, name: string = CommonNames.DefaultMemory, is64: bool = false): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemoryGrow(this.ref, delta, cStr, is64);\n  }\n\n  table_size(name: string): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSize(this.ref, cStr);\n  }\n\n  table_grow(name: string, delta: ExpressionRef, value: ExpressionRef = 0): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGrow(this.ref, cStr, value, delta);\n  }\n\n  local_get(\n    index: i32,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalGet(this.ref, index, type);\n  }\n\n  tostack(value: ExpressionRef): ExpressionRef {\n    if (this.useShadowStack) {\n      let type = binaryen._BinaryenExpressionGetType(value);\n      assert(type == TypeRef.I32 || type == TypeRef.Unreachable);\n      return this.call(BuiltinNames.tostack, [ value ], type);\n    }\n    return value;\n  }\n\n  local_tee(\n    index: i32,\n    value: ExpressionRef,\n    isManaged: bool,\n    type: TypeRef = -1,\n  ): ExpressionRef {\n    if (type == -1) type = binaryen._BinaryenExpressionGetType(value);\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalTee(this.ref, index, value, type);\n  }\n\n  global_get(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);\n  }\n\n  table_get(\n    name: string,\n    index: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGet(this.ref, cStr, index, type);\n  }\n\n  load(\n    bytes: Index,\n    signed: bool,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes, // naturally aligned by default\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr, cStr);\n  }\n\n  store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes, // naturally aligned by default\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type, cStr);\n  }\n\n  atomic_load(\n    bytes: Index,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr, cStr);\n  }\n\n  atomic_store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type, cStr);\n  }\n\n  atomic_rmw(\n    op: AtomicRMWOp,\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type, cStr);\n  }\n\n  atomic_cmpxchg(\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    replacement: ExpressionRef,\n    type: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type, cStr);\n  }\n\n  atomic_wait(\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    timeout: ExpressionRef,\n    expectedType: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType, cStr);\n  }\n\n  atomic_notify(\n    ptr: ExpressionRef,\n    notifyCount: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount, cStr);\n  }\n\n  atomic_fence(name: string | null = null): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicFence(this.ref, cStr);\n  }\n\n  // statements\n\n  local_set(\n    index: Index,\n    value: ExpressionRef,\n    isManaged: bool\n  ): ExpressionRef {\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalSet(this.ref, index, value);\n  }\n\n  global_set(\n    name: string,\n    value: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);\n  }\n\n  table_set(\n    name: string,\n    index: ExpressionRef,\n    value: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSet(this.ref, cStr, index, value);\n  }\n\n  block(\n    label: string | null,\n    children: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    let cArr = allocPtrArray(children);\n    let ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */\n  flatten(\n    stmts: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    let length = stmts.length;\n    if (length == 0) return this.nop(); // usually filtered out again\n    if (length == 1) {\n      let single = stmts[0];\n      switch (getExpressionId(single)) {\n        case ExpressionId.Return:\n        case ExpressionId.Throw:\n        case ExpressionId.Unreachable: {\n          // type does no matter, terminates anyway\n          return single;\n        }\n      }\n      let singleType = getExpressionType(single);\n      if (singleType != TypeRef.Unreachable && singleType != type) {\n        // can happen when there was a diagnostic prior\n        return this.unreachable();\n      }\n      return single;\n    }\n    return this.block(null, stmts, type);\n  }\n\n  br(\n    label: string | null,\n    condition: ExpressionRef = 0,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);\n  }\n\n  drop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenDrop(this.ref, expression);\n  }\n\n  /** Drops an expression if it evaluates to a value. */\n  maybeDrop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    let type = binaryen._BinaryenExpressionGetType(expression);\n    if (type != TypeRef.None && type != TypeRef.Unreachable) {\n      return binaryen._BinaryenDrop(this.ref, expression);\n    }\n    return expression;\n  }\n\n  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {\n    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early\n    // when encountering a local with an unknown value. This helper only drops\n    // the pre-evaluated condition if it has relevant side effects.\n    // see WebAssembly/binaryen#1237\n    if ((getSideEffects(condition, this.ref) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {\n      return this.block(null, [\n        this.drop(condition),\n        result\n      ], getExpressionType(result));\n    }\n    return result;\n  }\n\n  loop(\n    label: string | null,\n    body: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    return binaryen._BinaryenLoop(this.ref, cStr, body);\n  }\n\n  if(\n    condition: ExpressionRef,\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);\n  }\n\n  nop(): ExpressionRef {\n    return binaryen._BinaryenNop(this.ref);\n  }\n\n  return(\n    expression: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenReturn(this.ref, expression);\n  }\n\n  select(\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef,\n    condition: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse, type);\n  }\n\n  switch(\n    names: string[],\n    defaultName: string | null,\n    condition: ExpressionRef,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    let numNames = names.length;\n    let strs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      unchecked(strs[i] = this.allocStringCached(names[i]));\n    }\n    let cArr = allocPtrArray(strs);\n    let cStr = this.allocStringCached(defaultName);\n    let ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(target);\n    let cArr = allocPtrArray(operands);\n    let ret = isReturn\n      ? binaryen._BinaryenReturnCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        )\n      : binaryen._BinaryenCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef\n  ): ExpressionRef {\n    return this.call(target, operands, returnType, true);\n  }\n\n  call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(tableName != null\n      ? tableName\n      : CommonNames.DefaultTable\n    );\n    let cArr = allocPtrArray(operands);\n    let ret = isReturn\n      ? binaryen._BinaryenReturnCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        )\n      : binaryen._BinaryenCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef\n  ): ExpressionRef {\n    return this.call_indirect(tableName, index, operands, params, results, true);\n  }\n\n  unreachable(): ExpressionRef {\n    return binaryen._BinaryenUnreachable(this.ref);\n  }\n\n  // bulk memory\n\n  memory_copy(\n    dest: ExpressionRef,\n    source: ExpressionRef,\n    size: ExpressionRef,\n    destName: string = CommonNames.DefaultMemory,\n    sourceName: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr1 = this.allocStringCached(destName);\n    let cStr2 = this.allocStringCached(sourceName);\n    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size, cStr1, cStr2);\n  }\n\n  memory_fill(\n    dest: ExpressionRef,\n    value: ExpressionRef,\n    size: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size, cStr);\n  }\n\n  // exception handling\n\n  try(\n    name: string | null,\n    body: ExpressionRef,\n    catchTags: string[],\n    catchBodies: ExpressionRef[],\n    delegateTarget: string | null = null\n  ): ExpressionRef {\n    let numCatchTags = catchTags.length;\n    let strs = new Array<TagRef>(numCatchTags);\n    for (let i = 0; i < numCatchTags; ++i) {\n      strs[i] = this.allocStringCached(catchTags[i]);\n    }\n    let cArr1 = allocPtrArray(strs);\n    let cArr2 = allocPtrArray(catchBodies);\n    let cStr1 = this.allocStringCached(name);\n    let cStr2 = this.allocStringCached(delegateTarget);\n    let ret = binaryen._BinaryenTry(\n      this.ref, cStr1, body, cArr1, numCatchTags, cArr2, catchBodies.length, cStr2\n    );\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    return ret;\n  }\n\n  throw(\n    tagName: string,\n    operands: ExpressionRef[]\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(tagName);\n    let cArr = allocPtrArray(operands);\n    let ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  rethrow(\n    target: string\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(target);\n    return binaryen._BinaryenRethrow(this.ref, cStr);\n  }\n\n  // multi value (pseudo instructions)\n\n  pop(\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenPop(this.ref, type);\n  }\n\n  tuple_make(operands: ExpressionRef[]): ExpressionRef {\n    let cArr = allocPtrArray(operands);\n    let ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {\n    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);\n  }\n\n  // simd\n\n  simd_extract(\n    op: SIMDExtractOp,\n    vec: ExpressionRef,\n    idx: u8\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);\n  }\n\n  simd_replace(\n    op: SIMDReplaceOp,\n    vec: ExpressionRef,\n    idx: u8,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);\n  }\n\n  simd_shuffle(\n    vec1: ExpressionRef,\n    vec2: ExpressionRef,\n    mask: Uint8Array\n  ): ExpressionRef {\n    assert(mask.length == 16);\n    let cArr = allocU8Array(mask);\n    let ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  simd_ternary(\n    op: SIMDTernaryOp,\n    a: ExpressionRef,\n    b: ExpressionRef,\n    c: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);\n  }\n\n  simd_shift(\n    op: SIMDShiftOp,\n    vec: ExpressionRef,\n    shift: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);\n  }\n\n  simd_load(\n    op: SIMDLoadOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr, cStr);\n  }\n\n  simd_loadstorelane(\n    op: SIMDLoadStoreLaneOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    index: u8,\n    vec: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenSIMDLoadStoreLane(this.ref, op, offset, align, index, ptr, vec, cStr);\n  }\n\n  // reference types / gc\n\n  ref_is(\n    op: RefIsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefIs(this.ref, op, expr);\n  }\n\n  ref_is_null(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    if (isNullableType(getExpressionType(expr))) {\n      return binaryen._BinaryenRefIs(this.ref, RefIsOp.Null, expr);\n    } else {\n      return this.i32(0); // false literal\n    }\n  }\n\n  ref_as(\n    op: RefAsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefAs(this.ref, op, expr);\n  }\n\n  ref_as_nonnull(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    if (isNullableType(getExpressionType(expr))) {\n      return binaryen._BinaryenRefAs(this.ref, RefAsOp.NonNull, expr);\n    } else {\n      return expr;\n    }\n  }\n\n  ref_func(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenRefFunc(this.ref, cStr, type);\n  }\n\n  i31_new(\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenI31New(this.ref, value);\n  }\n\n  i31_get(\n    expr: ExpressionRef,\n    signed: bool\n  ): ExpressionRef {\n    return binaryen._BinaryenI31Get(this.ref, expr, signed);\n  }\n\n  // globals\n\n  addGlobal(\n    name: string,\n    type: TypeRef,\n    mutable: bool,\n    initializer: ExpressionRef\n  ): GlobalRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);\n  }\n\n  getGlobal(\n    name: string\n  ): GlobalRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetGlobal(this.ref, cStr);\n  }\n\n  removeGlobal(\n    name: string\n  ): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveGlobal(this.ref, cStr);\n  }\n\n  // tags\n\n  addTag(\n    name: string,\n    params: TypeRef,\n    results: TypeRef\n  ): TagRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddTag(this.ref, cStr, params, results);\n  }\n\n  getTag(\n    name: string\n  ): TagRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetTag(this.ref, cStr);\n  }\n\n  removeTag(\n    name: string\n  ): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveTag(this.ref, cStr);\n  }\n\n  // functions\n\n  addFunction(\n    name: string,\n    params: TypeRef,\n    results: TypeRef,\n    varTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    let cStr = this.allocStringCached(name);\n    let cArr = allocPtrArray(varTypes);\n    let ret = binaryen._BinaryenAddFunction(\n      this.ref,\n      cStr,\n      params,\n      results,\n      cArr,\n      varTypes ? varTypes.length : 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  setLocalName(funcRef: FunctionRef, index: u32, name: string): void {\n    binaryen._BinaryenFunctionSetLocalName(funcRef, index, this.allocStringCached(name));\n  }\n\n  getFunction(\n    name: string\n  ): FunctionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr);\n  }\n\n  removeFunction(name: string): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveFunction(this.ref, cStr);\n  }\n\n  hasFunction(name: string): bool {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr) != 0;\n  }\n\n  private hasTemporaryFunction: bool = false;\n\n  addTemporaryFunction(\n    result: TypeRef,\n    paramTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);\n    let tempName = this.allocStringCached(\"\");\n    let cArr = allocPtrArray(paramTypes);\n    let ret = binaryen._BinaryenAddFunction(this.ref,\n      tempName,\n      createType(paramTypes),\n      result,\n      0, 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  removeTemporaryFunction(): void {\n    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);\n    let tempName = this.allocStringCached(\"\");\n    binaryen._BinaryenRemoveFunction(this.ref, tempName);\n  }\n\n  setStart(func: FunctionRef): void {\n    binaryen._BinaryenSetStart(this.ref, func);\n  }\n\n  // exports\n\n  addFunctionExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\n  }\n\n  addTableExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);\n  }\n\n  addMemoryExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\n  }\n\n  addGlobalExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\n  }\n\n  addTagExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTagExport(this.ref, cStr1, cStr2);\n  }\n\n  removeExport(externalName: string): void {\n    let cStr = this.allocStringCached(externalName);\n    binaryen._BinaryenRemoveExport(this.ref, cStr);\n  }\n\n  hasExport(externalName: string): bool {\n    let cStr = this.allocStringCached(externalName);\n    return binaryen._BinaryenGetExport(this.ref, cStr) != 0;\n  }\n\n  // imports\n\n  addFunctionImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);\n  }\n\n  addTableImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\n  }\n\n  addMemoryImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    shared: bool = false,\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);\n  }\n\n  addGlobalImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    globalType: TypeRef,\n    mutable: bool = false\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);\n  }\n\n  addTagImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTagImport(\n      this.ref, cStr1, cStr2, cStr3, params, results\n    );\n  }\n\n  // memory\n\n  /** Unlimited memory constant. */\n  static readonly UNLIMITED_MEMORY: Index = <Index>-1;\n\n  setMemory(\n    initial: Index,\n    maximum: Index,\n    segments: MemorySegment[],\n    target: Target,\n    exportName: string | null = null,\n    name: string = CommonNames.DefaultMemory,\n    shared: bool = false\n  ): void {\n    let cStr1 = this.allocStringCached(exportName);\n    let cStr2 = this.allocStringCached(name);\n    let k = segments.length;\n    let segs = new Array<usize>(k);\n    let psvs = new Uint8Array(k);\n    let offs = new Array<ExpressionRef>(k);\n    let sizs = new Array<Index>(k);\n    for (let i = 0; i < k; ++i) {\n      let segment = unchecked(segments[i]);\n      let buffer = segment.buffer;\n      let offset = segment.offset;\n      unchecked(segs[i] = allocU8Array(buffer));\n      unchecked(psvs[i] = 0); // no passive segments currently\n      unchecked(offs[i] = target == Target.Wasm64\n        ? this.i64(i64_low(offset), i64_high(offset))\n        : this.i32(i64_low(offset))\n      );\n      unchecked(sizs[i] = buffer.length);\n    }\n    let cArr1 = allocPtrArray(segs);\n    let cArr2 = allocU8Array(psvs);\n    let cArr3 = allocPtrArray(offs);\n    let cArr4 = allocU32Array(sizs);\n    binaryen._BinaryenSetMemory(\n      this.ref, initial, maximum, cStr1, cArr1, cArr2, cArr3, cArr4, k, shared, false, cStr2\n    );\n    binaryen._free(cArr4);\n    binaryen._free(cArr3);\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    for (let i = k - 1; i >= 0; --i) {\n      binaryen._free(unchecked(segs[i]));\n    }\n  }\n\n  // table\n\n  /** Unlimited table constant. */\n  static readonly UNLIMITED_TABLE: Index = <Index>-1;\n\n  addFunctionTable(\n    name: string,\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    let cStr = this.allocStringCached(name);\n    let numNames = funcs.length;\n    let names = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      unchecked(names[i] = this.allocStringCached(funcs[i]));\n    }\n    let cArr = allocPtrArray(names);\n    let tableRef = binaryen._BinaryenGetTable(this.ref, cStr);\n    if (!tableRef) {\n      tableRef = binaryen._BinaryenAddTable(this.ref, cStr, initial, maximum, TypeRef.Funcref);\n    } else {\n      binaryen._BinaryenTableSetInitial(tableRef, initial);\n      binaryen._BinaryenTableSetMax(tableRef, maximum);\n    }\n    binaryen._BinaryenAddActiveElementSegment(this.ref, cStr, cStr, cArr, numNames, offset);\n    binaryen._free(cArr);\n  }\n\n  /* setFunctionTable(\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    let numNames = funcs.length;\n    let names = new Array<CString>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    let cArr = allocPtrArray(names);\n    binaryen._BinaryenSetFunctionTable(\n      this.ref, initial, maximum, cArr, numNames, offset\n    );\n    binaryen._free(cArr);\n  } */\n\n  // sections\n\n  addCustomSection(name: string, contents: Uint8Array): void {\n    let cStr = this.allocStringCached(name);\n    let cArr = allocU8Array(contents);\n    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);\n    binaryen._free(cArr);\n  }\n\n  // meta (global)\n\n  getOptimizeLevel(): i32 {\n    return binaryen._BinaryenGetOptimizeLevel();\n  }\n\n  setOptimizeLevel(level: i32): void {\n    binaryen._BinaryenSetOptimizeLevel(level);\n  }\n\n  getShrinkLevel(): i32 {\n    return binaryen._BinaryenGetShrinkLevel();\n  }\n\n  setShrinkLevel(level: i32): void {\n    binaryen._BinaryenSetShrinkLevel(level);\n  }\n\n  getDebugInfo(): boolean {\n    return binaryen._BinaryenGetDebugInfo();\n  }\n\n  setDebugInfo(on: bool): void {\n    binaryen._BinaryenSetDebugInfo(on);\n  }\n\n  getLowMemoryUnused(): bool {\n    return binaryen._BinaryenGetLowMemoryUnused();\n  }\n\n  setLowMemoryUnused(on: bool): void {\n    binaryen._BinaryenSetLowMemoryUnused(on);\n  }\n\n  getZeroFilledMemory(): bool {\n    return binaryen._BinaryenGetZeroFilledMemory();\n  }\n\n  setZeroFilledMemory(on: bool): void {\n    binaryen._BinaryenSetZeroFilledMemory(on);\n  }\n\n  getFastMath(): bool {\n    return binaryen._BinaryenGetFastMath();\n  }\n\n  setFastMath(on: bool): void {\n    binaryen._BinaryenSetFastMath(on);\n  }\n\n  getPassArgument(key: string): string | null {\n    let cStr = this.allocStringCached(key);\n    let ptr = binaryen._BinaryenGetPassArgument(cStr);\n    return ptr ? readString(ptr) : null;\n  }\n\n  setPassArgument(key: string, value: string | null): void {\n    let cStr1 = this.allocStringCached(key);\n    let cStr2 = this.allocStringCached(value);\n    binaryen._BinaryenSetPassArgument(cStr1, cStr2);\n  }\n\n  clearPassArguments(): void {\n    binaryen._BinaryenClearPassArguments();\n  }\n\n  getAlwaysInlineMaxSize(): Index {\n    return binaryen._BinaryenGetAlwaysInlineMaxSize();\n  }\n\n  setAlwaysInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetAlwaysInlineMaxSize(size);\n  }\n\n  getFlexibleInlineMaxSize(): Index {\n    return binaryen._BinaryenGetFlexibleInlineMaxSize();\n  }\n\n  setFlexibleInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetFlexibleInlineMaxSize(size);\n  }\n\n  getOneCallerInlineMaxSize(): Index {\n    return binaryen._BinaryenGetOneCallerInlineMaxSize();\n  }\n\n  setOneCallerInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetOneCallerInlineMaxSize(size);\n  }\n\n  getAllowInliningFunctionsWithLoops(): bool {\n    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();\n  }\n\n  setAllowInliningFunctionsWithLoops(enabled: bool): void {\n    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);\n  }\n\n  // meta (module)\n\n  getFeatures(): FeatureFlags {\n    return binaryen._BinaryenModuleGetFeatures(this.ref);\n  }\n\n  setFeatures(featureFlags: FeatureFlags): void {\n    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);\n  }\n\n  runPasses(passes: string[], func: FunctionRef = 0): void {\n    let numNames = passes.length;\n    let cStrs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      cStrs[i] = allocString(passes[i]);\n    }\n    let cArr = allocPtrArray(cStrs);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);\n    }\n    binaryen._free(cArr);\n    for (let i = numNames - 1; i >= 0; --i) binaryen._free(cStrs[i]);\n  }\n\n  optimize(\n    optimizeLevel: i32,\n    shrinkLevel: i32,\n    debugInfo: bool = false,\n    zeroFilledMemory: bool = false\n  ): void {\n    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n    this.setOptimizeLevel(optimizeLevel);\n    this.setShrinkLevel(shrinkLevel);\n    this.setDebugInfo(debugInfo);\n    this.setZeroFilledMemory(zeroFilledMemory);\n    this.setFastMath(true);\n    this.clearPassArguments();\n\n    // Tweak inlining limits based on optimization levels\n    if (optimizeLevel >= 2 && shrinkLevel == 0) {\n      this.setAlwaysInlineMaxSize(12);\n      this.setFlexibleInlineMaxSize(70);\n      this.setOneCallerInlineMaxSize(200);\n      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);\n    } else {\n      this.setAlwaysInlineMaxSize(\n        optimizeLevel <= 1 || shrinkLevel >= 2\n          ? 2\n          : 6\n      );\n      this.setFlexibleInlineMaxSize(65);\n      this.setOneCallerInlineMaxSize(80);\n      this.setAllowInliningFunctionsWithLoops(false);\n    }\n\n    // Pass order here differs substantially from Binaryen's defaults\n    // see: Binaryen/src/pass.cpp\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\n      let passes = new Array<string>();\n\n      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---\n\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-module-elements\"); // +\n\n      // --- PassRunner::addDefaultFunctionOptimizationPasses ---\n      if (optimizeLevel >= 2) {\n        passes.push(\"once-reduction\");\n        passes.push(\"inlining\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"local-cse\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"gufa-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 3) {\n        passes.push(\"simplify-locals-nostructure\");\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"vacuum\");\n        passes.push(\"licm\");\n        passes.push(\"merge-locals\");\n        passes.push(\"reorder-locals\");\n      }\n      passes.push(\"optimize-instructions\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"dce\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        passes.push(\"inlining\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"pick-load-signs\");\n      }\n      passes.push(\"simplify-locals-notee-nostructure\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"local-cse\");\n      }\n      passes.push(\"reorder-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"simplify-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"reorder-locals\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"merge-locals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      passes.push(\"merge-blocks\");\n      if (optimizeLevel >= 3) {\n        passes.push(\"optimize-instructions\");\n      }\n\n      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---\n\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"inlining-optimizing\");\n      }\n      if (this.getLowMemoryUnused()) {\n        if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n          passes.push(\"optimize-added-constants-propagate\");\n        } else {\n          passes.push(\"optimize-added-constants\");\n        }\n      }\n      passes.push(\"duplicate-import-elimination\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"simplify-globals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 && (this.getFeatures() & FeatureFlags.GC) != 0) {\n        passes.push(\"heap2local\");\n        passes.push(\"merge-locals\");\n        passes.push(\"local-subtyping\");\n      }\n      // precompute works best after global optimizations\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      passes.push(\"directize\"); // replace indirect with direct calls\n      passes.push(\"dae-optimizing\"); // reduce arity\n      passes.push(\"inlining-optimizing\"); // and inline if possible\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"rse\");\n        // move code on early return (after CFG cleanup)\n        passes.push(\"code-pushing\");\n        if (optimizeLevel >= 3) {\n          // very expensive, so O3 only\n          passes.push(\"simplify-globals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"precompute-propagate\");\n\n          // replace indirect with direct calls again and inline\n          passes.push(\"inlining-optimizing\");\n          passes.push(\"directize\");\n          passes.push(\"dae-optimizing\");\n          passes.push(\"local-cse\");\n\n          passes.push(\"merge-locals\");\n          passes.push(\"coalesce-locals\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"inlining\");\n          passes.push(\"precompute-propagate\");\n          passes.push(\"rse\");\n          passes.push(\"vacuum\");\n          passes.push(\"ssa-nomerge\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"coalesce-locals\");\n        }\n        passes.push(\"optimize-instructions\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"vacuum\");\n\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"optimize-instructions\");\n      }\n      // clean up\n      passes.push(\"duplicate-function-elimination\");\n      if (shrinkLevel >= 2) {\n        passes.push(\"merge-similar-functions\");\n      }\n      passes.push(\"memory-packing\");\n      passes.push(\"remove-unused-module-elements\");\n\n      this.runPasses(passes);\n    }\n  }\n\n  validate(): bool {\n    return binaryen._BinaryenModuleValidate(this.ref) == 1;\n  }\n\n  interpret(): void {\n    binaryen._BinaryenModuleInterpret(this.ref);\n  }\n\n  toBinary(sourceMapUrl: string | null = null): BinaryModule {\n    assert(\n      binaryen._BinaryenSizeofLiteral() >=\n      binaryen._BinaryenSizeofAllocateAndWriteResult()\n    );\n\n    // now safely reuse lit buffer for BinaryenModuleAllocateAndWriteResult\n    let resPtr = this.lit;\n    let urlPtr = allocString(sourceMapUrl);\n\n    binaryen._BinaryenModuleAllocateAndWrite(resPtr, this.ref, urlPtr);\n\n    // read BinaryenModuleAllocateAndWriteResult struct\n    let binaryPtr = binaryen.__i32_load(resPtr + 0) as usize; // non-nullabe\n    let binaryLen = binaryen.__i32_load(resPtr + 4);\n    let srcMapPtr = binaryen.__i32_load(resPtr + 8) as usize; // nullable\n\n    let binary = new BinaryModule(\n      readBuffer(assert(binaryPtr), binaryLen),\n      readString(srcMapPtr)\n    );\n\n    if (urlPtr) binaryen._free(urlPtr);\n    if (srcMapPtr) binaryen._free(srcMapPtr);\n    binaryen._free(binaryPtr);\n\n    return binary;\n  }\n\n  toText(watFormat: bool = true): string {\n    let textPtr = watFormat\n      ? binaryen._BinaryenModuleAllocateAndWriteStackIR(this.ref, true)\n      : binaryen._BinaryenModuleAllocateAndWriteText(this.ref);\n    let text = readString(textPtr);\n    if (textPtr) binaryen._free(textPtr);\n    return text || \"\";\n  }\n\n  private cachedStringsToPointers: Map<string,usize> = new Map();\n  private cachedPointersToStrings: Map<usize,string | null> = new Map();\n\n  allocStringCached(str: string | null): usize {\n    if (str == null) return 0;\n    let cached = this.cachedStringsToPointers;\n    if (cached.has(str)) return changetype<usize>(cached.get(str));\n    let ptr = allocString(str);\n    cached.set(str, ptr);\n    return ptr;\n  }\n\n  readStringCached(ptr: usize): string | null {\n    // Binaryen internalizes names, so using this method where it's safe can\n    // avoid quite a bit of unnecessary garbage.\n    if (ptr == 0) return null;\n    let cached = this.cachedPointersToStrings;\n    if (cached.has(ptr)) return changetype<string>(cached.get(ptr));\n    let str = readString(ptr);\n    cached.set(ptr, str);\n    return str;\n  }\n\n  dispose(): void {\n    assert(this.ref);\n    // TODO: for (let ptr of this.cachedStrings.values()) {\n    for (let _values = Map_values(this.cachedStringsToPointers), i = 0, k = _values.length; i < k; ++i) {\n      let ptr = unchecked(_values[i]);\n      binaryen._free(ptr);\n    }\n    this.cachedStringsToPointers.clear();\n    this.cachedPointersToStrings.clear();\n    binaryen._free(this.lit);\n    binaryen._BinaryenModuleDispose(this.ref);\n    this.ref = 0;\n  }\n\n  createRelooper(): Relooper {\n    return Relooper.create(this);\n  }\n\n  /** Makes a copy of a trivial expression (doesn't contain subexpressions). Returns `0` if non-trivial. */\n  tryCopyTrivialExpression(expr: ExpressionRef): ExpressionRef {\n    switch (binaryen._BinaryenExpressionGetId(expr)) {\n      case ExpressionId.LocalGet:\n      case ExpressionId.GlobalGet:\n      case ExpressionId.Const:\n      case ExpressionId.MemorySize:\n      case ExpressionId.Nop:\n      case ExpressionId.Unreachable:\n      case ExpressionId.DataDrop:\n      case ExpressionId.RefNull: return this.copyExpression(expr);\n    }\n    return 0;\n  }\n\n  /** Makes a copy of any expression including all subexpressions. */\n  copyExpression(expr: ExpressionRef): ExpressionRef {\n    // TODO: Copy debug location as well (needs Binaryen support)\n    return binaryen._BinaryenExpressionCopy(expr, this.ref);\n  }\n\n  runExpression(\n    expr: ExpressionRef,\n    flags: ExpressionRunnerFlags,\n    maxDepth: i32 = 50,\n    maxLoopIterations: i32 = 1\n  ): ExpressionRef {\n    let runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);\n    let precomp = binaryen._ExpressionRunnerRunAndDispose(runner, expr);\n    if (precomp) {\n      if (!this.isConstExpression(precomp)) return 0;\n      assert(getExpressionType(precomp) == getExpressionType(expr));\n    }\n    return precomp;\n  }\n\n  isConstExpression(expr: ExpressionRef): bool {\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Const:\n      case ExpressionId.RefNull:\n      case ExpressionId.RefFunc:\n      case ExpressionId.I31New: return true;\n      case ExpressionId.Binary: {\n        if (this.getFeatures() & FeatureFlags.ExtendedConst) {\n          switch (getBinaryOp(expr)) {\n            case BinaryOp.AddI32:\n            case BinaryOp.SubI32:\n            case BinaryOp.MulI32:\n            case BinaryOp.AddI64:\n            case BinaryOp.SubI64:\n            case BinaryOp.MulI64:\n              return (\n                this.isConstExpression(getBinaryLeft(expr)) &&\n                this.isConstExpression(getBinaryRight(expr))\n              );\n          }\n        }\n        break;\n      }\n    }\n    return false;\n  }\n\n  // source map generation\n\n  addDebugInfoFile(name: string): Index {\n    let cStr = allocString(name);\n    let ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\n    binaryen._free(cStr);\n    return ret;\n  }\n\n  getDebugInfoFile(index: Index): string | null {\n    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));\n  }\n\n  setDebugLocation(\n    func: FunctionRef,\n    expr: ExpressionRef,\n    fileIndex: Index,\n    lineNumber: Index,\n    columnNumber: Index\n  ): void {\n    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\n  }\n}\n\n// types\n\nexport function createType(types: TypeRef[] | null): TypeRef {\n  if (!types) return TypeRef.None;\n  switch (types.length) {\n    case 0: return TypeRef.None;\n    case 1: return types[0];\n  }\n  let cArr = allocPtrArray(types);\n  let ret = binaryen._BinaryenTypeCreate(cArr, types.length);\n  binaryen._free(cArr);\n  return ret;\n}\n\nexport function expandType(type: TypeRef): TypeRef[] {\n  let arity = binaryen._BinaryenTypeArity(type);\n  let cArr = binaryen._malloc(<usize>arity << 2);\n  binaryen._BinaryenTypeExpand(type, cArr);\n  let types = new Array<TypeRef>(arity);\n  for (let i: u32 = 0; i < arity; ++i) {\n    unchecked(types[i] = binaryen.__i32_load(cArr + (<usize>i << 2)));\n  }\n  binaryen._free(cArr);\n  return types;\n}\n\nexport function isNullableType(type: TypeRef): bool {\n  return binaryen._BinaryenTypeIsNullable(type);\n}\n\n// expressions\n\nexport function getExpressionId(expr: ExpressionRef): ExpressionId {\n  return binaryen._BinaryenExpressionGetId(expr);\n}\n\nexport function getExpressionType(expr: ExpressionRef): TypeRef {\n  return binaryen._BinaryenExpressionGetType(expr);\n}\n\nexport function getConstValueI32(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI32(expr);\n}\n\nexport function getConstValueI64Low(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64Low(expr);\n}\n\nexport function getConstValueI64High(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64High(expr);\n}\n\nexport function getConstValueF32(expr: ExpressionRef): f32 {\n  return binaryen._BinaryenConstGetValueF32(expr);\n}\n\nexport function getConstValueF64(expr: ExpressionRef): f64 {\n  return binaryen._BinaryenConstGetValueF64(expr);\n}\n\nexport function getConstValueV128(expr: ExpressionRef): Uint8Array {\n  let cArr = binaryen._malloc(16);\n  binaryen._BinaryenConstGetValueV128(expr, cArr);\n  let out = new Uint8Array(16);\n  for (let i = 0; i < 16; ++i) {\n    out[i] = binaryen.__i32_load8_u(cArr + i);\n  }\n  binaryen._free(cArr);\n  return out;\n}\n\nexport function isConstZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) == 0;\n  if (type == TypeRef.I64) return (getConstValueI64Low(expr) | getConstValueI64High(expr)) == 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) == 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) == 0;\n  return false;\n}\n\nexport function isConstNonZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) != 0;\n  if (type == TypeRef.I64) return (getConstValueI64Low(expr) | getConstValueI64High(expr)) != 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) != 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) != 0;\n  return false;\n}\n\nexport function isConstNegZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32) {\n    let d = getConstValueF32(expr);\n    return d == 0 && f32_as_i32(d) < 0;\n  }\n  if (type == TypeRef.F64) {\n    let d = getConstValueF64(expr);\n    return d == 0 && i64_signbit(f64_as_i64(d));\n  }\n  return false;\n}\n\nexport function isConstNaN(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32) return isNaN(getConstValueF32(expr));\n  if (type == TypeRef.F64) return isNaN(getConstValueF64(expr));\n  return false;\n}\n\nexport function isConstExpressionNaN(module: Module, expr: ExpressionRef): bool {\n  let id = getExpressionId(expr);\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32 || type == TypeRef.F64) {\n    if (id == ExpressionId.Const) {\n      return isNaN(\n        type == TypeRef.F32\n          ? getConstValueF32(expr)\n          : getConstValueF64(expr)\n      );\n    } else if (id == ExpressionId.GlobalGet) {\n      let precomp = module.runExpression(expr, ExpressionRunnerFlags.Default, 8);\n      if (precomp) {\n        return isNaN(\n          type == TypeRef.F32\n            ? getConstValueF32(precomp)\n            : getConstValueF64(precomp)\n        );\n      }\n    }\n  }\n  return false;\n}\n\nexport function getLocalGetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalGetGetIndex(expr);\n}\n\nexport function getLocalSetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalSetGetIndex(expr);\n}\n\nexport function getLocalSetValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLocalSetGetValue(expr);\n}\n\nexport function isLocalTee(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLocalSetIsTee(expr);\n}\n\nexport function getGlobalGetName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetGetName(expr));\n}\n\nexport function getBinaryOp(expr: ExpressionRef): BinaryOp {\n  return binaryen._BinaryenBinaryGetOp(expr);\n}\n\nexport function getBinaryLeft(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetLeft(expr);\n}\n\nexport function getBinaryRight(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetRight(expr);\n}\n\nexport function getUnaryOp(expr: ExpressionRef): UnaryOp {\n  return binaryen._BinaryenUnaryGetOp(expr);\n}\n\nexport function getUnaryValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenUnaryGetValue(expr);\n}\n\nexport function getLoadBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetBytes(expr);\n}\n\nexport function getLoadOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetOffset(expr);\n}\n\nexport function getLoadPtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoadGetPtr(expr);\n}\n\nexport function isLoadSigned(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLoadIsSigned(expr);\n}\n\nexport function getStoreBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetBytes(expr);\n}\n\nexport function getStoreOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetOffset(expr);\n}\n\nexport function getStorePtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetPtr(expr);\n}\n\nexport function getStoreValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetValue(expr);\n}\n\nexport function getBlockName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBlockGetName(expr));\n}\n\nexport function getBlockChildCount(expr: ExpressionRef): Index {\n  return binaryen._BinaryenBlockGetNumChildren(expr);\n}\n\nexport function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenBlockGetChildAt(expr, index);\n}\n\nexport function getIfCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetCondition(expr);\n}\n\nexport function getIfTrue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfTrue(expr);\n}\n\nexport function getIfFalse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfFalse(expr);\n}\n\nexport function getLoopName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenLoopGetName(expr));\n}\n\nexport function getLoopBody(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoopGetBody(expr);\n}\n\nexport function getBreakName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBreakGetName(expr));\n}\n\nexport function getBreakCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBreakGetCondition(expr);\n}\n\nexport function getSelectThen(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfTrue(expr);\n}\n\nexport function getSelectElse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfFalse(expr);\n}\n\nexport function getSelectCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetCondition(expr);\n}\n\nexport function getDropValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenDropGetValue(expr);\n}\n\nexport function getReturnValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenReturnGetValue(expr);\n}\n\nexport function getCallTarget(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenCallGetTarget(expr));\n}\n\nexport function getCallOperandCount(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenCallGetNumOperands(expr);\n}\n\nexport function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenCallGetOperandAt(expr, index);\n}\n\nexport function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenMemoryGrowGetDelta(expr);\n}\n\n// functions\n\nexport function getFunctionBody(func: FunctionRef): ExpressionRef {\n  return binaryen._BinaryenFunctionGetBody(func);\n}\n\nexport function getFunctionName(func: FunctionRef): string | null {\n  return readString(binaryen._BinaryenFunctionGetName(func));\n}\n\nexport function getFunctionParams(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetParams(func);\n}\n\nexport function getFunctionResults(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetResults(func);\n}\n\nexport function getFunctionVars(func: FunctionRef): TypeRef[] {\n  let count = binaryen._BinaryenFunctionGetNumVars(func);\n  let types = new Array<TypeRef>(count);\n  for (let i: Index = 0; i < count; ++i) {\n    unchecked(types[i] = binaryen._BinaryenFunctionGetVar(func, i));\n  }\n  return types;\n}\n\n// globals\n\nexport function getGlobalName(global: GlobalRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetName(global));\n}\n\nexport function getGlobalType(global: GlobalRef): TypeRef {\n  return binaryen._BinaryenGlobalGetType(global);\n}\n\nexport function isGlobalMutable(global: GlobalRef): bool {\n  return binaryen._BinaryenGlobalIsMutable(global);\n}\n\nexport function getGlobalInit(global: GlobalRef): ExpressionRef {\n  return binaryen._BinaryenGlobalGetInitExpr(global);\n}\n\n// tags\n\nexport function getTagName(tag: TagRef): string | null {\n  return readString(binaryen._BinaryenTagGetName(tag));\n}\n\nexport function getTagParams(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetParams(tag);\n}\n\nexport function getTagResults(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetResults(tag);\n}\n\nexport class Relooper {\n  constructor(\n    /** Module this relooper belongs to. */\n    public module: Module,\n    /** Binaryen relooper reference. */\n    public ref: RelooperRef\n  ) {}\n\n  static create(module: Module): Relooper {\n    return new Relooper(module, binaryen._RelooperCreate(module.ref));\n  }\n\n  addBlock(code: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlock(this.ref, code);\n  }\n\n  addBranch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    condition: ExpressionRef = 0,\n    code: ExpressionRef = 0\n  ): void {\n    binaryen._RelooperAddBranch(from, to, condition, code);\n  }\n\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);\n  }\n\n  addBranchForSwitch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    indexes: i32[],\n    code: ExpressionRef = 0\n  ): void {\n    let cArr = allocI32Array(indexes);\n    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\n    binaryen._free(cArr);\n  }\n\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\n    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);\n  }\n}\n\n/** Builds a switch using a sequence of `br_if`s. */\nexport class SwitchBuilder {\n  // This is useful because Binaryen understands sequences of `br_if`s and\n  // knows how to make a `br_table` from such a sequence if switched over\n  // values are considered dense enough, respectively a size-efficient sequence\n  // of `if`s if not, depending on optimization levels.\n\n  private module: Module;\n  private condition: ExpressionRef;\n  private values: i32[] = new Array();\n  private indexes: i32[] = new Array();\n  private cases: ExpressionRef[][] = new Array();\n  private defaultIndex: i32 = -1;\n\n  /** Creates a new builder using the specified i32 condition. */\n  constructor(module: Module, condition: ExpressionRef) {\n    this.module = module;\n    this.condition = condition;\n  }\n\n  /** Links a case to the specified branch. */\n  addCase(value: i32, code: ExpressionRef[]): void {\n    let cases = this.cases;\n    let index = cases.indexOf(code);\n    if (index < 0) {\n      index = cases.length;\n      cases.push(code);\n    }\n    this.values.push(value);\n    this.indexes.push(index);\n  }\n\n  /** Links the default branch. */\n  addDefault(code: ExpressionRef[]): void {\n    assert(this.defaultIndex == -1);\n    let cases = this.cases;\n    this.defaultIndex = cases.length;\n    cases.push(code);\n  }\n\n  /** Renders the switch to a block. */\n  render(localIndex: i32, labelPostfix: string = \"\"): ExpressionRef {\n    let module = this.module;\n    let cases = this.cases;\n    let numCases = cases.length;\n    if (!numCases) {\n      return module.drop(this.condition);\n    }\n    let values = this.values;\n    let numValues = values.length;\n    let indexes = this.indexes;\n    let entry = new Array<ExpressionRef>(1 + numValues + 1);\n    let labels = new Array<string>(numCases);\n    for (let i = 0; i < numCases; ++i) {\n      unchecked(labels[i] = `case${i}${labelPostfix}`);\n    }\n    entry[0] = module.local_set(localIndex, this.condition, false); // u32\n    for (let i = 0; i < numValues; ++i) {\n      let index = unchecked(indexes[i]);\n      unchecked(entry[1 + i] = module.br(labels[index],\n        module.binary(BinaryOp.EqI32,\n          module.local_get(localIndex, TypeRef.I32),\n          module.i32(values[i])\n        )\n      ));\n    }\n    let defaultIndex = this.defaultIndex;\n    let defaultLabel = `default${labelPostfix}`;\n    entry[1 + numValues] = module.br(\n      ~defaultIndex\n        ? labels[defaultIndex]\n        : defaultLabel\n    );\n    let current = module.block(labels[0], entry);\n    for (let i = 1; i < numCases; ++i) {\n      let block = cases[i - 1];\n      block.unshift(current);\n      current = module.block(unchecked(labels[i]), block);\n    }\n    let lastCase = cases[numCases - 1];\n    lastCase.unshift(current);\n    return module.block(\n      ~defaultIndex\n        ? null\n        : defaultLabel,\n      lastCase\n    );\n  }\n}\n\nexport const enum SideEffects {\n  None = 0 /* _BinaryenSideEffectNone */,\n  Branches = 1 /* _BinaryenSideEffectBranches */,\n  Calls = 2 /* _BinaryenSideEffectCalls */,\n  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,\n  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,\n  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,\n  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,\n  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,\n  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,\n  ReadsTable = 256 /* _BinaryenSideEffectReadsTable */,\n  WritesTable = 512 /* _BinaryenSideEffectWritesTable */,\n  ImplicitTrap = 1024 /* _BinaryenSideEffectImplicitTrap */,\n  IsAtomic = 2048 /* _BinaryenSideEffectIsAtomic */,\n  Throws = 4096 /* _BinaryenSideEffectThrows */,\n  DanglingPop = 8192 /* _BinaryenSideEffectDanglingPop */,\n  TrapsNeverHappen = 16384 /* _BinaryenSideEffectTrapsNeverHappen */,\n  Any = 32767 /* _BinaryenSideEffectAny */\n}\n\nexport function getSideEffects(expr: ExpressionRef, module: ModuleRef): SideEffects {\n  return binaryen._BinaryenExpressionGetSideEffects(expr, module);\n}\n\nexport function mustPreserveSideEffects(expr: ExpressionRef, module: ModuleRef): bool {\n  return (getSideEffects(expr, module) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != SideEffects.None;\n}\n\n// helpers\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\n\nfunction allocU8Array(u8s: Uint8Array | null): usize {\n  if (!u8s) return 0;\n  let len = u8s.length;\n  let ptr = binaryen._malloc(len);\n  for (let i = 0; i < len; ++i) {\n    binaryen.__i32_store8(ptr + i, unchecked(u8s[i]));\n  }\n  return ptr;\n}\n\nfunction allocI32Array(i32s: i32[] | null): usize {\n  if (!i32s) return 0;\n  let len = i32s.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = unchecked(i32s[i]);\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction allocU32Array(u32s: u32[] | null): usize {\n  if (!u32s) return 0;\n  let len = u32s.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = unchecked(u32s[i]);\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nexport function allocPtrArray(ptrs: usize[] | null): usize {\n  if (!ptrs) return 0;\n  // TODO: WASM64\n  assert(ASC_TARGET != Target.Wasm64);\n  let len = ptrs.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0, k = len; i < k; ++i) {\n    let val = unchecked(ptrs[i]);\n    binaryen.__i32_store(idx, <i32>val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction stringLengthUTF8(str: string): usize {\n  let len = 0;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let c1 = str.charCodeAt(i) >>> 0;\n    if (c1 <= 0x7F) {\n      len += 1;\n    } else if (c1 <= 0x7FF) {\n      len += 2;\n    } else if (\n      isHighSurrogate(c1) && i + 1 < k &&\n      isLowSurrogate(str.charCodeAt(i + 1))\n    ) {\n      i++;\n      len += 4;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\nfunction allocString(str: string | null): usize {\n  if (str == null) return 0;\n  let len = stringLengthUTF8(str);\n  let ptr = binaryen._malloc(len + 1) >>> 0;\n  let idx = ptr;\n  if (len == str.length) {\n    // fast path when all chars are ascii\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let u = str.charCodeAt(i) >>> 0;\n      binaryen.__i32_store8(idx++, u as u8);\n    }\n  } else {\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let c1 = str.charCodeAt(i) >>> 0, c2: i32;\n      if (c1 <= 0x7F) {\n        binaryen.__i32_store8(idx++, c1 as u8);\n      } else if (c1 <= 0x7FF) {\n        binaryen.__i32_store8(idx++, (0xC0 |  (c1 >>> 6)       ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else if (\n        isHighSurrogate(c1) && i + 1 < k &&\n        isLowSurrogate(c2 = str.charCodeAt(i + 1))\n      ) {\n        c1 = combineSurrogates(c1, c2);\n        ++i;\n        binaryen.__i32_store8(idx++, (0xF0 |  (c1 >>> 18)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>> 12) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else {\n        binaryen.__i32_store8(idx++, (0xE0 |  (c1 >>> 12)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      }\n    }\n  }\n  binaryen.__i32_store8(idx, 0); // \\0\n  return ptr;\n}\n\nfunction readBuffer(ptr: usize, len: i32): Uint8Array {\n  let ret = new Uint8Array(len);\n  for (let i = 0; i < len; ++i) {\n    unchecked(ret[i] = binaryen.__i32_load8_u(ptr + <usize>i));\n  }\n  return ret;\n}\n\nexport function readString(ptr: usize): string | null {\n  if (!ptr) return null;\n  let arr = new Array<i32>();\n  // the following is based on Emscripten's UTF8ArrayToString\n  let cp: u32;\n  let u1: u32, u2: u32, u3: u32;\n  while (cp = binaryen.__i32_load8_u(ptr++)) {\n    if (!(cp & 0x80)) {\n      arr.push(cp);\n      continue;\n    }\n    u1 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xE0) == 0xC0) {\n      arr.push(((cp & 31) << 6) | u1);\n      continue;\n    }\n    u2 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xF0) == 0xE0) {\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u3 = binaryen.__i32_load8_u(ptr++) & 63;\n      if ((cp & 0xF8) == 0xF0) {\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n      } else {\n        assert(false, \"Invalid UTF8 sequence during readString\");\n      }\n    }\n    if (cp < 0x10000) {\n      arr.push(cp);\n    } else {\n      let ch = cp - 0x10000;\n      arr.push(SURROGATE_HIGH | (ch >>> 10));\n      arr.push(SURROGATE_LOW | (ch & 0x3FF));\n    }\n  }\n  // TODO: implement and use String.fromCodePoints\n  return String.fromCharCodes(arr);\n}\n\n/** Result structure of {@link Module#toBinary}. */\nexport class BinaryModule {\n  constructor(\n    /** WebAssembly binary. */\n    public output: Uint8Array,\n    /** Source map, if generated. */\n    public sourceMap: string | null\n  ) {}\n}\n\n// TypeBuilder\n\nconst DEBUG_TYPEBUILDER = false;\n\n/** Ensures that the given potentially complex type has a corresponding GC type. */\nexport function ensureType(type: Type): TypeRef {\n  // Obtain basic type if applicable\n  if (type == Type.void) return TypeRef.None;\n  let typeRef = tryEnsureBasicType(type);\n  if (typeRef) return typeRef;\n\n  // From here on we are dealing with heap types independent of nullability.\n  // Nullability is applied again when returning the final type.\n  let originalType = type;\n  type = type.nonNullableType;\n\n  // Obtain cached type if already built. Guaranteed to be not a temp type.\n  if (typeRef = type.ref) {\n    return binaryen._BinaryenTypeFromHeapType(\n      binaryen._BinaryenTypeGetHeapType(typeRef),\n      originalType.is(TypeFlags.Nullable) // apply nullability\n    );\n  }\n\n  // Otherwise use a type builder\n  if (ASC_TARGET) {\n    // @ts-ignore: Wasm only\n    assert(sizeof<usize>() == 4); // ABI code below assumes 32-bit pointers\n  }\n  assert(binaryen._BinaryenGetTypeSystem() == TypeSystem.Nominal);\n  let builder = binaryen._TypeBuilderCreate(0);\n  let seen = new Map<Type,HeapTypeRef>();\n  prepareType(builder, seen, type); // drop temp return\n  let size = binaryen._TypeBuilderGetSize(builder);\n  let out = binaryen._malloc(max(4 * size, 8)); // either each heap type or index + reason\n  if (!binaryen._TypeBuilderBuildAndDispose(builder, out, out, out + 4)) {\n    let errorIndex = binaryen.__i32_load(out);\n    let errorReason = binaryen.__i32_load(out + 4);\n    binaryen._free(out);\n    throw new Error(`type builder error at index ${errorIndex}: ${TypeBuilderErrorReason.toString(errorReason)}`);\n  }\n\n  // Assign all the built types to their respective non-nullable type\n  for (let _keys = Map_keys(seen), i = 0, k = _keys.length; i < k; ++i) {\n    let seenType = _keys[i];\n    assert(!seenType.is(TypeFlags.Nullable)); // non-nullable only\n    let heapType = <HeapTypeRef>binaryen.__i32_load(out + 4 * i);\n    let fullType = binaryen._BinaryenTypeFromHeapType(heapType, false);\n    assert(!seenType.ref);\n    seenType.ref = fullType;\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` set ${seenType.toString()}`);\n    }\n    let classInstance = seenType.getClass();\n    if (classInstance) {\n      let module = classInstance.program.module;\n      binaryen._BinaryenModuleSetTypeName(module.ref, heapType, module.allocStringCached(classInstance.internalName));\n      let members = classInstance.members;\n      if (members) {\n        let numFieldsInType = binaryen._BinaryenStructTypeGetNumFields(heapType);\n        let numFieldsInClass = 0;\n        for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n          let member = _values[i];\n          if (member.kind != ElementKind.PropertyPrototype) continue;\n          // only interested in fields (resolved during class finalization)\n          let property = (<PropertyPrototype>member).instance;\n          if (!property || !property.isField) continue;\n          binaryen._BinaryenModuleSetFieldName(module.ref, heapType, numFieldsInClass++, module.allocStringCached(property.name));\n        }\n        assert(numFieldsInType == numFieldsInClass);\n      }\n    }\n  }\n  binaryen._free(out);\n\n  // Initial type should now exist in its non-nullable variant\n  if (DEBUG_TYPEBUILDER) {\n    console.log(` finalize ${type.toString()}`);\n  }\n  typeRef = assert(type.ref);\n  return binaryen._BinaryenTypeFromHeapType(\n    binaryen._BinaryenTypeGetHeapType(typeRef),\n    originalType.is(TypeFlags.Nullable) // apply nullability\n  );\n}\n\n/** Obtains the basic type of the given type, if any. */\nfunction tryEnsureBasicType(type: Type): TypeRef {\n  switch (type.kind) {\n    case TypeKind.Bool:\n    case TypeKind.I8:\n    case TypeKind.U8:\n    case TypeKind.I16:\n    case TypeKind.U16:\n    case TypeKind.I32:\n    case TypeKind.U32: return TypeRef.I32;\n    case TypeKind.I64:\n    case TypeKind.U64: return TypeRef.I64;\n    case TypeKind.Isize:\n    case TypeKind.Usize: {\n      if (type.isInternalReference) break; // non-basic\n      return type.size == 64 ? TypeRef.I64 : TypeRef.I32;\n    }\n    case TypeKind.F32: return TypeRef.F32;\n    case TypeKind.F64: return TypeRef.F64;\n    case TypeKind.V128: return TypeRef.V128;\n    case TypeKind.Funcref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Func, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Externref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Extern, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Anyref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Any, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Eqref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Eq, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.I31ref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.I31, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Dataref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Data, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Arrayref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Array, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Stringref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.String, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.StringviewWTF8: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF8, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.StringviewWTF16: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF16, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.StringviewIter: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewIter, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Void: assert(false); // invalid here\n  }\n  return 0; // non-basic\n}\n\n/** Determines the packed GC type of the given type, if applicable. */\nfunction determinePackedType(type: Type): PackedType {\n  switch (type.kind) {\n    case TypeKind.Bool:\n    case TypeKind.I8:\n    case TypeKind.U8: return PackedType.I8;\n    case TypeKind.I16:\n    case TypeKind.U16: return PackedType.I16;\n  }\n  return PackedType.NotPacked;\n}\n\n/** Recursively prepares the given GC type, potentially returning a temporary type. */\nfunction prepareType(builder: binaryen.TypeBuilderRef, seen: Map<Type,HeapTypeRef>, type: Type): TypeRef {\n  // Obtain basic type if applicable\n  if (type == Type.void) return TypeRef.None;\n  let typeRef = tryEnsureBasicType(type);\n  if (typeRef) return typeRef;\n\n  assert(!type.is(TypeFlags.Nullable)); // operating on non-nullable types only\n\n  // Reuse existing type\n  if (typeRef = type.ref) return typeRef;\n\n  // Reuse seen temporary type if it exists\n  if (seen.has(type)) {\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` prepare ${type.toString()} (seen)`);\n    }\n    return changetype<HeapTypeRef>(seen.get(type));\n  }\n\n  if (DEBUG_TYPEBUILDER) {\n    console.log(`prepare ${type.toString()}`);\n  }\n\n  // Otherwise construct a new class type. Note that arrays are not supported, as these would\n  // have to involve a Wasm-level `array`, either wrapped in `Array` or `Uint8Array` etc., or\n  // directly representing an `ArrayBuffer` or `StaticArray`. TBD.\n  let classReference = type.getClass();\n  if (classReference) {\n    // Make sure the base type has been built prior, at a lower index\n    let base = classReference.base;\n    let baseRef: HeapTypeRef = 0;\n    if (base) baseRef = prepareType(builder, seen, base.type); // might be temporary, is non-nullable\n\n    // Block this index with a temporary type and cache\n    let index = binaryen._TypeBuilderGetSize(builder);\n    binaryen._TypeBuilderGrow(builder, 1);\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` block [${index}]: ${type.toString()}`);\n    }\n    let heapTypeRef = binaryen._TypeBuilderGetTempHeapType(builder, index);\n    typeRef = binaryen._TypeBuilderGetTempRefType(builder, heapTypeRef, false);\n    seen.set(type, typeRef);\n\n    // Populate the struct type (TODO: names)\n    let fieldTypes = new Array<TypeRef>();\n    let packedTypes = new Array<PackedType>();\n    let fieldMutables = new Array<u32>();\n    let members = classReference.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        // only interested in fields (resolved during class finalization)\n        let property = (<PropertyPrototype>member).instance;\n        if (!property || !property.isField) continue;\n        let fieldType = property.type;\n        if (DEBUG_TYPEBUILDER) {\n          console.log(`  field ${fieldType.toString()}`);\n        }\n        if (fieldType.is(TypeFlags.Nullable)) {\n          fieldTypes.push(\n            binaryen._TypeBuilderGetTempRefType(\n              builder,\n              binaryen._BinaryenTypeGetHeapType(\n                prepareType(builder, seen, fieldType.nonNullableType)\n              ),\n              true\n            )\n          );\n        } else {\n          fieldTypes.push(prepareType(builder, seen, fieldType));\n        }\n        packedTypes.push(determinePackedType(fieldType));\n        fieldMutables.push(1);\n      }\n    }\n    let cArrFT = allocPtrArray(fieldTypes);\n    let cArrPT = allocU32Array(packedTypes);\n    let cArrFM = allocU32Array(fieldMutables);\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` concretize [${index}]: ${type.toString()}`);\n    }\n    binaryen._TypeBuilderSetStructType(builder, index, cArrFT, cArrPT, cArrFM, fieldTypes.length);\n    if (base) {\n      if (DEBUG_TYPEBUILDER) {\n        console.log(` set super [${index}]: ${type.toString()} <: ${base.type.toString()} ${baseRef == base.type.ref ? \" (known)\" : \"\"}`);\n      }\n      binaryen._TypeBuilderSetSubType(builder, index, binaryen._BinaryenTypeGetHeapType(baseRef));\n    }\n    binaryen._free(cArrFM);\n    binaryen._free(cArrPT);\n    binaryen._free(cArrFT);\n    return typeRef;\n  }\n\n  // Respectively a new signature type\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n\n    // Block this index with a temporary type and cache\n    let index = binaryen._TypeBuilderGetSize(builder);\n    binaryen._TypeBuilderGrow(builder, 1);\n    let tempTypeRef = binaryen._TypeBuilderGetTempRefType(\n      builder,\n      binaryen._TypeBuilderGetTempHeapType(builder, index),\n      false\n    );\n    seen.set(type, tempTypeRef);\n\n    let paramTypes = new Array<TypeRef>();\n    let resultTypes = new Array<TypeRef>();\n    let parameterTypes = signatureReference.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let paramType = parameterTypes[i];\n      if (paramType.is(TypeFlags.Nullable)) {\n        paramTypes.push(\n          binaryen._TypeBuilderGetTempRefType(\n            builder,\n            binaryen._BinaryenTypeGetHeapType(\n              prepareType(builder, seen, paramType.nonNullableType)\n            ),\n            true\n          )\n        );\n      } else {\n        paramTypes.push(prepareType(builder, seen, paramType));\n      }\n    }\n    let returnType = signatureReference.returnType;\n    resultTypes.push(\n      returnType == Type.void\n        ? TypeRef.None\n        : returnType.is(TypeFlags.Nullable)\n          ? binaryen._TypeBuilderGetTempRefType(\n              builder,\n              binaryen._BinaryenTypeGetHeapType(\n                prepareType(builder, seen, returnType.nonNullableType)\n              ),\n              true\n            )\n          : prepareType(builder, seen, returnType)\n    );\n    let tempParamType: TypeRef;\n    if (paramTypes.length > 1) {\n      let cArrPT = allocPtrArray(paramTypes);\n      tempParamType = binaryen._TypeBuilderGetTempTupleType(builder, cArrPT, paramTypes.length);\n      binaryen._free(cArrPT);\n    } else {\n      tempParamType = paramTypes.length ? paramTypes[0] : TypeRef.None;\n    }\n    let tempResultType: TypeRef;\n    if (resultTypes.length > 1) {\n      let cArrRT = allocPtrArray(resultTypes);\n      tempResultType = binaryen._TypeBuilderGetTempTupleType(builder, cArrRT, resultTypes.length);\n      binaryen._free(cArrRT);\n    } else {\n      tempResultType = resultTypes[0];\n    }\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` concretize [${index}]: ${type.toString()}`);\n    }\n    binaryen._TypeBuilderSetSignatureType(builder, index, tempParamType, tempResultType);\n    return tempTypeRef;\n  }\n\n  throw new Error(`unexpected complex type: ${type.toString()}`);\n}\n", "/**\n * @fileoverview A concurrent code flow analyzer.\n *\n * Flows keep track of compilation state and can be queried for various\n * conditions, like whether the current branch always terminates, whether\n * a local is known to be non-null or whether an expression has possibly\n * overflown its value range.\n *\n * To accomplish this, compilation of each function begins with a clean\n * flow populated with initial local states etc. While compilation\n * progresses, statements and expressions update flow state while control\n * constructs fork, potentially add scoped locals and later merge these\n * forked branches as necessary.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\n\nimport {\n  Program,\n  Local,\n  Function,\n  Element,\n  ElementKind,\n  Class,\n  TypedElement,\n  mangleInternalName,\n  Property,\n  PropertyPrototype\n} from \"./program\";\n\nimport {\n  TypeRef,\n  ExpressionId,\n  ExpressionRef,\n  BinaryOp,\n  UnaryOp,\n\n  getExpressionId,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetValue,\n  getGlobalGetName,\n  getBinaryOp,\n  getBinaryLeft,\n  getConstValueI32,\n  getBinaryRight,\n  getUnaryOp,\n  getExpressionType,\n  getConstValueI64Low,\n  getConstValueF32,\n  getConstValueF64,\n  getLoadBytes,\n  isLoadSigned,\n  getBlockName,\n  getBlockChildCount,\n  getBlockChildAt,\n  getIfTrue,\n  getIfFalse,\n  getSelectThen,\n  getSelectElse,\n  getCallTarget,\n  getLocalSetIndex,\n  getIfCondition,\n  getUnaryValue,\n  getCallOperandAt,\n  getCallOperandCount,\n  isConstZero,\n  isConstNonZero\n} from \"./module\";\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  UncheckedBehavior\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Node\n} from \"./ast\";\n\nimport {\n  cloneMap\n} from \"./util\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Control flow flags indicating specific conditions. */\nexport const enum FlowFlags {\n  /** No specific conditions. */\n  None = 0,\n\n  // categorical\n\n  /** This flow always returns. */\n  Returns = 1 << 0,\n  /** This flow always returns a wrapped value. */\n  ReturnsWrapped = 1 << 1,\n  /** This flow always returns a non-null value. */\n  ReturnsNonNull = 1 << 2,\n  /** This flow always throws. */\n  Throws = 1 << 3,\n  /** This flow always breaks. */\n  Breaks = 1 << 4,\n  /** This flow always continues. */\n  Continues = 1 << 5,\n  /** This flow always accesses `this`. Constructors only. */\n  AccessesThis = 1 << 6,\n  /** This flow always calls `super`. Constructors only. */\n  CallsSuper = 1 << 7,\n  /** This flow always terminates (returns, throws or continues). */\n  Terminates = 1 << 8, // Note that this doesn't cover BREAKS, which is separate\n\n  // conditional\n\n  /** This flow conditionally returns in a child flow. */\n  ConditionallyReturns = 1 << 9,\n  /** This flow conditionally throws in a child flow. */\n  ConditionallyThrows = 1 << 10,\n  /** This flow conditionally breaks in a child flow. */\n  ConditionallyBreaks = 1 << 11,\n  /** This flow conditionally continues in a child flow. */\n  ConditionallyContinues = 1 << 12,\n  /** This flow conditionally accesses `this` in a child flow. Constructors only. */\n  ConditionallyAccessesThis = 1 << 13,\n  /** This flow may return a non-this value. Constructors only. */\n  MayReturnNonThis = 1 << 14,\n\n  // other\n\n  /** This is a flow with explicitly disabled bounds checking. */\n  UncheckedContext = 1 << 15,\n  /** This is a flow compiling a constructor parameter. */\n  CtorParamContext = 1 << 16,\n\n  // masks\n\n  /** Any categorical flag. */\n  AnyCategorical = FlowFlags.Returns\n                 | FlowFlags.ReturnsWrapped\n                 | FlowFlags.ReturnsNonNull\n                 | FlowFlags.Throws\n                 | FlowFlags.Breaks\n                 | FlowFlags.Continues\n                 | FlowFlags.AccessesThis\n                 | FlowFlags.CallsSuper\n                 | FlowFlags.Terminates,\n\n  /** Any conditional flag. */\n  AnyConditional = FlowFlags.ConditionallyReturns\n                 | FlowFlags.ConditionallyThrows\n                 | FlowFlags.ConditionallyBreaks\n                 | FlowFlags.ConditionallyContinues\n                 | FlowFlags.ConditionallyAccessesThis\n}\n\n/** Flags indicating the current state of a local. */\nexport const enum LocalFlags {\n  /** No specific conditions. */\n  None = 0,\n\n  /** Local is constant. */\n  Constant = 1 << 0,\n  /** Local is properly wrapped. Relevant for small integers. */\n  Wrapped = 1 << 1,\n  /** Local is non-null. */\n  NonNull = 1 << 2,\n  /** Local is initialized. */\n  Initialized = 1 << 3\n}\n\n/** Flags indicating the current state of a field. */\nexport const enum FieldFlags {\n  None = 0,\n  Initialized = 1 << 0\n}\n\n/** Condition kinds. */\nexport const enum ConditionKind {\n  /** Outcome of the condition is unknown */\n  Unknown,\n  /** Condition is always true. */\n  True,\n  /** Condition is always false. */\n  False\n}\n\n/** A control flow evaluator. */\nexport class Flow {\n\n  /** Creates the default top-level flow of the specified function. */\n  static createDefault(targetFunction: Function): Flow {\n    let flow = new Flow(targetFunction);\n    if (targetFunction.is(CommonFlags.Constructor)) {\n      flow.initThisFieldFlags();\n    }\n    if (targetFunction.program.options.uncheckedBehavior === UncheckedBehavior.Always) {\n      flow.set(FlowFlags.UncheckedContext);\n    }\n    return flow;\n  }\n\n  /** Creates an inline flow, compiling `inlineFunction` into `targetFunction`. */\n  static createInline(targetFunction: Function, inlineFunction: Function): Flow {\n    // Note that `targetFunction` and `inlineFunction` can be the same function\n    // when it is inlined into itself.\n    let flow = new Flow(targetFunction, inlineFunction);\n    flow.inlineReturnLabel = `${inlineFunction.internalName}|inlined.${(inlineFunction.nextInlineId++)}`;\n    if (inlineFunction.is(CommonFlags.Constructor)) {\n      flow.initThisFieldFlags();\n    }\n    if (targetFunction.program.options.uncheckedBehavior === UncheckedBehavior.Always) {\n      flow.set(FlowFlags.UncheckedContext);\n    }\n    return flow;\n  }\n\n  private constructor(\n    /** Target function this flow generates code into. */\n    public targetFunction: Function,\n    /** Inline function this flow generates code from, if any. */\n    public inlineFunction: Function | null = null\n  ) {\n    // Setup is performed above so inline ids and field flags are not reset\n    // when forking flows, which also uses the constructor.\n  }\n\n  /** Parent flow. */\n  parent: Flow | null = null;\n  /** Outer flow. Only relevant for first-class functions. */\n  outer: Flow | null = null;\n  /** Flow flags indicating specific conditions. */\n  flags: FlowFlags = FlowFlags.None;\n  /** The label we break to when encountering a continue statement. */\n  continueLabel: string | null = null;\n  /** The label we break to when encountering a break statement. */\n  breakLabel: string | null = null;\n  /** Scoped local variables. */\n  scopedLocals: Map<string,Local> | null = null;\n  /** Local flags. */\n  localFlags: LocalFlags[] = [];\n  /** Field flags on `this`. Constructors only. */\n  thisFieldFlags: Map<Property,FieldFlags> | null = null;\n  /** The label we break to when encountering a return statement, when inlining. */\n  inlineReturnLabel: string | null = null;\n  /** Alternative flows if a compound expression is true-ish. */\n  trueFlows: Map<ExpressionRef,Flow> | null = null;\n  /** Alternative flows if a compound expression is false-ish. */\n  falseFlows: Map<ExpressionRef,Flow> | null = null;\n\n  /** Tests if this is an inline flow. */\n  get isInline(): bool {\n    return this.inlineFunction != null;\n  }\n\n  /** Gets the source function being compiled. Differs from target when inlining. */\n  get sourceFunction(): Function {\n    // Obtaining the source function is useful when resolving elements relative\n    // to their source location. Note that the source function does not necessarily\n    // materialize in the binary, as it might be inlined. Code, locals, etc. must\n    // always be added to / maintained in the materializing target function instead.\n    let inlineFunction = this.inlineFunction;\n    if (inlineFunction) return inlineFunction;\n    return this.targetFunction;\n  }\n\n  /** Gets the program this flow belongs to. */\n  get program(): Program {\n    return this.targetFunction.program;\n  }\n\n  /** Gets the current return type. */\n  get returnType(): Type {\n    return this.sourceFunction.signature.returnType;\n  }\n\n  /** Gets the current contextual type arguments. */\n  get contextualTypeArguments(): Map<string,Type> | null {\n    return this.sourceFunction.contextualTypeArguments;\n  }\n\n  /** Tests if this flow has the specified flag or flags. */\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this flow has one of the specified flags. */\n  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets the specified flag or flags. */\n  set(flag: FlowFlags): void { this.flags |= flag; }\n  /** Unsets the specified flag or flags. */\n  unset(flag: FlowFlags): void { this.flags &= ~flag; }\n\n  deriveConditionalFlags(): FlowFlags {\n    let condiFlags = this.flags & FlowFlags.AnyConditional;\n    if (this.is(FlowFlags.Returns)) {\n      condiFlags |= FlowFlags.ConditionallyReturns;\n    }\n    if (this.is(FlowFlags.Throws)) {\n      condiFlags |= FlowFlags.ConditionallyThrows;\n    }\n    if (this.is(FlowFlags.Breaks)) {\n      condiFlags |= FlowFlags.ConditionallyBreaks;\n    }\n    if (this.is(FlowFlags.Continues)) {\n      condiFlags |= FlowFlags.ConditionallyContinues;\n    }\n    if (this.is(FlowFlags.AccessesThis)) {\n      condiFlags |= FlowFlags.ConditionallyAccessesThis;\n    }\n    return condiFlags;\n  }\n\n  /** Forks this flow to a child flow. */\n  fork(\n    /** Whether a new break context is established, e.g. by a block. */\n    newBreakContext: bool = false,\n    /** Whether a new continue context is established, e.g. by a loop. */\n    newContinueContext: bool = newBreakContext\n  ): Flow {\n    let branch = new Flow(this.targetFunction, this.inlineFunction);\n    branch.parent = this;\n    branch.flags = this.flags;\n    branch.outer = this.outer;\n    if (newBreakContext) {\n      branch.flags &= ~(\n        FlowFlags.Breaks |\n        FlowFlags.ConditionallyBreaks\n      );\n    } else {\n      branch.breakLabel = this.breakLabel;\n    }\n    if (newContinueContext) {\n      branch.flags &= ~(\n        FlowFlags.Continues |\n        FlowFlags.ConditionallyContinues\n      );\n    } else {\n      branch.continueLabel = this.continueLabel;\n    }\n    branch.localFlags = this.localFlags.slice();\n    if (this.sourceFunction.is(CommonFlags.Constructor)) {\n      let thisFieldFlags = assert(this.thisFieldFlags);\n      branch.thisFieldFlags = cloneMap(thisFieldFlags);\n    } else {\n      assert(!this.thisFieldFlags);\n    }\n    branch.inlineReturnLabel = this.inlineReturnLabel;\n    return branch;\n  }\n\n  /** Forks this flow to a child flow where `condExpr` is true-ish. */\n  forkThen(\n    /** Condition that turned out to be true. */\n    condExpr: ExpressionRef,\n    /** Whether a new break context is established, e.g. by a block. */\n    newBreakContext: bool = false,\n    /** Whether a new continue context is established, e.g. by a loop. */\n    newContinueContext: bool = newBreakContext\n  ): Flow {\n    let flow = this.fork(newBreakContext, newContinueContext);\n    let trueFlows = this.trueFlows;\n    if (trueFlows && trueFlows.has(condExpr)) {\n      flow.inherit(changetype<Flow>(trueFlows.get(condExpr)));\n    }\n    flow.inheritNonnullIfTrue(condExpr);\n    return flow;\n  }\n\n  /** Remembers the alternative flow if `condExpr` turns out `true`. */\n  noteThen(condExpr: ExpressionRef, trueFlow: Flow): void {\n    let trueFlows = this.trueFlows;\n    if (!trueFlows) this.trueFlows = trueFlows = new Map();\n    trueFlows.set(condExpr, trueFlow);\n  }\n\n  /** Forks this flow to a child flow where `condExpr` is false-ish. */\n  forkElse(\n    /** Condition that turned out to be false. */\n    condExpr: ExpressionRef\n  ): Flow {\n    let flow = this.fork();\n    let falseFlows = this.falseFlows;\n    if (falseFlows && falseFlows.has(condExpr)) {\n      flow.inherit(changetype<Flow>(falseFlows.get(condExpr)));\n    }\n    flow.inheritNonnullIfFalse(condExpr);\n    return flow;\n  }\n\n  /** Remembers the alternative flow if `condExpr` turns out `false`. */\n  noteElse(condExpr: ExpressionRef, falseFlow: Flow): void {\n    let falseFlows = this.falseFlows;\n    if (!falseFlows) this.falseFlows = falseFlows = new Map();\n    falseFlows.set(condExpr, falseFlow);\n  }\n\n  /** Gets a free temporary local of the specified type. */\n  getTempLocal(type: Type): Local {\n    let local = this.targetFunction.addLocal(type);\n    this.unsetLocalFlag(local.index, ~0);\n    return local;\n  }\n\n  /** Gets the scoped local of the specified name. */\n  getScopedLocal(name: string): Local | null {\n    let scopedLocals = this.scopedLocals;\n    if (scopedLocals && scopedLocals.has(name)) return assert(scopedLocals.get(name));\n    return null;\n  }\n\n  /** Adds a new scoped local of the specified name. */\n  addScopedLocal(name: string, type: Type): Local {\n    let scopedLocal = this.getTempLocal(type);\n    scopedLocal.name = name;\n    scopedLocal.internalName = mangleInternalName(name, scopedLocal.parent, false);\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedLocal.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedLocal);\n    return scopedLocal;\n  }\n\n  /** Adds a new scoped dummy local of the specified name. */\n  addScopedDummyLocal(name: string, type: Type, declarationNode: Node): Local {\n    let scopedDummy = new Local(name, -1, type, this.targetFunction);\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else if (scopedLocals.has(name)) {\n      this.program.error(\n        DiagnosticCode.Cannot_redeclare_block_scoped_variable_0,\n        declarationNode.range, name\n      );\n    }\n    scopedDummy.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedDummy);\n    return scopedDummy;\n  }\n\n  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */\n  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) {\n      this.scopedLocals = scopedLocals = new Map();\n    } else if (scopedLocals.has(name)) {\n      let existingLocal = assert(scopedLocals.get(name));\n      if (reportNode) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range,\n            existingLocal.declaration.name.range,\n            name\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range, name\n          );\n        }\n      }\n      return existingLocal;\n    }\n    assert(index < this.targetFunction.localsByIndex.length);\n    let scopedAlias = new Local(name, index, type, this.targetFunction);\n    scopedAlias.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedAlias);\n    return scopedAlias;\n  }\n\n  /** Frees a single scoped local by its name. */\n  freeScopedDummyLocal(name: string): void {\n    let scopedLocals = assert(this.scopedLocals);\n    assert(scopedLocals.has(name));\n    let local = assert(scopedLocals.get(name));\n    assert(local.index == -1);\n    scopedLocals.delete(name);\n  }\n\n  /** Looks up the local of the specified name in the current scope. */\n  lookupLocal(name: string): Local | null {\n    let current: Flow | null = this;\n    do {\n      let scope = current.scopedLocals;\n      if (scope && scope.has(name)) return assert(scope.get(name));\n      current = current.parent;\n    } while (current);\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to the scope of this flow. */\n  lookup(name: string): Element | null {\n    let element = this.lookupLocal(name);\n    if (element) return element;\n    return this.sourceFunction.lookup(name);\n  }\n\n  /** Tests if the local at the specified index has the specified flag or flags. */\n  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    let localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;\n  }\n\n  /** Tests if the local at the specified index has any of the specified flags. */\n  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    let localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;\n  }\n\n  /** Sets the specified flag or flags on the local at the specified index. */\n  setLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    let localFlags = this.localFlags;\n    let flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags | flag;\n  }\n\n  /** Unsets the specified flag or flags on the local at the specified index. */\n  unsetLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    let localFlags = this.localFlags;\n    let flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags & ~flag;\n  }\n\n  /** Initializes `this` field flags. */\n  initThisFieldFlags(): void {\n    let sourceFunction = this.sourceFunction;\n    assert(sourceFunction.is(CommonFlags.Constructor));\n    let parent = sourceFunction.parent;\n    assert(parent.kind == ElementKind.Class);\n    let classInstance = <Class>parent;\n    this.thisFieldFlags = new Map();\n    let members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        // only interested in fields (resolved during class finalization)\n        let property = (<PropertyPrototype>member).instance;\n        if (!property || !property.isField) continue;\n        if (\n          // guaranteed by super\n          property.prototype.parent != classInstance ||\n          // has field initializer\n          property.initializerNode ||\n          // is initialized as a ctor parameter\n          property.prototype.parameterIndex != -1 ||\n          // is safe to initialize with zero\n          property.type.isAny(TypeFlags.Value | TypeFlags.Nullable)\n        ) {\n          this.setThisFieldFlag(property, FieldFlags.Initialized);\n        }\n      }\n    }\n  }\n\n  /** Tests if the specified `this` field has the specified flag or flags. */\n  isThisFieldFlag(field: Property, flag: FieldFlags): bool {\n    let fieldFlags = this.thisFieldFlags;\n    if (fieldFlags != null && fieldFlags.has(field)) {\n      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;\n    }\n    return false;\n  }\n\n  /** Sets the specified flag or flags on the given `this` field. */\n  setThisFieldFlag(field: Property, flag: FieldFlags): void {\n    let fieldFlags = this.thisFieldFlags;\n    if (fieldFlags) {\n      assert(this.sourceFunction.is(CommonFlags.Constructor));\n      if (fieldFlags.has(field)) {\n        let flags = changetype<FieldFlags>(fieldFlags.get(field));\n        fieldFlags.set(field, flags | flag);\n      } else {\n        fieldFlags.set(field, flag);\n      }\n    } else {\n      assert(!this.sourceFunction.is(CommonFlags.Constructor));\n    }\n  }\n\n  /** Pushes a new control flow label, for example when entering a loop that one can `break` from. */\n  pushControlFlowLabel(): i32 {\n    let targetFunction = this.targetFunction;\n    let id = targetFunction.nextBreakId++;\n    let stack = targetFunction.breakStack;\n    if (!stack) targetFunction.breakStack = [ id ];\n    else stack.push(id);\n    return id;\n  }\n\n  /** Pops the most recent control flow label and validates that it matches. */\n  popControlFlowLabel(expectedLabel: i32): void {\n    let targetFunction = this.targetFunction;\n    let stack = assert(targetFunction.breakStack); // should exist\n    assert(stack.length); // should not be empty\n    assert(stack.pop() == expectedLabel); // should match\n  }\n\n  /** Inherits flags of another flow into this one, i.e. a finished inner block. */\n  inherit(other: Flow): void {\n    assert(other.targetFunction == this.targetFunction);\n    let otherFlags = other.flags;\n\n    // respective inner flags are irrelevant if contexts differ\n    if (this.breakLabel != other.breakLabel) {\n      if (otherFlags & (FlowFlags.Breaks | FlowFlags.ConditionallyBreaks)) {\n        otherFlags &= ~FlowFlags.Terminates;\n      }\n      otherFlags &= ~(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    }\n    if (this.continueLabel != other.continueLabel) {\n      otherFlags &= ~(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    }\n\n    this.flags = this.flags | otherFlags; // what happens before is still true\n    this.localFlags = other.localFlags;\n    this.thisFieldFlags = other.thisFieldFlags;\n  }\n\n\n  /** Merges only the side effects of a branch, i.e. when not taken. */\n  mergeSideEffects(other: Flow): void {\n    assert(other.targetFunction == this.targetFunction);\n\n    let thisFlags = this.flags;\n    let otherFlags = other.flags;\n    let newFlags = FlowFlags.None;\n\n    if (thisFlags & FlowFlags.Returns) { // nothing can change that\n      newFlags |= FlowFlags.Returns;\n    } else if (otherFlags & FlowFlags.Returns) {\n      newFlags |= FlowFlags.ConditionallyReturns;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyReturns;\n    }\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.ReturnsWrapped;\n    newFlags |= thisFlags & otherFlags & FlowFlags.ReturnsNonNull;\n\n    if (thisFlags & FlowFlags.Throws) { // nothing can change that\n      newFlags |= FlowFlags.Throws;\n    } else if (otherFlags & FlowFlags.Throws) {\n      newFlags |= FlowFlags.ConditionallyThrows;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyThrows;\n    }\n\n    if (thisFlags & FlowFlags.Breaks) { // nothing can change that\n      newFlags |= FlowFlags.Breaks;\n    } else if (other.breakLabel == this.breakLabel) {\n      if (otherFlags & FlowFlags.Breaks) {\n        newFlags |= FlowFlags.ConditionallyBreaks;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyBreaks;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.ConditionallyBreaks;\n    }\n\n    if (thisFlags & FlowFlags.Continues) { // nothing can change that\n      newFlags |= FlowFlags.Continues;\n    } else if (other.continueLabel == this.continueLabel) {\n      if (otherFlags & FlowFlags.Continues) {\n        newFlags |= FlowFlags.ConditionallyContinues;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyContinues;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.ConditionallyContinues;\n    }\n\n    if (thisFlags & FlowFlags.AccessesThis) { // can become conditional\n      if (otherFlags & FlowFlags.AccessesThis) {\n        newFlags |= FlowFlags.AccessesThis;\n      } else {\n        newFlags |= FlowFlags.ConditionallyAccessesThis;\n      }\n    } else if (otherFlags & FlowFlags.AccessesThis) {\n      newFlags |= FlowFlags.ConditionallyAccessesThis;\n    }\n\n    // may be the case in any\n    newFlags |= (thisFlags | otherFlags) & FlowFlags.MayReturnNonThis;\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.CallsSuper;\n\n    if (thisFlags & FlowFlags.Terminates) { // nothing can change that\n      newFlags |= FlowFlags.Terminates;\n    }\n\n    this.flags = newFlags | (thisFlags & (FlowFlags.UncheckedContext | FlowFlags.CtorParamContext));\n  }\n\n  /** Merges a branch joining again with this flow, i.e. then without else. */\n  mergeBranch(other: Flow): void {\n    this.mergeSideEffects(other);\n\n    // Local flags matter if the branch does not terminate\n    let thisLocalFlags = this.localFlags;\n    let numThisLocalFlags = thisLocalFlags.length;\n    let otherLocalFlags = other.localFlags;\n    let numOtherLocalFlags = otherLocalFlags.length;\n    let maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);\n    for (let i = 0; i < maxLocalFlags; ++i) {\n      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;\n      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;\n      thisLocalFlags[i] = thisFlags & otherFlags & (\n        LocalFlags.Constant  |\n        LocalFlags.Wrapped   |\n        LocalFlags.NonNull   |\n        LocalFlags.Initialized\n      );\n    }\n\n    // field flags do not matter here since there's only INITIALIZED, which can\n    // only be set if it has been observed prior to entering the branch.\n  }\n\n  /** Inherits two alternate branches to become this flow, i.e. then with else. */\n  inheritAlternatives(left: Flow, right: Flow): void {\n    assert(left.targetFunction == right.targetFunction);\n    assert(left.targetFunction == this.targetFunction);\n    // Differs from `mergeBranch` in that the alternatives are intersected to\n    // then become this branch.\n\n    let leftFlags = left.flags;\n    let rightFlags = right.flags;\n    let newFlags = FlowFlags.None;\n\n    if (leftFlags & FlowFlags.Returns) {\n      if (rightFlags & FlowFlags.Returns) {\n        newFlags |= FlowFlags.Returns;\n      } else {\n        newFlags |= FlowFlags.ConditionallyReturns;\n      }\n    } else if (rightFlags & FlowFlags.Returns) {\n      newFlags |= FlowFlags.ConditionallyReturns;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyReturns;\n    }\n\n    if ((leftFlags & FlowFlags.ReturnsWrapped) && (rightFlags & FlowFlags.ReturnsWrapped)) {\n      newFlags |= FlowFlags.ReturnsWrapped;\n    }\n\n    if ((leftFlags & FlowFlags.ReturnsNonNull) && (rightFlags & FlowFlags.ReturnsNonNull)) {\n      newFlags |= FlowFlags.ReturnsNonNull;\n    }\n\n    if (leftFlags & FlowFlags.Throws) {\n      if (rightFlags & FlowFlags.Throws) {\n        newFlags |= FlowFlags.Throws;\n      } else {\n        newFlags |= FlowFlags.ConditionallyThrows;\n      }\n    } else if (rightFlags & FlowFlags.Throws) {\n      newFlags |= FlowFlags.ConditionallyThrows;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyThrows;\n    }\n\n    if (leftFlags & FlowFlags.Breaks) {\n      if (rightFlags & FlowFlags.Breaks) {\n        newFlags |= FlowFlags.Breaks;\n      } else {\n        newFlags |= FlowFlags.ConditionallyBreaks;\n      }\n    } else if (rightFlags & FlowFlags.Breaks) {\n      newFlags |= FlowFlags.ConditionallyBreaks;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyBreaks;\n    }\n\n    if (leftFlags & FlowFlags.Continues) {\n      if (rightFlags & FlowFlags.Continues) {\n        newFlags |= FlowFlags.Continues;\n      } else {\n        newFlags |= FlowFlags.ConditionallyContinues;\n      }\n    } else if (rightFlags & FlowFlags.Continues) {\n      newFlags |= FlowFlags.ConditionallyContinues;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyContinues;\n    }\n\n    if (leftFlags & FlowFlags.AccessesThis) {\n      if (rightFlags & FlowFlags.AccessesThis) {\n        newFlags |= FlowFlags.AccessesThis;\n      } else {\n        newFlags |= FlowFlags.ConditionallyAccessesThis;\n      }\n    } else if (rightFlags & FlowFlags.AccessesThis) {\n      newFlags |= FlowFlags.ConditionallyAccessesThis;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyAccessesThis;\n    }\n\n    newFlags |= (leftFlags | rightFlags) & FlowFlags.MayReturnNonThis;\n\n    if ((leftFlags & FlowFlags.CallsSuper) && (rightFlags & FlowFlags.CallsSuper)) {\n      newFlags |= FlowFlags.CallsSuper;\n    }\n\n    if ((leftFlags & FlowFlags.Terminates) && (rightFlags & FlowFlags.Terminates)) {\n      newFlags |= FlowFlags.Terminates;\n    }\n\n    this.flags = newFlags | (this.flags & (FlowFlags.UncheckedContext | FlowFlags.CtorParamContext));\n\n    // local flags\n    let thisLocalFlags = this.localFlags;\n    if (leftFlags & FlowFlags.Terminates) {\n      if (!(rightFlags & FlowFlags.Terminates)) {\n        let rightLocalFlags = right.localFlags;\n        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {\n          thisLocalFlags[i] = rightLocalFlags[i];\n        }\n      }\n    } else if (rightFlags & FlowFlags.Terminates) {\n      let leftLocalFlags = left.localFlags;\n      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {\n        thisLocalFlags[i] = leftLocalFlags[i];\n      }\n    } else {\n      let leftLocalFlags = left.localFlags;\n      let numLeftLocalFlags = leftLocalFlags.length;\n      let rightLocalFlags = right.localFlags;\n      let numRightLocalFlags = rightLocalFlags.length;\n      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);\n      for (let i = 0; i < maxLocalFlags; ++i) {\n        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;\n        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;\n        thisLocalFlags[i] = leftFlags & rightFlags & (\n          LocalFlags.Constant  |\n          LocalFlags.Wrapped   |\n          LocalFlags.NonNull   |\n          LocalFlags.Initialized\n        );\n      }\n    }\n\n    // field flags (currently only INITIALIZED, so can simplify)\n    let leftFieldFlags = left.thisFieldFlags;\n    if (leftFieldFlags) {\n      let newFieldFlags = new Map<Property,FieldFlags>();\n      let rightFieldFlags = assert(right.thisFieldFlags);\n      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {\n        let key = _keys[i];\n        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));\n        if (\n          (leftFlags & FieldFlags.Initialized) != 0 && rightFieldFlags.has(key) &&\n          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.Initialized)\n        ) {\n          newFieldFlags.set(key, FieldFlags.Initialized);\n        }\n      }\n      this.thisFieldFlags = newFieldFlags;\n    } else {\n      assert(!right.thisFieldFlags);\n    }\n  }\n\n  /** Tests if recompilation is needed due to incompatible local flags between loops, and resets if necessary. */\n  resetIfNeedsRecompile(\n    /** Resulting flow of the current compilation attempt. */\n    other: Flow,\n    /** Number of locals before the compilation attempt. */\n    numLocalsBefore: i32\n  ): bool {\n    let numThisLocalFlags = this.localFlags.length;\n    let numOtherLocalFlags = other.localFlags.length;\n    let targetFunction = this.targetFunction;\n    assert(targetFunction == other.targetFunction);\n    let localsByIndex = targetFunction.localsByIndex;\n    assert(localsByIndex == other.targetFunction.localsByIndex);\n    let needsRecompile = false;\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      let local = localsByIndex[i];\n      let type = local.type;\n      if (type.isShortIntegerValue) {\n        if (this.isLocalFlag(i, LocalFlags.Wrapped) && !other.isLocalFlag(i, LocalFlags.Wrapped)) {\n          this.unsetLocalFlag(i, LocalFlags.Wrapped); // assume not wrapped\n          needsRecompile = true;\n        }\n      }\n      if (type.isNullableReference) {\n        if (this.isLocalFlag(i, LocalFlags.NonNull) && !other.isLocalFlag(i, LocalFlags.NonNull)) {\n          this.unsetLocalFlag(i, LocalFlags.NonNull); // assume possibly null\n          needsRecompile = true;\n        }\n      }\n    }\n    if (needsRecompile) {\n      // Reset function locals to state before the compilation attempt\n      assert(localsByIndex.length >= numLocalsBefore);\n      localsByIndex.length = numLocalsBefore;\n      if (this.localFlags.length > numLocalsBefore) {\n        this.localFlags.length = numLocalsBefore;\n      }\n    }\n    return needsRecompile;\n  }\n\n  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */\n  isNonnull(expr: ExpressionRef, type: Type): bool {\n    if (!type.isNullableReference) return true;\n    // below, only teeLocal/getLocal are relevant because these are the only expressions that\n    // depend on a dynamic nullable state (flag = LocalFlags.NonNull), while everything else\n    // has already been handled by the nullable type check above.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.targetFunction.localsByIndex[getLocalSetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NonNull, false);\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NonNull, false);\n      }\n    }\n    return false;\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */\n  private inheritNonnullIfTrue(\n    /** Expression being true. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is true-ish -> Q: how did that happen?\n\n    // The iff argument is useful in situations like\n    //\n    //  if (!ref) {\n    //    ref = new Ref();\n    //  }\n    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null\n    //\n\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.targetFunction.localsByIndex[getLocalSetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NonNull)) {\n          this.setLocalFlag(local.index, LocalFlags.NonNull);\n        }\n        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NonNull)) {\n          this.setLocalFlag(local.index, LocalFlags.NonNull);\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifFalse = getIfFalse(expr);\n        if (ifFalse && isConstZero(ifFalse)) {\n          // Logical AND: (if (condition ifTrue 0))\n          // the only way this had become true is if condition and ifTrue are true\n          this.inheritNonnullIfTrue(getIfCondition(expr), iff);\n          this.inheritNonnullIfTrue(getIfTrue(expr), iff);\n        }\n        break;\n      }\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstNonZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (isConstNonZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (isConstZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        // handle string eq/ne/not overloads\n        let name = getCallTarget(expr);\n        if (name == BuiltinNames.String_eq) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstNonZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n          } else if (isConstNonZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_ne) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n          } else if (isConstZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_not) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfFalse(getCallOperandAt(expr, 0), iff); // !value -> value must have been false\n        } else if (name == BuiltinNames.tostack) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */\n  private inheritNonnullIfFalse(\n    /** Expression being false. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is false-ish -> Q: how did that happen?\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifTrue = getIfTrue(expr);\n        let ifFalse = getIfFalse(expr);\n        if (ifFalse && isConstNonZero(ifTrue)) {\n          // Logical OR: (if (condition 1 ifFalse))\n          // the only way this had become false is if condition and ifFalse are false\n          this.inheritNonnullIfFalse(getIfCondition(expr), iff);\n          this.inheritNonnullIfFalse(getIfFalse(expr), iff);\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          // remember: we want to know how the _entire_ expression became FALSE (!)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // !(FALSE == right) -> right must have been true\n            } else if (isConstZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // !(left == FALSE) -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstNonZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // !(TRUE != right) -> right must have been true\n            } else if (isConstNonZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // !(left != TRUE) -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        // handle string eq/ne/not overloads\n        let name = getCallTarget(expr);\n        if (name == BuiltinNames.String_eq) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // !(FALSE == right) -> right must have been true\n          } else if (isConstZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // !(left == FALSE) -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_ne) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstNonZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // !(TRUE != right) -> right must have been true\n          } else if (isConstNonZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // !(left != TRUE) -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_not) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff); // !(!value) -> value must have been true\n        } else if (name == BuiltinNames.tostack) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfFalse(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the\n   * expression might already have overflown and returns `false` only if the operation neglects\n   * any possible combination of garbage bits being present.\n   */\n  canOverflow(expr: ExpressionRef, type: Type): bool {\n    // TODO: the following catches most common and a few uncommon cases, but there are additional\n    // opportunities here, obviously.\n\n    // types other than i8, u8, i16, u16 and bool do not overflow\n    if (!type.isShortIntegerValue) return false;\n\n    let operand: ExpressionRef;\n    switch (getExpressionId(expr)) {\n\n      // overflows if the local isn't wrapped or the conversion does\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !this.isLocalFlag(local.index, LocalFlags.Wrapped, true)\n            || canConversionOverflow(local.type, type);\n      }\n\n      // overflows if the value does\n      case ExpressionId.LocalSet: { // tee\n        assert(isLocalTee(expr));\n        return this.canOverflow(getLocalSetValue(expr), type);\n      }\n\n      // overflows if the conversion does (globals are wrapped on set)\n      case ExpressionId.GlobalGet: {\n        // TODO: this is inefficient because it has to read a string\n        let global = assert(this.program.elementsByName.get(assert(getGlobalGetName(expr))));\n        assert(global.kind == ElementKind.Global || global.kind == ElementKind.EnumValue);\n        return canConversionOverflow((<TypedElement>global).type, type);\n      }\n\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64:\n          case BinaryOp.EqF32:\n          case BinaryOp.EqF64:\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64:\n          case BinaryOp.NeF32:\n          case BinaryOp.NeF64:\n          case BinaryOp.LtI32:\n          case BinaryOp.LtU32:\n          case BinaryOp.LtI64:\n          case BinaryOp.LtU64:\n          case BinaryOp.LtF32:\n          case BinaryOp.LtF64:\n          case BinaryOp.LeI32:\n          case BinaryOp.LeU32:\n          case BinaryOp.LeI64:\n          case BinaryOp.LeU64:\n          case BinaryOp.LeF32:\n          case BinaryOp.LeF64:\n          case BinaryOp.GtI32:\n          case BinaryOp.GtU32:\n          case BinaryOp.GtI64:\n          case BinaryOp.GtU64:\n          case BinaryOp.GtF32:\n          case BinaryOp.GtF64:\n          case BinaryOp.GeI32:\n          case BinaryOp.GeU32:\n          case BinaryOp.GeI64:\n          case BinaryOp.GeU64:\n          case BinaryOp.GeF32:\n          case BinaryOp.GeF64: return false;\n\n          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped\n          case BinaryOp.MulI32: {\n            return !(\n              (\n                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryRight(expr), type)\n                  )\n                )\n              ) || (\n                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryLeft(expr), type)\n                  )\n                )\n              )\n            );\n          }\n\n          // result won't overflow if one side is a constant less than this type's mask or one side\n          // is wrapped\n          case BinaryOp.AndI32: {\n            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types\n            // because signed value garbage bits must be guaranteed to be equal to the MSB.\n            return !(\n              (\n                (\n                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              ) || (\n                (\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              )\n            );\n          }\n\n          // overflows if the shift doesn't clear potential garbage bits\n          case BinaryOp.ShlI32: {\n            let shift = 32 - type.size;\n            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const\n                || getConstValueI32(operand) < shift;\n          }\n\n          // overflows if the value does and the shift doesn't clear potential garbage bits\n          case BinaryOp.ShrI32: {\n            let shift = 32 - type.size;\n            return this.canOverflow(getBinaryLeft(expr), type) && (\n              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||\n              getConstValueI32(operand) < shift\n            );\n          }\n\n          // overflows if the shift does not clear potential garbage bits. if an unsigned value is\n          // wrapped, it can't overflow.\n          case BinaryOp.ShrU32: {\n            let shift = 32 - type.size;\n            return type.isSignedIntegerValue\n              ? !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) > shift // must clear MSB\n                )\n              : this.canOverflow(getBinaryLeft(expr), type) &&\n                !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) >= shift // can leave MSB\n                );\n          }\n\n          // overflows if any side does\n          case BinaryOp.DivU32:\n          case BinaryOp.RemI32:\n          case BinaryOp.RemU32: {\n            return this.canOverflow(getBinaryLeft(expr), type)\n                || this.canOverflow(getBinaryRight(expr), type);\n          }\n        }\n        break;\n      }\n\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: return false;\n\n          // overflow if the maximum result (32) cannot be represented in the target type\n          case UnaryOp.ClzI32:\n          case UnaryOp.CtzI32:\n          case UnaryOp.PopcntI32: return type.size < 7;\n\n          // sign extensions overflow if result can have high garbage bits in the target type\n          case UnaryOp.Extend8I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 8);\n          case UnaryOp.Extend8I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 8);\n          case UnaryOp.Extend16I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 16);\n          case UnaryOp.Extend16I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 16);\n          case UnaryOp.Extend32I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 32);\n        }\n        break;\n      }\n\n      // overflows if the value cannot be represented in the target type\n      case ExpressionId.Const: {\n        let value: i32 = 0;\n        switch (<u32>getExpressionType(expr)) {\n          case <u32>TypeRef.I32: { value = getConstValueI32(expr); break; }\n          case <u32>TypeRef.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits\n          case <u32>TypeRef.F32: { value = i32(getConstValueF32(expr)); break; }\n          case <u32>TypeRef.F64: { value = i32(getConstValueF64(expr)); break; }\n          case <u32>TypeRef.V128: return false;\n          default: assert(false);\n        }\n        switch (type.kind) {\n          case TypeKind.Bool: return (value & ~1) != 0;\n          case TypeKind.I8:   return value < <i32>i8.MIN_VALUE  || value > <i32>i8.MAX_VALUE;\n          case TypeKind.I16:  return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;\n          case TypeKind.U8:   return value < 0 || value > <i32>u8.MAX_VALUE;\n          case TypeKind.U16:  return value < 0 || value > <i32>u16.MAX_VALUE;\n        }\n        break;\n      }\n\n      // overflows if the conversion does\n      case ExpressionId.Load: {\n        let fromType: Type;\n        let signed = isLoadSigned(expr);\n        switch (getLoadBytes(expr)) {\n          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }\n          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }\n          default: { fromType = signed ? Type.i32 : Type.u32; break; }\n        }\n        return canConversionOverflow(fromType, type);\n      }\n\n      // overflows if the result does, which is either\n      // - the last expression of the block, by contract, if the block doesn't have a label\n      // - the last expression or the value of an inner br if the block has a label (TODO)\n      case ExpressionId.Block: {\n        if (!getBlockName(expr)) {\n          let size = assert(getBlockChildCount(expr));\n          let last = getBlockChildAt(expr, size - 1);\n          return this.canOverflow(last, type);\n        }\n        break;\n      }\n\n      // overflows if either side does\n      case ExpressionId.If: {\n        return this.canOverflow(getIfTrue(expr), type)\n            || this.canOverflow(assert(getIfFalse(expr)), type);\n      }\n\n      // overflows if either side does\n      case ExpressionId.Select: {\n        return this.canOverflow(getSelectThen(expr), type)\n            || this.canOverflow(getSelectElse(expr), type);\n      }\n\n      // overflows if the call does not return a wrapped value or the conversion does\n      case ExpressionId.Call: {\n        let program = this.program;\n        let instancesByName = program.instancesByName;\n        let instanceName = assert(getCallTarget(expr));\n        if (instancesByName.has(instanceName)) {\n          let instance = assert(instancesByName.get(instanceName));\n          assert(instance.kind == ElementKind.Function);\n          let functionInstance = <Function>instance;\n          let returnType = functionInstance.signature.returnType;\n          return !functionInstance.flow.is(FlowFlags.ReturnsWrapped)\n              || canConversionOverflow(returnType, type);\n        }\n        return false; // assume no overflow for builtins\n      }\n\n      // doesn't technically overflow\n      case ExpressionId.Unreachable: return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    let levels = 0;\n    let parent = this.parent;\n    while (parent) {\n      parent = parent.parent;\n      ++levels;\n    }\n    let sb = new Array<string>();\n    if (this.is(FlowFlags.Returns)) sb.push(\"RETURNS\");\n    if (this.is(FlowFlags.ReturnsWrapped)) sb.push(\"RETURNS_WRAPPED\");\n    if (this.is(FlowFlags.ReturnsNonNull)) sb.push(\"RETURNS_NONNULL\");\n    if (this.is(FlowFlags.Throws)) sb.push(\"THROWS\");\n    if (this.is(FlowFlags.Breaks)) sb.push(\"BREAKS\");\n    if (this.is(FlowFlags.Continues)) sb.push(\"CONTINUES\");\n    if (this.is(FlowFlags.AccessesThis)) sb.push(\"ACCESSES_THIS\");\n    if (this.is(FlowFlags.CallsSuper)) sb.push(\"CALLS_SUPER\");\n    if (this.is(FlowFlags.Terminates)) sb.push(\"TERMINATES\");\n    if (this.is(FlowFlags.ConditionallyReturns)) sb.push(\"CONDITIONALLY_RETURNS\");\n    if (this.is(FlowFlags.ConditionallyThrows)) sb.push(\"CONDITIONALLY_THROWS\");\n    if (this.is(FlowFlags.ConditionallyBreaks)) sb.push(\"CONDITIONALLY_BREAKS\");\n    if (this.is(FlowFlags.ConditionallyContinues)) sb.push(\"CONDITIONALLY_CONTINUES\");\n    if (this.is(FlowFlags.ConditionallyAccessesThis)) sb.push(\"CONDITIONALLY_ACCESSES_THIS\");\n    if (this.is(FlowFlags.MayReturnNonThis)) sb.push(\"MAY_RETURN_NONTHIS\");\n    return `Flow(${this.sourceFunction})[${levels}] ${sb.join(\" \")}`;\n  }\n}\n\n/** Tests if a conversion from one type to another can technically overflow. */\nfunction canConversionOverflow(fromType: Type, toType: Type): bool {\n  return toType.isShortIntegerValue && (\n    !fromType.isIntegerValue ||                                    // i.e. float to small int\n    fromType.size > toType.size ||                                 // larger int to small int\n    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch\n  );\n}\n", "/**\n * @fileoverview Resolve infrastructure to obtain types and elements.\n *\n * Similar to the compiler making instructions of expressions, the resolver\n * obtains metadata of expressions. As such, for each `compileX` method in\n * the compiler there is one `lookupX` method in the resolver returning the\n * respective IR element, respectively one `resolveX` method returning the\n * respective type of an expression. It is also able to make new elements,\n * like instances of classes given its concrete type arguments.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Range,\n  DiagnosticEmitter,\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Program,\n  ElementKind,\n  OperatorKind,\n  Element,\n  Class,\n  ClassPrototype,\n  Interface,\n  Function,\n  FunctionPrototype,\n  VariableLikeElement,\n  Property,\n  PropertyPrototype,\n  Global,\n  TypeDefinition,\n  TypedElement,\n  IndexSignature,\n  isTypedElement,\n  InterfacePrototype,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  FunctionTypeNode,\n  ParameterKind,\n  TypeNode,\n  NodeKind,\n  NamedTypeNode,\n  TypeName,\n  TypeParameterNode,\n  Node,\n  IdentifierExpression,\n  CallExpression,\n  ElementAccessExpression,\n  PropertyAccessExpression,\n  LiteralExpression,\n  LiteralKind,\n  ParenthesizedExpression,\n  AssertionExpression,\n  Expression,\n  IntegerLiteralExpression,\n  UnaryPrefixExpression,\n  UnaryPostfixExpression,\n  AssertionKind,\n  BinaryExpression,\n  ThisExpression,\n  SuperExpression,\n  CommaExpression,\n  InstanceOfExpression,\n  TernaryExpression,\n  isTypeOmitted,\n  FunctionExpression,\n  NewExpression,\n  ArrayLiteralExpression,\n  ArrowKind,\n  ExpressionStatement\n} from \"./ast\";\n\nimport {\n  Type,\n  Signature,\n  typesToString,\n  TypeKind\n} from \"./types\";\n\nimport {\n  CommonFlags,\n  CommonNames\n} from \"./common\";\n\nimport {\n  cloneMap,\n  isPowerOf2\n} from \"./util\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Indicates whether errors are reported or not. */\nexport const enum ReportMode {\n  /** Report errors. */\n  Report,\n  /** Swallow errors. */\n  Swallow\n}\n\n/** Provides tools to resolve types and expressions. */\nexport class Resolver extends DiagnosticEmitter {\n\n  /** The program this resolver belongs to. */\n  program: Program;\n\n  /** Target expression of the previously resolved property or element access. */\n  currentThisExpression: Expression | null = null;\n  /** Element expression of the previously resolved element access. */\n  currentElementExpression : Expression | null = null;\n  /** Whether a new override has been discovered. */\n  discoveredOverride: bool = false;\n\n  /** Constructs the resolver for the specified program. */\n  constructor(\n    /** The program to construct a resolver for. */\n    program: Program\n  ) {\n    super(program.diagnostics);\n    this.program = program;\n  }\n\n  // ====================================================== Types ======================================================\n\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\n  resolveType(\n    /** The type to resolve. */\n    node: TypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.NamedType: {\n        return this.resolveNamedType(\n          <NamedTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      case NodeKind.FunctionType: {\n        return this.resolveFunctionType(\n          <FunctionTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */\n  private resolveNamedType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let nameNode = node.name;\n    let typeArgumentNodes = node.typeArguments;\n    let isSimpleType = !nameNode.next;\n\n    // Look up in contextual types if a simple type\n    if (isSimpleType) {\n      let simpleName = nameNode.identifier.text;\n      if (ctxTypes && ctxTypes.has(simpleName)) {\n        let type = assert(ctxTypes.get(simpleName));\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, type.toString()\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, type.toString()\n            );\n          }\n        }\n        return type;\n      }\n    }\n\n    // Look up in context\n    let element = this.resolveTypeName(nameNode, ctxElement, reportMode);\n    if (!element) return null;\n\n    // Use shadow type if present (i.e. namespace sharing a type)\n    let shadowType = element.shadowType;\n    if (shadowType) {\n      element = shadowType;\n\n    } else {\n\n      // Handle enums (become i32)\n      if (element.kind == ElementKind.Enum) {\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, `${element.name}/i32`\n            );\n          }\n        }\n        return Type.i32;\n      }\n\n      // Handle classes and interfaces\n      if (\n        element.kind == ElementKind.ClassPrototype ||\n        element.kind == ElementKind.InterfacePrototype\n      ) {\n        let instance = this.resolveClassInclTypeArguments(\n          <ClassPrototype>element,\n          typeArgumentNodes,\n          ctxElement,\n          cloneMap(ctxTypes), // don't inherit\n          node,\n          reportMode\n        );\n        if (!instance) return null;\n        return node.isNullable ? instance.type.asNullable() : instance.type;\n      }\n    }\n\n    // Handle type definitions\n    if (element.kind == ElementKind.TypeDefinition) {\n      let typeDefinition = <TypeDefinition>element;\n\n      // Shortcut already resolved (mostly builtins)\n      if (element.is(CommonFlags.Resolved)) {\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        let type = typeDefinition.type;\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              nameNode.range, nameNode.identifier.text\n            );\n          }\n        }\n        return type;\n      }\n\n      // Handle special built-in types\n      if (isSimpleType) {\n        let text = nameNode.identifier.text;\n        if (text == CommonNames.native)   return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.indexof)  return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.valueof)  return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.nonnull)  return this.resolveBuiltinNotNullableType(node, ctxElement, ctxTypes, reportMode);\n      }\n\n      // Resolve normally\n      let typeParameterNodes = typeDefinition.typeParameterNodes;\n      let typeArguments: Type[] | null = null;\n      if (typeParameterNodes) {\n        typeArguments = this.resolveTypeArguments(\n          typeParameterNodes,\n          typeArgumentNodes,\n          ctxElement,\n          ctxTypes = cloneMap(ctxTypes), // update\n          node,\n          reportMode\n        );\n        if (!typeArguments) return null;\n      } else if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          node.range, nameNode.identifier.text\n        );\n      }\n      let type = this.resolveType(\n        typeDefinition.typeNode,\n        element,\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      if (node.isNullable) {\n        if (type.isInternalReference) return type.asNullable();\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_cannot_be_nullable,\n            nameNode.range, nameNode.identifier.text\n          );\n        }\n      }\n      return type;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        nameNode.range, nameNode.identifier.text\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */\n  private resolveFunctionType(\n    /** The type to resolve. */\n    node: FunctionTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let explicitThisType = node.explicitThisType;\n    let thisType: Type | null = null;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n    }\n    let parameterNodes = node.parameters;\n    let numParameters = parameterNodes.length;\n    let parameterTypes = new Array<Type>(numParameters);\n    let requiredParameters = 0;\n    let hasRest = false;\n    for (let i = 0; i < numParameters; ++i) {\n      let parameterNode = parameterNodes[i];\n      switch (parameterNode.parameterKind) {\n        case ParameterKind.Default: {\n          requiredParameters = i + 1;\n          break;\n        }\n        case ParameterKind.Rest: {\n          assert(i == numParameters);\n          hasRest = true;\n          break;\n        }\n      }\n      let parameterTypeNode = parameterNode.type;\n      if (isTypeOmitted(parameterTypeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            parameterTypeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        parameterTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      parameterTypes[i] = parameterType;\n    }\n    let returnTypeNode = node.returnType;\n    let returnType: Type | null;\n    if (isTypeOmitted(returnTypeNode)) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnTypeNode.range\n        );\n      }\n      returnType = Type.void;\n    } else {\n      returnType = this.resolveType(\n        returnTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!returnType) return null;\n    }\n    let signature = Signature.create(this.program, parameterTypes, returnType, thisType, requiredParameters, hasRest);\n    return node.isNullable ? signature.type.asNullable() : signature.type;\n  }\n\n  private resolveBuiltinNativeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    switch (typeArgument.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:  return Type.i32;\n      case TypeKind.Isize: if (!this.program.options.isWasm64) return Type.i32;\n      case TypeKind.I64:  return Type.i64;\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.Bool: return Type.u32;\n      case TypeKind.Usize: if (!this.program.options.isWasm64) return Type.u32;\n      case TypeKind.U64:  return Type.u64;\n      case TypeKind.F32:  return Type.f32;\n      case TypeKind.F64:  return Type.f64;\n      case TypeKind.V128: return Type.v128;\n      case TypeKind.Void: return Type.void;\n      default: assert(false);\n    }\n    return null;\n  }\n\n  private resolveBuiltinIndexofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let classReference = typeArgument.classReference;\n    if (!classReference) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Index_signature_is_missing_in_type_0,\n          typeArgumentNode.range, typeArgument.toString()\n        );\n      }\n      return null;\n    }\n    let overload = classReference.lookupOverload(OperatorKind.IndexedGet);\n    if (overload) {\n      let parameterTypes = overload.signature.parameterTypes;\n      if (overload.is(CommonFlags.Static)) {\n        assert(parameterTypes.length == 2);\n        return parameterTypes[1];\n      } else {\n        assert(parameterTypes.length == 1);\n        return parameterTypes[0];\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinValueofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let classReference = typeArgument.getClassOrWrapper(this.program);\n    if (classReference) {\n      let overload = classReference.lookupOverload(OperatorKind.IndexedGet);\n      if (overload) return overload.signature.returnType;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinReturnTypeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventualy diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let signatureReference = typeArgument.getSignature();\n    if (signatureReference) return signatureReference.returnType;\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Type_0_has_no_call_signatures,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinNotNullableType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    if (!typeArgument.isNullableReference) return typeArgument;\n    return typeArgument.nonNullableType;\n  }\n\n  /** Resolves a type name to the program element it refers to. */\n  resolveTypeName(\n    /** The type name to resolve. */\n    node: TypeName,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let element = ctxElement.lookup(node.identifier.text, true);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Cannot_find_name_0,\n          node.range, node.identifier.text\n        );\n      }\n      return null;\n    }\n    let prev = node;\n    let next = node.next;\n    while (next) {\n      if (!(element = element.getMember(next.identifier.text))) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\n            next.range, next.identifier.text, prev.identifier.text\n          );\n        }\n        return null;\n      }\n      prev = next;\n      next = next.next;\n    }\n    return element;\n  }\n\n  /** Resolves an array of type arguments to concrete types. */\n  resolveTypeArguments(\n    /** Type parameter nodes present. */\n    typeParameters: TypeParameterNode[],\n    /** Type argument nodes provided. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. Updated in place with the new set of contextual types. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** Alternative report node in case of empty type arguments. */\n    alternativeReportNode: Node | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type[] | null {\n    var\n      minParameterCount = 0,\n      maxParameterCount = 0;\n    for (let i = 0, k = typeParameters.length; i < k; ++i) {\n      if (!typeParameters[i].defaultType) ++minParameterCount;\n      ++maxParameterCount;\n    }\n    let argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\n    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          argumentCount\n            ? Range.join(\n                typeArgumentNodes![0].range,\n                typeArgumentNodes![argumentCount - 1].range\n              )\n            : alternativeReportNode!.range,\n          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),\n          argumentCount.toString()\n        );\n      }\n      return null;\n    }\n    let typeArguments = new Array<Type>(maxParameterCount);\n    let oldCtxTypes = cloneMap(ctxTypes);\n    ctxTypes.clear();\n    for (let i = 0; i < maxParameterCount; ++i) {\n      let type = i < argumentCount\n        ? this.resolveType( // reports\n            typeArgumentNodes![i],\n            ctxElement,\n            oldCtxTypes, // update\n            reportMode\n          )\n        : this.resolveType( // reports\n            assert(typeParameters[i].defaultType),\n            ctxElement,\n            cloneMap(ctxTypes), // don't update\n            reportMode\n          );\n      if (!type) return null;\n      // TODO: check extendsType\n      ctxTypes.set(typeParameters[i].name.text, type);\n      typeArguments[i] = type;\n    }\n    return typeArguments;\n  }\n\n  /** Resolves respectively infers the concrete instance of a function by call context. */\n  maybeInferCall(\n    node: CallExpression,\n    prototype: FunctionPrototype,\n    ctxFlow: Flow,\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let typeArguments = node.typeArguments;\n\n    // resolve generic call if type arguments have been provided\n    if (typeArguments) {\n      if (!prototype.is(CommonFlags.Generic)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            node.expression.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n      return this.resolveFunctionInclTypeArguments(\n        prototype,\n        typeArguments,\n        ctxFlow.sourceFunction,\n        cloneMap(ctxFlow.contextualTypeArguments), // don't inherit\n        node,\n        reportMode\n      );\n    }\n\n    // infer generic call if type arguments have been omitted\n    if (prototype.is(CommonFlags.Generic)) {\n      let contextualTypeArguments = cloneMap(ctxFlow.contextualTypeArguments);\n\n      // fill up contextual types with auto for each generic component\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let typeParameterNames = new Set<string>();\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let name = typeParameterNodes[i].name.text;\n        contextualTypeArguments.set(name, Type.auto);\n        typeParameterNames.add(name);\n      }\n\n      let parameterNodes = prototype.functionTypeNode.parameters;\n      let numParameters = parameterNodes.length;\n      let argumentNodes = node.args;\n      let numArguments = argumentNodes.length;\n\n      // infer types with generic components while updating contextual types\n      for (let i = 0; i < numParameters; ++i) {\n        let argumentExpression = i < numArguments\n          ? argumentNodes[i]\n          : parameterNodes[i].initializer;\n        if (!argumentExpression) {\n          // optional but not have initializer should be handled in the other place\n          if (parameterNodes[i].parameterKind == ParameterKind.Optional) {\n            continue;\n          }\n          // missing initializer -> too few arguments\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              node.range, numParameters.toString(), numArguments.toString()\n            );\n          }\n          return null;\n        }\n        let typeNode = parameterNodes[i].type;\n        if (typeNode.hasGenericComponent(typeParameterNodes)) {\n          let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.Swallow);\n          if (type) {\n            this.propagateInferredGenericTypes(\n              typeNode,\n              type,\n              prototype,\n              contextualTypeArguments,\n              typeParameterNames\n            );\n          }\n        }\n      }\n\n      // apply concrete types to the generic function signature\n      let resolvedTypeArguments = new Array<Type>(numTypeParameters);\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let typeParameterNode = typeParameterNodes[i];\n        let name = typeParameterNode.name.text;\n        if (contextualTypeArguments.has(name)) {\n          let inferredType = assert(contextualTypeArguments.get(name));\n          if (inferredType != Type.auto) {\n            resolvedTypeArguments[i] = inferredType;\n            continue;\n          }\n          let defaultType = typeParameterNode.defaultType;\n          if (defaultType) {\n            // Default parameters are resolved in context of the called function, not the calling function\n            let parent = prototype.parent;\n            let defaultTypeContextualTypeArguments: Map<string, Type> | null = null;\n            if (parent.kind == ElementKind.Class) {\n              defaultTypeContextualTypeArguments = (<Class>parent).contextualTypeArguments;\n            } else if (parent.kind == ElementKind.Function) {\n              defaultTypeContextualTypeArguments = (<Function>parent).contextualTypeArguments;\n            }\n            let resolvedDefaultType = this.resolveType(\n              defaultType,\n              prototype,\n              defaultTypeContextualTypeArguments,\n              reportMode\n            );\n            if (!resolvedDefaultType) return null;\n            resolvedTypeArguments[i] = resolvedDefaultType;\n            continue;\n          }\n        }\n        // unused template, e.g. `function test<T>(): void {...}` called as `test()`\n        // invalid because the type is effectively unknown inside the function body\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            node.expression.range.atEnd\n          );\n        }\n        return null;\n      }\n      return this.resolveFunction(\n        prototype,\n        resolvedTypeArguments,\n        cloneMap(ctxFlow.contextualTypeArguments),\n        reportMode\n      );\n    }\n\n    // otherwise resolve the non-generic call as usual\n    return this.resolveFunction(prototype, null, new Map(), reportMode);\n  }\n\n  /** Updates contextual types with a possibly encapsulated inferred type. */\n  private propagateInferredGenericTypes(\n    /** The inferred type node. */\n    node: TypeNode,\n    /** The inferred type. */\n    type: Type,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */\n    ctxTypes: Map<string,Type>,\n    /** The names of the type parameters being inferred. */\n    typeParameterNames: Set<string>\n  ): void {\n    if (node.kind == NodeKind.NamedType) {\n      let namedTypeNode = <NamedTypeNode>node;\n      let typeArgumentNodes = namedTypeNode.typeArguments;\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)\n        let classReference = type.classReference;\n        if (classReference) {\n          let classPrototype = this.resolveTypeName(namedTypeNode.name, ctxElement);\n          if (!classPrototype || classPrototype.kind != ElementKind.ClassPrototype) return;\n          if (classReference.prototype == <ClassPrototype>classPrototype) {\n            let typeArguments = classReference.typeArguments;\n            if (typeArguments && typeArguments.length == typeArgumentNodes.length) {\n              for (let i = 0, k = typeArguments.length; i < k; ++i) {\n                this.propagateInferredGenericTypes(\n                  typeArgumentNodes[i],\n                  typeArguments[i],\n                  ctxElement,\n                  ctxTypes,\n                  typeParameterNames\n                );\n              }\n              return;\n            }\n          }\n        }\n      } else { // foo<T>(bar: T)\n        let name = namedTypeNode.name.identifier.text;\n        if (ctxTypes.has(name)) {\n          let currentType = assert(ctxTypes.get(name));\n          if (\n            currentType == Type.auto ||\n            (typeParameterNames.has(name) && currentType.isAssignableTo(type))\n          ) ctxTypes.set(name, type);\n        }\n      }\n    } else if (node.kind == NodeKind.FunctionType) { // foo<T>(bar: (baz: T) => i32))\n      let functionTypeNode = <FunctionTypeNode>node;\n      let parameterNodes = functionTypeNode.parameters;\n      let signatureReference = type.signatureReference;\n      if (signatureReference) {\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = min(parameterTypes.length, parameterNodes.length) ; i < k; ++i) {\n          this.propagateInferredGenericTypes(\n            parameterNodes[i].type,\n            parameterTypes[i],\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        let returnType = signatureReference.returnType;\n        if (returnType != Type.void) {\n          this.propagateInferredGenericTypes(\n            functionTypeNode.returnType,\n            returnType,\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        let thisType = signatureReference.thisType;\n        let explicitThisType = functionTypeNode.explicitThisType;\n        if (thisType && explicitThisType) {\n          this.propagateInferredGenericTypes(\n            explicitThisType,\n            thisType,\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        return;\n      }\n    }\n  }\n\n  /** Gets the concrete type of an element. */\n  getTypeOfElement(element: Element): Type | null {\n    let kind = element.kind;\n    if (kind == ElementKind.Global) {\n      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.Swallow)) return null;\n    }\n    if (isTypedElement(kind)) {\n      let type = (<TypedElement>element).type;\n      let classReference = type.getClassOrWrapper(this.program);\n      if (classReference) {\n        let wrappedType = classReference.wrappedType;\n        if (wrappedType) type = wrappedType;\n      }\n      return type;\n    }\n    return null;\n  }\n\n  /** Gets the element of a concrete type. */\n  getElementOfType(type: Type): Element | null {\n    let classReference = type.getClassOrWrapper(this.program);\n    if (classReference) return classReference;\n    return null;\n  }\n\n  // =================================================== Expressions ===================================================\n\n  /** Looks up the program element the specified expression refers to. */\n  lookupExpression(\n    /** The expression to look up. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    while (node.kind == NodeKind.Parenthesized) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.Assertion: {\n        return this.lookupAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Binary: {\n        return this.lookupBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Call: {\n        return this.lookupCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Comma: {\n        return this.lookupCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ElementAccess: {\n        return this.lookupElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Function: {\n        return this.lookupFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.True: {\n        return this.lookupIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxFlow.sourceFunction, reportMode\n        );\n      }\n      case NodeKind.This: {\n        return this.lookupThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Super: {\n        return this.lookupSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.InstanceOf: {\n        return this.lookupInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Literal: {\n        return this.lookupLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.New: {\n        return this.lookupNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PropertyAccess: {\n        return this.lookupPropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Ternary: {\n        return this.lookupTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPostfix: {\n        return this.lookupUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPrefix: {\n        return this.lookupUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** resolving expressions */\n  private resolvingExpressions: Set<Expression> = new Set();\n\n  /** Resolves an expression to its static type. */\n  resolveExpression(\n    /** The expression to resolve. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const resolvingExpressions = this.resolvingExpressions;\n    if (resolvingExpressions.has(node)) return null;\n    resolvingExpressions.add(node);\n    const resolved = this.doResolveExpression(node, ctxFlow, ctxType, reportMode);\n    resolvingExpressions.delete(node);\n    return resolved;\n  }\n\n  /** Resolves an expression to its static type. (may cause stack overflow) */\n  private doResolveExpression(\n    node: Expression,\n    ctxFlow: Flow,\n    ctxType: Type = Type.auto,\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    while (node.kind == NodeKind.Parenthesized) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.Assertion: {\n        return this.resolveAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Binary: {\n        return this.resolveBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Call: {\n        return this.resolveCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Comma: {\n        return this.resolveCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ElementAccess: {\n        return this.resolveElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Function: {\n        return this.resolveFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.True: {\n        return this.resolveIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxType, ctxFlow.sourceFunction, reportMode\n        );\n      }\n      case NodeKind.This: {\n        return this.resolveThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Super: {\n        return this.resolveSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.InstanceOf: {\n        return this.resolveInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Literal: {\n        return this.resolveLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.New: {\n        return this.resolveNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PropertyAccess: {\n        return this.resolvePropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Ternary: {\n        return this.resolveTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPostfix: {\n        return this.resolveUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPrefix: {\n        return this.resolveUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified identifier expression refers to. */\n  lookupIdentifierExpression(\n    /** The expression to look up. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.sourceFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    switch (node.kind) {\n      case NodeKind.True:\n      case NodeKind.False:\n      case NodeKind.Null: {\n        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);\n        return type ? this.getElementOfType(type) : null;\n      }\n    }\n    let name = node.text;\n    let element: Element | null;\n    if (element = ctxFlow.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    let outerFlow = ctxFlow.outer;\n    if (outerFlow) {\n      if (element = outerFlow.lookup(name)) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return element;\n      }\n    }\n    if (element = ctxElement.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = this.program.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        node.range, name\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an identifier to its static type. */\n  private resolveIdentifierExpression(\n    /** The expression to resolve. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.sourceFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.True:\n      case NodeKind.False: return Type.bool;\n      case NodeKind.Null: {\n        let classReference = ctxType.getClass();\n        if (classReference) {\n          return classReference.type.asNullable();\n        } else {\n          let signatureReference = ctxType.getSignature();\n          if (signatureReference) {\n            return signatureReference.type.asNullable();\n          } else if (ctxType.isExternalReference) {\n            return ctxType; // TODO: nullable?\n          }\n        }\n        return this.program.options.usizeType;\n      }\n    }\n    let element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.FunctionPrototype) {\n      let instance = this.resolveFunction(<FunctionPrototype>element, null, new Map(), reportMode);\n      if (!instance) return null;\n      element = instance;\n    }\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */\n  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.Report): bool {\n    if (global.is(CommonFlags.Resolved)) return true;\n    let typeNode = global.typeNode;\n    let type = typeNode\n      ? this.resolveType(typeNode, global.parent, null, reportMode)\n      : this.resolveExpression(\n          assert(global.initializerNode),\n          global.file.startFunction.flow,\n          Type.auto,\n          reportMode\n        );\n    if (!type) return false;\n    global.setType(type); // also sets resolved\n    return true;\n  }\n\n  /** Looks up the program element the specified property access expression refers to. */\n  private lookupPropertyAccessExpression(\n    /** The expression to look up. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let targetNode = node.expression;\n    let target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports\n    if (!target) return null;\n    let propertyName = node.property.text;\n\n    // Resolve variable-likes to their class type first\n    switch (target.kind) {\n      case ElementKind.Global: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;\n      case ElementKind.EnumValue:\n      case ElementKind.Local: { // someVar.prop\n        let variableLikeElement = <VariableLikeElement>target;\n        let type = variableLikeElement.type;\n        assert(type != Type.void);\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, variableLikeElement.type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.PropertyPrototype: { // SomeClass.prop\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: { // someInstance.prop\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance); // must have a getter\n        let type = getterInstance.signature.returnType;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.IndexSignature: { // someInstance[x].prop\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        let elementExpression = assert(this.currentElementExpression);\n        let indexedGet = classInstance.lookupOverload(OperatorKind.IndexedGet);\n        if (!indexedGet) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              elementExpression.range, parent.internalName\n            );\n          }\n          return null;\n        }\n        let returnType = indexedGet.signature.returnType;\n        let classReference = returnType.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, returnType.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.FunctionPrototype: {\n        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol\n        let shadowType = target.shadowType;\n        if (shadowType) {\n          if (!shadowType.is(CommonFlags.Resolved)) {\n            let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);\n            if (resolvedType) shadowType.setType(resolvedType);\n          }\n          let classReference = shadowType.type.classReference;\n          if (classReference) target = classReference.prototype;\n          break;\n        } else if (!target.is(CommonFlags.Generic)) {\n          // Inherit from 'Function' if not overridden, i.e. fn.call\n          let ownMember = target.getMember(propertyName);\n          if (!ownMember) {\n            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, new Map(), ReportMode.Swallow);\n            if (functionInstance) {\n              let wrapper = functionInstance.type.getClassOrWrapper(this.program);\n              if (wrapper) target = wrapper;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // Look up the member within\n    switch (target.kind) {\n      case ElementKind.ClassPrototype:\n      case ElementKind.InterfacePrototype:\n      case ElementKind.Class:\n      case ElementKind.Interface: {\n        do {\n          let member = target.getMember(propertyName);\n          if (member) {\n            if (member.kind == ElementKind.PropertyPrototype) {\n              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);\n              if (!propertyInstance) return null;\n              member = propertyInstance;\n              if (propertyInstance.is(CommonFlags.Static)) {\n                this.currentThisExpression = null;\n              } else {\n                this.currentThisExpression = targetNode;\n              }\n            } else {\n              this.currentThisExpression = targetNode;\n            }\n            this.currentElementExpression = null;\n            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...\n          }\n          // traverse inherited static members on the base prototype if target is a class prototype\n          if (\n            target.kind == ElementKind.ClassPrototype ||\n            target.kind == ElementKind.InterfacePrototype\n          ) {\n            let classPrototype = <ClassPrototype>target;\n            let basePrototype = classPrototype.basePrototype;\n            if (basePrototype) {\n              target = basePrototype;\n            } else {\n              break;\n            }\n          // traverse inherited instance members on the base class if target is a class instance\n          } else if (\n            target.kind == ElementKind.Class ||\n            target.kind == ElementKind.Interface\n          ) {\n            let classInstance = <Class>target;\n            let baseInstance = classInstance.base;\n            if (baseInstance) {\n              target = baseInstance;\n            } else {\n              break;\n            }\n          } else {\n            break;\n          }\n        } while (true);\n        break;\n      }\n      default: { // enums or other namespace-like elements\n        let member = target.getMember(propertyName);\n        if (member) {\n          this.currentThisExpression = targetNode;\n          this.currentElementExpression = null;\n          return member; // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...\n        }\n        break;\n      }\n    }\n\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Property_0_does_not_exist_on_type_1,\n        node.property.range, propertyName, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a property access expression to its static type. */\n  private resolvePropertyAccessExpression(\n    /** The expression to resolve. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified element access expression refers to. */\n  private lookupElementAccessExpression(\n    /** The expression to look up. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let targetExpression = node.expression;\n    let targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);\n    if (!targetType) return null;\n    let classReference = targetType.getClassOrWrapper(this.program);\n    if (classReference) {\n      do {\n        let indexSignature = classReference.indexSignature;\n        if (indexSignature) {\n          this.currentThisExpression = targetExpression;\n          this.currentElementExpression = node.elementExpression;\n          return indexSignature;\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        targetExpression.range, targetType.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an element access expression to its static type. */\n  private resolveElementAccessExpression(\n    /** The expression to resolve. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Determines the final type of an integer literal given the specified contextual type. */\n  determineIntegerLiteralType(\n    /** Integer literal value. */\n    expr: IntegerLiteralExpression,\n    /** Has unary minus before literal. */\n    negate: bool,\n    /** Contextual type. */\n    ctxType: Type\n  ): Type {\n    let intValue = expr.value;\n    if (negate) {\n      // x + i64.min > 0   ->   underflow\n      if (i64_gt(i64_add(intValue, i64_minimum), i64_zero)) {\n        let range = expr.range;\n        this.error(\n          DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n          range, range.source.text.substring(range.start - 1, range.end)\n        );\n      } else if (i64_eq(intValue, i64_zero)) {\n        // Special handling for -0\n        if (ctxType.isFloatValue) {\n          return ctxType.kind == TypeKind.F32\n            ? Type.f32\n            : Type.f64;\n        } else if (!ctxType.isIntegerValue) {\n          // If it's unknown just always assume this is f64\n          return Type.f64;\n        }\n      }\n      intValue = i64_neg(intValue);\n    }\n    if (ctxType.isValue) {\n      // compile to contextual type if matching\n      switch (ctxType.kind) {\n        case TypeKind.Bool: {\n          if (i64_is_bool(intValue)) return Type.bool;\n          break;\n        }\n        case TypeKind.I8: {\n          if (i64_is_i8(intValue)) return Type.i8;\n          break;\n        }\n        case TypeKind.U8: {\n          if (i64_is_u8(intValue)) return Type.u8;\n          break;\n        }\n        case TypeKind.I16: {\n          if (i64_is_i16(intValue)) return Type.i16;\n          break;\n        }\n        case TypeKind.U16: {\n          if (i64_is_u16(intValue)) return Type.u16;\n          break;\n        }\n        case TypeKind.I32: {\n          if (i64_is_i32(intValue)) return Type.i32;\n          break;\n        }\n        case TypeKind.U32: {\n          if (i64_is_u32(intValue)) return Type.u32;\n          break;\n        }\n        case TypeKind.Isize: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_i32(intValue)) return Type.isize32;\n            break;\n          }\n          return Type.isize64;\n        }\n        case TypeKind.Usize: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_u32(intValue)) return Type.usize32;\n            break;\n          }\n          return Type.usize64;\n        }\n        case TypeKind.I64: return Type.i64;\n        case TypeKind.U64: return Type.u64;\n        case TypeKind.F32: return Type.f32;\n        case TypeKind.F64: return Type.f64;\n      }\n    }\n    // otherwise compile to best fitting type\n    if (i64_is_i32(intValue)) return Type.i32;\n    if (i64_is_u32(intValue)) return Type.u32;\n    return Type.i64; // TODO: u64 if positive and larger than i64?\n  }\n\n  /** Looks up the program element the specified assertion expression refers to. */\n  private lookupAssertionExpression(\n    /** The expression to look up. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    switch (node.assertionKind) {\n      case AssertionKind.As:\n      case AssertionKind.Prefix: {\n        let type = this.resolveType(\n          assert(node.toType), // must be set if not NONNULL\n          ctxFlow.sourceFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n        if (!type) return null;\n        let element = this.getElementOfType(type);\n        if (element) return element;\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_illegal_in_this_context,\n            node.range, type.toString()\n          );\n        }\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return null;\n      }\n      case AssertionKind.NonNull: {\n        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n      }\n      case AssertionKind.Const: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n        // if (!element) return null;\n        // if (element.kind == ElementKind.Class && (<Class>element).extends(this.program.arrayPrototype)) {\n        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];\n        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          node.range,\n          \"Const assertion\"\n        );\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an assertion expression to its static type. */\n  private resolveAssertionExpression(\n    /** The expression to resolve. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.assertionKind) {\n      case AssertionKind.As:\n      case AssertionKind.Prefix: {\n        return this.resolveType(\n          assert(node.toType),\n          ctxFlow.sourceFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n      }\n      case AssertionKind.NonNull: {\n        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);\n        return type ? type.nonNullableType : null;\n      }\n      case AssertionKind.Const: {\n        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);\n        if (!element) return null;\n        let type = this.getTypeOfElement(element);\n        if (!type) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n              node.range\n            );\n          }\n        }\n        return type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary prefix expression refers to. */\n  private lookupUnaryPrefixExpression(\n    /** The expression to look up. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary prefix expression to its static type. */\n  private resolveUnaryPrefixExpression(\n    /** The expression to resolve. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let operand = node.operand;\n    let operator = node.operator;\n    switch (operator) {\n      case Token.Minus: {\n        // implicitly negate if an integer literal to distinguish between i32/u32/i64\n        if (operand.isLiteralKind(LiteralKind.Integer)) {\n          return this.determineIntegerLiteralType(\n            <IntegerLiteralExpression>operand,\n            true,\n            ctxType\n          );\n        }\n        // fall-through\n      }\n      case Token.Plus:\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n      case Token.Exclamation: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Not);\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool; // incl. references\n      }\n      case Token.Tilde: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseNot);\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, \"~\", type.toString()\n            );\n          }\n          return null;\n        }\n        return type.intType;\n      }\n      case Token.Dot_Dot_Dot: {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            node.range, \"Spread operator\"\n          );\n        }\n        return null;\n      }\n      case Token.TypeOf: {\n        return this.program.stringInstance.type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary postfix expression refers to. */\n  private lookupUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary postfix expression to its static type. */\n  private resolveUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let operator = node.operator;\n    switch (operator) {\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified binary expression refers to. */\n  private lookupBinaryExpression(\n    /** The expression to look up. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (element) return element; // otherwise void\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Type_0_is_illegal_in_this_context,\n        node.range, type.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a binary expression to its static type. */\n  private resolveBinaryExpression(\n    /** The expression to resolve. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let left = node.left;\n    let right = node.right;\n    let operator = node.operator;\n\n    switch (operator) {\n\n      // assignment: result is the target's type\n\n      case Token.Equals:\n      case Token.Plus_Equals:\n      case Token.Minus_Equals:\n      case Token.Asterisk_Equals:\n      case Token.Asterisk_Asterisk_Equals:\n      case Token.Slash_Equals:\n      case Token.Percent_Equals:\n      case Token.LessThan_LessThan_Equals:\n      case Token.GreaterThan_GreaterThan_Equals:\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n      case Token.Ampersand_Equals:\n      case Token.Bar_Equals:\n      case Token.Caret_Equals: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n\n      // comparison: result is Bool, preferring overloads, integer/float only\n\n      case Token.LessThan:\n      case Token.GreaterThan:\n      case Token.LessThan_Equals:\n      case Token.GreaterThan_Equals: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return Type.bool;\n      }\n\n      // equality: result is Bool, preferring overloads, incl. references\n\n      case Token.Equals_Equals:\n      case Token.Exclamation_Equals: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool;\n      }\n\n      // identity: result is Bool, not supporting overloads\n\n      case Token.Equals_Equals_Equals:\n      case Token.Exclamation_Equals_Equals: {\n        return Type.bool;\n      }\n\n      // arithmetics: result is common type of LHS and RHS, preferring overloads\n\n      case Token.Plus:\n      case Token.Minus:\n      case Token.Asterisk:\n      case Token.Slash:\n      case Token.Percent: // mod has special logic, but also behaves like this\n      case Token.Asterisk_Asterisk: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // shift: result is LHS (RHS is converted to LHS), preferring overloads\n\n      case Token.LessThan_LessThan:\n      case Token.GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_GreaterThan: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isIntegerValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return leftType;\n      }\n\n      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads\n\n      case Token.Ampersand:\n      case Token.Bar:\n      case Token.Caret: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType || !commonType.isIntegerValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // logical: result is LHS (RHS is converted to LHS), not supporting overloads\n\n      case Token.Ampersand_Ampersand:\n      case Token.Bar_Bar: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified this expression refers to. */\n  private lookupThisExpression(\n    /** The expression to look up. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);\n      if (thisLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return thisLocal;\n      }\n    }\n    let parent = ctxFlow.sourceFunction.parent;\n    if (parent) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return parent;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode._this_cannot_be_referenced_in_current_location,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a this expression to its static type. */\n  private resolveThisExpression(\n    /** The expression to resolve. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified super expression refers to. */\n  private lookupSuperExpression(\n    /** The expression to look up. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);\n      if (superLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return superLocal;\n      }\n    }\n    let parent: Element | null = ctxFlow.sourceFunction.parent;\n    if (parent && parent.kind == ElementKind.Class) {\n      let base = (<Class>parent).base;\n      if (base) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return base;\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a super expression to its static type. */\n  private resolveSuperExpression(\n    /** The expression to resolve. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified literal expression refers to. */\n  private lookupLiteralExpression(\n    /** The expression to look up. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    this.currentThisExpression = node;\n    this.currentElementExpression = null;\n    switch (node.literalKind) {\n      case LiteralKind.Integer: {\n        let intType = this.determineIntegerLiteralType(\n          <IntegerLiteralExpression>node,\n          false,\n          ctxType\n        );\n        return assert(intType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.Float: {\n        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;\n        return assert(fltType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.String:\n      case LiteralKind.Template: {\n        return this.program.stringInstance;\n      }\n      case LiteralKind.RegExp: {\n        return this.program.regexpInstance;\n      }\n      case LiteralKind.Array: {\n        let classReference = ctxType.getClass();\n        if (classReference && classReference.prototype == this.program.arrayPrototype) {\n          return this.getElementOfType(ctxType);\n        }\n        // otherwise infer, ignoring ctxType\n        let expressions = (<ArrayLiteralExpression>node).elementExpressions;\n        let length = expressions.length;\n        let elementType = Type.auto;\n        let numNullLiterals = 0;\n        for (let i = 0, k = length; i < k; ++i) {\n          let expression = expressions[i];\n          if (expression) {\n            if (expression.kind == NodeKind.Null && length > 1) {\n              ++numNullLiterals;\n            } else {\n              let currentType = this.resolveExpression(expression, ctxFlow, elementType);\n              if (!currentType) return null;\n              if (elementType == Type.auto) elementType = currentType;\n              else if (currentType != elementType) {\n                let commonType = Type.commonDenominator(elementType, currentType, false);\n                if (commonType) elementType = commonType;\n                // otherwise triggers error on compilation\n              }\n            }\n          }\n        }\n        if (elementType /* still */ == Type.auto) {\n          if (numNullLiterals == length) { // all nulls infers as usize\n            elementType = this.program.options.usizeType;\n          } else {\n            if (reportMode == ReportMode.Report) {\n              this.error(\n                DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,\n                node.range, \"T\"\n              );\n            }\n            return null;\n          }\n        }\n        if (\n          numNullLiterals > 0 &&\n          elementType.isInternalReference\n        ) {\n          elementType = elementType.asNullable();\n        }\n        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));\n      }\n      case LiteralKind.Object: {\n        if (ctxType.isClass) return ctxType.classReference;\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            node.range\n          );\n        }\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves a literal expression to its static type. */\n  private resolveLiteralExpression(\n    /** The expression to resolve. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified call expression refers to. */\n  private lookupCallExpression(\n    /** The expression to look up. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a call expression to its static type. */\n  private resolveCallExpression(\n    /** The expression to resolve. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let targetExpression = node.expression;\n    let target = this.lookupExpression( // reports\n      targetExpression,\n      ctxFlow,\n      ctxType,\n      reportMode\n    );\n    if (!target) return null;\n    switch (target.kind) {\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        // `unchecked` behaves like parenthesized\n        if (\n          functionPrototype.internalName == BuiltinNames.unchecked &&\n          node.args.length > 0\n        ) {\n          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);\n        }\n        let functionInstance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);\n        if (!functionInstance) return null;\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.Function: {\n        return (<Function>target).signature.returnType;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      default: {\n        if (!isTypedElement(target.kind)) break;\n        let targetElement = this.getElementOfType((<TypedElement>target).type);\n        if (!targetElement || targetElement.kind != ElementKind.Class) break;\n        target = targetElement;\n        // fall-through\n      }\n      case ElementKind.Class: {\n        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);\n        if (!(typeArguments && typeArguments.length)) break;\n        let signature = assert(typeArguments[0].getSignature());\n        return signature.returnType;\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n        targetExpression.range, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified comma expression refers to. */\n  private lookupCommaExpression(\n    /** The expression to look up. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let expressions = node.expressions;\n    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Resolves a comma expression to its static type. */\n  private resolveCommaExpression(\n    /** The expression to resolve. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let expressions = node.expressions;\n    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Looks up the program element the specified instanceof expression refers to. */\n  private lookupInstanceOfExpression(\n    /** The expression to look up. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    return assert(Type.bool.getClassOrWrapper(this.program));\n  }\n\n  /** Resolves an instanceof expression to its static type. */\n  private resolveInstanceOfExpression(\n    /** The expression to resolve. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    return Type.bool;\n  }\n\n  /** Looks up the program element the specified ternary expression refers to. */\n  private lookupTernaryExpression(\n    /** The expression to look up. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a ternary expression to its static type. */\n  private resolveTernaryExpression(\n    /** The expression to resolve. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);\n    if (!thenType) return null;\n    let elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);\n    if (!elseType) return null;\n    let commonType = Type.commonDenominator(thenType, elseType, false);\n    if (!commonType) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n          node.range, \"?:\", thenType.toString(), elseType.toString()\n        );\n      }\n    }\n    return commonType;\n  }\n\n  /** Looks up the program element the specified new expression refers to. */\n  private lookupNewExpression(\n    /** The expression to look up. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let element = this.resolveTypeName(node.typeName, ctxFlow.sourceFunction, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.ClassPrototype) {\n      return this.resolveClassInclTypeArguments(\n        <ClassPrototype>element,\n        node.typeArguments,\n        ctxFlow.sourceFunction,\n        cloneMap(ctxFlow.contextualTypeArguments),\n        node,\n        reportMode\n      );\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a new expression to its static type. */\n  private resolveNewExpression(\n    /** The expression to resolve. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified function expression refers to. */\n  private lookupFunctionExpression(\n    /** The expression to look up. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a function expression to its static type. */\n  private resolveFunctionExpression(\n    /** The expression to resolve. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const declaration = node.declaration;\n    const signature = declaration.signature;\n    const body = declaration.body;\n    let functionType = this.resolveFunctionType(signature, ctxFlow.sourceFunction, ctxFlow.contextualTypeArguments, reportMode);\n    if (\n      functionType &&\n      declaration.arrowKind != ArrowKind.None &&\n      body && body.kind == NodeKind.Expression &&\n      isTypeOmitted(signature.returnType)\n    ) {\n      // (x) => ret, infer return type accordingt to `ret`\n      const expr = (<ExpressionStatement>body).expression;\n      let signatureReference = assert(functionType.getSignature());\n      // create a temp flow to resolve expression\n      let tempFlow = Flow.createDefault(ctxFlow.sourceFunction);\n      let parameters = signature.parameters;\n      // return type of resolveFunctionType should have same parameter length with signature\n      assert(signatureReference.parameterTypes.length == parameters.length);\n      for (let i = 0, k = parameters.length; i < k; i++) {\n        const parameter = parameters[i];\n        const type = signatureReference.parameterTypes[i];\n        tempFlow.addScopedDummyLocal(parameter.name.text, type, parameter);\n      }\n      const type = this.resolveExpression(expr, tempFlow, ctxType, reportMode);\n      if (type) {\n        functionType.signatureReference = Signature.create(\n          this.program,\n          signatureReference.parameterTypes,\n          type,\n          signatureReference.thisType,\n          signatureReference.requiredParameters,\n          signatureReference.hasRest,\n        );\n      }\n    }\n    return functionType;\n  }\n\n  // ==================================================== Elements =====================================================\n\n  /** Resolves a function prototype using the specified concrete type arguments. */\n  resolveFunction(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let classInstance: Class | null = null; // if an instance method\n    let instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Instance method prototypes are pre-bound to their concrete class as their parent\n    if (prototype.is(CommonFlags.Instance)) {\n      classInstance = assert(prototype.getBoundClassOrInterface());\n\n      // check if this exact concrete class and function combination is known already\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n\n      // inherit class specific type arguments\n      let classTypeArguments = classInstance.typeArguments;\n      if (classTypeArguments) {\n        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);\n        let numClassTypeArguments = classTypeParameters.length;\n        assert(numClassTypeArguments == classTypeParameters.length);\n        for (let i = 0; i < numClassTypeArguments; ++i) {\n          let classTypeParameterName = classTypeParameters[i].name.text;\n          // override contextual\n          ctxTypes.set(classTypeParameterName, classTypeArguments[i]);\n        }\n      }\n    } else {\n      assert(!prototype.isBound);\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n    }\n\n    // override whatever is contextual with actual function type arguments\n    let signatureNode = prototype.functionTypeNode;\n    let typeParameterNodes = prototype.typeParameterNodes;\n    let numFunctionTypeArguments: i32;\n    if (typeArguments && (numFunctionTypeArguments = typeArguments.length) > 0) {\n      assert(typeParameterNodes && numFunctionTypeArguments == typeParameterNodes.length);\n      for (let i = 0; i < numFunctionTypeArguments; ++i) {\n        ctxTypes.set(\n          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,\n          typeArguments[i]\n        );\n      }\n    } else {\n      assert(!typeParameterNodes || typeParameterNodes.length == 0);\n    }\n\n    // resolve `this` type if applicable\n    let thisType: Type | null = null;\n    let explicitThisType = signatureNode.explicitThisType;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n      ctxTypes.set(CommonNames.this_, thisType);\n    } else if (classInstance) {\n      thisType = classInstance.type;\n      ctxTypes.set(CommonNames.this_, thisType);\n    }\n\n    // resolve parameter types\n    let signatureParameters = signatureNode.parameters;\n    let numSignatureParameters = signatureParameters.length;\n    let parameterTypes = new Array<Type>(numSignatureParameters);\n    let requiredParameters = 0;\n    for (let i = 0; i < numSignatureParameters; ++i) {\n      let parameterDeclaration = signatureParameters[i];\n      if (parameterDeclaration.parameterKind == ParameterKind.Default) {\n        requiredParameters = i + 1;\n      }\n      let typeNode = parameterDeclaration.type;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      if (parameterType == Type.void) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      parameterTypes[i] = parameterType;\n    }\n\n    // resolve return type\n    let returnType: Type;\n    if (prototype.is(CommonFlags.Set)) {\n      returnType = Type.void; // not annotated\n    } else if (prototype.is(CommonFlags.Constructor)) {\n      returnType = classInstance!.type; // not annotated\n    } else {\n      let typeNode = signatureNode.returnType;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let type = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      returnType = type;\n    }\n\n    let signature = Signature.create(this.program, parameterTypes, returnType, thisType, requiredParameters);\n\n    let nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += `<${instanceKey}>`;\n    let instance = new Function(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      signature,\n      ctxTypes\n    );\n    prototype.setResolvedInstance(instanceKey, instance);\n\n    // check against overridden base member\n    if (classInstance) {\n      let methodOrPropertyName = instance.declaration.name.text;\n      let baseClass = classInstance.base;\n      if (baseClass) {\n        let baseMember = baseClass.getMember(methodOrPropertyName);\n        if (baseMember) {\n          // note override discovery (used by stub finalization)\n          this.discoveredOverride = true;\n          // verify that this is a compatible override\n          let incompatibleOverride = true;\n          if (instance.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            if (baseMember.kind == ElementKind.PropertyPrototype) {\n              let baseProperty = this.resolveProperty(<PropertyPrototype>baseMember, reportMode);\n              if (baseProperty) {\n                if (instance.is(CommonFlags.Get)) {\n                  let baseGetter = baseProperty.getterInstance;\n                  if (baseGetter && instance.signature.isAssignableTo(baseGetter.signature, true)) {\n                    incompatibleOverride = false;\n                  }\n                } else {\n                  assert(instance.is(CommonFlags.Set));\n                  let baseSetter = baseProperty.setterInstance;\n                  if (baseSetter && instance.signature.isAssignableTo(baseSetter.signature, true)) {\n                    incompatibleOverride = false;\n                  }\n                }\n              }\n            }\n          } else if (instance.is(CommonFlags.Constructor)) {\n            incompatibleOverride = false;\n          } else {\n            if (baseMember.kind == ElementKind.FunctionPrototype) {\n              // Possibly generic. Resolve with same type arguments to obtain the correct one.\n              let basePrototype = <FunctionPrototype>baseMember;\n              let baseFunction = this.resolveFunction(basePrototype, typeArguments, new Map(), ReportMode.Swallow);\n              if (baseFunction && instance.signature.isAssignableTo(baseFunction.signature, true)) {\n                incompatibleOverride = false;\n              }\n            }\n          }\n          if (incompatibleOverride) {\n            this.errorRelated(\n              DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n              instance.identifierAndSignatureRange, baseMember.identifierAndSignatureRange\n            );\n          }\n        }\n      }\n    }\n    return instance;\n  }\n\n  /** Resolves a function prototypeby first resolving the specified type arguments. */\n  resolveFunctionInclTypeArguments(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.Generic)) {\n\n      // If this is an instance method, first apply the class's type arguments\n      if (prototype.is(CommonFlags.Instance)) {\n        let classInstance = assert(prototype.getBoundClassOrInterface());\n        let classTypeArguments = classInstance.typeArguments;\n        if (classTypeArguments) {\n          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);\n          let numClassTypeArguments = classTypeArguments.length;\n          assert(numClassTypeArguments == typeParameterNodes.length);\n          for (let i = 0; i < numClassTypeArguments; ++i) {\n            ctxTypes.set(\n              typeParameterNodes[i].name.text,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes),\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveFunction(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves reachable overrides of the given instance method. */\n  resolveOverrides(instance: Function): Function[] | null {\n    let overridePrototypes = instance.prototype.unboundOverrides;\n    if (!overridePrototypes) return null;\n\n    let parentClassInstance = assert(instance.getBoundClassOrInterface());\n    let overrides = new Set<Function>();\n\n    // A method's `overrides` property contains its unbound override prototypes\n    // so we first have to find the concrete classes it became bound to, obtain\n    // their bound prototypes and make sure these are resolved.\n    for (let _values = Set_values(overridePrototypes), i = 0, k = _values.length; i < k; ++i) {\n      let unboundOverridePrototype = _values[i];\n      assert(!unboundOverridePrototype.isBound);\n      let unboundOverrideParent = unboundOverridePrototype.parent;\n      let classInstances: Map<string,Class> | null;\n      assert(unboundOverrideParent.kind == ElementKind.ClassPrototype);\n      classInstances = (<ClassPrototype>unboundOverrideParent).instances;\n      if (!classInstances) continue;\n      for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {\n        let classInstance = _values[j];\n        // Check if the parent class is a subtype of instance's class\n        if (!classInstance.isAssignableTo(parentClassInstance)) continue;\n        let overrideInstance: Function | null = null;\n        if (instance.isAny(CommonFlags.Get | CommonFlags.Set)) {\n          let propertyName = instance.declaration.name.text;\n          let boundPropertyPrototype = assert(classInstance.getMember(propertyName));\n          assert(boundPropertyPrototype.kind == ElementKind.PropertyPrototype);\n          let boundPropertyInstance = this.resolveProperty(<PropertyPrototype>boundPropertyPrototype);\n          if (!boundPropertyInstance) continue;\n          if (instance.is(CommonFlags.Get)) {\n            overrideInstance = boundPropertyInstance.getterInstance;\n          } else {\n            assert(instance.is(CommonFlags.Set));\n            overrideInstance = boundPropertyInstance.setterInstance;\n          }\n        } else {\n          let boundPrototype = classInstance.getMember(unboundOverridePrototype.name);\n          if (boundPrototype) { // might have errored earlier and wasn't added\n            assert(boundPrototype.kind == ElementKind.FunctionPrototype);\n            overrideInstance = this.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);\n          }\n        }\n        if (overrideInstance) overrides.add(overrideInstance);\n      }\n    }\n    return Set_values(overrides);\n  }\n\n  /** Currently resolving classes. */\n  private resolveClassPending: Set<Class> = new Set();\n\n  /** Resolves a class prototype using the specified concrete type arguments. */\n  resolveClass(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Class | null {\n    let instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Do not attempt to resolve the same class twice. This can return a class\n    // that isn't fully resolved yet, but only on deeper levels of recursion.\n    let instance = prototype.getResolvedInstance(instanceKey);\n    if (instance) return instance;\n\n    // Otherwise create\n    let nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += `<${instanceKey}>`;\n    if (prototype.kind == ElementKind.InterfacePrototype) {\n      instance = new Interface(nameInclTypeParameters, <InterfacePrototype>prototype, typeArguments);\n    } else {\n      instance = new Class(nameInclTypeParameters, prototype, typeArguments);\n    }\n    prototype.setResolvedInstance(instanceKey, instance);\n    let pendingClasses = this.resolveClassPending;\n    pendingClasses.add(instance);\n\n    // Insert contextual type arguments for this operation. Internally, this method is always\n    // called with matching type parameter / argument counts.\n    if (typeArguments) {\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let numTypeArguments = typeArguments.length;\n      assert(numTypeArguments == numTypeParameters);\n      for (let i = 0; i < numTypeArguments; ++i) {\n        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);\n      }\n    } else {\n      let typeParameterNodes = prototype.typeParameterNodes;\n      assert(!(typeParameterNodes && typeParameterNodes.length > 0));\n    }\n    instance.contextualTypeArguments = ctxTypes;\n\n    let anyPending = false;\n\n    // Resolve base class if applicable\n    let basePrototype = prototype.basePrototype;\n    if (basePrototype) {\n      let current: ClassPrototype | null = basePrototype;\n      do {\n        if (current == prototype) {\n          this.error(\n            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n            prototype.identifierNode.range,\n            prototype.internalName\n          );\n          return null;\n        }\n        current = current.basePrototype;\n      } while (current);\n      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype\n      let base = this.resolveClassInclTypeArguments(\n        basePrototype,\n        extendsNode.typeArguments,\n        prototype.parent, // relative to derived class\n        cloneMap(ctxTypes), // don't inherit\n        extendsNode,\n        reportMode\n      );\n      if (!base) return null;\n      instance.setBase(base);\n\n      // If the base class is still pending, yield here and instead resolve any\n      // derived classes once the base class's `finishResolveClass` is done.\n      // This is guaranteed to never happen at the entry of the recursion, i.e.\n      // where `resolveClass` is called from other code.\n      if (pendingClasses.has(base)) anyPending = true;\n\n    // Implicitly extend `Object` if a derived object\n    } else if (prototype.implicitlyExtendsObject) {\n      instance.setBase(this.program.objectInstance);\n    }\n\n    // Resolve interfaces if applicable\n    let interfacePrototypes = prototype.interfacePrototypes;\n    if (interfacePrototypes) {\n      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {\n        let interfacePrototype = interfacePrototypes[i];\n        let current: ClassPrototype | null = interfacePrototype;\n        do {\n          if (current == prototype) {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              prototype.identifierNode.range,\n              prototype.internalName\n            );\n            return null;\n          }\n          current = current.basePrototype;\n        } while (current);\n        let implementsNode = assert(prototype.implementsNodes![i]);\n        let iface = this.resolveClassInclTypeArguments(\n          interfacePrototype,\n          implementsNode.typeArguments,\n          prototype.parent,\n          cloneMap(ctxTypes),\n          implementsNode,\n          reportMode\n        );\n        if (!iface) return null;\n        assert(iface.kind == ElementKind.Interface);\n        instance.addInterface(<Interface>iface);\n\n        // Like above, if any implemented interface is still pending, yield\n        if (pendingClasses.has(iface)) anyPending = true;\n      }\n    }\n    if (anyPending) return instance;\n\n    // We only get here if the base class has been fully resolved already.\n    this.finishResolveClass(instance, reportMode);\n    return instance;\n  }\n\n  /** Checks whether an override's visibility is valid. */\n  private checkOverrideVisibility(\n    /** Name to report. */\n    name: string,\n    /** Overriding member. */\n    thisMember: DeclaredElement,\n    /** Overriding class. */\n    thisClass: Class,\n    /** Overridden member. */\n    baseMember: DeclaredElement,\n    /** Overridden class. */\n    baseClass: Class,\n    /** Report mode. */\n    reportMode: ReportMode\n  ): bool {\n    let hasErrors = false;\n    if (thisMember.is(CommonFlags.Constructor)) {\n      assert(baseMember.is(CommonFlags.Constructor));\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            baseClass.internalName\n          );\n        }\n        hasErrors = true;\n      }\n    } else if (thisMember.is(CommonFlags.Private)) {\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Types_have_separate_declarations_of_a_private_property_0,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name\n          );\n        }\n        hasErrors = true;\n      } else {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, thisClass.internalName, baseClass.internalName\n          );\n        }\n        hasErrors = true;\n      }\n    } else if (thisMember.is(CommonFlags.Protected)) {\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, baseClass.internalName, thisClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else if (baseMember.isPublic) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_protected_in_type_1_but_public_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, thisClass.internalName, baseClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else {\n        assert(baseMember.is(CommonFlags.Protected));\n      }\n    } else if (thisMember.isPublic) {\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, baseClass.internalName, thisClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else if (baseMember.is(CommonFlags.Protected)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_protected_in_type_1_but_public_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, baseClass.internalName, thisClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else {\n        assert(baseMember.isPublic);\n      }\n    }\n    return !hasErrors;\n  }\n\n  /** Finishes resolving the specified class. */\n  private finishResolveClass(\n    /** Class to finish resolving. */\n    instance: Class,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode\n  ): void {\n    let members = instance.members;\n    if (!members) instance.members = members = new Map();\n\n    let pendingClasses = this.resolveClassPending;\n    let unimplemented = new Map<string,DeclaredElement>();\n    // Alias implemented interface members\n    let interfaces = instance.interfaces;\n    if (interfaces) {\n      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n        let iface = _values[i];\n        assert(!pendingClasses.has(iface));\n        let ifaceMembers = iface.members;\n        if (ifaceMembers) {\n          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let ifaceMember = assert(ifaceMembers.get(memberName));\n            let existingMember = instance.getMember(memberName);\n            if (existingMember && !this.checkOverrideVisibility(memberName, existingMember, instance, ifaceMember, iface, reportMode)) {\n              continue; // keep previous\n            }\n            members.set(memberName, ifaceMember);\n            unimplemented.set(memberName, ifaceMember);\n          }\n        }\n      }\n    }\n\n    // Alias base members\n    let memoryOffset: u32 = 0;\n    let base = instance.base;\n    if (base) {\n      let implicitlyExtendsObject = instance.prototype.implicitlyExtendsObject;\n      assert(!pendingClasses.has(base));\n      let baseMembers = base.members;\n      if (baseMembers) {\n        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {\n        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let baseMember = assert(baseMembers.get(memberName));\n          if (implicitlyExtendsObject && baseMember.is(CommonFlags.Static)) continue;\n          let existingMember = instance.getMember(memberName);\n          if (existingMember && !this.checkOverrideVisibility(memberName, existingMember, instance, baseMember, base, reportMode)) {\n            continue; // keep previous\n          }\n          members.set(memberName, baseMember);\n          if (baseMember.is(CommonFlags.Abstract)) {\n            unimplemented.set(memberName, baseMember);\n          } else {\n            unimplemented.delete(memberName);\n          }\n        }\n      }\n      memoryOffset = base.nextMemoryOffset;\n    }\n\n    // Resolve instance members\n    let prototype = instance.prototype;\n    let instanceMemberPrototypes = prototype.instanceMembers;\n    let properties = new Array<Property>();\n    if (instanceMemberPrototypes) {\n      // TODO: for (let member of instanceMemberPrototypes.values()) {\n      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        let memberName = member.name;\n        if (base) {\n          let baseMember = base.getMember(memberName);\n          if (baseMember) this.checkOverrideVisibility(memberName, member, instance, baseMember, base, reportMode);\n        }\n        switch (member.kind) {\n          case ElementKind.FunctionPrototype: {\n            let boundPrototype = (<FunctionPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          case ElementKind.PropertyPrototype: {\n            let boundPrototype = (<PropertyPrototype>member).toBound(instance);\n            if (boundPrototype.isField) { // resolve and lay out\n              let boundInstance = this.resolveProperty(boundPrototype, reportMode);\n              if (boundInstance) {\n                let fieldType = boundInstance.type;\n                if (fieldType == Type.void) break; // failed to resolve earlier\n                let needsLayout = true;\n                if (base) {\n                  let existingMember = base.getMember(boundPrototype.name);\n                  if (existingMember && existingMember.kind == ElementKind.PropertyPrototype) {\n                    let existingPrototype = <PropertyPrototype>existingMember;\n                    let existingProperty = this.resolveProperty(existingPrototype, reportMode);\n                    if (existingProperty && existingProperty.isField) {\n                      if (existingProperty.type != boundInstance.type) {\n                        // make sure fields are invariant (Binaryen would otherwise error)\n                        this.errorRelated(\n                          DiagnosticCode.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,\n                          boundInstance.identifierNode.range, existingProperty.identifierNode.range,\n                          boundInstance.name, instance.internalName, base.internalName\n                        );\n                        break; // keep existing\n                      }\n                      boundInstance.memoryOffset = existingProperty.memoryOffset;\n                      needsLayout = false;\n                    }\n                  }\n                }\n                if (needsLayout) {\n                  let byteSize = fieldType.byteSize;\n                  assert(isPowerOf2(byteSize));\n                  let mask = byteSize - 1;\n                  if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;\n                  boundInstance.memoryOffset = memoryOffset;\n                  memoryOffset += byteSize;\n                }\n                boundPrototype.instance = boundInstance;\n                instance.add(boundPrototype.name, boundPrototype); // reports\n                // field materializes here, so check for supported type early\n                // (other checks are performed once an element is compiled)\n                let typeNode = assert(boundPrototype.fieldDeclaration).type;\n                if (typeNode) this.program.checkTypeSupported(fieldType, typeNode);\n              }\n            } else {\n              instance.add(boundPrototype.name, boundPrototype); // reports\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        if (!member.is(CommonFlags.Abstract)) {\n          unimplemented.delete(memberName);\n        }\n      }\n    }\n\n    // Check that property getters and setters match\n    for (let i = 0, k = properties.length; i < k; ++i) {\n      let property = properties[i];\n      let propertyGetter = property.getterInstance;\n      if (!propertyGetter) {\n        this.error(\n          DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,\n          property.identifierNode.range, property.name\n        );\n      } else {\n        let propertySetter = property.setterInstance;\n        if (propertySetter && !propertyGetter.visibilityEquals(propertySetter)) {\n          this.errorRelated(\n            DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,\n            propertyGetter.identifierNode.range, propertySetter.identifierNode.range\n          );\n        }\n      }\n    }\n\n    if (instance.kind != ElementKind.Interface) {\n\n      // Check that all required members are implemented\n      if (!instance.is(CommonFlags.Abstract) && unimplemented.size > 0) {\n        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = _keys[i];\n          let member = assert(unimplemented.get(memberName));\n          this.errorRelated(\n            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,\n            instance.identifierNode.range, member.identifierNode.range,\n            instance.internalName, memberName, member.parent.internalName\n          );\n        }\n      }\n\n      // Finalize memory offset\n      instance.nextMemoryOffset = memoryOffset;\n\n      // Link _own_ constructor if present\n      {\n        let ctorPrototype = instance.getMember(CommonNames.constructor);\n        if (ctorPrototype && ctorPrototype.parent == instance) {\n          assert(ctorPrototype.kind == ElementKind.FunctionPrototype);\n          let ctorInstance = this.resolveFunction(\n            <FunctionPrototype>ctorPrototype,\n            null,\n            assert(instance.contextualTypeArguments),\n            reportMode\n          );\n          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;\n        }\n      }\n    }\n\n    // Fully resolve operator overloads (don't have type parameters on their own)\n    let overloadPrototypes = prototype.operatorOverloadPrototypes;\n    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {\n    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {\n      let overloadKind = unchecked(_keys[i]);\n      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));\n      assert(overloadKind != OperatorKind.Invalid);\n      if (overloadPrototype.is(CommonFlags.Generic)) {\n        // Already errored during initialization: AS212: Decorator '@operator' is not valid here\n        continue;\n      }\n      let operatorInstance: Function | null;\n      if (overloadPrototype.is(CommonFlags.Instance)) {\n        let boundPrototype = overloadPrototype.toBound(instance);\n        operatorInstance = this.resolveFunction(\n          boundPrototype,\n          null,\n          new Map(),\n          reportMode\n        );\n      } else {\n        operatorInstance = this.resolveFunction(\n          overloadPrototype,\n          null,\n          new Map(),\n          reportMode\n        );\n      }\n      if (!operatorInstance) continue;\n      let overloads = instance.operatorOverloads;\n      if (!overloads) instance.operatorOverloads = overloads = new Map();\n      // inc/dec are special in that an instance overload attempts to re-assign\n      // the corresponding value, thus requiring a matching return type, while a\n      // static overload works like any other overload.\n      if (operatorInstance.is(CommonFlags.Instance)) {\n        switch (overloadKind) {\n          case OperatorKind.PrefixInc:\n          case OperatorKind.PrefixDec:\n          case OperatorKind.PostfixInc:\n          case OperatorKind.PostfixDec: {\n            let returnType = operatorInstance.signature.returnType;\n            if (!returnType.isAssignableTo(instance.type)) {\n              if (reportMode == ReportMode.Report) {\n                this.error(\n                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()\n                );\n              }\n            }\n          }\n        }\n      }\n      if (!overloads.has(overloadKind)) {\n        overloads.set(overloadKind, operatorInstance);\n        if (overloadKind == OperatorKind.IndexedGet || overloadKind == OperatorKind.IndexedSet) {\n          let index = instance.indexSignature;\n          if (!index) instance.indexSignature = index = new IndexSignature(instance);\n          if (overloadKind == OperatorKind.IndexedGet) {\n            index.setType(operatorInstance.signature.returnType);\n          }\n        }\n      } else {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Duplicate_decorator,\n            operatorInstance.declaration.range\n          );\n        }\n      }\n    }\n\n    // Remove this class from pending\n    assert(pendingClasses.has(instance)); // must be pending\n    pendingClasses.delete(instance);\n\n    // Finish derived classes that we postponed in `resolveClass` due to the\n    // base class still being pending, again triggering `finishResolveClass`\n    // of any classes derived from those classes, ultimately leading to all\n    // pending classes being resolved.\n    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {\n      let pending = _values[i];\n      let dependsOnInstance = pending.base == instance;\n      let interfaces = pending.interfaces;\n      if (interfaces) {\n        let anyPending = false;\n        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {\n          let iface = _values2[j];\n          if (iface == instance) dependsOnInstance = true;\n          else if (pendingClasses.has(iface)) anyPending = true;\n        }\n        if (anyPending) continue;\n      }\n      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);\n    }\n  }\n\n  /** Resolves a class prototype by first resolving the specified type arguments. */\n  resolveClassInclTypeArguments(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Class | null {\n    let resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.Generic)) {\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes), // must be present if generic\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveClass(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves a property prototype. */\n  resolveProperty(\n    /** The prototype of the property. */\n    prototype: PropertyPrototype,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Property | null {\n    let instance = prototype.instance;\n    if (instance) return instance;\n    prototype.instance = instance = new Property(\n      prototype,\n      prototype.parent // same level as prototype\n    );\n    let getterPrototype = prototype.getterPrototype;\n    if (getterPrototype) {\n      let getterInstance = this.resolveFunction(\n        getterPrototype,\n        null,\n        new Map(),\n        reportMode\n      );\n      if (getterInstance) {\n        instance.getterInstance = getterInstance;\n        instance.setType(getterInstance.signature.returnType);\n      }\n    }\n    let setterPrototype = prototype.setterPrototype;\n    if (setterPrototype) {\n      let setterInstance = this.resolveFunction(\n        setterPrototype,\n        null,\n        new Map(),\n        reportMode\n      );\n      if (setterInstance) {\n        instance.setterInstance = setterInstance;\n        if (!instance.is(CommonFlags.Resolved)) {\n          assert(setterInstance.signature.parameterTypes.length == 1);\n          instance.setType(setterInstance.signature.parameterTypes[0]);\n        }\n      }\n    }\n    return instance;\n  }\n\n  private ensureOneTypeArgument(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): TypeNode | null {\n    let typeArgumentNodes = node.typeArguments;\n    let numTypeArguments = 0;\n    if (!typeArgumentNodes || (numTypeArguments = typeArgumentNodes.length) != 1) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    return typeArgumentNodes[0];\n  }\n}\n", "/**\n * @fileoverview A TypeScript parser for the AssemblyScript subset.\n *\n * Takes the tokens produced by the `Tokenizer` and builds an abstract\n * syntax tree composed of `Node`s wrapped in a `Source` out of it.\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags,\n  LIBRARY_PREFIX,\n  PATH_DELIMITER\n} from \"./common\";\n\nimport {\n  Tokenizer,\n  Token,\n  CommentHandler,\n  IdentifierHandling,\n  isIllegalVariableIdentifier\n} from \"./tokenizer\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticEmitter,\n  DiagnosticMessage\n} from \"./diagnostics\";\n\nimport {\n  CharCode,\n  normalizePath\n} from \"./util\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  TypeNode,\n  TypeName,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  AssertionKind,\n  CallExpression,\n  ClassExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  StringLiteralExpression,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DecoratorNode,\n  DoStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportImportStatement,\n  ExportMember,\n  ExportStatement,\n  ExpressionStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportDeclaration,\n  ImportStatement,\n  IndexSignatureNode,\n  NamespaceDeclaration,\n  ParameterNode,\n  ParameterKind,\n  ReturnStatement,\n  SwitchCase,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  TypeDeclaration,\n  TypeParameterNode,\n  VariableStatement,\n  VariableDeclaration,\n  VoidStatement,\n  WhileStatement,\n  ModuleDeclaration,\n\n  mangleInternalPath\n} from \"./ast\";\n\n/** Represents a dependee. */\nclass Dependee {\n  constructor(\n    public source: Source,\n    public reportNode: Node\n  ) {}\n}\n\n/** Parser interface. */\nexport class Parser extends DiagnosticEmitter {\n\n  /** Source file names to be requested next. */\n  backlog: string[] = new Array();\n  /** Source file names already seen, that is processed or backlogged. */\n  seenlog: Set<string> = new Set();\n  /** Source file names already completely processed. */\n  donelog: Set<string> = new Set();\n  /** Optional handler to intercept comments while tokenizing. */\n  onComment: CommentHandler | null = null;\n  /** Current file being parsed. */\n  currentSource: Source | null = null;\n  /** Map of dependees being depended upon by a source, by path. */\n  dependees: Map<string, Dependee> = new Map();\n  /** An array of parsed sources. */\n  sources: Source[];\n  /** Current overridden module name. */\n  currentModuleName: string | null = null;\n\n  /** Constructs a new parser. */\n  constructor(\n    diagnostics: DiagnosticMessage[] | null = null,\n    sources: Source[] = []\n  ) {\n    super(diagnostics);\n    this.sources = sources;\n  }\n\n  /** Parses a file and adds its definitions to the program. */\n  parseFile(\n    /** Source text of the file, or `null` to indicate not found. */\n    text: string | null,\n    /** Normalized path of the file. */\n    path: string,\n    /** Whether this is an entry file. */\n    isEntry: bool\n  ): void {\n    // the frontend gives us paths with file extensions\n    let normalizedPath = normalizePath(path);\n    let internalPath = mangleInternalPath(normalizedPath);\n\n    // check if already processed\n    if (this.donelog.has(internalPath)) return;\n    this.donelog.add(internalPath); // do not parse again\n    this.seenlog.add(internalPath); // do not request again\n\n    // check if this is an error\n    if (text == null) {\n      let dependees = this.dependees;\n      let dependee: Dependee | null = null;\n      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        dependee\n          ? dependee.reportNode.range\n          : null,\n        path\n      );\n      return;\n    }\n\n    // create the source element\n    let source = new Source(\n      isEntry\n        ? SourceKind.UserEntry\n        : path.startsWith(LIBRARY_PREFIX)\n          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\n            ? SourceKind.LibraryEntry\n            : SourceKind.Library\n          : SourceKind.User,\n      normalizedPath,\n      text\n    );\n\n    this.sources.push(source);\n    this.currentSource = source;\n    this.currentModuleName = null;\n\n    // tokenize and parse\n    let tn = new Tokenizer(source, this.diagnostics);\n    tn.onComment = this.onComment;\n    let statements = source.statements;\n    while (!tn.skip(Token.EndOfFile)) {\n      let statement = this.parseTopLevelStatement(tn, null);\n      if (statement) {\n        statements.push(statement);\n      } else {\n        this.skipStatement(tn);\n      }\n    }\n  }\n\n  /** Parses a top-level statement. */\n  parseTopLevelStatement(\n    tn: Tokenizer,\n    namespace: NamespaceDeclaration | null = null\n  ): Statement | null {\n    let flags = namespace ? namespace.flags & CommonFlags.Ambient : CommonFlags.None;\n    let startPos = -1;\n\n    // check decorators\n    let decorators: DecoratorNode[] | null = null;\n    while (tn.skip(Token.At)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      let decorator = this.parseDecorator(tn);\n      if (!decorator) {\n        this.skipStatement(tn);\n        continue;\n      }\n      if (!decorators) decorators = [decorator];\n      else decorators.push(decorator);\n    }\n\n    // check modifiers\n    let exportStart = 0;\n    let exportEnd = 0;\n    let defaultStart = 0;\n    let defaultEnd = 0;\n    if (tn.skip(Token.Export)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      flags |= CommonFlags.Export;\n      exportStart = tn.tokenPos;\n      exportEnd = tn.pos;\n      if (tn.skip(Token.Default)) {\n        defaultStart = tn.tokenPos;\n        defaultEnd = tn.pos;\n      }\n    }\n\n    let declareStart = 0;\n    let declareEnd = 0;\n    let contextIsAmbient = namespace != null && namespace.is(CommonFlags.Ambient);\n    if (tn.skip(Token.Declare)) {\n      if (contextIsAmbient) {\n        this.error(\n          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n          tn.range()\n        ); // recoverable\n      } else {\n        if (startPos < 0) startPos = tn.tokenPos;\n        declareStart = startPos;\n        declareEnd = tn.pos;\n        flags |= CommonFlags.Declare | CommonFlags.Ambient;\n      }\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.Ambient;\n    }\n\n    // parse the statement\n    let statement: Statement | null = null;\n\n    // handle declarations\n    let first = tn.peek();\n    if (startPos < 0) startPos = tn.nextTokenPos;\n    switch (first) {\n      case Token.Const: {\n        tn.next();\n        flags |= CommonFlags.Const;\n        if (tn.skip(Token.Enum)) {\n          statement = this.parseEnum(tn, flags, decorators, startPos);\n        } else {\n          statement = this.parseVariable(tn, flags, decorators, startPos);\n        }\n        decorators = null;\n        break;\n      }\n      case Token.Let: flags |= CommonFlags.Let;\n      case Token.Var: {\n        tn.next();\n        statement = this.parseVariable(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Enum: {\n        tn.next();\n        statement = this.parseEnum(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Function: {\n        tn.next();\n        statement = this.parseFunction(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Abstract: {\n        let state = tn.mark();\n        tn.next();\n        let abstractStart = tn.tokenPos;\n        let abstractEnd = tn.pos;\n        let next = tn.peek(true);\n        if (tn.nextTokenOnNewLine) {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        }\n        if (next != Token.Class) {\n          if (next == Token.Interface) {\n            this.error(\n              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,\n              tn.range(abstractStart, abstractEnd)\n            );\n          }\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        } else {\n          tn.discard(state);\n        }\n        flags |= CommonFlags.Abstract;\n        // fall through\n      }\n      case Token.Class:\n      case Token.Interface: {\n        tn.next();\n        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Namespace: {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.Prefer) == Token.Identifier) {\n          tn.discard(state);\n          statement = this.parseNamespace(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.Import: {\n        tn.next();\n        flags |= CommonFlags.Import;\n        if (flags & CommonFlags.Export) {\n          statement = this.parseExportImport(tn, startPos);\n        } else {\n          statement = this.parseImport(tn);\n        }\n        break;\n      }\n      case Token.Type: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.Prefer) == Token.Identifier) {\n          tn.discard(state);\n          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.Module: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(true) == Token.StringLiteral && !tn.nextTokenOnNewLine) {\n          tn.discard(state);\n          statement = this.parseModuleDeclaration(tn, flags);\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      default: {\n\n        // handle plain exports\n        if (flags & CommonFlags.Export) {\n          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.Prefer)) {\n            if (declareEnd) {\n              this.error(\n                DiagnosticCode.An_export_assignment_cannot_have_modifiers,\n                tn.range(declareStart, declareEnd)\n              );\n            }\n            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);\n            defaultStart = defaultEnd = 0; // consume\n          } else {\n            statement = this.parseExport(tn, startPos, (flags & CommonFlags.Declare) != 0);\n          }\n\n        // handle non-declaration statements\n        } else {\n          if (exportEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(exportStart, exportEnd), \"export\"\n            ); // recoverable\n          }\n          if (declareEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(declareStart, declareEnd), \"declare\"\n            ); // recoverable\n          }\n          if (!namespace) {\n            statement = this.parseStatement(tn, true);\n          } // TODO: else?\n        }\n        break;\n      }\n    }\n\n    // check for decorators that weren't consumed\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          decorators[i].range\n        );\n      }\n    }\n\n    // check if this an `export default` declaration\n    if (defaultEnd && statement != null) {\n      switch (statement.kind) {\n        case NodeKind.EnumDeclaration:\n        case NodeKind.FunctionDeclaration:\n        case NodeKind.ClassDeclaration:\n        case NodeKind.InterfaceDeclaration:\n        case NodeKind.NamespaceDeclaration: {\n          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));\n        }\n        default: {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(defaultStart, defaultEnd), \"default\"\n          );\n        }\n      }\n    }\n    return statement;\n  }\n\n  /** Obtains the next file to parse. */\n  nextFile(): string | null {\n    let backlog = this.backlog;\n    return backlog.length ? assert(backlog.shift()) : null;\n  }\n\n  /** Obtains the path of the dependee of the given imported file. */\n  getDependee(dependent: string): string | null {\n    let dependees = this.dependees;\n    if (dependees.has(dependent)) {\n      let dependee = assert(dependees.get(dependent));\n      return dependee.source.internalPath;\n    }\n    return null;\n  }\n\n  /** Finishes parsing. */\n  finish(): void {\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\n    this.backlog = [];\n    this.seenlog.clear();\n    this.donelog.clear();\n    this.dependees.clear();\n  }\n\n  // types\n\n  /** Parses a type name. */\n  parseTypeName(\n    tn: Tokenizer\n  ): TypeName | null {\n\n    // at: Identifier ('.' Identifier)*\n\n    let first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n    let current = first;\n    while (tn.skip(Token.Dot)) {\n      if (tn.skip(Token.Identifier)) {\n        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n        current.next = next;\n        current = next;\n      } else {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range(tn.pos)\n        );\n        return null;\n      }\n    }\n    return first;\n  }\n\n  /** Parses a type. */\n  parseType(\n    tn: Tokenizer,\n    acceptParenthesized: bool = true,\n    suppressErrors: bool = false\n  ): TypeNode | null {\n\n    // before: Type\n\n    // NOTE: this parses our limited subset\n    let token = tn.next();\n    let startPos = tn.tokenPos;\n\n    let type: TypeNode;\n\n    // '(' ...\n    if (token == Token.OpenParen) {\n\n      // '(' FunctionSignature ')' '|' 'null'?\n      let isNullableSignature = tn.skip(Token.OpenParen);\n      // FunctionSignature?\n      let signature = this.tryParseFunctionType(tn);\n      if (signature) {\n        if (isNullableSignature) {\n          if (!tn.skip(Token.CloseParen)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \")\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.Bar)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"|\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.Null)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          signature.isNullable = true;\n        }\n        return signature;\n      } else if (isNullableSignature || this.tryParseSignatureIsSignature) {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n      // Type (',' Type)* ')'\n      if (acceptParenthesized) {\n        let innerType = this.parseType(tn, false, suppressErrors);\n        if (!innerType) return null;\n        if (!tn.skip(Token.CloseParen)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \")\"\n            );\n          }\n          return null;\n        }\n        type = innerType;\n        type.range.start = startPos;\n        type.range.end = tn.pos;\n      } else {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n    // 'void'\n    } else if (token == Token.Void) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'this'\n    } else if (token == Token.This) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"this\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'true'\n    } else if (token == Token.True || token == Token.False) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'null'\n    } else if (token == Token.Null) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"null\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // StringLiteral\n    } else if (token == Token.StringLiteral) {\n      tn.readString();\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // Identifier\n    } else if (token == Token.Identifier) {\n      let name = this.parseTypeName(tn);\n      if (!name) return null;\n      let parameters: TypeNode[] | null = null;\n\n      // Name<T>\n      if (tn.skip(Token.LessThan)) {\n        do {\n          let parameter = this.parseType(tn, true, suppressErrors);\n          if (!parameter) return null;\n          if (!parameters) parameters = [ parameter ];\n          else parameters.push(parameter);\n        } while (tn.skip(Token.Comma));\n        if (!tn.skip(Token.GreaterThan)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \">\"\n            );\n          }\n          return null;\n        }\n      }\n      if (!parameters) parameters = [];\n      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));\n    } else {\n      if (!suppressErrors) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        );\n      }\n      return null;\n    }\n    // ... | null\n    while (tn.skip(Token.Bar)) {\n      if (tn.skip(Token.Null)) {\n        type.isNullable = true;\n      } else {\n        let notNullStart = tn.pos;\n        let notNull = this.parseType(tn, false, true);\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            notNull ? notNull.range : tn.range(notNullStart), \"null\"\n          );\n        }\n        return null;\n      }\n    }\n    // ... [][]\n    while (tn.skip(Token.OpenBracket)) {\n      let bracketStart = tn.tokenPos;\n      if (!tn.skip(Token.CloseBracket)) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"]\"\n          );\n        }\n        return null;\n      }\n      let bracketRange = tn.range(bracketStart, tn.pos);\n\n      // ...[] | null\n      let nullable = false;\n      if (tn.skip(Token.Bar)) {\n        if (tn.skip(Token.Null)) {\n          nullable = true;\n        } else {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          return null;\n        }\n      }\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"Array\", bracketRange),\n        [ type ],\n        nullable,\n        tn.range(startPos, tn.pos)\n      );\n      if (nullable) break;\n    }\n\n    return type;\n  }\n\n  // Indicates whether tryParseSignature determined that it is handling a Signature\n  private tryParseSignatureIsSignature: bool = false;\n\n  /** Parses a function type, as used in type declarations. */\n  tryParseFunctionType(\n    tn: Tokenizer\n  ): FunctionTypeNode | null {\n\n    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type\n\n    let state = tn.mark();\n    let startPos = tn.tokenPos;\n    let parameters: ParameterNode[] | null = null;\n    let thisType: NamedTypeNode | null = null;\n    let isSignature: bool = false;\n    let firstParamNameNoType: IdentifierExpression | null = null;\n    let firstParamKind: ParameterKind = ParameterKind.Default;\n\n    if (tn.skip(Token.CloseParen)) {\n      isSignature = true;\n      tn.discard(state);\n      parameters = [];\n\n    } else {\n      isSignature = false; // not yet known\n      do {\n        let paramStart = -1;\n        let kind = ParameterKind.Default;\n        if (tn.skip(Token.Dot_Dot_Dot)) {\n          paramStart = tn.tokenPos;\n          isSignature = true;\n          tn.discard(state);\n          kind = ParameterKind.Rest;\n        }\n        if (tn.skip(Token.This)) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          if (tn.skip(Token.Colon)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn, false);\n            if (!type) return null;\n            if (type.kind != NodeKind.NamedType) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                type.range\n              );\n              this.tryParseSignatureIsSignature = true;\n              return null;\n            }\n            thisType = <NamedTypeNode>type;\n          } else {\n            tn.reset(state);\n            this.tryParseSignatureIsSignature = false;\n            return null;\n          }\n        } else if (tn.skipIdentifier()) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));\n          if (tn.skip(Token.Question)) {\n            isSignature = true;\n            tn.discard(state);\n            if (kind == ParameterKind.Rest) {\n              this.error(\n                DiagnosticCode.A_rest_parameter_cannot_be_optional,\n                tn.range()\n              ); // recoverable\n            } else {\n              kind = ParameterKind.Optional;\n            }\n          }\n          if (tn.skip(Token.Colon)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn); // not suppressing errors because known\n            if (!type) {\n              this.tryParseSignatureIsSignature = isSignature;\n              return null;\n            }\n            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));\n            if (!parameters) parameters = [ param ];\n            else parameters.push(param);\n          } else {\n            if (!isSignature) {\n              if (tn.peek() == Token.Comma) {\n                isSignature = true;\n                tn.discard(state);\n              }\n            }\n            if (isSignature) {\n              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));\n              if (!parameters) parameters = [ param ];\n              else parameters.push(param);\n              this.error(\n                DiagnosticCode.Type_expected,\n                param.type.range\n              ); // recoverable\n            } else if (!parameters) {\n              // on '(' Identifier ^',' we don't yet know whether this is a\n              // parenthesized or a function type, hence we have to delay the\n              // respective diagnostic until we know for sure.\n              firstParamNameNoType = name;\n              firstParamKind = kind;\n            }\n          }\n        } else {\n          if (isSignature) {\n            this.error(\n              DiagnosticCode.Identifier_expected,\n              tn.range()\n            );\n          } else {\n            tn.reset(state);\n          }\n          this.tryParseSignatureIsSignature = isSignature;\n          return null;\n        }\n      } while (tn.skip(Token.Comma));\n      if (!tn.skip(Token.CloseParen)) {\n        if (isSignature) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        } else {\n          tn.reset(state);\n        }\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    }\n\n    let returnType: TypeNode | null;\n    if (tn.skip(Token.Equals_GreaterThan)) {\n      if (!isSignature) {\n        isSignature = true;\n        tn.discard(state);\n        if (firstParamNameNoType) { // now we know\n          let param = Node.createParameter(\n            firstParamKind,\n            firstParamNameNoType,\n            Node.createOmittedType(firstParamNameNoType.range.atEnd),\n            null,\n            firstParamNameNoType.range\n          );\n          if (!parameters) parameters = [ param ];\n          else parameters.push(param);\n          this.error(\n            DiagnosticCode.Type_expected,\n            param.type.range\n          ); // recoverable\n        }\n      }\n      returnType = this.parseType(tn);\n      if (!returnType) {\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    } else {\n      if (isSignature) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=>\"\n        );\n      } else {\n        tn.reset(state);\n      }\n      this.tryParseSignatureIsSignature = isSignature;\n      return null;\n    }\n    this.tryParseSignatureIsSignature = true;\n\n    if (!parameters) parameters = [];\n\n    return Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  // statements\n\n  parseDecorator(\n    tn: Tokenizer\n  ): DecoratorNode | null {\n\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\n\n    let startPos = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let name = tn.readIdentifier();\n      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\n      while (tn.skip(Token.Dot)) {\n        if (tn.skipIdentifier(IdentifierHandling.Prefer)) {\n          name = tn.readIdentifier();\n          expression = Node.createPropertyAccessExpression(\n            expression,\n            Node.createIdentifierExpression(name, tn.range()),\n            tn.range(startPos, tn.pos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let args: Expression[] | null;\n      if (tn.skip(Token.OpenParen)) {\n        args = this.parseArguments(tn);\n        if (args) {\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\n        }\n      } else {\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVariable(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32,\n    isFor: bool = false\n  ): VariableStatement | null {\n\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\n\n    let declarations = new Array<VariableDeclaration>();\n    do {\n      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);\n      if (!declaration) return null;\n      declaration.overriddenModuleName = this.currentModuleName;\n      declarations.push(declaration);\n    } while (tn.skip(Token.Comma));\n\n    let ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseVariableDeclaration(\n    tn: Tokenizer,\n    parentFlags: CommonFlags,\n    parentDecorators: DecoratorNode[] | null,\n    isFor: bool = false\n  ): VariableDeclaration | null {\n\n    // before: Identifier (':' Type)? ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (isIllegalVariableIdentifier(identifier.text)) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        identifier.range\n      );\n    }\n    let flags = parentFlags;\n    if (tn.skip(Token.Exclamation)) {\n      flags |= CommonFlags.DefinitelyAssigned;\n    }\n\n    let type: TypeNode | null = null;\n    if (tn.skip(Token.Colon)) {\n      type = this.parseType(tn, true);\n    }\n\n    let initializer: Expression | null = null;\n    if (tn.skip(Token.Equals)) {\n      if (flags & CommonFlags.Ambient) {\n        this.error(\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n      initializer = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!initializer) return null;\n      if (flags & CommonFlags.DefinitelyAssigned) {\n        this.error(\n          DiagnosticCode.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions,\n          initializer.range\n        );\n      }\n    } else if (!isFor) {\n      if (flags & CommonFlags.Const) {\n        if (!(flags & CommonFlags.Ambient)) {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            identifier.range\n          ); // recoverable\n        }\n      } else if (!type) { // neither type nor initializer\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range(tn.pos)\n        ); // recoverable\n      }\n    }\n    let range = Range.join(identifier.range, tn.range());\n    if ((flags & CommonFlags.DefinitelyAssigned) != 0 && (flags & CommonFlags.Ambient) != 0) {\n      this.error(\n        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n        range\n      );\n    }\n    return Node.createVariableDeclaration(\n      identifier,\n      parentDecorators,\n      flags,\n      type,\n      initializer,\n      range\n    );\n  }\n\n  parseEnum(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): EnumDeclaration | null {\n\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\n\n    if (tn.next() != Token.Identifier) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (tn.next() != Token.OpenBrace) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n    let members = new Array<EnumValueDeclaration>();\n    while (!tn.skip(Token.CloseBrace)) {\n      let member = this.parseEnumValue(tn, CommonFlags.None);\n      if (!member) return null;\n      members.push(member);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseBrace)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          return null;\n        }\n      }\n    }\n    let ret = Node.createEnumDeclaration(\n      identifier,\n      decorators,\n      flags,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    ret.overriddenModuleName = this.currentModuleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseEnumValue(\n    tn: Tokenizer,\n    parentFlags: CommonFlags\n  ): EnumValueDeclaration | null {\n\n    // before: Identifier ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    let value: Expression | null = null;\n    if (tn.skip(Token.Equals)) {\n      value = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!value) return null;\n    }\n    return Node.createEnumValueDeclaration(\n      identifier,\n      parentFlags,\n      value,\n      Range.join(identifier.range, tn.range())\n    );\n  }\n\n  parseReturn(\n    tn: Tokenizer\n  ): ReturnStatement | null {\n\n    // at 'return': Expression | (';' | '}' | ...'\\n')\n\n    let startPos = tn.tokenPos;\n    let expr: Expression | null = null;\n    if (\n      tn.peek(true) != Token.Semicolon &&\n      tn.nextToken != Token.CloseBrace &&\n      !tn.nextTokenOnNewLine\n    ) {\n      if (!(expr = this.parseExpression(tn))) return null;\n    }\n\n    let ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseTypeParameters(\n    tn: Tokenizer\n  ): TypeParameterNode[] | null {\n\n    // at '<': TypeParameter (',' TypeParameter)* '>'\n\n    let typeParameters = new Array<TypeParameterNode>();\n    let seenOptional = false;\n    let start = tn.tokenPos;\n    while (!tn.skip(Token.GreaterThan)) {\n      let typeParameter = this.parseTypeParameter(tn);\n      if (!typeParameter) return null;\n      if (typeParameter.defaultType) {\n        seenOptional = true;\n      } else if (seenOptional) {\n        this.error(\n          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,\n          typeParameter.range\n        );\n        typeParameter.defaultType = null;\n      }\n      typeParameters.push(typeParameter);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.GreaterThan)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n      }\n    }\n    if (!typeParameters.length) {\n      this.error(\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\n        tn.range(start, tn.pos)\n      ); // recoverable\n    }\n    return typeParameters;\n  }\n\n  parseTypeParameter(\n    tn: Tokenizer\n  ): TypeParameterNode | null {\n\n    // before: Identifier ('extends' Type)? ('=' Type)?\n\n    if (tn.next() == Token.Identifier) {\n      let identifier = Node.createIdentifierExpression(\n        tn.readIdentifier(),\n        tn.range()\n      );\n      let extendsType: NamedTypeNode | null = null;\n      if (tn.skip(Token.Extends)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        extendsType = <NamedTypeNode>type;\n      }\n      let defaultType: NamedTypeNode | null = null;\n      if (tn.skip(Token.Equals)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        defaultType = <NamedTypeNode>type;\n      }\n      return Node.createTypeParameter(\n        identifier,\n        extendsType,\n        defaultType,\n        Range.join(identifier.range, tn.range())\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  private parseParametersThis: NamedTypeNode | null = null;\n\n  parseParameters(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode[] | null {\n\n    // at '(': (Parameter (',' Parameter)*)? ')'\n\n    let parameters = new Array<ParameterNode>();\n    let seenRest: ParameterNode | null = null;\n    let seenOptional = false;\n    let reportedRest = false;\n    let thisType: TypeNode | null = null;\n\n    // check if there is a leading `this` parameter\n    this.parseParametersThis = null;\n    if (tn.skip(Token.This)) {\n      if (tn.skip(Token.Colon)) {\n        thisType = this.parseType(tn); // reports\n        if (!thisType) return null;\n        if (thisType.kind == NodeKind.NamedType) {\n          this.parseParametersThis = <NamedTypeNode>thisType;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            thisType.range\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n        return null;\n      }\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          return parameters;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n\n    while (!tn.skip(Token.CloseParen)) {\n      let param = this.parseParameter(tn, isConstructor); // reports\n      if (!param) return null;\n      if (seenRest && !reportedRest) {\n        this.error(\n          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\n          seenRest.name.range\n        );\n        reportedRest = true;\n      }\n      switch (param.parameterKind) {\n        default: {\n          if (seenOptional) {\n            this.error(\n              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\n              param.name.range\n            );\n          }\n          break;\n        }\n        case ParameterKind.Optional: {\n          seenOptional = true;\n          break;\n        }\n        case ParameterKind.Rest: {\n          seenRest = param;\n          break;\n        }\n      }\n      parameters.push(param);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return parameters;\n  }\n\n  parseParameter(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode | null {\n\n    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?\n\n    let isRest = false;\n    let isOptional = false;\n    let startRange: Range | null = null;\n    let accessFlags: CommonFlags = CommonFlags.None;\n    if (isConstructor) {\n      if (tn.skip(Token.Public)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Public;\n      } else if (tn.skip(Token.Protected)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Protected;\n      } else if (tn.skip(Token.Private)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Private;\n      }\n      if (tn.peek() == Token.Readonly) {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() != Token.Colon) { // modifier\n          tn.discard(state);\n          if (!startRange) startRange = tn.range();\n          accessFlags |= CommonFlags.Readonly;\n        } else { // identifier\n          tn.reset(state);\n        }\n      }\n    }\n    if (tn.skip(Token.Dot_Dot_Dot)) {\n      if (accessFlags) {\n        this.error(\n          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,\n          tn.range()\n        );\n      } else {\n        startRange = tn.range();\n      }\n      isRest = true;\n    }\n    if (tn.skipIdentifier()) {\n      if (!isRest) startRange = tn.range();\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let type: TypeNode | null = null;\n      if (isOptional = tn.skip(Token.Question)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\n            identifier.range\n          );\n        }\n      }\n      if (tn.skip(Token.Colon)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        type = Node.createOmittedType(tn.range(tn.pos));\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.Equals)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\n            identifier.range\n          );\n        }\n        if (isOptional) {\n          this.error(\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\n            identifier.range\n          );\n        } else {\n          isOptional = true;\n        }\n        initializer = this.parseExpression(tn, Precedence.Comma + 1);\n        if (!initializer) return null;\n      }\n      let param = Node.createParameter(\n        isRest\n          ? ParameterKind.Rest\n          : isOptional\n            ? ParameterKind.Optional\n            : ParameterKind.Default,\n        identifier,\n        type,\n        initializer,\n        Range.join(assert(startRange), tn.range())\n      );\n      param.flags |= accessFlags;\n      return param;\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseFunction(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): FunctionDeclaration | null {\n\n    // at 'function':\n    //  Identifier\n    //  ('<' TypeParameters)?\n    //  '(' Parameters (':' Type)?\n    //  '{' Statement* '}'\n    //  ';'?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range(tn.pos)\n      );\n      return null;\n    }\n\n    let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    let signatureStart = -1;\n\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      signatureStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.Generic;\n    }\n\n    if (!tn.skip(Token.OpenParen)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"(\"\n      );\n      return null;\n    }\n\n    if (signatureStart < 0) {\n      signatureStart = tn.tokenPos;\n    }\n\n    let parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n    let thisType = this.parseParametersThis;\n\n    let isSetter = (flags & CommonFlags.Set) != 0;\n    if (isSetter) {\n      if (parameters.length != 1) {\n        this.error(\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n          name.range\n        ); // recoverable\n      }\n      if (parameters.length > 0 && parameters[0].initializer) {\n        this.error(\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    if (flags & CommonFlags.Get) {\n      if (parameters.length) {\n        this.error(\n          DiagnosticCode.A_get_accessor_cannot_have_parameters,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    let returnType: TypeNode | null = null;\n    if (tn.skip(Token.Colon)) {\n      returnType = this.parseType(tn, true, isSetter);\n      if (!returnType) return null;\n    }\n\n    if (!returnType) {\n      returnType = Node.createOmittedType(\n        tn.range(tn.pos)\n      );\n      if (!isSetter) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnType.range\n        ); // recoverable\n      }\n    }\n\n    let signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    let body: Statement | null = null;\n    if (tn.skip(Token.OpenBrace)) {\n      if (flags & CommonFlags.Ambient) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n\n      body = this.parseBlockStatement(tn, false);\n      if (!body) return null;\n    } else if (!(flags & CommonFlags.Ambient)) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        tn.range(tn.pos)\n      );\n    }\n\n    let ret = Node.createFunctionDeclaration(\n      name,\n      decorators,\n      flags,\n      typeParameters,\n      signature,\n      body,\n      ArrowKind.None,\n      tn.range(startPos, tn.pos)\n    );\n    ret.overriddenModuleName = this.currentModuleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\n    let startPos = tn.tokenPos;\n    let name: IdentifierExpression;\n    let arrowKind = ArrowKind.None;\n\n    // either at 'function':\n    //  Identifier?\n    //  '(' Parameters (':' Type)?\n    //  Statement\n\n    if (tn.token == Token.Function) {\n      if (tn.skipIdentifier()) {\n        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      } else { // empty name\n        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n      }\n      if (!tn.skip(Token.OpenParen)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"(\"\n        );\n        return null;\n      }\n\n      // or at '(' of arrow function:\n      //  Parameters (':' Type)?\n      //  Statement\n\n    } else {\n      arrowKind = ArrowKind.Parenthesized;\n      assert(tn.token == Token.OpenParen);\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));\n    }\n\n    // TODO: type parameters? doesn't seem worth it.\n\n    let signatureStart = tn.pos;\n    let parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n\n    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);\n  }\n\n  private parseFunctionExpressionCommon(\n    tn: Tokenizer,\n    name: IdentifierExpression,\n    parameters: ParameterNode[],\n    explicitThis: NamedTypeNode | null,\n    arrowKind: ArrowKind,\n    startPos: i32 = -1,\n    signatureStart: i32 = -1\n  ): FunctionExpression | null {\n    if (startPos < 0) startPos = name.range.start;\n    if (signatureStart < 0) signatureStart = startPos;\n\n    let returnType: TypeNode | null = null;\n    if (arrowKind != ArrowKind.Single && tn.skip(Token.Colon)) {\n      returnType = this.parseType(tn);\n      if (!returnType) return null;\n    } else {\n      returnType = Node.createOmittedType(tn.range(tn.pos));\n    }\n\n    if (arrowKind) {\n      if (!tn.skip(Token.Equals_GreaterThan)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"=>\"\n        );\n        return null;\n      }\n    }\n\n    let signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      explicitThis,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    let body: Statement | null = null;\n    if (arrowKind) {\n      if (tn.skip(Token.OpenBrace)) {\n        body = this.parseBlockStatement(tn, false);\n      } else {\n        let bodyExpression = this.parseExpression(tn, Precedence.Comma + 1);\n        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);\n      }\n    } else {\n      if (!tn.skip(Token.OpenBrace)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"{\"\n        );\n        return null;\n      }\n      body = this.parseBlockStatement(tn, false);\n    }\n    if (!body) return null;\n\n    let declaration = Node.createFunctionDeclaration(\n      name,\n      null,\n      CommonFlags.None,\n      null,\n      signature,\n      body,\n      arrowKind,\n      tn.range(startPos, tn.pos)\n    );\n    return Node.createFunctionExpression(declaration);\n  }\n\n  parseClassOrInterface(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): ClassDeclaration | null {\n\n    // at ('class' | 'interface'):\n    //   Identifier\n    //   ('<' TypeParameters)?\n    //   ('extends' Type)?\n    //   ('implements' Type (',' Type)*)?\n    //   '{' ClassMember* '}'\n\n    let isInterface = tn.token == Token.Interface;\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n\n    let identifier = Node.createIdentifierExpression(\n      tn.readIdentifier(),\n      tn.range()\n    );\n\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.Generic;\n    }\n\n    let extendsType: NamedTypeNode | null = null;\n    if (tn.skip(Token.Extends)) {\n      let type = this.parseType(tn);\n      if (!type) return null;\n      if (type.kind != NodeKind.NamedType) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          type.range\n        );\n        return null;\n      }\n      extendsType = <NamedTypeNode>type;\n    }\n\n    let implementsTypes: NamedTypeNode[] | null = null;\n    if (tn.skip(Token.Implements)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,\n          tn.range()\n        ); // recoverable\n      }\n      do {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        if (!isInterface) {\n          if (!implementsTypes) implementsTypes = [];\n          implementsTypes.push(<NamedTypeNode>type);\n        }\n      } while (tn.skip(Token.Comma));\n    }\n\n    if (!tn.skip(Token.OpenBrace)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n\n    let members = new Array<DeclarationStatement>();\n    let declaration: ClassDeclaration;\n    if (isInterface) {\n      assert(!implementsTypes);\n      declaration = Node.createInterfaceDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        null,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    } else {\n      declaration = Node.createClassDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        implementsTypes,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    }\n    if (!tn.skip(Token.CloseBrace)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.IndexSignature) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(member instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.EndOfFile)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CloseBrace));\n    }\n    declaration.range.end = tn.pos;\n    declaration.overriddenModuleName = this.currentModuleName;\n    return declaration;\n  }\n\n  parseClassExpression(tn: Tokenizer): ClassExpression | null {\n\n    // at 'class': Identifier? '{' ... '}'\n\n    let startPos = tn.tokenPos;\n    let name: IdentifierExpression;\n\n    if (tn.skipIdentifier()) {\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    } else {\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n    }\n\n    if (!tn.skip(Token.OpenBrace)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"{\"\n      );\n      return null;\n    }\n\n    let members = new Array<DeclarationStatement>();\n    let declaration = Node.createClassDeclaration(\n      name,\n      null,\n      CommonFlags.None,\n      null,\n      null,\n      null,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    if (!tn.skip(Token.CloseBrace)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.IndexSignature) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(declaration instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.EndOfFile)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CloseBrace));\n    }\n    declaration.range.end = tn.pos;\n    return Node.createClassExpression(declaration);\n  }\n\n  parseClassMember(\n    tn: Tokenizer,\n    parent: ClassDeclaration\n  ): Node | null {\n\n    // before:\n    //   'declare'?\n    //   ('public' | 'private' | 'protected')?\n    //   ('static' | 'abstract')?\n    //   'override'?\n    //   'readonly'?\n    //   ('get' | 'set')?\n    //   Identifier ...\n\n    let isInterface = parent.kind == NodeKind.InterfaceDeclaration;\n    let startPos = 0;\n    let decorators: DecoratorNode[] | null = null;\n    if (tn.skip(Token.At)) {\n      startPos = tn.tokenPos;\n      do {\n        let decorator = this.parseDecorator(tn);\n        if (!decorator) break;\n        if (!decorators) decorators = new Array();\n        decorators.push(decorator);\n      } while (tn.skip(Token.At));\n      if (isInterface && decorators) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n        );\n      }\n    }\n\n    // inherit ambient status\n    let flags = parent.flags & CommonFlags.Ambient;\n\n    // interface methods are always overridden if used\n    if (isInterface) flags |= CommonFlags.Overridden;\n\n    let declareStart = 0;\n    let declareEnd = 0;\n    let contextIsAmbient = parent.is(CommonFlags.Ambient);\n    if (tn.skip(Token.Declare)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"declare\"\n        );\n      } else {\n        if (contextIsAmbient) {\n          this.error(\n            DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n            tn.range()\n          ); // recoverable\n        } else {\n          flags |= CommonFlags.Declare | CommonFlags.Ambient;\n          declareStart = tn.tokenPos;\n          declareEnd = tn.pos;\n        }\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.Ambient;\n    }\n\n    let accessStart = 0;\n    let accessEnd = 0;\n    if (tn.skip(Token.Public)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"public\"\n        );\n      } else {\n        flags |= CommonFlags.Public;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.Private)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"private\"\n        );\n      } else {\n        flags |= CommonFlags.Private;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.Protected)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"protected\"\n        );\n      } else {\n        flags |= CommonFlags.Protected;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    let staticStart = 0;\n    let staticEnd = 0;\n    let abstractStart = 0;\n    let abstractEnd = 0;\n    if (tn.skip(Token.Static)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"static\"\n        );\n      } else {\n        flags |= CommonFlags.Static;\n        staticStart = tn.tokenPos;\n        staticEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else {\n      flags |= CommonFlags.Instance;\n      if (tn.skip(Token.Abstract)) {\n        if (isInterface || !parent.is(CommonFlags.Abstract)) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(), \"abstract\"\n          );\n        } else {\n          flags |= CommonFlags.Abstract;\n          abstractStart = tn.tokenPos;\n          abstractEnd = tn.pos;\n        }\n        if (!startPos) startPos = tn.tokenPos;\n      }\n      if (parent.flags & CommonFlags.Generic) flags |= CommonFlags.GenericContext;\n    }\n\n    let overrideStart = 0;\n    let overrideEnd = 0;\n    if (tn.skip(Token.Override)) {\n      if (isInterface || parent.extendsType == null) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"override\"\n        );\n      } else {\n        flags |= CommonFlags.Override;\n        overrideStart = tn.tokenPos;\n        overrideEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    let readonlyStart = 0;\n    let readonlyEnd = 0;\n    if (tn.peek() == Token.Readonly) {\n      let state = tn.mark();\n      tn.next();\n      if (tn.peek() != Token.Colon) { // modifier\n        tn.discard(state);\n        flags |= CommonFlags.Readonly;\n        readonlyStart = tn.tokenPos;\n        readonlyEnd = tn.pos;\n        if (!startPos) startPos = readonlyStart;\n      } else { // identifier\n        tn.reset(state);\n      }\n    }\n\n    // check if accessor: ('get' | 'set') ^\\n Identifier\n    let state = tn.mark();\n    let isConstructor = false;\n    let isGetter = false;\n    let getStart = 0;\n    let getEnd = 0;\n    let isSetter = false;\n    let setStart = 0;\n    let setEnd = 0;\n    if (!isInterface) {\n      if (tn.skip(Token.Get)) {\n        if (tn.peek(true, IdentifierHandling.Prefer) == Token.Identifier && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.Get;\n          isGetter = true;\n          getStart = tn.tokenPos;\n          getEnd = tn.pos;\n          if (!startPos) startPos = getStart;\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.Set)) {\n        if (tn.peek(true, IdentifierHandling.Prefer) == Token.Identifier && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.Set;\n          isSetter = true;\n          setStart = tn.tokenPos;\n          setEnd = tn.pos;\n          if (!startPos) startPos = setStart;\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.Constructor)) {\n        flags |= CommonFlags.Constructor;\n        isConstructor = true;\n        if (!startPos) startPos = tn.tokenPos;\n        if (flags & CommonFlags.Static) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Readonly) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(readonlyStart, readonlyEnd), \"readonly\"\n          ); // recoverable\n        }\n      }\n    }\n\n    let isGetterOrSetter = isGetter || isSetter;\n    let name: IdentifierExpression;\n    if (isConstructor) {\n      name = Node.createConstructorExpression(tn.range());\n    } else {\n      if (!isGetterOrSetter && tn.skip(Token.OpenBracket)) {\n        if (!startPos) startPos = tn.tokenPos;\n        // TODO: also handle symbols, which might have some of these modifiers\n        if (flags & CommonFlags.Public) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"public\"\n          ); // recoverable\n        } else if (flags & CommonFlags.Protected) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        } else if (flags & CommonFlags.Private) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"private\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Static) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Override) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(overrideStart, overrideEnd), \"override\"\n          );\n        }\n        if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        let retIndex = this.parseIndexSignature(tn, flags, decorators);\n        if (!retIndex) {\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n          return null;\n        }\n        tn.skip(Token.Semicolon);\n        return retIndex;\n      }\n      if (!tn.skipIdentifier(IdentifierHandling.Always)) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range()\n        );\n        return null;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      let typeParametersStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      if (isConstructor) {\n        this.error(\n          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else if (isGetterOrSetter) {\n        this.error(\n          DiagnosticCode.An_accessor_cannot_have_type_parameters,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else {\n        flags |= CommonFlags.Generic;\n      }\n    }\n\n    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\n    if (tn.skip(Token.OpenParen)) {\n      if (flags & CommonFlags.Declare) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_appear_on_class_elements_of_this_kind,\n          tn.range(declareStart, declareEnd), \"declare\"\n        ); // recoverable\n      }\n\n      let signatureStart = tn.tokenPos;\n      let parameters = this.parseParameters(tn, isConstructor);\n      if (!parameters) return null;\n      let thisType = this.parseParametersThis;\n      if (isConstructor) {\n        for (let i = 0, k = parameters.length; i < k; ++i) {\n          let parameter = parameters[i];\n          if (parameter.isAny(\n            CommonFlags.Public |\n            CommonFlags.Protected |\n            CommonFlags.Private |\n            CommonFlags.Readonly\n          )) {\n            let implicitFieldDeclaration = Node.createFieldDeclaration(\n              parameter.name,\n              null,\n              parameter.flags | CommonFlags.Instance,\n              parameter.type,\n              null, // initialized via parameter\n              parameter.range\n            );\n            implicitFieldDeclaration.parameterIndex = i;\n            parameter.implicitFieldDeclaration = implicitFieldDeclaration;\n            parent.members.push(implicitFieldDeclaration);\n          }\n        }\n      } else if (isGetter) {\n        if (parameters.length) {\n          this.error(\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\n            name.range\n          );\n        }\n      } else if (isSetter) {\n        if (parameters.length != 1) {\n          this.error(\n            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n            name.range\n          );\n        }\n        if (parameters.length > 0 && parameters[0].initializer) {\n          this.error(\n            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n            name.range\n          );\n        }\n      } else if (name.text == \"constructor\") {\n        this.error(\n          DiagnosticCode._0_keyword_cannot_be_used_here,\n          name.range, \"constructor\"\n        );\n      }\n\n      let returnType: TypeNode | null = null;\n      if (tn.skip(Token.Colon)) {\n        if (name.kind == NodeKind.Constructor) {\n          this.error(\n            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\n            tn.range()\n          );\n        } else if (isSetter) {\n          this.error(\n            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\n            tn.range()\n          );\n        }\n        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.Constructor);\n        if (!returnType) return null;\n      } else {\n        returnType = Node.createOmittedType(tn.range(tn.pos));\n        if (!isSetter && name.kind != NodeKind.Constructor) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            returnType.range\n          ); // recoverable\n        }\n      }\n\n      let signature = Node.createFunctionType(\n        parameters,\n        returnType,\n        thisType,\n        false,\n        tn.range(signatureStart, tn.pos)\n      );\n\n      let body: Statement | null = null;\n      if (tn.skip(Token.OpenBrace)) {\n        if (flags & CommonFlags.Ambient) {\n          this.error(\n            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        } else if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,\n            tn.range(), name.text\n          ); // recoverable\n        } else if (isInterface) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          ); // recoverable\n        }\n        body = this.parseBlockStatement(tn, false);\n        if (!body) return null;\n      } else if (!isInterface && !(flags & (CommonFlags.Ambient | CommonFlags.Abstract))) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          tn.range()\n        ); // recoverable\n      }\n\n      let retMethod = Node.createMethodDeclaration(\n        name,\n        decorators,\n        flags,\n        typeParameters,\n        signature,\n        body,\n        tn.range(startPos, tn.pos)\n      );\n      if (!(isInterface && tn.skip(Token.Comma))) {\n        tn.skip(Token.Semicolon);\n      }\n      return retMethod;\n\n    } else if (isConstructor) {\n      this.error(\n        DiagnosticCode.Constructor_implementation_is_missing,\n        name.range\n      );\n\n    } else if (isGetterOrSetter) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        name.range\n      );\n\n    // field: (':' Type)? ('=' Expression)? ';'?\n    } else {\n      if (flags & CommonFlags.Declare) {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(declareStart, declareEnd), \"Ambient fields\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Abstract) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(abstractStart, abstractEnd), \"abstract\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Get) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(getStart, getEnd), \"get\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Set) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(setStart, setEnd), \"set\"\n        ); // recoverable\n      }\n\n      let type: TypeNode | null = null;\n      if (tn.skip(Token.Question)) {\n        this.error(\n          DiagnosticCode.Optional_properties_are_not_supported,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      if (tn.skip(Token.Exclamation)) {\n        flags |= CommonFlags.DefinitelyAssigned;\n      }\n      if (tn.skip(Token.Colon)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        ); // recoverable\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.Equals)) {\n        if (flags & CommonFlags.Ambient) {\n          this.error(\n            DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        }\n        initializer = this.parseExpression(tn);\n        if (!initializer) return null;\n        if (flags & CommonFlags.DefinitelyAssigned) {\n          this.error(\n            DiagnosticCode.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions,\n            name.range\n          );\n        }\n      }\n      let range = tn.range(startPos, tn.pos);\n      if ((flags & CommonFlags.DefinitelyAssigned) != 0 && (isInterface || (flags & CommonFlags.Ambient) != 0)) {\n        this.error(\n          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n          range\n        );\n      }\n      let retField = Node.createFieldDeclaration(\n        name,\n        decorators,\n        flags,\n        type,\n        initializer,\n        range\n      );\n      if (!(isInterface && tn.skip(Token.Comma))) {\n        tn.skip(Token.Semicolon);\n      }\n      return retField;\n    }\n    return null;\n  }\n\n  parseIndexSignature(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n  ): IndexSignatureNode | null {\n\n    // at: '[': 'key' ':' Type ']' ':' Type\n\n    if (decorators && decorators.length > 0) {\n      this.error(\n        DiagnosticCode.Decorators_are_not_valid_here,\n        Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n      ); // recoverable\n    }\n\n    let start = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let id = tn.readIdentifier();\n      if (id == \"key\") {\n        if (tn.skip(Token.Colon)) {\n          let keyType = this.parseType(tn);\n          if (!keyType) return null;\n          if (keyType.kind != NodeKind.NamedType) {\n            this.error(\n              DiagnosticCode.Type_expected,\n              tn.range()\n            );\n            return null;\n          }\n          if (tn.skip(Token.CloseBracket)) {\n            if (tn.skip(Token.Colon)) {\n              let valueType = this.parseType(tn);\n              if (!valueType) return null;\n              if (valueType.kind != NodeKind.NamedType) {\n                this.error(\n                  DiagnosticCode.Identifier_expected,\n                  valueType.range\n                );\n                return null;\n              }\n              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \":\"\n              );\n            }\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \":\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"key\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseNamespace(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): NamespaceDeclaration | null {\n\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\n\n    if (tn.skipIdentifier()) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.OpenBrace)) {\n        let members = new Array<Statement>();\n        let declaration = Node.createNamespaceDeclaration(\n          identifier,\n          decorators,\n          flags,\n          members,\n          tn.range(startPos, tn.pos)\n        );\n        while (!tn.skip(Token.CloseBrace)) {\n          let member = this.parseTopLevelStatement(tn, declaration);\n          if (member) {\n            if (member.kind == NodeKind.Export) {\n              this.error(\n                DiagnosticCode.A_default_export_can_only_be_used_in_a_module,\n                member.range,\n              );\n              return null;\n            }\n            members.push(member);\n          } else {\n            this.skipStatement(tn);\n            if (tn.skip(Token.EndOfFile)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        declaration.range.end = tn.pos;\n        declaration.overriddenModuleName = this.currentModuleName;\n        tn.skip(Token.Semicolon);\n        return declaration;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"{\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExport(\n    tn: Tokenizer,\n    startPos: i32,\n    isDeclare: bool\n  ): ExportStatement | null {\n\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\n\n    let path: StringLiteralExpression | null = null;\n    let currentSource = assert(this.currentSource);\n    if (tn.skip(Token.OpenBrace)) {\n      let members = new Array<ExportMember>();\n      while (!tn.skip(Token.CloseBrace)) {\n        let member = this.parseExportMember(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.Comma)) {\n          if (tn.skip(Token.CloseBrace)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n      if (tn.skip(Token.From)) {\n        if (tn.skip(Token.StringLiteral)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));\n      if (path) {\n        let internalPath = assert(ret.internalPath);\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(currentSource, path));\n          this.backlog.push(internalPath);\n          this.seenlog.add(internalPath);\n        }\n      }\n      tn.skip(Token.Semicolon);\n      return ret;\n    } else if (tn.skip(Token.Asterisk)) {\n      if (tn.skip(Token.From)) {\n        if (tn.skip(Token.StringLiteral)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));\n          let internalPath = assert(ret.internalPath);\n          let source = tn.source;\n          let exportPaths = source.exportPaths;\n          if (!exportPaths) source.exportPaths = [ internalPath ];\n          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);\n          if (!this.seenlog.has(internalPath)) {\n            this.dependees.set(internalPath, new Dependee(currentSource, path));\n            this.backlog.push(internalPath);\n          }\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"from\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseExportMember(\n    tn: Tokenizer\n  ): ExportMember | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.Always)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier(IdentifierHandling.Always)) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createExportMember(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createExportMember(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportDefaultAlias(\n    tn: Tokenizer,\n    startPos: i32,\n    defaultStart: i32,\n    defaultEnd: i32\n  ): ExportStatement {\n\n    // at 'export' 'default': [Known-To-Be-]Identifier\n\n    let name = tn.readIdentifier();\n    let range = tn.range();\n    let ret = Node.createExportStatement([\n      Node.createExportMember(\n        Node.createIdentifierExpression(name, range),\n        Node.createIdentifierExpression(\"default\", tn.range(defaultStart, defaultEnd)),\n        range\n      )\n    ], null, false, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseImport(\n    tn: Tokenizer\n  ): ImportStatement | null {\n\n    // at 'import':\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\n    //  'from' StringLiteral ';'?\n\n    let startPos = tn.tokenPos;\n    let members: ImportDeclaration[] | null = null;\n    let namespaceName: IdentifierExpression | null = null;\n    let skipFrom = false;\n    if (tn.skip(Token.OpenBrace)) { // import { ... } from \"file\"\n      members = new Array();\n      while (!tn.skip(Token.CloseBrace)) {\n        let member = this.parseImportDeclaration(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.Comma)) {\n          if (tn.skip(Token.CloseBrace)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n    } else if (tn.skip(Token.Asterisk)) { // import * from \"file\"\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier()) {\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"as\"\n        );\n        return null;\n      }\n    } else if (tn.skip(Token.Identifier, IdentifierHandling.Prefer)) { // import Name from \"file\"\n      let name = tn.readIdentifier();\n      let range = tn.range();\n      members = [\n        Node.createImportDeclaration(\n          Node.createIdentifierExpression(\"default\", range),\n          Node.createIdentifierExpression(name, range),\n          range\n        )\n      ];\n      if (tn.skip(Token.Comma)) {\n        // TODO: default + star, default + members\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(),\n          \"Mixed default and named imports\"\n        );\n        return null;\n      }\n    } else { // import \"file\"\n      skipFrom = true;\n    }\n\n    if (skipFrom || tn.skip(Token.From)) {\n      if (tn.skip(Token.StringLiteral)) {\n        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        let ret: ImportStatement;\n        if (namespaceName) {\n          assert(!members);\n          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));\n        } else {\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\n        }\n        let internalPath = ret.internalPath;\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));\n          this.backlog.push(internalPath);\n        }\n        tn.skip(Token.Semicolon);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode.String_literal_expected,\n          tn.range()\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"from\"\n      );\n    }\n    return null;\n  }\n\n  parseImportDeclaration(\n    tn: Tokenizer\n  ): ImportDeclaration | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.Always)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier()) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createImportDeclaration(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createImportDeclaration(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportImport(\n    tn: Tokenizer,\n    startPos: i32\n  ): ExportImportStatement | null {\n\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\n\n    if (tn.skipIdentifier()) {\n      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.Equals)) {\n        if (tn.skipIdentifier()) {\n          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseStatement(\n    tn: Tokenizer,\n    topLevel: bool = false\n  ): Statement | null {\n\n    // at previous token\n\n    let state = tn.mark();\n    let token = tn.next();\n    let statement: Statement | null = null;\n    switch (token) {\n      case Token.Break: {\n        statement = this.parseBreak(tn);\n        break;\n      }\n      case Token.Const: {\n        statement = this.parseVariable(tn, CommonFlags.Const, null, tn.tokenPos);\n        break;\n      }\n      case Token.Continue: {\n        statement = this.parseContinue(tn);\n        break;\n      }\n      case Token.Do: {\n        statement = this.parseDoStatement(tn);\n        break;\n      }\n      case Token.For: {\n        statement = this.parseForStatement(tn);\n        break;\n      }\n      case Token.If: {\n        statement = this.parseIfStatement(tn);\n        break;\n      }\n      case Token.Let: {\n        statement = this.parseVariable(tn, CommonFlags.Let, null, tn.tokenPos);\n        break;\n      }\n      case Token.Var: {\n        statement = this.parseVariable(tn, CommonFlags.None, null, tn.tokenPos);\n        break;\n      }\n      case Token.OpenBrace: {\n        statement = this.parseBlockStatement(tn, topLevel);\n        break;\n      }\n      case Token.Return: {\n        if (topLevel) {\n          this.error(\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\n            tn.range()\n          ); // recoverable\n        }\n        statement = this.parseReturn(tn);\n        break;\n      }\n      case Token.Semicolon: {\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\n      }\n      case Token.Switch: {\n        statement = this.parseSwitchStatement(tn);\n        break;\n      }\n      case Token.Throw: {\n        statement = this.parseThrowStatement(tn);\n        break;\n      }\n      case Token.Try: {\n        statement = this.parseTryStatement(tn);\n        break;\n      }\n      case Token.Void: {\n        statement = this.parseVoidStatement(tn);\n        break;\n      }\n      case Token.While: {\n        statement = this.parseWhileStatement(tn);\n        break;\n      }\n      case Token.Type: { // also identifier\n        if (tn.peek(false, IdentifierHandling.Prefer) == Token.Identifier) {\n          statement = this.parseTypeDeclaration(tn, CommonFlags.None, null, tn.tokenPos);\n          break;\n        }\n        // fall-through\n      }\n      default: {\n        tn.reset(state);\n        statement = this.parseExpressionStatement(tn);\n        break;\n      }\n    }\n    if (!statement) { // has been reported\n      tn.reset(state);\n      this.skipStatement(tn);\n    } else {\n      tn.discard(state);\n    }\n    return statement;\n  }\n\n  parseBlockStatement(\n    tn: Tokenizer,\n    topLevel: bool\n  ): BlockStatement | null {\n\n    // at '{': Statement* '}' ';'?\n\n    let startPos = tn.tokenPos;\n    let statements = new Array<Statement>();\n    while (!tn.skip(Token.CloseBrace)) {\n      let state = tn.mark();\n      let statement = this.parseStatement(tn, topLevel);\n      if (!statement) {\n        if (tn.token == Token.EndOfFile) return null;\n        tn.reset(state);\n        this.skipStatement(tn);\n      } else {\n        tn.discard(state);\n        statements.push(statement);\n      }\n    }\n    let ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseBreak(\n    tn: Tokenizer\n  ): BreakStatement | null {\n\n    // at 'break': Identifier? ';'?\n\n    let identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.Identifier && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.Prefer);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let ret = Node.createBreakStatement(identifier, tn.range());\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseContinue(\n    tn: Tokenizer\n  ): ContinueStatement | null {\n\n    // at 'continue': Identifier? ';'?\n\n    let identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.Identifier && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.Prefer);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let ret = Node.createContinueStatement(identifier, tn.range());\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseDoStatement(\n    tn: Tokenizer\n  ): DoStatement | null {\n\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\n\n    let startPos = tn.tokenPos;\n    let statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    if (tn.skip(Token.While)) {\n\n      if (tn.skip(Token.OpenParen)) {\n        let condition = this.parseExpression(tn);\n        if (!condition) return null;\n\n        if (tn.skip(Token.CloseParen)) {\n          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"(\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"while\"\n      );\n    }\n    return null;\n  }\n\n  parseExpressionStatement(\n    tn: Tokenizer\n  ): ExpressionStatement | null {\n\n    // at previous token\n\n    let expr = this.parseExpression(tn);\n    if (!expr) return null;\n\n    let ret = Node.createExpressionStatement(expr);\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseForStatement(\n    tn: Tokenizer\n  ): Statement | null {\n\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\n\n    let startPos = tn.tokenPos;\n\n    if (tn.skip(Token.OpenParen)) {\n      let initializer: Statement | null = null;\n\n      if (tn.skip(Token.Const)) {\n        initializer = this.parseVariable(tn, CommonFlags.Const, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.Let)) {\n        initializer = this.parseVariable(tn, CommonFlags.Let, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.Var)) {\n        initializer = this.parseVariable(tn, CommonFlags.None, null, tn.tokenPos, true);\n\n      } else if (!tn.skip(Token.Semicolon)) {\n        initializer = this.parseExpressionStatement(tn);\n        if (!initializer) return null;\n      }\n\n      if (initializer) {\n        if (tn.skip(Token.Of)) {\n          // TODO: for (let [key, val] of ...)\n          if (initializer.kind == NodeKind.Expression) {\n            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.Identifier) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                initializer.range\n              );\n              return null;\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          if (initializer.kind == NodeKind.Variable) {\n            let declarations = (<VariableStatement>initializer).declarations;\n            for (let i = 0, k = declarations.length; i < k; ++i) {\n              let declaration = declarations[i];\n              let initializer = declaration.initializer;\n              if (initializer) {\n                this.error(\n                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,\n                  initializer.range\n                ); // recoverable\n              }\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            initializer.range\n          );\n          return null;\n        }\n        // non-for..of needs type or initializer\n        if (initializer.kind == NodeKind.Variable) {\n          let declarations = (<VariableStatement>initializer).declarations;\n          for (let i = 0, k = declarations.length; i < k; ++i) {\n            let declaration = declarations[i];\n            if (!declaration.initializer) {\n              if (declaration.flags & CommonFlags.Const) {\n                this.error(\n                  DiagnosticCode._const_declarations_must_be_initialized,\n                  declaration.name.range\n                );\n              } else if (!declaration.type) {\n                this.error(\n                  DiagnosticCode.Type_expected,\n                  declaration.name.range.atEnd\n                );\n              }\n            }\n          }\n        }\n      }\n\n      if (tn.token == Token.Semicolon) {\n        let condition: ExpressionStatement | null = null;\n        if (!tn.skip(Token.Semicolon)) {\n          condition = this.parseExpressionStatement(tn);\n          if (!condition) return null;\n        }\n\n        if (tn.token == Token.Semicolon) {\n          let incrementor: Expression | null = null;\n          if (!tn.skip(Token.CloseParen)) {\n            incrementor = this.parseExpression(tn);\n            if (!incrementor) return null;\n\n            if (!tn.skip(Token.CloseParen)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n              return null;\n            }\n          }\n\n          let statement = this.parseStatement(tn);\n          if (!statement) return null;\n\n          return Node.createForStatement(\n            initializer,\n            condition\n              ? condition.expression\n              : null,\n            incrementor,\n            statement,\n            tn.range(startPos, tn.pos)\n          );\n\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \";\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseForOfStatement(\n    tn: Tokenizer,\n    startPos: i32,\n    variable: Statement,\n  ): ForOfStatement | null {\n\n    // at 'of': Expression ')' Statement\n\n    let iterable = this.parseExpression(tn);\n    if (!iterable) return null;\n\n    if (!tn.skip(Token.CloseParen)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \")\"\n      );\n      return null;\n    }\n\n    let statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    return Node.createForOfStatement(\n      variable,\n      iterable,\n      statement,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  parseIfStatement(\n    tn: Tokenizer\n  ): IfStatement | null {\n\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CloseParen)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let elseStatement: Statement | null = null;\n        if (tn.skip(Token.Else)) {\n          elseStatement = this.parseStatement(tn);\n          if (!elseStatement) return null;\n        }\n        return Node.createIfStatement(\n          condition,\n          statement,\n          elseStatement,\n          tn.range(startPos, tn.pos)\n        );\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchStatement(\n    tn: Tokenizer\n  ): SwitchStatement | null {\n\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CloseParen)) {\n        if (tn.skip(Token.OpenBrace)) {\n          let switchCases = new Array<SwitchCase>();\n          while (!tn.skip(Token.CloseBrace)) {\n            let switchCase = this.parseSwitchCase(tn);\n            if (!switchCase) return null;\n            switchCases.push(switchCase);\n          }\n          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchCase(\n    tn: Tokenizer\n  ): SwitchCase | null {\n\n    let startPos = tn.tokenPos;\n    let statements: Statement[],\n        statement: Statement | null;\n\n    // 'case' Expression ':' Statement*\n\n    if (tn.skip(Token.Case)) {\n      let label = this.parseExpression(tn);\n      if (!label) return null;\n      if (tn.skip(Token.Colon)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.Case &&\n          tn.nextToken != Token.Default &&\n          tn.nextToken != Token.CloseBrace\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n\n      // 'default' ':' Statement*\n\n    } else if (tn.skip(Token.Default)) {\n      if (tn.skip(Token.Colon)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.Case &&\n          tn.nextToken != Token.Default &&\n          tn.nextToken != Token.CloseBrace\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._case_or_default_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseThrowStatement(\n    tn: Tokenizer\n  ): ThrowStatement | null {\n\n    // at 'throw': Expression ';'?\n\n    let startPos = tn.tokenPos;\n    let expression = this.parseExpression(tn);\n    if (!expression) return null;\n    let ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseTryStatement(\n    tn: Tokenizer\n  ): TryStatement | null {\n\n    // at 'try':\n    //   '{' Statement* '}'\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\n    //   ('finally' '{' Statement* '}'? ';'?\n\n    let startPos = tn.tokenPos;\n    let stmt: Statement | null;\n    if (tn.skip(Token.OpenBrace)) {\n      let bodyStatements = new Array<Statement>();\n      while (!tn.skip(Token.CloseBrace)) {\n        stmt = this.parseStatement(tn);\n        if (!stmt) return null;\n        bodyStatements.push(stmt);\n      }\n      let catchVariable: IdentifierExpression | null = null;\n      let catchStatements: Statement[] | null = null;\n      let finallyStatements: Statement[] | null = null;\n      if (tn.skip(Token.Catch)) {\n        if (!tn.skip(Token.OpenParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"(\"\n          );\n          return null;\n        }\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        if (!tn.skip(Token.CloseParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        if (!tn.skip(Token.OpenBrace)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        catchStatements = [];\n        while (!tn.skip(Token.CloseBrace)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          catchStatements.push(stmt);\n        }\n      }\n      if (tn.skip(Token.Finally)) {\n        if (!tn.skip(Token.OpenBrace)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        finallyStatements = [];\n        while (!tn.skip(Token.CloseBrace)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          finallyStatements.push(stmt);\n        }\n      }\n      if (!(catchStatements || finallyStatements)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"catch\"\n        );\n        return null;\n      }\n      let ret = Node.createTryStatement(\n        bodyStatements,\n        catchVariable,\n        catchStatements,\n        finallyStatements,\n        tn.range(startPos, tn.pos)\n      );\n      tn.skip(Token.Semicolon);\n      return ret;\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  private getRecursiveDepthForTypeDeclaration(\n    identifierName: string,\n    type: TypeNode,\n    depth: i32 = 0\n  ): i32 {\n    switch (type.kind) {\n      case NodeKind.NamedType: {\n        let typeArguments = (<NamedTypeNode>type).typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; i++) {\n            let res = this.getRecursiveDepthForTypeDeclaration(identifierName, typeArguments[i], depth + 1);\n            if (res != -1) return res;\n          }\n        }\n        if ((<NamedTypeNode>type).name.identifier.text == identifierName) {\n          return depth;\n        }\n        break;\n      }\n      case NodeKind.FunctionType: {\n        let fnType = <FunctionTypeNode>type;\n        let res = this.getRecursiveDepthForTypeDeclaration(identifierName, fnType.returnType, depth + 1);\n        if (res != -1) return res;\n        let params = fnType.parameters;\n        for (let i = 0, k = params.length; i < k; i++) {\n          res = this.getRecursiveDepthForTypeDeclaration(identifierName, params[i].type, depth + 1);\n          if (res != -1) return res;\n        }\n        break;\n      }\n    }\n    return -1;\n  }\n\n  parseTypeDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): TypeDeclaration | null {\n\n    // at 'type': Identifier ('<' TypeParameters '>')? '=' '|'? Type ';'?\n\n    if (tn.skipIdentifier()) {\n      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let typeParameters: TypeParameterNode[] | null = null;\n      if (tn.skip(Token.LessThan)) {\n        typeParameters = this.parseTypeParameters(tn);\n        if (!typeParameters) return null;\n        flags |= CommonFlags.Generic;\n      }\n      if (tn.skip(Token.Equals)) {\n        tn.skip(Token.Bar);\n        let type = this.parseType(tn);\n        if (!type) return null;\n        let depth = this.getRecursiveDepthForTypeDeclaration(name.text, type);\n        if (depth >= 0) {\n          if (depth == 0) {\n            this.error(\n              DiagnosticCode.Type_alias_0_circularly_references_itself,\n              tn.range(), name.text\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Not_implemented_0,\n              tn.range(), \"Recursion in type aliases\"\n            );\n          }\n          return null;\n        }\n        let ret = Node.createTypeDeclaration(\n          name,\n          decorators,\n          flags,\n          typeParameters,\n          type,\n          tn.range(startPos, tn.pos)\n        );\n        tn.skip(Token.Semicolon);\n        ret.overriddenModuleName = this.currentModuleName;\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseModuleDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags\n  ): ModuleDeclaration | null {\n\n    // at 'module': StringLiteral ';'?\n\n    let startPos = tn.tokenPos;\n    assert(tn.next() == Token.StringLiteral); // checked earlier\n    let moduleName = tn.readString();\n    let ret = Node.createModuleDeclaration(moduleName, flags, tn.range(startPos, tn.pos));\n    this.currentModuleName = moduleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseVoidStatement(\n    tn: Tokenizer\n  ): VoidStatement | null {\n\n    // at 'void': Expression ';'?\n\n    let startPos = tn.tokenPos;\n    let expression = this.parseExpression(tn, Precedence.Grouping);\n    if (!expression) return null;\n    let ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseWhileStatement(\n    tn: Tokenizer\n  ): WhileStatement | null {\n\n    // at 'while': '(' Expression ')' Statement ';'?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let expression = this.parseExpression(tn);\n      if (!expression) return null;\n      if (tn.skip(Token.CloseParen)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\n        tn.skip(Token.Semicolon);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  // expressions\n\n  parseExpressionStart(\n    tn: Tokenizer\n  ): Expression | null {\n    let token = tn.next(IdentifierHandling.Prefer);\n    let startPos = tn.tokenPos;\n    switch (token) {\n\n      // TODO: SpreadExpression, YieldExpression\n      case Token.Dot_Dot_Dot:\n      case Token.Yield: // fallthrough to unsupported UnaryPrefixExpression\n\n      // UnaryPrefixExpression\n      case Token.Exclamation:\n      case Token.Tilde:\n      case Token.Plus:\n      case Token.Minus:\n      case Token.TypeOf:\n      case Token.Void:\n      case Token.Delete: {\n        let operand = this.parseExpression(tn, Precedence.UnaryPrefix);\n        if (!operand) return null;\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let operand = this.parseExpression(tn, Precedence.UnaryPrefix);\n        if (!operand) return null;\n        switch (operand.kind) {\n          case NodeKind.Identifier:\n          case NodeKind.ElementAccess:\n          case NodeKind.PropertyAccess: break;\n          default: {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              operand.range\n            );\n          }\n        }\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n\n      // NewExpression\n      case Token.New: {\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        let typeName = this.parseTypeName(tn);\n        if (!typeName) return null;\n        let typeArguments: TypeNode[] | null = null;\n        let arguments_: Expression[] | null = null;\n        if (\n          tn.skip(Token.OpenParen) ||\n          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn))\n        ) {\n          arguments_ = this.parseArguments(tn);\n          if (!arguments_) return null;\n        } else {\n          arguments_ = []; // new Type;\n        }\n        return Node.createNewExpression(\n          typeName,\n          typeArguments,\n          arguments_,\n          tn.range(startPos, tn.pos)\n        );\n      }\n\n      // Special IdentifierExpression\n      case Token.Null: return Node.createNullExpression(tn.range());\n      case Token.True: return Node.createTrueExpression(tn.range());\n      case Token.False: return Node.createFalseExpression(tn.range());\n      case Token.This: return Node.createThisExpression(tn.range());\n      case Token.Constructor: return Node.createConstructorExpression(tn.range());\n\n      // ParenthesizedExpression or FunctionExpression\n      case Token.OpenParen: {\n\n        // determine whether this is a function expression\n        if (tn.skip(Token.CloseParen)) { // must be a function expression (fast route)\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [],\n            null,\n            ArrowKind.Parenthesized\n          );\n        }\n        let state = tn.mark();\n        let again = true;\n        do {\n          switch (tn.next(IdentifierHandling.Prefer)) {\n\n            // function expression\n            case Token.Dot_Dot_Dot: {\n              tn.reset(state);\n              return this.parseFunctionExpression(tn);\n            }\n            // can be both\n            case Token.Identifier: {\n              tn.readIdentifier();\n              switch (tn.next()) {\n\n                // if we got here, check for arrow\n                case Token.CloseParen: {\n                  if (\n                    !tn.skip(Token.Colon) &&\n                    !tn.skip(Token.Equals_GreaterThan)\n                  ) {\n                    again = false;\n                    break;\n                  }\n                  // fall-through\n                }\n                // function expression\n                case Token.Colon: {    // type annotation\n                  tn.reset(state);\n                  return this.parseFunctionExpression(tn);\n                }\n                // optional parameter or parenthesized\n                case Token.Question: {\n                  if (\n                    tn.skip(Token.Colon) ||   // optional parameter with type\n                    tn.skip(Token.Comma) ||   // optional parameter without type\n                    tn.skip(Token.CloseParen) // last optional parameter without type\n                  ) {\n                    tn.reset(state);\n                    return this.parseFunctionExpression(tn);\n                  }\n                  again = false; // parenthesized\n                  break;\n                }\n                case Token.Comma: {\n                  break; // continue\n                }\n                // parenthesized expression\n                // case Token.EQUALS:  // missing type annotation for simplicity\n                default: {\n                  again = false;\n                  break;\n                }\n              }\n              break;\n            }\n            // parenthesized expression\n            default: {\n              again = false;\n              break;\n            }\n          }\n        } while (again);\n        tn.reset(state);\n\n        // parse parenthesized\n        let inner = this.parseExpression(tn);\n        if (!inner) return null;\n        if (!tn.skip(Token.CloseParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, inner);\n      }\n      // ArrayLiteralExpression\n      case Token.OpenBracket: {\n        let elementExpressions = new Array<Expression>();\n        while (!tn.skip(Token.CloseBracket)) {\n          let expr: Expression | null;\n          if (tn.peek() == Token.Comma) {\n            expr = Node.createOmittedExpression(tn.range(tn.pos));\n          } else {\n            expr = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!expr) return null;\n          }\n          elementExpressions.push(expr);\n          if (!tn.skip(Token.Comma)) {\n            if (tn.skip(Token.CloseBracket)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"]\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\n      }\n      // ObjectLiteralExpression\n      case Token.OpenBrace: {\n        let startPos = tn.tokenPos;\n        let names = new Array<IdentifierExpression>();\n        let values = new Array<Expression>();\n        let name: IdentifierExpression;\n        while (!tn.skip(Token.CloseBrace)) {\n          if (!tn.skipIdentifier()) {\n            if (!tn.skip(Token.StringLiteral)) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                tn.range(),\n              );\n              return null;\n            }\n            name = Node.createIdentifierExpression(tn.readString(), tn.range());\n            name.isQuoted = true;\n          } else {\n            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          }\n          names.push(name);\n          if (tn.skip(Token.Colon)) {\n            let value = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!value) return null;\n            values.push(value);\n          } else if (!name.isQuoted) {\n            values.push(name);\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.Comma)) {\n            if (tn.skip(Token.CloseBrace)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));\n      }\n      // AssertionExpression (unary prefix)\n      case Token.LessThan: {\n        let toType = this.parseType(tn);\n        if (!toType) return null;\n        if (!tn.skip(Token.GreaterThan)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n        let expr = this.parseExpression(tn, Precedence.Call);\n        if (!expr) return null;\n        return Node.createAssertionExpression(\n          AssertionKind.Prefix,\n          expr,\n          toType,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.Identifier: {\n        let identifierText = tn.readIdentifier();\n        if (identifierText == \"null\") return Node.createNullExpression(tn.range()); // special\n        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));\n        if (tn.skip(Token.TemplateLiteral)) {\n          return this.parseTemplateLiteral(tn, identifier);\n        }\n        if (tn.peek(true) == Token.Equals_GreaterThan && !tn.nextTokenOnNewLine) {\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [\n              Node.createParameter(\n                ParameterKind.Default,\n                identifier,\n                Node.createOmittedType(identifier.range.atEnd),\n                null,\n                identifier.range\n              )\n            ],\n            null,\n            ArrowKind.Single,\n            startPos\n          );\n        }\n        return this.maybeParseCallExpression(tn, identifier, true);\n      }\n      case Token.Super: {\n        if (tn.peek() != Token.Dot && tn.nextToken != Token.OpenParen) {\n          this.error(\n            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,\n            tn.range()\n          );\n        }\n        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.StringLiteral: {\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\n      }\n      case Token.TemplateLiteral: {\n        return this.parseTemplateLiteral(tn);\n      }\n      case Token.IntegerLiteral: {\n        let value = tn.readInteger();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createIntegerLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      case Token.FloatLiteral: {\n        let value = tn.readFloat();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createFloatLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      // RegexpLiteralExpression\n      // note that this also continues on invalid ones so the surrounding AST remains intact\n      case Token.Slash: {\n        let regexpPattern = tn.readRegexpPattern(); // also reports\n        if (!tn.skip(Token.Slash)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"/\"\n          );\n          return null;\n        }\n        return Node.createRegexpLiteralExpression(\n          regexpPattern,\n          tn.readRegexpFlags(), // also reports\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.Function: {\n        let expr = this.parseFunctionExpression(tn);\n        if (!expr) return null;\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.Class: {\n        return this.parseClassExpression(tn);\n      }\n      default: {\n        if (token == Token.EndOfFile) {\n          this.error(\n            DiagnosticCode.Unexpected_end_of_text,\n            tn.range(startPos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_expected,\n            tn.range()\n          );\n        }\n        return null;\n      }\n    }\n  }\n\n  tryParseTypeArgumentsBeforeArguments(\n    tn: Tokenizer\n  ): TypeNode[] | null {\n\n    // at '<': Type (',' Type)* '>' '('\n\n    let state = tn.mark();\n    if (!tn.skip(Token.LessThan)) return null;\n    let start = tn.tokenPos;\n    let typeArguments: TypeNode[] | null = null;\n    do {\n      if (tn.peek() == Token.GreaterThan) {\n        break;\n      }\n      let type = this.parseType(tn, true, true);\n      if (!type) {\n        tn.reset(state);\n        return null;\n      }\n      if (!typeArguments) typeArguments = [ type ];\n      else typeArguments.push(type);\n    } while (tn.skip(Token.Comma));\n    if (tn.skip(Token.GreaterThan)) {\n      let end = tn.pos;\n      if (tn.skip(Token.OpenParen)) {\n        if (!typeArguments) {\n          this.error(\n            DiagnosticCode.Type_argument_list_cannot_be_empty,\n            tn.range(start, end)\n          );\n        }\n        return typeArguments;\n      }\n    }\n    tn.reset(state);\n    return null;\n  }\n\n  parseArguments(\n    tn: Tokenizer\n  ): Expression[] | null {\n\n    // at '(': (Expression (',' Expression)*)? ')'\n\n    let args = new Array<Expression>();\n    while (!tn.skip(Token.CloseParen)) {\n      let expr = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!expr) return null;\n      args.push(expr);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return args;\n  }\n\n  parseExpression(\n    tn: Tokenizer,\n    precedence: Precedence = Precedence.Comma\n  ): Expression | null {\n    assert(precedence != Precedence.None);\n    let expr = this.parseExpressionStart(tn);\n    if (!expr) return null;\n    let startPos = expr.range.start;\n\n    // precedence climbing\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\n    let nextPrecedence: Precedence;\n    while (\n      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence\n    ) {\n      let token = tn.next();\n      switch (token) {\n\n        // AssertionExpression\n        case Token.As: {\n          if (tn.skip(Token.Const)) {\n            expr = Node.createAssertionExpression(\n              AssertionKind.Const,\n              expr,\n              null,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let toType = this.parseType(tn); // reports\n            if (!toType) return null;\n            expr = Node.createAssertionExpression(\n              AssertionKind.As,\n              expr,\n              toType,\n              tn.range(startPos, tn.pos)\n            );\n          }\n          break;\n        }\n        case Token.Exclamation: {\n          expr = Node.createAssertionExpression(\n            AssertionKind.NonNull,\n            expr,\n            null,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // InstanceOfExpression\n        case Token.InstanceOf: {\n          let isType = this.parseType(tn); // reports\n          if (!isType) return null;\n          expr = Node.createInstanceOfExpression(\n            expr,\n            isType,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // ElementAccessExpression\n        case Token.OpenBracket: {\n          let next = this.parseExpression(tn); // reports\n          if (!next) return null;\n          if (!tn.skip(Token.CloseBracket)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n            return null;\n          }\n          expr = Node.createElementAccessExpression(\n            expr,\n            next,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // UnaryPostfixExpression\n        case Token.Plus_Plus:\n        case Token.Minus_Minus: {\n          if (\n            expr.kind != NodeKind.Identifier &&\n            expr.kind != NodeKind.ElementAccess &&\n            expr.kind != NodeKind.PropertyAccess\n          ) {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              expr.range\n            );\n          }\n          expr = Node.createUnaryPostfixExpression(\n            token,\n            expr,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // TernaryExpression\n        case Token.Question: {\n          let ifThen = this.parseExpression(tn);\n          if (!ifThen) return null;\n          if (!tn.skip(Token.Colon)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          let ifElse = this.parseExpression(tn, precedence > Precedence.Comma\n            ? Precedence.Comma + 1\n            : Precedence.Comma\n          );\n          if (!ifElse) return null;\n          expr = Node.createTernaryExpression(\n            expr,\n            ifThen,\n            ifElse,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // CommaExpression\n        case Token.Comma: {\n          let commaExprs: Expression[] = [ expr ];\n          do {\n            expr = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!expr) return null;\n            commaExprs.push(expr);\n          } while (tn.skip(Token.Comma));\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\n          break;\n        }\n        // PropertyAccessExpression\n        case Token.Dot: {\n          if (tn.skipIdentifier(IdentifierHandling.Always)) { // expr '.' Identifier\n            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n            expr = Node.createPropertyAccessExpression(\n              expr,\n              next,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let next = this.parseExpression(tn, nextPrecedence + 1);\n            if (!next) return null;\n            if (next.kind == NodeKind.Call) { // expr '.' CallExpression\n              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);\n              if (!expr) return null;\n            } else {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                next.range\n              );\n              return null;\n            }\n          }\n          if (tn.skip(Token.TemplateLiteral)) {\n            expr = this.parseTemplateLiteral(tn, expr);\n            if (!expr) return null;\n          } else {\n            expr = this.maybeParseCallExpression(tn, expr, true);\n          }\n          break;\n        }\n        // BinaryExpression (right associative)\n        case Token.Equals:\n        case Token.Plus_Equals:\n        case Token.Minus_Equals:\n        case Token.Asterisk_Asterisk_Equals:\n        case Token.Asterisk_Equals:\n        case Token.Slash_Equals:\n        case Token.Percent_Equals:\n        case Token.LessThan_LessThan_Equals:\n        case Token.GreaterThan_GreaterThan_Equals:\n        case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n        case Token.Ampersand_Equals:\n        case Token.Caret_Equals:\n        case Token.Bar_Equals:\n        case Token.Asterisk_Asterisk: {\n          let next = this.parseExpression(tn, nextPrecedence);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        // BinaryExpression\n        case Token.LessThan:\n        case Token.GreaterThan:\n        case Token.LessThan_Equals:\n        case Token.GreaterThan_Equals:\n        case Token.Equals_Equals:\n        case Token.Equals_Equals_Equals:\n        case Token.Exclamation_Equals_Equals:\n        case Token.Exclamation_Equals:\n        case Token.Plus:\n        case Token.Minus:\n        case Token.Asterisk:\n        case Token.Slash:\n        case Token.Percent:\n        case Token.LessThan_LessThan:\n        case Token.GreaterThan_GreaterThan:\n        case Token.GreaterThan_GreaterThan_GreaterThan:\n        case Token.Ampersand:\n        case Token.Bar:\n        case Token.Caret:\n        case Token.Ampersand_Ampersand:\n        case Token.Bar_Bar: {\n          let next = this.parseExpression(tn, nextPrecedence + 1);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        default: assert(false); // filtered by determinePrecedence\n      }\n    }\n    return expr;\n  }\n\n  private parseTemplateLiteral(tn: Tokenizer, tag: Expression | null = null): Expression | null {\n    // at '`': ... '`'\n    let startPos = tag ? tag.range.start : tn.tokenPos;\n    let parts = new Array<string>();\n    let rawParts = new Array<string>();\n    let exprs = new Array<Expression>();\n    parts.push(tn.readString(0, tag != null));\n    rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    while (tn.readingTemplateString) {\n      let expr = this.parseExpression(tn);\n      if (!expr) return null;\n      exprs.push(expr);\n      if (!tn.skip(Token.CloseBrace)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"}\"\n        );\n        return null;\n      }\n      parts.push(tn.readString(CharCode.Backtick, tag != null));\n      rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    }\n    return Node.createTemplateLiteralExpression(tag, parts, rawParts, exprs, tn.range(startPos, tn.pos));\n  }\n\n  private joinPropertyCall(\n    tn: Tokenizer,\n    startPos: i32,\n    expr: Expression,\n    call: CallExpression\n  ): Expression | null {\n    let callee = call.expression;\n    switch (callee.kind) {\n      case NodeKind.Identifier: { // join property access and use as call target\n        call.expression = Node.createPropertyAccessExpression(\n          expr,\n          <IdentifierExpression>callee,\n          tn.range(startPos, tn.pos)\n        );\n        break;\n      }\n      case NodeKind.Call: { // join call target und wrap the original call around it\n        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);\n        if (!inner) return null;\n        call.expression = inner;\n        call.range = tn.range(startPos, tn.pos);\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          call.range\n        );\n        return null;\n      }\n    }\n    return call;\n  }\n\n  private maybeParseCallExpression(\n    tn: Tokenizer,\n    expr: Expression,\n    potentiallyGeneric: bool = false\n  ): Expression {\n    let typeArguments: TypeNode[] | null = null;\n    while (\n      tn.skip(Token.OpenParen) ||\n      potentiallyGeneric &&\n      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn))\n    ) {\n      let args = this.parseArguments(tn);\n      if (!args) break;\n      expr = Node.createCallExpression( // is again callable\n        expr,\n        typeArguments,\n        args,\n        tn.range(expr.range.start, tn.pos)\n      );\n      potentiallyGeneric = false;\n    }\n    return expr;\n  }\n\n  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipStatement(tn: Tokenizer): void {\n    tn.peek(true);\n    if (tn.nextTokenOnNewLine) tn.next(); // if reset() to the previous line\n    do {\n      let nextToken = tn.peek(true);\n      if (\n        nextToken == Token.EndOfFile ||   // next step should handle this\n        nextToken == Token.Semicolon      // end of the statement for sure\n      ) {\n        tn.next();\n        break;\n      }\n      if (tn.nextTokenOnNewLine) break;   // end of the statement maybe\n      switch (tn.next()) {\n        case Token.Identifier: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.StringLiteral:\n        case Token.TemplateLiteral: {\n          tn.readString();\n          break;\n        }\n        case Token.IntegerLiteral: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FloatLiteral: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.OpenBrace: {\n          this.skipBlock(tn);\n          break;\n        }\n      }\n    } while (true);\n    tn.readingTemplateString = false;\n  }\n\n  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipBlock(tn: Tokenizer): void {\n    // at '{': ... '}'\n    let depth = 1;\n    let again = true;\n    do {\n      switch (tn.next()) {\n        case Token.EndOfFile: {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          again = false;\n          break;\n        }\n        case Token.OpenBrace: {\n          ++depth;\n          break;\n        }\n        case Token.CloseBrace: {\n          --depth;\n          if (!depth) again = false;\n          break;\n        }\n        case Token.Identifier: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.StringLiteral:{\n          tn.readString();\n          break;\n        }\n        case Token.TemplateLiteral: {\n          tn.readString();\n          while(tn.readingTemplateString){\n            this.skipBlock(tn);\n            tn.readString(CharCode.Backtick);\n          }\n          break;\n        }\n        case Token.IntegerLiteral: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FloatLiteral: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n      }\n    } while (again);\n  }\n}\n\n/** Operator precedence from least to largest. */\nexport const enum Precedence {\n  None,\n  Comma,\n  Spread,\n  Yield,\n  Assignment,\n  Conditional,\n  LogicalOr,\n  LogicalAnd,\n  BitwiseOr,\n  BitwiseXor,\n  BitwiseAnd,\n  Equality,\n  Relational,\n  Shift,\n  Additive,\n  Multiplicative,\n  Exponentiated,\n  UnaryPrefix,\n  UnaryPostfix,\n  Call,\n  MemberAccess,\n  Grouping\n}\n\n/** Determines the precende of a non-starting token. */\nfunction determinePrecedence(kind: Token): Precedence {\n  switch (kind) {\n    case Token.Comma: return Precedence.Comma;\n    case Token.Equals:\n    case Token.Plus_Equals:\n    case Token.Minus_Equals:\n    case Token.Asterisk_Asterisk_Equals:\n    case Token.Asterisk_Equals:\n    case Token.Slash_Equals:\n    case Token.Percent_Equals:\n    case Token.LessThan_LessThan_Equals:\n    case Token.GreaterThan_GreaterThan_Equals:\n    case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n    case Token.Ampersand_Equals:\n    case Token.Caret_Equals:\n    case Token.Bar_Equals: return Precedence.Assignment;\n    case Token.Question: return Precedence.Conditional;\n    case Token.Bar_Bar: return Precedence.LogicalOr;\n    case Token.Ampersand_Ampersand: return Precedence.LogicalAnd;\n    case Token.Bar: return Precedence.BitwiseOr;\n    case Token.Caret: return Precedence.BitwiseXor;\n    case Token.Ampersand: return Precedence.BitwiseAnd;\n    case Token.Equals_Equals:\n    case Token.Exclamation_Equals:\n    case Token.Equals_Equals_Equals:\n    case Token.Exclamation_Equals_Equals: return Precedence.Equality;\n    case Token.As:\n    case Token.In:\n    case Token.InstanceOf:\n    case Token.LessThan:\n    case Token.GreaterThan:\n    case Token.LessThan_Equals:\n    case Token.GreaterThan_Equals: return Precedence.Relational;\n    case Token.LessThan_LessThan:\n    case Token.GreaterThan_GreaterThan:\n    case Token.GreaterThan_GreaterThan_GreaterThan: return Precedence.Shift;\n    case Token.Plus:\n    case Token.Minus: return Precedence.Additive;\n    case Token.Asterisk:\n    case Token.Slash:\n    case Token.Percent: return Precedence.Multiplicative;\n    case Token.Asterisk_Asterisk: return Precedence.Exponentiated;\n    case Token.Plus_Plus:\n    case Token.Minus_Minus: return Precedence.UnaryPostfix;\n    case Token.Dot:\n    case Token.OpenBracket:\n    case Token.Exclamation: return Precedence.MemberAccess;\n  }\n  return Precedence.None;\n}\n", "/**\n * @fileoverview AssemblyScript's intermediate representation.\n *\n * The compiler uses Binaryen IR, which is fairly low level, as its\n * primary intermediate representation, with the following structures\n * holding any higher level information that cannot be represented by\n * Binaryen IR alone, for example higher level types.\n *\n * Similar to the AST being composed of `Node`s in `Source`s, the IR is\n * composed of `Element`s in a `Program`. Each class or function is\n * represented by a \"prototype\" holding all the relevant information,\n * including each's concrete instances. If a class or function is not\n * generic, there is exactly one instance, otherwise there is one for\n * each concrete set of type arguments.\n *\n * @license Apache-2.0\n */\n\n// Element                    Base class of all elements\n// \u251C\u2500DeclaredElement          Base class of elements with a declaration\n// \u2502 \u251C\u2500TypedElement           Base class of elements resolving to a type\n// \u2502 \u2502 \u251C\u2500TypeDefinition       Type alias declaration\n// \u2502 \u2502 \u251C\u2500VariableLikeElement  Base class of all variable-like elements\n// \u2502 \u2502 \u2502 \u251C\u2500EnumValue          Enum value\n// \u2502 \u2502 \u2502 \u251C\u2500Global             File global\n// \u2502 \u2502 \u2502 \u251C\u2500Local              Function local\n// \u2502 \u2502 \u2502 \u2514\u2500Property           Class property (incl. instance fields)\n// \u2502 \u2502 \u251C\u2500IndexSignature       Class index signature\n// \u2502 \u2502 \u251C\u2500Function             Concrete function instance\n// \u2502 \u2502 \u2514\u2500Class                Concrete class instance\n// \u2502 \u251C\u2500Namespace              Namespace with static members\n// \u2502 \u251C\u2500FunctionPrototype      Prototype of concrete function instances\n// \u2502 \u251C\u2500PropertyPrototype      Prototype of concrete property instances\n// \u2502 \u2514\u2500ClassPrototype         Prototype of concrete classe instances\n// \u2514\u2500File                     File, analogous to Source in the AST\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  STATIC_DELIMITER,\n  INSTANCE_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INNER_DELIMITER,\n  INDEX_SUFFIX,\n  STUB_DELIMITER,\n  CommonNames,\n  Feature,\n  Target,\n  featureToString\n} from \"./common\";\n\nimport {\n  Options\n} from \"./compiler\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Type,\n  TypeKind,\n  Signature,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  Token\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  DecoratorNode,\n  DecoratorKind,\n  TypeParameterNode,\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  IdentifierExpression,\n  LiteralKind,\n  StringLiteralExpression,\n\n  Statement,\n  ClassDeclaration,\n  DeclarationStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportMember,\n  ExportDefaultStatement,\n  ExportStatement,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  ImportStatement,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n  VariableLikeDeclarationStatement,\n  VariableStatement,\n  ParameterKind,\n  ParameterNode,\n  TypeName\n} from \"./ast\";\n\nimport {\n  Module,\n  FunctionRef,\n  MemorySegment,\n  getFunctionName\n} from \"./module\";\n\nimport {\n  CharCode,\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  writeI64,\n  writeI32AsI64,\n  writeI64AsI32\n} from \"./util\";\n\nimport {\n  Resolver\n} from \"./resolver\";\n\nimport {\n  Flow,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  Parser\n} from \"./parser\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n// Memory manager constants\nconst AL_SIZE = 16;\nconst AL_MASK = AL_SIZE - 1;\n\n/** Represents a yet unresolved `import`. */\nclass QueuedImport {\n  constructor(\n    /** File being imported into. */\n    public localFile: File,\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. Is an `import *` if not set. */\n    public foreignIdentifier: IdentifierExpression | null,\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string\n  ) {}\n}\n\n/** Represents a yet unresolved `export`. */\nclass QueuedExport {\n  constructor(\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. */\n    public foreignIdentifier: IdentifierExpression,\n    /** Path to the other file if a re-export. */\n    public foreignPath: string | null,\n    /** Alternative path to the other file if a re-export. */\n    public foreignPathAlt: string | null\n  ) {}\n}\n\n/** Represents a yet unresolved `export *`. */\nclass QueuedExportStar {\n  // stored in a map with localFile as the key\n  constructor(\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string,\n    /** Reference to the path literal for reporting. */\n    public pathLiteral: StringLiteralExpression\n  ) {}\n}\n\n/** Represents the kind of an operator overload. */\nexport enum OperatorKind {\n  Invalid,\n\n  // indexed access\n  IndexedGet,          // a[]\n  IndexedSet,          // a[]=b\n  UncheckedIndexedGet, // unchecked(a[])\n  UncheckedIndexedSet, // unchecked(a[]=b)\n\n  // binary\n  Add,                 // a + b\n  Sub,                 // a - b\n  Mul,                 // a * b\n  Div,                 // a / b\n  Rem,                 // a % b\n  Pow,                 // a ** b\n  BitwiseAnd,          // a & b\n  BitwiseOr,           // a | b\n  BitwiseXor,          // a ^ b\n  BitwiseShl,          // a << b\n  BitwiseShr,          // a >> b\n  BitwiseShrU,         // a >>> b\n  Eq,                  // a == b, a === b\n  Ne,                  // a != b, a !== b\n  Gt,                  // a > b\n  Ge,                  // a >= b\n  Lt,                  // a < b\n  Le,                  // a <= b\n\n  // unary prefix\n  Plus,                // +a\n  Minus,               // -a\n  Not,                 // !a\n  BitwiseNot,          // ~a\n  PrefixInc,           // ++a\n  PrefixDec,           // --a\n\n  // unary postfix\n  PostfixInc,          // a++\n  PostfixDec           // a--\n\n  // not overridable:\n  // LogicalAnd        // a && b\n  // LogicalOr         // a || b\n}\n\nexport namespace OperatorKind {\n\n  /** Returns the operator kind represented by the specified decorator and string argument. */\n  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {\n    assert(arg.length);\n    switch (decoratorKind) {\n      case DecoratorKind.Operator:\n      case DecoratorKind.OperatorBinary: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.OpenBracket: {\n            if (arg == \"[]\") return OperatorKind.IndexedGet;\n            if (arg == \"[]=\") return OperatorKind.IndexedSet;\n            break;\n          }\n          case CharCode.OpenBrace: {\n            if (arg == \"{}\") return OperatorKind.UncheckedIndexedGet;\n            if (arg == \"{}=\") return OperatorKind.UncheckedIndexedSet;\n            break;\n          }\n          case CharCode.Plus: {\n            if (arg == \"+\") return OperatorKind.Add;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"-\") return OperatorKind.Sub;\n            break;\n          }\n          case CharCode.Asterisk: {\n            if (arg == \"*\") return OperatorKind.Mul;\n            if (arg == \"**\") return OperatorKind.Pow;\n            break;\n          }\n          case CharCode.Slash: {\n            if (arg == \"/\") return OperatorKind.Div;\n            break;\n          }\n          case CharCode.Percent: {\n            if (arg == \"%\") return OperatorKind.Rem;\n            break;\n          }\n          case CharCode.Ampersand: {\n            if (arg == \"&\") return OperatorKind.BitwiseAnd;\n            break;\n          }\n          case CharCode.Bar: {\n            if (arg == \"|\") return OperatorKind.BitwiseOr;\n            break;\n          }\n          case CharCode.Caret: {\n            if (arg == \"^\") return OperatorKind.BitwiseXor;\n            break;\n          }\n          case CharCode.Equals: {\n            if (arg == \"==\") return OperatorKind.Eq;\n            break;\n          }\n          case CharCode.Exclamation: {\n            if (arg == \"!=\") return OperatorKind.Ne;\n            break;\n          }\n          case CharCode.GreaterThan: {\n            if (arg == \">\") return OperatorKind.Gt;\n            if (arg == \">=\") return OperatorKind.Ge;\n            if (arg == \">>\") return OperatorKind.BitwiseShr;\n            if (arg == \">>>\") return OperatorKind.BitwiseShrU;\n            break;\n          }\n          case CharCode.LessThan: {\n            if (arg == \"<\") return OperatorKind.Lt;\n            if (arg == \"<=\") return OperatorKind.Le;\n            if (arg == \"<<\") return OperatorKind.BitwiseShl;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OperatorPrefix: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.Plus: {\n            if (arg == \"+\") return OperatorKind.Plus;\n            if (arg == \"++\") return OperatorKind.PrefixInc;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"-\") return OperatorKind.Minus;\n            if (arg == \"--\") return OperatorKind.PrefixDec;\n            break;\n          }\n          case CharCode.Exclamation: {\n            if (arg == \"!\") return OperatorKind.Not;\n            break;\n          }\n          case CharCode.Tilde: {\n            if (arg == \"~\") return OperatorKind.BitwiseNot;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OperatorPostfix: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.Plus: {\n            if (arg == \"++\") return OperatorKind.PostfixInc;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"--\") return OperatorKind.PostfixDec;\n            break;\n          }\n        }\n        break;\n      }\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a binary operator token to the respective operator kind. */\n  export function fromBinaryToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus:\n      case Token.Plus_Equals: return OperatorKind.Add;\n      case Token.Minus:\n      case Token.Minus_Equals: return OperatorKind.Sub;\n      case Token.Asterisk:\n      case Token.Asterisk_Equals: return OperatorKind.Mul;\n      case Token.Slash:\n      case Token.Slash_Equals: return OperatorKind.Div;\n      case Token.Percent:\n      case Token.Percent_Equals: return OperatorKind.Rem;\n      case Token.Asterisk_Asterisk:\n      case Token.Asterisk_Asterisk_Equals: return OperatorKind.Pow;\n      case Token.Ampersand:\n      case Token.Ampersand_Equals: return OperatorKind.BitwiseAnd;\n      case Token.Bar:\n      case Token.Bar_Equals: return OperatorKind.BitwiseOr;\n      case Token.Caret:\n      case Token.Caret_Equals: return OperatorKind.BitwiseXor;\n      case Token.LessThan_LessThan:\n      case Token.LessThan_LessThan_Equals: return OperatorKind.BitwiseShl;\n      case Token.GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_Equals: return OperatorKind.BitwiseShr;\n      case Token.GreaterThan_GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals: return OperatorKind.BitwiseShrU;\n      case Token.Equals_Equals: return OperatorKind.Eq;\n      case Token.Exclamation_Equals: return OperatorKind.Ne;\n      case Token.GreaterThan: return OperatorKind.Gt;\n      case Token.GreaterThan_Equals: return OperatorKind.Ge;\n      case Token.LessThan: return OperatorKind.Lt;\n      case Token.LessThan_Equals: return OperatorKind.Le;\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a unary prefix operator token to the respective operator kind. */\n  export function fromUnaryPrefixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus: return OperatorKind.Plus;\n      case Token.Minus: return OperatorKind.Minus;\n      case Token.Exclamation: return OperatorKind.Not;\n      case Token.Tilde: return OperatorKind.BitwiseNot;\n      case Token.Plus_Plus: return OperatorKind.PrefixInc;\n      case Token.Minus_Minus: return OperatorKind.PrefixDec;\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a unary postfix operator token to the respective operator kind. */\n  export function fromUnaryPostfixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus_Plus: return OperatorKind.PostfixInc;\n      case Token.Minus_Minus: return OperatorKind.PostfixDec;\n    }\n    return OperatorKind.Invalid;\n  }\n}\n\n/** Represents an AssemblyScript program. */\nexport class Program extends DiagnosticEmitter {\n\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\n  constructor(\n    /** Compiler options. */\n    public options: Options,\n    /** Shared array of diagnostic messages (emitted so far). */\n    diagnostics: DiagnosticMessage[] | null = null\n  ) {\n    super(diagnostics);\n    this.module = Module.create(options.stackSize > 0, options.sizeTypeRef);    \n    this.parser = new Parser(this.diagnostics, this.sources);\n    this.resolver = new Resolver(this);\n    let nativeFile = new File(this, Source.native);\n    this.nativeFile = nativeFile;\n    this.filesByName.set(nativeFile.internalName, nativeFile);\n  }\n\n  /** Module instance. */\n  module: Module;\n  /** Parser instance. */\n  parser!: Parser;\n  /** Resolver instance. */\n  resolver!: Resolver;\n  /** Array of sources. */\n  sources: Source[] = [];\n  /** Diagnostic offset used where successively obtaining the next diagnostic. */\n  diagnosticsOffset: i32 = 0;\n  /** Special native code file. */\n  nativeFile!: File;\n  /** Next class id. */\n  nextClassId: u32 = 0;\n  /** Next signature id. */\n  nextSignatureId: i32 = 0;\n  /** An indicator if the program has been initialized. */\n  initialized: bool = false;\n\n  // Lookup maps\n\n  /** Files by unique internal name. */\n  filesByName: Map<string,File> = new Map();\n  /** Elements by unique internal name in element space. */\n  elementsByName: Map<string,Element> = new Map();\n  /** Elements by declaration. */\n  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();\n  /** Element instances by unique internal name. */\n  instancesByName: Map<string,Element> = new Map();\n  /** Classes wrapping basic types like `i32`. */\n  wrapperClasses: Map<Type,Class> = new Map();\n  /** Managed classes contained in the program, by id. */\n  managedClasses: Map<i32,Class> = new Map();\n  /** A set of unique function signatures contained in the program, by id. */\n  uniqueSignatures: Map<string, Signature> = new Map<string, Signature>();\n  /** Module exports. */\n  moduleExports: Map<string,Element> = new Map();\n  /** Module imports. */\n  moduleImports: Map<string,Map<string,Element>> = new Map();\n\n  // Standard library\n\n  /** Gets the standard `ArrayBufferView` instance. */\n  get arrayBufferViewInstance(): Class {\n    let cached = this._arrayBufferViewInstance;\n    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);\n    return cached;\n  }\n  private _arrayBufferViewInstance: Class | null = null;\n\n  /** Gets the standard `ArrayBuffer` instance. */\n  get arrayBufferInstance(): Class {\n    let cached = this._arrayBufferInstance;\n    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);\n    return cached;\n  }\n  private _arrayBufferInstance: Class | null = null;\n\n  /** Gets the standard `Array` prototype. */\n  get arrayPrototype(): ClassPrototype {\n    let cached = this._arrayPrototype;\n    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _arrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `StaticArray` prototype. */\n  get staticArrayPrototype(): ClassPrototype {\n    let cached = this._staticArrayPrototype;\n    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _staticArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Set` prototype. */\n  get setPrototype(): ClassPrototype {\n    let cached = this._setPrototype;\n    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _setPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Map` prototype. */\n  get mapPrototype(): ClassPrototype {\n    let cached = this._mapPrototype;\n    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _mapPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Function` prototype. */\n  get functionPrototype(): ClassPrototype {\n    let cached = this._functionPrototype;\n    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _functionPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int8Array` prototype. */\n  get int8ArrayPrototype(): ClassPrototype {\n    let cached = this._int8ArrayPrototype;\n    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int16Array` prototype. */\n  get int16ArrayPrototype(): ClassPrototype {\n    let cached = this._int16ArrayPrototype;\n    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int32Array` prototype. */\n  get int32ArrayPrototype(): ClassPrototype {\n    let cached = this._int32ArrayPrototype;\n    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int64Array` prototype. */\n  get int64ArrayPrototype(): ClassPrototype {\n    let cached = this._int64ArrayPrototype;\n    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8Array` prototype. */\n  get uint8ArrayPrototype(): ClassPrototype {\n    let cached = this._uint8ArrayPrototype;\n    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8ClampedArray` prototype. */\n  get uint8ClampedArrayPrototype(): ClassPrototype {\n    let cached = this._uint8ClampedArrayPrototype;\n    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint16Array` prototype. */\n  get uint16ArrayPrototype(): ClassPrototype {\n    let cached = this._uint16ArrayPrototype;\n    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint32Array` prototype. */\n  get uint32ArrayPrototype(): ClassPrototype {\n    let cached = this._uint32ArrayPrototype;\n    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint64Array` prototype. */\n  get uint64ArrayPrototype(): ClassPrototype {\n    let cached = this._uint64ArrayPrototype;\n    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float32Array` prototype. */\n  get float32ArrayPrototype(): ClassPrototype {\n    let cached = this._float32ArrayPrototype;\n    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _float32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float64Array` prototype. */\n  get float64ArrayPrototype(): ClassPrototype {\n    let cached = this._float64ArrayPrototype;\n    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _float64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `String` instance. */\n  get stringInstance(): Class {\n    let cached = this._stringInstance;\n    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);\n    return cached;\n  }\n  private _stringInstance: Class | null = null;\n\n  /** Gets the standard `RegExp` instance. */\n  get regexpInstance(): Class {\n    let cached = this._regexpInstance;\n    if (!cached) this._regexpInstance = cached = this.requireClass(CommonNames.RegExp);\n    return cached;\n  }\n  private _regexpInstance: Class | null = null;\n\n  /** Gets the standard `Object` prototype. */\n  get objectPrototype(): ClassPrototype {\n    let cached = this._objectPrototype;\n    if (!cached) this._objectPrototype = cached = <ClassPrototype>this.require(CommonNames.Object, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _objectPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Object` instance. */\n  get objectInstance(): Class {\n    let cached = this._objectInstance;\n    if (!cached) this._objectInstance = cached = this.requireClass(CommonNames.Object);\n    return cached;\n  }\n  private _objectInstance: Class | null = null;\n\n  /** Gets the standard `TemplateStringsArray` instance. */\n  get templateStringsArrayInstance(): Class {\n    let cached = this._templateStringsArrayInstance;\n    if (!cached) this._templateStringsArrayInstance = cached = this.requireClass(CommonNames.TemplateStringsArray);\n    return cached;\n  }\n  private _templateStringsArrayInstance: Class | null = null;\n\n  /** Gets the standard `abort` instance, if not explicitly disabled. */\n  get abortInstance(): Function | null {\n    let prototype = this.lookup(CommonNames.abort);\n    if (!prototype || prototype.kind != ElementKind.FunctionPrototype) return null;\n    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n  }\n\n  // Runtime interface\n\n  /** Gets the runtime `__alloc(size: usize): usize` instance. */\n  get allocInstance(): Function {\n    let cached = this._allocInstance;\n    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);\n    return cached;\n  }\n  private _allocInstance: Function | null = null;\n\n  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */\n  get reallocInstance(): Function {\n    let cached = this._reallocInstance;\n    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);\n    return cached;\n  }\n  private _reallocInstance: Function | null = null;\n\n  /** Gets the runtime `__free(ptr: usize): void` instance. */\n  get freeInstance(): Function {\n    let cached = this._freeInstance;\n    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);\n    return cached;\n  }\n  private _freeInstance: Function | null = null;\n\n  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */\n  get newInstance(): Function {\n    let cached = this._newInstance;\n    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);\n    return cached;\n  }\n  private _newInstance: Function | null = null;\n\n  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */\n  get renewInstance(): Function {\n    let cached = this._renewInstance;\n    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);\n    return cached;\n  }\n  private _renewInstance: Function | null = null;\n\n  /** Gets the runtime `__link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void` instance. */\n  get linkInstance(): Function {\n    let cached = this._linkInstance;\n    if (!cached) this._linkInstance = cached = this.requireFunction(CommonNames.link);\n    return cached;\n  }\n  private _linkInstance: Function | null = null;\n\n  /** Gets the runtime `__collect(): void` instance. */\n  get collectInstance(): Function {\n    let cached = this._collectInstance;\n    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);\n    return cached;\n  }\n  private _collectInstance: Function | null = null;\n\n  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */\n  get visitInstance(): Function {\n    let cached = this._visitInstance;\n    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);\n    return cached;\n  }\n  private _visitInstance: Function | null = null;\n\n  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */\n  get newBufferInstance(): Function {\n    let cached = this._newBufferInstance;\n    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);\n    return cached;\n  }\n  private _newBufferInstance: Function | null = null;\n\n  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */\n  get newArrayInstance(): Function {\n    let cached = this._newArrayInstance;\n    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);\n    return cached;\n  }\n  private _newArrayInstance: Function | null = null;\n\n  /** Gets the runtime's internal `BLOCK` instance. */\n  get BLOCKInstance(): Class {\n    let cached = this._BLOCKInstance;\n    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);\n    return cached;\n  }\n  private _BLOCKInstance: Class | null = null;\n\n  /** Gets the runtime's internal `OBJECT` instance. */\n  get OBJECTInstance(): Class {\n    let cached = this._OBJECTInstance;\n    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);\n    return cached;\n  }\n  private _OBJECTInstance: Class | null = null;\n\n  // Utility\n\n  /** Obtains the source matching the specified internal path. */\n  getSource(internalPath: string): string | null {\n    let sources = this.sources;\n    for (let i = 0; i < sources.length; ++i) {\n      let source = sources[i];\n      if (source.internalPath == internalPath) return source.text;\n    }\n    return null;\n  }\n\n  /** Gets the overhead of a memory manager block. */\n  get blockOverhead(): i32 {\n    // BLOCK | data...\n    //       ^ 16b alignment\n    return this.BLOCKInstance.nextMemoryOffset;\n  }\n\n  /** Gets the overhead of a managed object, excl. block overhead, incl. alignment. */\n  get objectOverhead(): i32 {\n    // OBJECT+align | data...\n    //        \u2514 0 \u2518 ^ 16b alignment\n    return (this.OBJECTInstance.nextMemoryOffset - this.blockOverhead + AL_MASK) & ~AL_MASK;\n  }\n\n  /** Gets the total overhead of a managed object, incl. block overhead. */\n  get totalOverhead(): i32 {\n    // BLOCK | OBJECT+align | data...\n    // \u2514     = TOTAL      \u2518 ^ 16b alignment\n    return this.blockOverhead + this.objectOverhead;\n  }\n\n  searchFunctionByRef(ref: FunctionRef): Function | null {\n    const modifiedFunctionName = getFunctionName(ref);\n    if (modifiedFunctionName) {\n      const instancesByName = this.instancesByName;\n      if (instancesByName.has(modifiedFunctionName)) {\n        const element = assert(instancesByName.get(modifiedFunctionName));\n        if (element.kind == ElementKind.Function) {\n          return <Function>element;\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart(currentOffset: i32): i32 {\n    let blockOverhead = this.blockOverhead;\n    return ((currentOffset + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart64(currentOffset: i64): i64 {\n    let blockOverhead = i64_new(this.blockOverhead);\n    return i64_sub(i64_align(i64_add(currentOffset, blockOverhead), AL_SIZE), blockOverhead);\n  }\n\n  /** Computes the size of a memory manager block, excl. block overhead. */\n  computeBlockSize(payloadSize: i32, isManaged: bool): i32 {\n    // see: std/rt/tlsf.ts, computeSize; becomes mmInfo\n    if (isManaged) payloadSize += this.objectOverhead;\n    // we know that payload must be aligned, and that block sizes must be chosen\n    // so that blocks are adjacent with the next payload aligned. hence, block\n    // size is payloadSize rounded up to where the next block would start:\n    let blockSize = this.computeBlockStart(payloadSize);\n    // make sure that block size is valid according to TLSF requirements\n    let blockOverhead = this.blockOverhead;\n    let blockMinsize = ((3 * this.options.usizeType.byteSize + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n    if (blockSize < blockMinsize) blockSize = blockMinsize;\n    const blockMaxsize = 1 << 30; // 1 << (FL_BITS + SB_BITS - 1), exclusive\n    const tagsMask = 3;\n    if (blockSize >= blockMaxsize || (blockSize & tagsMask) != 0) {\n      throw new Error(\"invalid block size\");\n    }\n    return blockSize;\n  }\n\n  /** Creates a native variable declaration. */\n  makeNativeVariableDeclaration(\n    /** The simple name of the variable */\n    name: string,\n    /** Flags indicating specific traits, e.g. `CONST`. */\n    flags: CommonFlags = CommonFlags.None\n  ): VariableDeclaration {\n    let range = Source.native.range;\n    return Node.createVariableDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, null, range\n    );\n  }\n\n  /** Creates a native type declaration. */\n  makeNativeTypeDeclaration(\n    /** The simple name of the type. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.None\n  ): TypeDeclaration {\n    let range = Source.native.range;\n    let identifier = Node.createIdentifierExpression(name, range);\n    return Node.createTypeDeclaration(\n      identifier,\n      null, flags, null,\n      Node.createOmittedType(range),\n      range\n    );\n  }\n\n  // a dummy signature for programmatically generated native functions\n  private nativeDummySignature: FunctionTypeNode | null = null;\n\n  /** Creates a native function declaration. */\n  makeNativeFunctionDeclaration(\n    /** The simple name of the function. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `DECLARE`. */\n    flags: CommonFlags = CommonFlags.None\n  ): FunctionDeclaration {\n    let range = Source.native.range;\n    let signature = this.nativeDummySignature;\n    if (!signature) {\n      this.nativeDummySignature = signature = Node.createFunctionType([],\n        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway\n          Node.createSimpleTypeName(CommonNames.void_, range),\n          null, false, range\n        ),\n        null, false, range\n      );\n    }\n    return Node.createFunctionDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, signature, null, ArrowKind.None, range\n    );\n  }\n\n  /** Creates a native namespace declaration. */\n  makeNativeNamespaceDeclaration(\n    /** The simple name of the namespace. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `EXPORT`. */\n    flags: CommonFlags = CommonFlags.None\n  ): NamespaceDeclaration {\n    let range = Source.native.range;\n    return Node.createNamespaceDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, [], range\n    );\n  }\n\n  /** Creates a native function. */\n  makeNativeFunction(\n    /** The simple name of the function. */\n    name: string,\n    /** Concrete function signature. */\n    signature: Signature,\n    /** Parent element, usually a file, class or namespace. */\n    parent: Element = this.nativeFile,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.None,\n    /** Decorator flags representing built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ): Function {\n    return new Function(\n      name,\n      new FunctionPrototype(\n        name,\n        parent,\n        this.makeNativeFunctionDeclaration(name, flags),\n        decoratorFlags\n      ),\n      null,\n      signature\n    );\n  }\n\n  /** Gets the (possibly merged) program element linked to the specified declaration. */\n  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {\n    let elementsByDeclaration = this.elementsByDeclaration;\n    return elementsByDeclaration.has(declaration)\n      ? assert(elementsByDeclaration.get(declaration))\n      : null;\n  }\n\n  /** Initializes the program and its elements prior to compilation. */\n  initialize(): void {\n    if (this.initialized) return;\n    this.initialized = true;\n\n    let options = this.options;\n\n    // register native types\n    this.registerNativeType(CommonNames.i8, Type.i8);\n    this.registerNativeType(CommonNames.i16, Type.i16);\n    this.registerNativeType(CommonNames.i32, Type.i32);\n    this.registerNativeType(CommonNames.i64, Type.i64);\n    this.registerNativeType(CommonNames.isize, options.isizeType);\n    this.registerNativeType(CommonNames.u8, Type.u8);\n    this.registerNativeType(CommonNames.u16, Type.u16);\n    this.registerNativeType(CommonNames.u32, Type.u32);\n    this.registerNativeType(CommonNames.u64, Type.u64);\n    this.registerNativeType(CommonNames.usize, options.usizeType);\n    this.registerNativeType(CommonNames.bool, Type.bool);\n    this.registerNativeType(CommonNames.f32, Type.f32);\n    this.registerNativeType(CommonNames.f64, Type.f64);\n    this.registerNativeType(CommonNames.void_, Type.void);\n    this.registerNativeType(CommonNames.number, Type.f64); // alias\n    this.registerNativeType(CommonNames.boolean, Type.bool); // alias\n    this.nativeFile.add(CommonNames.native, new TypeDefinition(\n      CommonNames.native,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(\n      CommonNames.indexof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(\n      CommonNames.valueof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(\n      CommonNames.returnof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.nonnull, new TypeDefinition(\n      CommonNames.nonnull,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.nonnull, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n\n    // The following types might not be enabled by compiler options, so the\n    // compiler needs to check this condition whenever such a value is created\n    // respectively stored or loaded.\n    this.registerNativeType(CommonNames.v128, Type.v128);\n    this.registerNativeType(CommonNames.funcref, Type.funcref);\n    this.registerNativeType(CommonNames.externref, Type.externref);\n    this.registerNativeType(CommonNames.anyref, Type.anyref);\n    this.registerNativeType(CommonNames.eqref, Type.eqref);\n    this.registerNativeType(CommonNames.i31ref, Type.i31ref);\n    this.registerNativeType(CommonNames.dataref, Type.dataref);\n    this.registerNativeType(CommonNames.arrayref, Type.arrayref);\n    this.registerNativeType(CommonNames.stringref, Type.stringref);\n    this.registerNativeType(CommonNames.stringview_wtf8, Type.stringview_wtf8);\n    this.registerNativeType(CommonNames.stringview_wtf16, Type.stringview_wtf16);\n    this.registerNativeType(CommonNames.stringview_iter, Type.stringview_iter);\n\n    // register compiler hints\n    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,\n      i64_new(options.isWasm64 ? Target.Wasm64 : Target.Wasm32));\n    this.registerConstantInteger(CommonNames.ASC_RUNTIME, Type.i32,\n      i64_new(options.runtime));\n    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,\n      i64_new(options.noAssert ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,\n      i64_new(options.memoryBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,\n      i64_new(options.tableBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,\n      i64_new(options.optimizeLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,\n      i64_new(options.shrinkLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,\n      i64_new(options.lowMemoryLimit, 0));\n    this.registerConstantInteger(CommonNames.ASC_EXPORT_RUNTIME, Type.bool,\n      i64_new(options.exportRuntime ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MAJOR, Type.i32,\n      i64_new(options.bundleMajorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MINOR, Type.i32,\n      i64_new(options.bundleMinorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_PATCH, Type.i32,\n      i64_new(options.bundlePatchVersion));\n\n    // register feature hints\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,\n      i64_new(options.hasFeature(Feature.SignExtension) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,\n      i64_new(options.hasFeature(Feature.MutableGlobals) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,\n      i64_new(options.hasFeature(Feature.NontrappingF2I) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,\n      i64_new(options.hasFeature(Feature.BulkMemory) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.Simd) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,\n      i64_new(options.hasFeature(Feature.Threads) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,\n      i64_new(options.hasFeature(Feature.ExceptionHandling) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,\n      i64_new(options.hasFeature(Feature.TailCalls) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,\n      i64_new(options.hasFeature(Feature.ReferenceTypes) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,\n      i64_new(options.hasFeature(Feature.MultiValue) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,\n      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,\n      i64_new(options.hasFeature(Feature.Memory64) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_RELAXED_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.RelaxedSimd) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXTENDED_CONST, Type.bool,\n      i64_new(options.hasFeature(Feature.ExtendedConst) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_STRINGREF, Type.bool,\n      i64_new(options.hasFeature(Feature.Stringref) ? 1 : 0, 0));\n\n    // remember deferred elements\n    let queuedImports = new Array<QueuedImport>();\n    let queuedExports = new Map<File,Map<string,QueuedExport>>();\n    let queuedExportsStar = new Map<File,QueuedExportStar[]>();\n    let queuedExtends = new Array<ClassPrototype>();\n    let queuedImplements = new Array<ClassPrototype>();\n\n    // initialize relevant declaration-like statements of the entire program\n    for (let i = 0, k = this.sources.length; i < k; ++i) {\n      let source = this.sources[i];\n      let file = new File(this, source);\n      this.filesByName.set(file.internalName, file);\n      let statements = source.statements;\n      for (let j = 0, l = statements.length; j < l; ++j) {\n        let statement = statements[j];\n        switch (statement.kind) {\n          case NodeKind.Export: {\n            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);\n            break;\n          }\n          case NodeKind.ExportDefault: {\n            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.Import: {\n            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);\n            break;\n          }\n          case NodeKind.Variable: {\n            this.initializeVariables(<VariableStatement>statement, file);\n            break;\n          }\n          case NodeKind.ClassDeclaration: {\n            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.EnumDeclaration: {\n            this.initializeEnum(<EnumDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.FunctionDeclaration: {\n            this.initializeFunction(<FunctionDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.InterfaceDeclaration: {\n            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);\n            break;\n          }\n          case NodeKind.NamespaceDeclaration: {\n            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.TypeDeclaration: {\n            this.initializeTypeDefinition(<TypeDeclaration>statement, file);\n            break;\n          }\n        }\n      }\n    }\n\n    // queued exports * should be linkable now that all files have been processed\n    // TODO: for (let [file, starExports] of queuedExportsStar) {\n    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {\n      let file = _keys[i];\n      let starExports = assert(queuedExportsStar.get(file));\n      for (let j = 0, l = starExports.length; j < l; ++j) {\n        let exportStar = unchecked(starExports[j]);\n        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);\n        if (!foreignFile) {\n          this.error(\n            DiagnosticCode.File_0_not_found,\n            exportStar.pathLiteral.range, exportStar.pathLiteral.value\n          );\n          continue;\n        }\n        file.ensureExportStar(foreignFile);\n      }\n    }\n\n    // queued imports should be resolvable now through traversing exports and queued exports.\n    // note that imports may depend upon imports, so repeat until there's no more progress.\n    do {\n      let i = 0, madeProgress = false;\n      while (i < queuedImports.length) {\n        let queuedImport = queuedImports[i];\n        let localIdentifier = queuedImport.localIdentifier;\n        let foreignIdentifier = queuedImport.foreignIdentifier;\n        // File must be found here, as it would otherwise already have been reported by the parser\n        let foreignFile = assert(this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt));\n        if (foreignIdentifier) { // i.e. import { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            foreignIdentifier.text,\n            foreignFile,\n            queuedExports\n          );\n          if (element) {\n            queuedImport.localFile.add(\n              localIdentifier.text,\n              element,\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n          }\n        } else { // i.e. import * as bar from \"./bar\"\n          let localFile = queuedImport.localFile;\n          let localName = localIdentifier.text;\n          localFile.add(\n            localName,\n            foreignFile.asAliasNamespace(\n              localName,\n              localFile,\n              localIdentifier\n            ),\n            localIdentifier // isImport\n          );\n          queuedImports.splice(i, 1);\n          madeProgress = true;\n        }\n      }\n      if (!madeProgress) {\n        // report queued imports we were unable to resolve\n        for (let j = 0, l = queuedImports.length; j < l; ++j) {\n          let queuedImport = queuedImports[j];\n          let foreignIdentifier = queuedImport.foreignIdentifier;\n          if (foreignIdentifier) {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text\n            );\n          }\n        }\n        break;\n      }\n    } while (true);\n\n    // queued exports should be resolvable now that imports are finalized\n    // TODO: for (let [file, exports] of queuedExports) {\n    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {\n      let file = unchecked(_keys[i]);\n      let exports = assert(queuedExports.get(file));\n      // TODO: for (let [exportName, queuedExport] of exports) {\n      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {\n        let exportName = unchecked(exportNames[j]);\n        let queuedExport = assert(exports.get(exportName));\n        let localName = queuedExport.localIdentifier.text;\n        let foreignPath = queuedExport.foreignPath;\n        if (foreignPath) { // i.e. export { foo [as bar] } from \"./baz\"\n          // File must be found here, as it would otherwise already have been reported by the parser\n          let foreignFile = assert(this.lookupForeignFile(foreignPath, assert(queuedExport.foreignPathAlt)));\n          let element = this.lookupForeign(localName, foreignFile, queuedExports);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              queuedExport.localIdentifier.range,\n              foreignPath, localName\n            );\n          }\n        } else { // i.e. export { foo [as bar] }\n          let element = file.getMember(localName);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            let globalElement = this.lookup(localName);\n            if (globalElement && isDeclaredElement(globalElement.kind)) { // export { memory }\n              file.ensureExport(exportName, <DeclaredElement>globalElement);\n            } else {\n              this.error(\n                DiagnosticCode.Module_0_has_no_exported_member_1,\n                queuedExport.foreignIdentifier.range,\n                file.internalName, queuedExport.foreignIdentifier.text\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // register foundational classes with fixed ids\n    assert(this.objectInstance.id == 0);\n    assert(this.arrayBufferInstance.id == 1);\n    assert(this.stringInstance.id == 2);\n    assert(this.arrayBufferViewInstance.id == 3);\n\n    // register classes backing basic types\n    this.registerWrapperClass(Type.i8, CommonNames.I8);\n    this.registerWrapperClass(Type.i16, CommonNames.I16);\n    this.registerWrapperClass(Type.i32, CommonNames.I32);\n    this.registerWrapperClass(Type.i64, CommonNames.I64);\n    this.registerWrapperClass(options.isizeType, CommonNames.Isize);\n    this.registerWrapperClass(Type.u8, CommonNames.U8);\n    this.registerWrapperClass(Type.u16, CommonNames.U16);\n    this.registerWrapperClass(Type.u32, CommonNames.U32);\n    this.registerWrapperClass(Type.u64, CommonNames.U64);\n    this.registerWrapperClass(options.usizeType, CommonNames.Usize);\n    this.registerWrapperClass(Type.bool, CommonNames.Bool);\n    this.registerWrapperClass(Type.f32, CommonNames.F32);\n    this.registerWrapperClass(Type.f64, CommonNames.F64);\n    if (options.hasFeature(Feature.Simd)) this.registerWrapperClass(Type.v128, CommonNames.V128);\n    if (options.hasFeature(Feature.ReferenceTypes)) {\n      this.registerWrapperClass(Type.funcref, CommonNames.Funcref);\n      this.registerWrapperClass(Type.externref, CommonNames.Externref);\n      if (options.hasFeature(Feature.GC)) {\n        this.registerWrapperClass(Type.anyref, CommonNames.Anyref);\n        this.registerWrapperClass(Type.eqref, CommonNames.Eqref);\n        this.registerWrapperClass(Type.i31ref, CommonNames.I31ref);\n        this.registerWrapperClass(Type.dataref, CommonNames.Dataref);\n        this.registerWrapperClass(Type.arrayref, CommonNames.Arrayref);\n      }\n    }\n\n    // resolve prototypes of extended classes or interfaces\n    let resolver = this.resolver;\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends\n      let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent);\n      if (!baseElement) continue;\n      if (thisPrototype.kind == ElementKind.ClassPrototype) {\n        if (baseElement.kind == ElementKind.ClassPrototype) {\n          let basePrototype = <ClassPrototype>baseElement;\n          if (basePrototype.hasDecorator(DecoratorFlags.Final)) {\n            this.error(\n              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,\n              extendsNode.range, basePrototype.identifierNode.text\n            );\n          }\n          if (\n            basePrototype.hasDecorator(DecoratorFlags.Unmanaged) !=\n            thisPrototype.hasDecorator(DecoratorFlags.Unmanaged)\n          ) {\n            this.error(\n              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,\n              Range.join(thisPrototype.identifierNode.range, extendsNode.range)\n            );\n          }\n          if (!thisPrototype.extends(basePrototype)) {\n            thisPrototype.basePrototype = basePrototype;\n          } else {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              basePrototype.identifierNode.range,\n              basePrototype.identifierNode.text,\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode.A_class_may_only_extend_another_class,\n            extendsNode.range\n          );\n        }\n      } else if (thisPrototype.kind == ElementKind.InterfacePrototype) {\n        if (baseElement.kind == ElementKind.InterfacePrototype) {\n          const basePrototype = <InterfacePrototype>baseElement;\n          if (!thisPrototype.extends(basePrototype)) {\n            thisPrototype.basePrototype = basePrototype;\n          } else {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              basePrototype.identifierNode.range,\n              basePrototype.identifierNode.text,\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode.An_interface_can_only_extend_an_interface,\n            extendsNode.range\n          );\n        }\n      }\n    }\n\n    // check override\n    for (let i = 0, k = queuedExtends.length; i < k; i++) {\n      let prototype = queuedExtends[i];\n      let instanesMembers = prototype.instanceMembers;\n      if (instanesMembers) {\n        let members = Map_values(instanesMembers);\n        for (let j = 0, k = members.length; j < k; j++) {\n          let member = members[j];\n          let declaration = member.declaration;\n          if (declaration.is(CommonFlags.Override)) {\n            let basePrototype = prototype.basePrototype;\n            let hasOverride = false;\n            while (basePrototype) {\n              let instanceMembers = basePrototype.instanceMembers;\n              if (instanceMembers) {\n                if (instanceMembers.has(member.name)) {\n                  hasOverride = true;\n                  break;\n                }\n              }\n              basePrototype = basePrototype.basePrototype;\n            }\n            if (!hasOverride) {\n              let basePrototype = assert(prototype.basePrototype);\n              this.error(\n                DiagnosticCode.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,\n                declaration.name.range,\n                basePrototype.name\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // resolve prototypes of implemented interfaces\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements\n      for (let j = 0, l = implementsNodes.length; j < l; ++j) {\n        let implementsNode = implementsNodes[j];\n        let interfaceElement = resolver.resolveTypeName(implementsNode.name, thisPrototype.parent);\n        if (!interfaceElement) continue;\n        if (interfaceElement.kind == ElementKind.InterfacePrototype) {\n          let interfacePrototype = <InterfacePrototype>interfaceElement;\n          let interfacePrototypes = thisPrototype.interfacePrototypes;\n          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();\n          interfacePrototypes.push(interfacePrototype);\n        } else {\n          this.error(\n            DiagnosticCode.A_class_can_only_implement_an_interface,\n            implementsNode.range\n          );\n        }\n      }\n    }\n\n    // process overrides in extended classes and implemented interfaces\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let basePrototype = thisPrototype.basePrototype;\n      if (basePrototype) {\n        this.processOverrides(thisPrototype, basePrototype);\n      }\n    }\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let basePrototype = thisPrototype.basePrototype;\n      let interfacePrototypes = thisPrototype.interfacePrototypes;\n      if (basePrototype) {\n        this.processOverrides(thisPrototype, basePrototype);\n      }\n      if (interfacePrototypes) {\n        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {\n          this.processOverrides(thisPrototype, interfacePrototypes[j]);\n        }\n      }\n    }\n\n    // set up global aliases\n    {\n      let globalAliases = options.globalAliases;\n      if (!globalAliases) globalAliases = new Map();\n      if (!globalAliases.has(CommonNames.abort)) {\n        globalAliases.set(CommonNames.abort, BuiltinNames.abort);\n      }\n      if (!globalAliases.has(CommonNames.trace)) {\n        globalAliases.set(CommonNames.trace, BuiltinNames.trace);\n      }\n      if (!globalAliases.has(CommonNames.seed)) {\n        globalAliases.set(CommonNames.seed, BuiltinNames.seed);\n      }\n      if (!globalAliases.has(CommonNames.Math)) {\n        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);\n      }\n      if (!globalAliases.has(CommonNames.Mathf)) {\n        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);\n      }\n      // TODO: for (let [alias, name] of globalAliases) {\n      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {\n        let alias = unchecked(_keys[i]);\n        let name = changetype<string>(globalAliases.get(alias));\n        assert(name != null);\n        if (!name.length) {\n          this.elementsByName.delete(alias);\n          continue;\n        }\n        let firstChar = name.charCodeAt(0);\n        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {\n          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));\n        } else {\n          let elementsByName = this.elementsByName;\n          if (elementsByName.has(name)) {\n            elementsByName.set(alias, assert(elementsByName.get(name)));\n          } else {\n            this.error(DiagnosticCode.Element_0_not_found, null, name);\n          }\n        }\n      }\n    }\n\n    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries\n    // TODO: for (let file of this.filesByName.values()) {\n    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) {\n        this.markModuleExports(file);\n      }\n    }\n  }\n\n  /** Processes overridden members by this class in a base class. */\n  private processOverrides(\n    thisPrototype: ClassPrototype,\n    basePrototype: ClassPrototype,\n  ): void {\n    // Note that we don't know concrete instances of class members, yet. Type\n    // checking of concrete (generic) instances happens upon resolve.\n    let thisInstanceMembers = thisPrototype.instanceMembers;\n    if (thisInstanceMembers) {\n      let thisMembers = Map_values(thisInstanceMembers);\n      do {\n        let baseInstanceMembers = basePrototype.instanceMembers;\n        if (baseInstanceMembers) {\n          for (let j = 0, l = thisMembers.length; j < l; ++j) {\n            let thisMember = thisMembers[j];\n            if (baseInstanceMembers.has(thisMember.name)) {\n              let baseMember = assert(baseInstanceMembers.get(thisMember.name));\n              this.doProcessOverride(thisPrototype, thisMember, basePrototype, baseMember);\n            }\n          }\n        }\n        // A class can have a base class and multiple interfaces, but from the\n        // base member alone we only get one. Make sure we don't miss any.\n        let baseInterfacePrototypes = basePrototype.interfacePrototypes;\n        if (baseInterfacePrototypes) {\n          for (let i = 0, k = baseInterfacePrototypes.length; i < k; ++i) {\n            let baseInterfacePrototype = baseInterfacePrototypes[i];\n            if (baseInterfacePrototype != basePrototype) {\n              this.processOverrides(thisPrototype, baseInterfacePrototype);\n            }\n          }\n        }\n        let nextPrototype = basePrototype.basePrototype;\n        if (!nextPrototype) break;\n        basePrototype = nextPrototype;\n      } while (true);\n    }\n  }\n\n  /** Processes a single overridden member by this class in a base class. */\n  private doProcessOverride(\n    thisClass: ClassPrototype,\n    thisMember: DeclaredElement,\n    baseClass: ClassPrototype,\n    baseMember: DeclaredElement\n  ): void {\n    // Constructors and private members do not override\n    if (thisMember.isAny(CommonFlags.Constructor | CommonFlags.Private)) return;\n    if (\n      thisMember.kind == ElementKind.FunctionPrototype &&\n      baseMember.kind == ElementKind.FunctionPrototype\n    ) {\n      let thisMethod = <FunctionPrototype>thisMember;\n      let baseMethod = <FunctionPrototype>baseMember;\n      if (!thisMethod.visibilityEquals(baseMethod)) {\n        this.errorRelated(\n          DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n          thisMethod.identifierNode.range, baseMethod.identifierNode.range\n        );\n      }\n      baseMember.set(CommonFlags.Overridden);\n      let overrides = baseMethod.unboundOverrides;\n      if (!overrides) baseMethod.unboundOverrides = overrides = new Set();\n      overrides.add(<FunctionPrototype>thisMember);\n      let baseMethodInstances = baseMethod.instances;\n      if (baseMethodInstances) {\n        for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {\n          let baseMethodInstance = _values[a];\n          baseMethodInstance.set(CommonFlags.Overridden);\n        }\n      }\n    } else if (\n      thisMember.kind == ElementKind.PropertyPrototype &&\n      baseMember.kind == ElementKind.PropertyPrototype\n    ) {\n      let thisProperty = <PropertyPrototype>thisMember;\n      let baseProperty = <PropertyPrototype>baseMember;\n      if (!thisProperty.visibilityEquals(baseProperty)) {\n        this.errorRelated(\n          DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n          thisProperty.identifierNode.range, baseProperty.identifierNode.range\n        );\n      }\n      if (baseProperty.parent.kind != ElementKind.InterfacePrototype) {\n        // Interface fields/properties can be implemented by either, but other\n        // members must match to retain compatiblity with TS/JS.\n        let thisIsField = thisProperty.isField;\n        if (thisIsField != baseProperty.isField) {\n          if (thisIsField) { // base is property\n            this.errorRelated(\n              DiagnosticCode._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property,\n              thisProperty.identifierNode.range, baseProperty.identifierNode.range,\n              thisProperty.name, baseClass.internalName, thisClass.internalName\n            );\n          } else { // this is property, base is field\n            this.errorRelated(\n              DiagnosticCode._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor,\n              thisProperty.identifierNode.range, baseProperty.identifierNode.range,\n              thisProperty.name, baseClass.internalName, thisClass.internalName\n            );\n          }\n          return;\n        } else if (thisIsField) { // base is also field\n          // Fields don't override other fields and can only be redeclared\n          return;\n        }\n      }\n      baseProperty.set(CommonFlags.Overridden);\n      let baseGetter = baseProperty.getterPrototype;\n      if (baseGetter) {\n        baseGetter.set(CommonFlags.Overridden);\n        let thisGetter = thisProperty.getterPrototype;\n        if (thisGetter) {\n          let overrides = baseGetter.unboundOverrides;\n          if (!overrides) baseGetter.unboundOverrides = overrides = new Set();\n          overrides.add(thisGetter);\n        }\n        let baseGetterInstances = baseGetter.instances;\n        if (baseGetterInstances) {\n          for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {\n            let baseGetterInstance = _values[a];\n            baseGetterInstance.set(CommonFlags.Overridden);\n          }\n        }\n      }\n      let baseSetter = baseProperty.setterPrototype;\n      if (baseSetter && thisProperty.setterPrototype) {\n        baseSetter.set(CommonFlags.Overridden);\n        let thisSetter = thisProperty.setterPrototype;\n        if (thisSetter) {\n          let overrides = baseSetter.unboundOverrides;\n          if (!overrides) baseSetter.unboundOverrides = overrides = new Set();\n          overrides.add(thisSetter);\n        }\n        let baseSetterInstances = baseSetter.instances;\n        if (baseSetterInstances) {\n          for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {\n            let baseSetterInstance = _values[a];\n            baseSetterInstance.set(CommonFlags.Overridden);\n          }\n        }\n      }\n    } else {\n      this.errorRelated(\n        DiagnosticCode.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,\n        thisMember.identifierNode.range, baseMember.identifierNode.range,\n        thisMember.name, thisClass.internalName, baseClass.internalName\n      );\n    }\n  }\n\n  /** Looks up the element of the specified name in the global scope. */\n  lookup(name: string): Element | null {\n    let elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    return null;\n  }\n\n  /** Requires that a global library element of the specified kind is present and returns it. */\n  private require(name: string, kind: ElementKind): Element {\n    let element = this.lookup(name);\n    if (!element) throw new Error(`Missing standard library component: ${name}`);\n    if (element.kind != kind) throw Error(`Invalid standard library component kind: ${name}`);\n    return element;\n  }\n\n  /** Requires that a global variable is present and returns it. */\n  requireGlobal(name: string): Global {\n    return <Global>this.require(name, ElementKind.Global);\n  }\n\n  /** Requires that a non-generic global class is present and returns it. */\n  requireClass(name: string): Class {\n    let prototype = this.require(name, ElementKind.ClassPrototype);\n    let resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);\n    if (!resolved) throw new Error(`Invalid standard library class: ${name}`);\n    return resolved;\n  }\n\n  /** Requires that a global function is present and returns it. */\n  requireFunction(name: string, typeArguments: Type[] | null = null): Function {\n    let prototype = <FunctionPrototype>this.require(name, ElementKind.FunctionPrototype);\n    let resolved = this.resolver.resolveFunction(prototype, typeArguments);\n    if (!resolved) throw new Error(`Invalid standard library function: ${name}`);\n    return resolved;\n  }\n\n  /** Marks all exports of the specified file as module exports. */\n  private markModuleExports(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {\n        let element = unchecked(_values[j]);\n        this.markModuleExport(element);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.markModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Marks an element and its children as a module export. */\n  private markModuleExport(element: Element): void {\n    element.set(CommonFlags.ModuleExport);\n    switch (element.kind) {\n      case ElementKind.ClassPrototype: {\n        let instanceMembers = (<ClassPrototype>element).instanceMembers;\n        if (instanceMembers) {\n          // TODO: for (let member of instanceMembers.values()) {\n          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n            let member = unchecked(_values[i]);\n            this.markModuleExport(member);\n          }\n        }\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>element;\n        let getterPrototype = propertyPrototype.getterPrototype;\n        if (getterPrototype) this.markModuleExport(getterPrototype);\n        let setterPrototype = propertyPrototype.setterPrototype;\n        if (setterPrototype) this.markModuleExport(setterPrototype);\n        break;\n      }\n      case ElementKind.Property:\n      case ElementKind.Function:\n      case ElementKind.Class: assert(false); // assumes that there are no instances yet\n    }\n    let staticMembers = element.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.markModuleExport(member);\n      }\n    }\n  }\n\n  /** Marks an element as a module import. */\n  markModuleImport(moduleName: string, name: string, element: Element): void {\n    element.set(CommonFlags.ModuleImport);\n    let moduleImports = this.moduleImports;\n    let module: Map<string,Element>;\n    if (moduleImports.has(moduleName)) {\n      module = assert(moduleImports.get(moduleName));\n    } else {\n      module = new Map();\n      moduleImports.set(moduleName, module);\n    }\n    module.set(name, element);\n  }\n\n  /** Registers a native type with the program. */\n  private registerNativeType(name: string, type: Type): void {\n    let element = new TypeDefinition(\n      name,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(name, CommonFlags.Export),\n      DecoratorFlags.Builtin\n    );\n    element.setType(type);\n    this.nativeFile.add(name, element);\n  }\n\n  /** Registers the wrapper class of a non-class type. */\n  private registerWrapperClass(type: Type, className: string): void {\n    let wrapperClasses = this.wrapperClasses;\n    assert(!type.isInternalReference && !wrapperClasses.has(type));\n    let element = assert(this.lookup(className));\n    assert(element.kind == ElementKind.ClassPrototype);\n    let classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));\n    classElement.wrappedType = type;\n    wrapperClasses.set(type, classElement);\n  }\n\n  /** Registers a constant integer value within the global scope. */\n  registerConstantInteger(name: string, type: Type, value: i64): void {\n    assert(type.isIntegerInclReference);\n    let global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.None,\n      this.makeNativeVariableDeclaration(name, CommonFlags.Const | CommonFlags.Export)\n    );\n    global.setConstantIntegerValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Registers a constant float value within the global scope. */\n  private registerConstantFloat(name: string, type: Type, value: f64): void {\n    assert(type.isFloatValue);\n    let global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.None,\n      this.makeNativeVariableDeclaration(name, CommonFlags.Const | CommonFlags.Export)\n    );\n    global.setConstantFloatValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Ensures that the given global element exists. Attempts to merge duplicates. */\n  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {\n    let elementsByName = this.elementsByName;\n    if (elementsByName.has(name)) {\n      let existing = assert(elementsByName.get(name));\n      // NOTE: this is effectively only performed when merging native types with\n      // their respective namespaces in std/builtins, but can also trigger when a\n      // user has multiple global elements of the same name in different files,\n      // which might result in unexpected shared symbols accross files. considering\n      // this a wonky feature for now that we might want to revisit later.\n      if (existing != element) {\n        let merged = tryMerge(existing, element);\n        if (!merged) {\n          if (isDeclaredElement(existing.kind)) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range,\n              (<DeclaredElement>existing).declaration.name.range,\n              name\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range, name\n            );\n          }\n          return element;\n        }\n        element = merged;\n      }\n    }\n    elementsByName.set(name, element);\n    return element;\n  }\n\n  /** Tries to locate a foreign file given its normalized path. */\n  private lookupForeignFile(\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string\n  ): File | null {\n    let filesByName = this.filesByName;\n    return filesByName.has(foreignPath)\n      ? assert(filesByName.get(foreignPath))\n      : filesByName.has(foreignPathAlt)\n        ? assert(filesByName.get(foreignPathAlt))\n        : null;\n  }\n\n  /** Tries to locate a foreign element by traversing exports and queued exports. */\n  private lookupForeign(\n    /** Identifier within the other file. */\n    foreignName: string,\n    /** The other file. */\n    foreignFile: File,\n    /** So far queued exports. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): DeclaredElement | null {\n    do {\n      // check if already resolved\n      let element = foreignFile.lookupExport(foreignName);\n      if (element) return element;\n\n      // follow queued exports\n      if (queuedExports.has(foreignFile)) {\n        let fileQueuedExports = assert(queuedExports.get(foreignFile));\n        if (fileQueuedExports.has(foreignName)) {\n          let queuedExport = assert(fileQueuedExports.get(foreignName));\n          let queuedExportForeignPath = queuedExport.foreignPath;\n\n          // re-exported from another file\n          if (queuedExportForeignPath) {\n            let otherFile = this.lookupForeignFile(queuedExportForeignPath, assert(queuedExport.foreignPathAlt));\n            if (!otherFile) return null;\n            foreignName = queuedExport.localIdentifier.text;\n            foreignFile = otherFile;\n            continue;\n          }\n\n          // exported from this file\n          element = foreignFile.getMember(queuedExport.localIdentifier.text);\n          if (element) return element;\n        }\n      }\n      break;\n    } while (true);\n\n    // follow star exports\n    let exportsStar = foreignFile.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = this.lookupForeign(foreignName, exportsStar[i], queuedExports);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Validates that only supported decorators are present. */\n  private checkDecorators(\n    /** Decorators present on an element. */\n    decorators: DecoratorNode[] | null,\n    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */\n    acceptedFlags: DecoratorFlags\n  ): DecoratorFlags {\n    let flags = DecoratorFlags.None;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator = decorators[i];\n        let kind = DecoratorKind.fromNode(decorator.name);\n        let flag = DecoratorFlags.fromKind(kind);\n        if (flag) {\n          if (flag == DecoratorFlags.Builtin) {\n            if (!(acceptedFlags & flag) && !decorator.range.source.isLibrary) {\n              this.error(\n                DiagnosticCode.Decorator_0_is_not_valid_here,\n                decorator.range, decorator.name.range.toString()\n              );\n            } else {\n              flags |= flag;\n            }\n          } else if (!(acceptedFlags & flag)) {\n            this.error(\n              DiagnosticCode.Decorator_0_is_not_valid_here,\n              decorator.range, decorator.name.range.toString()\n            );\n          } else if (flags & flag) {\n            this.error(\n              DiagnosticCode.Duplicate_decorator,\n              decorator.range\n            );\n          } else {\n            flags |= flag;\n          }\n        }\n      }\n    }\n    return flags;\n  }\n\n  /** Checks whether a particular feature is enabled. */\n  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {\n    if (!this.options.hasFeature(feature)) {\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        reportNode.range, featureToString(feature)\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /** Checks whether a particular type is supported. */\n  checkTypeSupported(type: Type, reportNode: Node): bool {\n    switch (type.kind) {\n      case TypeKind.V128: return this.checkFeatureEnabled(Feature.Simd, reportNode);\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode);\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.I31ref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref: {\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode)\n            && this.checkFeatureEnabled(Feature.GC, reportNode);\n      }\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode)\n            && this.checkFeatureEnabled(Feature.Stringref, reportNode);\n      }\n    }\n    let classReference = type.getClass();\n    if (classReference) {\n      do {\n        let typeArguments = classReference.typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {\n              return false;\n            }\n          }\n        }\n        classReference = classReference.base;\n      } while (classReference);\n    } else {\n      let signatureReference = type.getSignature();\n      if (signatureReference) {\n        let thisType = signatureReference.thisType;\n        if (thisType) {\n          if (!this.checkTypeSupported(thisType, reportNode)) {\n            return false;\n          }\n        }\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {\n            return false;\n          }\n        }\n        let returnType = signatureReference.returnType;\n        if (!this.checkTypeSupported(returnType, reportNode)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Initializes a class declaration. */\n  private initializeClass(\n    /** The declaration to initialize. */\n    declaration: ClassDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): ClassPrototype | null {\n    let name = declaration.name.text;\n    let element = new ClassPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global |\n        DecoratorFlags.Final |\n        DecoratorFlags.Unmanaged\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember classes that implement interfaces\n    let implementsTypes = declaration.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        // cannot implement interfaces when unmanaged\n        if (element.hasDecorator(DecoratorFlags.Unmanaged)) {\n          this.error(\n            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,\n            Range.join(\n              declaration.name.range,\n              implementsTypes[numImplementsTypes - 1].range\n            )\n          );\n        } else {\n          queuedImplements.push(element);\n        }\n      }\n    }\n\n    // remember classes that extend another class\n    if (declaration.extendsType) {\n      queuedExtends.push(element);\n    } else if (\n      !element.hasDecorator(DecoratorFlags.Unmanaged) &&\n      element.internalName != BuiltinNames.Object\n    ) {\n      element.implicitlyExtendsObject = true;\n    }\n\n    // initialize members\n    let memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FieldDeclaration: {\n          this.initializeField(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.MethodDeclaration: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            let method = this.initializeMethod(methodDeclaration, element);\n            if (method && methodDeclaration.name.kind == NodeKind.Constructor) {\n              element.constructorPrototype = method;\n            }\n          }\n          break;\n        }\n        case NodeKind.IndexSignature: break; // ignored for now\n        default: assert(false); // class member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of a class or interface. */\n  private initializeField(\n    /** The declaration to initialize. */\n    declaration: FieldDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    let name = declaration.name.text;\n    let decorators = declaration.decorators;\n    let element: DeclaredElement;\n    let acceptedFlags: DecoratorFlags = DecoratorFlags.Unsafe;\n    if (parent.is(CommonFlags.Ambient)) {\n      acceptedFlags |= DecoratorFlags.External;\n    }\n    if (declaration.is(CommonFlags.Static)) { // global variable\n      assert(parent.kind != ElementKind.InterfacePrototype);\n      acceptedFlags |= DecoratorFlags.Lazy;\n      if (declaration.is(CommonFlags.Readonly)) {\n        acceptedFlags |= DecoratorFlags.Inline;\n      }\n      element = new Global(\n        name,\n        parent,\n        this.checkDecorators(decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) return;\n    } else { // actual instance field\n      assert(!declaration.isAny(CommonFlags.Abstract | CommonFlags.Get | CommonFlags.Set));\n      element = PropertyPrototype.forField(\n        name,\n        parent,\n        declaration,\n        this.checkDecorators(decorators, acceptedFlags)\n      );\n      if (!parent.addInstance(name, element)) return;\n    }\n  }\n\n  /** Initializes a method of a class or interface. */\n  private initializeMethod(\n    /** The declaration to initialize. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): FunctionPrototype | null {\n    let name = declaration.name.text;\n    let isStatic = declaration.is(CommonFlags.Static);\n    let acceptedFlags = DecoratorFlags.Inline | DecoratorFlags.Unsafe;\n    if (!declaration.is(CommonFlags.Generic)) {\n      acceptedFlags |= DecoratorFlags.OperatorBinary\n                    |  DecoratorFlags.OperatorPrefix\n                    |  DecoratorFlags.OperatorPostfix;\n    }\n    if (parent.is(CommonFlags.Ambient)) {\n      acceptedFlags |= DecoratorFlags.External;\n    }\n    let element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, acceptedFlags)\n    );\n    if (isStatic) { // global function\n      assert(declaration.name.kind != NodeKind.Constructor);\n      if (!parent.add(name, element)) return null;\n    } else { // actual instance method\n      if (!parent.addInstance(name, element)) return null;\n    }\n    this.checkOperatorOverloads(declaration.decorators, element, parent);\n    return element;\n  }\n\n  /** Checks that operator overloads are generally valid, if present. */\n  private checkOperatorOverloads(\n    /** Decorators to check. */\n    decorators: DecoratorNode[] | null,\n    /** Decorated method. */\n    prototype: FunctionPrototype,\n    /** Parent class. */\n    classPrototype: ClassPrototype\n  ): void {\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?\n        switch (decorator.decoratorKind) {\n          case DecoratorKind.Operator:\n          case DecoratorKind.OperatorBinary:\n          case DecoratorKind.OperatorPrefix:\n          case DecoratorKind.OperatorPostfix: {\n            let args = decorator.args;\n            let numArgs = args ? args.length : 0;\n            if (numArgs == 1) {\n              let firstArg = (<Expression[]>decorator.args)[0];\n              if (firstArg.isLiteralKind(LiteralKind.String)) {\n                let text = (<StringLiteralExpression>firstArg).value;\n                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);\n                if (kind == OperatorKind.Invalid) {\n                  this.error(\n                    DiagnosticCode._0_is_not_a_valid_operator,\n                    firstArg.range, text\n                  );\n                } else {\n                  let overloads = classPrototype.operatorOverloadPrototypes;\n                  if (overloads.has(kind)) {\n                    this.error(\n                      DiagnosticCode.Duplicate_function_implementation,\n                      firstArg.range\n                    );\n                  } else {\n                    prototype.operatorKind = kind;\n                    overloads.set(kind, prototype);\n                  }\n                }\n              } else {\n                this.error(\n                  DiagnosticCode.String_literal_expected,\n                  firstArg.range\n                );\n              }\n            } else {\n              this.error(\n                DiagnosticCode.Expected_0_arguments_but_got_1,\n                decorator.range, \"1\", numArgs.toString()\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** Ensures that the property introduced by the specified getter or setter exists.*/\n  private ensureProperty(\n    /** The declaration of the getter or setter introducing the property. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): PropertyPrototype | null {\n    let name = declaration.name.text;\n    if (declaration.is(CommonFlags.Static)) {\n      let parentMembers = parent.members;\n      if (parentMembers && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PropertyPrototype) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.add(name, element)) return null;\n        return element;\n      }\n    } else {\n      let parentMembers = parent.instanceMembers;\n      if (parentMembers && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PropertyPrototype) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.addInstance(name, element)) return null;\n        return element;\n      }\n    }\n    this.error(\n      DiagnosticCode.Duplicate_property_0,\n      declaration.name.range, name\n    );\n    return null;\n  }\n\n  /** Initializes a property of a class. */\n  private initializeProperty(\n    /** The declaration of the getter or setter. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    let property = this.ensureProperty(declaration, parent);\n    if (!property) return;\n    let name = declaration.name.text;\n    let isGetter = declaration.is(CommonFlags.Get);\n    if (isGetter) {\n      if (property.getterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    } else {\n      if (property.setterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    }\n    let element = new FunctionPrototype(\n      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,\n      property.parent, // same level as property\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Inline | DecoratorFlags.Unsafe\n      )\n    );\n    if (isGetter) {\n      property.getterPrototype = element;\n    } else {\n      property.setterPrototype = element;\n    }\n  }\n\n  /** Initializes an enum. */\n  private initializeEnum(\n    /** The declaration to initialize. */\n    declaration: EnumDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): Enum | null {\n    let name = declaration.name.text;\n    let element = new Enum(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global |\n        DecoratorFlags.Inline |\n        DecoratorFlags.Lazy\n      )\n    );\n    if (!parent.add(name, element)) return null;\n    let values = declaration.values;\n    for (let i = 0, k = values.length; i < k; ++i) {\n      this.initializeEnumValue(values[i], element);\n    }\n    return element;\n  }\n\n  /** Initializes an enum value. */\n  private initializeEnumValue(\n    /** The declaration to initialize. */\n    declaration: EnumValueDeclaration,\n    /** Parent enum. */\n    parent: Enum\n  ): void {\n    let name = declaration.name.text;\n    let element = new EnumValue(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.None\n      )\n    );\n    if (!parent.add(name, element)) return;\n  }\n\n  /** Initializes an `export` statement. */\n  private initializeExports(\n    /** The statement to initialize. */\n    statement: ExportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>,\n    /** So far queued `export *`s. */\n    queuedExportsStar: Map<File,QueuedExportStar[]>\n  ): void {\n    let members = statement.members;\n    if (members) { // export { foo, bar } [from \"./baz\"]\n      for (let i = 0, k = members.length; i < k; ++i) {\n        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);\n      }\n    } else { // export * from \"./baz\"\n      let queued: QueuedExportStar[];\n      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));\n      else queuedExportsStar.set(parent, queued = []);\n      let foreignPath = statement.internalPath!; // must be set for export *\n      queued.push(new QueuedExportStar(\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX,\n        assert(statement.path)\n      ));\n    }\n  }\n\n  /** Initializes a single `export` member. Does not handle `export *`. */\n  private initializeExport(\n    /** The member to initialize. */\n    member: ExportMember,\n    /** Local file. */\n    localFile: File,\n    /** Path to the other file, if present. */\n    foreignPath: string | null,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let localName = member.localName.text;\n    let foreignName = member.exportedName.text;\n\n    // check for duplicates\n    let element = localFile.lookupExport(foreignName);\n    if (element) {\n      this.error(\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\n        member.exportedName.range, foreignName\n      );\n      return;\n    }\n    // local element, i.e. export { foo [as bar] }\n    if (foreignPath == null) {\n\n      // resolve right away if the local element already exists\n      if (element = localFile.getMember(localName)) {\n        localFile.ensureExport(foreignName, element);\n\n      // otherwise queue it\n      } else {\n        let queued: Map<string,QueuedExport>;\n        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n        else queuedExports.set(localFile, queued = new Map());\n        queued.set(foreignName, new QueuedExport(\n          member.localName,\n          member.exportedName,\n          null, null\n        ));\n      }\n\n    // foreign element, i.e. export { foo } from \"./bar\"\n    } else {\n      let queued: Map<string,QueuedExport>;\n      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n      else queuedExports.set(localFile, queued = new Map());\n      queued.set(foreignName, new QueuedExport(\n        member.localName,\n        member.exportedName,\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX\n      ));\n    }\n  }\n\n  private initializeExportDefault(\n    /** The statement to initialize. */\n    statement: ExportDefaultStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `extends` clauses. */\n    queuedExtends: Array<ClassPrototype>,\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): void {\n    let declaration = statement.declaration;\n    let element: DeclaredElement | null = null;\n    switch (declaration.kind) {\n      case NodeKind.EnumDeclaration: {\n        element = this.initializeEnum(<EnumDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.ClassDeclaration: {\n        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      default: assert(false);\n    }\n    if (element) {\n      let exports = parent.exports;\n      if (!exports) parent.exports = exports = new Map();\n      else {\n        if (exports.has(\"default\")) {\n          let existing = assert(exports.get(\"default\"));\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existing.declaration.name.range,\n            \"default\"\n          );\n          return;\n        }\n      }\n      exports.set(\"default\", element);\n    }\n  }\n\n  /** Initializes an `import` statement. */\n  private initializeImports(\n    /** The statement to initialize. */\n    statement: ImportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let declarations = statement.declarations;\n    if (declarations) { // import { foo [as bar] } from \"./baz\"\n      for (let i = 0, k = declarations.length; i < k; ++i) {\n        this.initializeImport(\n          declarations[i],\n          parent,\n          statement.internalPath,\n          queuedImports,\n          queuedExports\n        );\n      }\n    } else {\n      let namespaceName = statement.namespaceName;\n      if (namespaceName) { // import * as foo from \"./bar\"\n        queuedImports.push(new QueuedImport(\n          parent,\n          namespaceName,\n          null, // indicates import *\n          statement.internalPath,\n          statement.internalPath + INDEX_SUFFIX\n        ));\n      } else {\n        // import \"./foo\"\n      }\n    }\n  }\n\n  /** Initializes a single `import` declaration. Does not handle `import *`. */\n  private initializeImport( // { foo [as bar] }\n    /** The declaration to initialize. */\n    declaration: ImportDeclaration,\n    /** Parent file. */\n    parent: File,\n    /** Path to the other file. */\n    foreignPath: string,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n      : foreignPath + INDEX_SUFFIX;\n\n    // resolve right away if the element exists\n    let foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);\n    if (foreignFile) {\n      let element = this.lookupForeign(declaration.foreignName.text, foreignFile, queuedExports);\n      if (element) {\n        parent.add(declaration.name.text, element, declaration.name /* isImport */);\n        return;\n      }\n    }\n\n    // otherwise queue it\n    queuedImports.push(new QueuedImport(\n      parent,\n      declaration.name,\n      declaration.foreignName,\n      foreignPath,\n      foreignPathAlt\n    ));\n  }\n\n  /** Initializes a function. Does not handle methods. */\n  private initializeFunction(\n    /** The declaration to initialize. */\n    declaration: FunctionDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): FunctionPrototype | null {\n    let name = declaration.name.text;\n    let validDecorators = DecoratorFlags.Unsafe | DecoratorFlags.Builtin;\n    if (declaration.is(CommonFlags.Ambient)) {\n      validDecorators |= DecoratorFlags.External | DecoratorFlags.ExternalJs;\n    } else {\n      validDecorators |= DecoratorFlags.Inline;\n      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.Export)) {\n        validDecorators |= DecoratorFlags.Lazy;\n      }\n    }\n    if (!declaration.is(CommonFlags.Instance)) {\n      if (parent.kind != ElementKind.ClassPrototype) {\n        validDecorators |= DecoratorFlags.Global;\n      }\n    }\n    let element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, validDecorators)\n    );\n    if (!parent.add(name, element)) return null;\n    return element;\n  }\n\n  /** Initializes an interface. */\n  private initializeInterface(\n    /** The declaration to initialize. */\n    declaration: InterfaceDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n  ): InterfacePrototype | null {\n    let name = declaration.name.text;\n    let element = new InterfacePrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember interfaces that extend another interface\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    let memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FieldDeclaration: {\n          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.MethodDeclaration: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            this.initializeMethod(methodDeclaration, element);\n          }\n          break;\n        }\n        default: assert(false); // interface member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of an interface, as a property. */\n  private initializeFieldAsProperty(\n    /** Field declaration. */\n    declaration: FieldDeclaration,\n    /** Parent interface. */\n    parent: InterfacePrototype\n  ): void {\n    let typeNode = declaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);\n    this.initializeProperty(\n      Node.createMethodDeclaration(\n        declaration.name,\n        declaration.decorators,\n        declaration.flags | CommonFlags.Get,\n        null,\n        Node.createFunctionType(\n          [],\n          typeNode,\n          null,\n          false,\n          declaration.range\n        ),\n        null,\n        declaration.range\n      ),\n      parent\n    );\n    if (!declaration.is(CommonFlags.Readonly)) {\n      this.initializeProperty(\n        Node.createMethodDeclaration(\n          declaration.name,\n          declaration.decorators,\n          declaration.flags | CommonFlags.Set,\n          null,\n          Node.createFunctionType(\n            [\n              Node.createParameter(\n                ParameterKind.Default,\n                declaration.name,\n                typeNode,\n                null,\n                declaration.name.range\n              )\n            ],\n            Node.createOmittedType(declaration.name.range.atEnd),\n            null,\n            false,\n            declaration.range\n          ),\n          null,\n          declaration.range\n        ),\n        parent\n      );\n    }\n  }\n\n  /** Initializes a namespace. */\n  private initializeNamespace(\n    /** The declaration to initialize. */\n    declaration: NamespaceDeclaration,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): DeclaredElement | null {\n    let name = declaration.name.text;\n    let original = new Namespace(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.Global)\n    );\n    if (!parent.add(name, original)) return null;\n    let element = assert(parent.getMember(name)); // possibly merged\n    let members = declaration.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      let member = members[i];\n      switch (member.kind) {\n        case NodeKind.ClassDeclaration: {\n          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.EnumDeclaration: {\n          this.initializeEnum(<EnumDeclaration>member, original);\n          break;\n        }\n        case NodeKind.FunctionDeclaration: {\n          this.initializeFunction(<FunctionDeclaration>member, original);\n          break;\n        }\n        case NodeKind.InterfaceDeclaration: {\n          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);\n          break;\n        }\n        case NodeKind.NamespaceDeclaration: {\n          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.TypeDeclaration: {\n          this.initializeTypeDefinition(<TypeDeclaration>member, original);\n          break;\n        }\n        case NodeKind.Variable: {\n          this.initializeVariables(<VariableStatement>member, original);\n          break;\n        }\n        default: assert(false); // namespace member expected\n      }\n    }\n    if (original != element) copyMembers(original, element); // keep original parent\n    return element;\n  }\n\n  /** Initializes a `type` definition. */\n  private initializeTypeDefinition(\n    /** The declaration to initialize. */\n    declaration: TypeDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    let name = declaration.name.text;\n    let element = new TypeDefinition(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.None)\n    );\n    parent.add(name, element); // reports\n  }\n\n  /** Initializes a variable statement. */\n  private initializeVariables(\n    /** The statement to initialize. */\n    statement: VariableStatement,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    let declarations = statement.declarations;\n    for (let i = 0, k = declarations.length; i < k; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let acceptedFlags = DecoratorFlags.Global | DecoratorFlags.Lazy;\n      if (declaration.is(CommonFlags.Ambient)) {\n        acceptedFlags |= DecoratorFlags.External;\n      }\n      if (declaration.is(CommonFlags.Const)) {\n        acceptedFlags |= DecoratorFlags.Inline;\n      }\n      let element = new Global(\n        name,\n        parent,\n        this.checkDecorators(declaration.decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) continue; // reports\n    }\n  }\n\n  /** Determines the element type of a built-in array. */\n  // determineBuiltinArrayType(target: Class): Type | null {\n  //   switch (target.internalName) {\n  //     case BuiltinSymbols.Int8Array: return Type.i8;\n  //     case BuiltinSymbols.Uint8ClampedArray:\n  //     case BuiltinSymbols.Uint8Array: return Type.u8;\n  //     case BuiltinSymbols.Int16Array: return Type.i16;\n  //     case BuiltinSymbols.Uint16Array: return Type.u16;\n  //     case BuiltinSymbols.Int32Array: return Type.i32;\n  //     case BuiltinSymbols.Uint32Array: return Type.u32;\n  //     case BuiltinSymbols.Int64Array: return Type.i64;\n  //     case BuiltinSymbols.Uint64Array: return Type.u64;\n  //     case BuiltinSymbols.Float32Array: return Type.f32;\n  //     case BuiltinSymbols.Float64Array: return Type.f64;\n  //   }\n  //   let current: Class | null = target;\n  //   let arrayPrototype = this.arrayPrototype;\n  //   do {\n  //     if (current.prototype == arrayPrototype) { // Array<T>\n  //       let typeArguments = assert(current.typeArguments);\n  //       assert(typeArguments.length == 1);\n  //       return typeArguments[0];\n  //     }\n  //   } while (current = current.base);\n  //   return null;\n  // }\n}\n\n/** Indicates the specific kind of an {@link Element}. */\nexport const enum ElementKind {\n  /** A {@link Global}. */\n  Global,\n  /** A {@link Local}. */\n  Local,\n  /** An {@link Enum}. */\n  Enum,\n  /** An {@link EnumValue}. */\n  EnumValue,\n  /** A {@link FunctionPrototype}. */\n  FunctionPrototype,\n  /** A {@link Function}. */\n  Function,\n  /** A {@link ClassPrototype}. */\n  ClassPrototype,\n  /** A {@link Class}. */\n  Class,\n  /** An {@link InterfacePrototype}. */\n  InterfacePrototype,\n  /** An {@link Interface}. */\n  Interface,\n  /** A {@link PropertyPrototype}.  */\n  PropertyPrototype,\n  /** A {@link Property}. */\n  Property,\n  /** A {@link Namespace}. */\n  Namespace,\n  /** A {@link File}. */\n  File,\n  /** A {@link TypeDefinition}.  */\n  TypeDefinition,\n  /** An {@link IndexSignature}. */\n  IndexSignature\n}\n\n/** Indicates built-in decorators that are present. */\nexport enum DecoratorFlags {\n  /** No flags set. */\n  None = 0,\n  /** Is a program global. */\n  Global = 1 << 0,\n  /** Is a binary operator overload. */\n  OperatorBinary = 1 << 1,\n  /** Is a unary prefix operator overload. */\n  OperatorPrefix = 1 << 2,\n  /** Is a unary postfix operator overload. */\n  OperatorPostfix = 1 << 3,\n  /** Is an unmanaged class. */\n  Unmanaged = 1 << 4,\n  /** Is a final class. */\n  Final = 1 << 5,\n  /** Is always inlined. */\n  Inline = 1 << 6,\n  /** Is using a different external name. */\n  External = 1 << 7,\n  /** Has external JavaScript code. */\n  ExternalJs = 1 << 8,\n  /** Is a builtin. */\n  Builtin = 1 << 9,\n  /** Is compiled lazily. */\n  Lazy = 1 << 10,\n  /** Is considered unsafe code. */\n  Unsafe = 1 << 11\n}\n\nexport namespace DecoratorFlags {\n\n  /** Translates a decorator kind to the respective decorator flag. */\n  export function fromKind(kind: DecoratorKind): DecoratorFlags {\n    switch (kind) {\n      case DecoratorKind.Global: return DecoratorFlags.Global;\n      case DecoratorKind.Operator:\n      case DecoratorKind.OperatorBinary: return DecoratorFlags.OperatorBinary;\n      case DecoratorKind.OperatorPrefix: return DecoratorFlags.OperatorPrefix;\n      case DecoratorKind.OperatorPostfix: return DecoratorFlags.OperatorPostfix;\n      case DecoratorKind.Unmanaged: return DecoratorFlags.Unmanaged;\n      case DecoratorKind.Final: return DecoratorFlags.Final;\n      case DecoratorKind.Inline: return DecoratorFlags.Inline;\n      case DecoratorKind.External: return DecoratorFlags.External;\n      case DecoratorKind.ExternalJs: return DecoratorFlags.ExternalJs;\n      case DecoratorKind.Builtin: return DecoratorFlags.Builtin;\n      case DecoratorKind.Lazy: return DecoratorFlags.Lazy;\n      case DecoratorKind.Unsafe: return DecoratorFlags.Unsafe;\n      default: return DecoratorFlags.None;\n    }\n  }\n}\n\n/** Base class of all program elements. */\nexport abstract class Element {\n\n  /** Parent element. */\n  parent!: Element;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.None;\n  /** Decorator flags indicating annotated traits. */\n  decoratorFlags: DecoratorFlags = DecoratorFlags.None;\n  /** Member elements. */\n  members: Map<string,DeclaredElement> | null = null;\n  /** Shadowing type in type space, if any. */\n  shadowType: TypeDefinition | null = null;\n\n  /** Constructs a new program element. */\n  protected constructor(\n    /** Specific element kind. */\n    public kind: ElementKind,\n    /** Simple name. */\n    public name: string,\n    /** Internal name referring to this element. */\n    public internalName: string,\n    /** Containing {@link Program}. */\n    public program: Program,\n    /** Parent element. */\n    parent: Element | null\n  ) {\n    this.program = program;\n    this.name = name;\n    this.internalName = internalName;\n    if (parent) {\n      this.parent = parent;\n    } else {\n      assert(this.kind == ElementKind.File);\n      this.parent = this; // special case to keep this.parent non-nullable\n    }\n  }\n\n  /** Gets the enclosing file. */\n  get file(): File {\n    let current: Element = this;\n    do {\n      current = current.parent;\n      if (current.kind == ElementKind.File) return <File>current;\n    } while (true);\n  }\n\n  /** Tests if this element has a specific flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this element has any of the specified flags. */\n  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n  /** Unsets the specific flag or flags. */\n  unset(flag: CommonFlags): void {this.flags &= ~flag; }\n  /** Tests if this element has a specific decorator flag or flags. */\n  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }\n  /** Tests if this element has any of the specified decorator flags. */\n  hasAnyDecorator(flags: DecoratorFlags): bool { return (this.decoratorFlags & flags) != 0; }\n\n  /** Get the member with the specified name, if any. */\n  getMember(name: string): DeclaredElement | null {\n    let members = this.members;\n    if (members && members.has(name)) return assert(members.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to this element. */\n  lookup(name: string, isType: bool = false): Element | null {\n    return this.parent.lookup(name, isType);\n  }\n\n  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    let originalDeclaration = element.declaration;\n    let members = this.members;\n    if (!members) this.members = members = new Map();\n    else if (members.has(name)) {\n      let existing = assert(members.get(name));\n      if (existing.parent != this) {\n        // override non-own element\n      } else {\n        let merged = tryMerge(existing, element);\n        if (merged) {\n          element = merged; // use merged element\n        } else {\n          let reportedIdentifier = localIdentifierIfImport\n            ? localIdentifierIfImport\n            : element.identifierNode;\n          if (isDeclaredElement(existing.kind)) {\n            this.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range,\n              (<DeclaredElement>existing).identifierNode.range,\n              reportedIdentifier.text\n            );\n          } else {\n            this.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range, reportedIdentifier.text\n            );\n          }\n          return false;\n        }\n      }\n    }\n    members.set(name, element);\n    let program = this.program;\n    if (element.kind != ElementKind.FunctionPrototype || !(<FunctionPrototype>element).isBound) {\n      // prefer unbound prototypes in global lookup maps\n      program.elementsByName.set(element.internalName, element);\n      program.elementsByDeclaration.set(originalDeclaration, element);\n    }\n    return true;\n  }\n\n  /** Checks if this element is public, explicitly or implicitly. */\n  get isPublic(): bool {\n    return !this.isAny(CommonFlags.Private | CommonFlags.Protected);\n  }\n\n  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */\n  get isImplicitlyPublic(): bool {\n    return this.isPublic && !this.is(CommonFlags.Public);\n  }\n\n  /** Checks if the visibility of this element equals the specified. */\n  visibilityEquals(other: Element): bool {\n    if (this.isPublic == other.isPublic) return true;\n    const vis = CommonFlags.Private | CommonFlags.Protected;\n    return (this.flags & vis) == (other.flags & vis);\n  }\n\n  /** Tests if this element is bound to a class. */\n  get isBound(): bool {\n    let parent = this.parent;\n    switch (parent.kind) {\n      case ElementKind.Class:\n      case ElementKind.Interface: return true;\n    }\n    return false;\n  }\n\n  /** Gets the class or interface this element is bound to, if any. */\n  getBoundClassOrInterface(): Class | null {\n    let parent = this.parent;\n    switch (parent.kind) {\n      case ElementKind.Class:\n      case ElementKind.Interface: return <Class>parent;\n    }\n    return null;\n  }\n\n  /** Returns a string representation of this element. */\n  toString(): string {\n    return `${this.internalName}, kind=${this.kind}`;\n  }\n}\n\n// Kinds of all declared elements\nlet declaredElements = new Set<ElementKind>();\n\n/** Tests if the specified element kind indicates a declared element. */\nexport function isDeclaredElement(kind: ElementKind): bool {\n  return declaredElements.has(kind);\n}\n\n/** Base class of elements with an associated declaration statement. */\nexport abstract class DeclaredElement extends Element {\n\n  /** Constructs a new declared program element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    public declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent);\n    declaredElements.add(kind);\n    // It is necessary to have access to identifiers of all members and exports\n    // for reporting purposes and this is the lowest common denominator. Comes\n    // at the expense of not having more specific type information in derived\n    // classes, though. Instead, derived classes implement getters for other\n    // important AST nodes directly through manual casting, allowing the resolver\n    // etc. to not worry about actual declarations.\n    this.declaration = declaration;\n    this.flags = declaration.flags; // inherit\n  }\n\n  /** Tests if this element is a library element. */\n  get isDeclaredInLibrary(): bool {\n    return this.declaration.range.source.isLibrary;\n  }\n\n  /** Gets the associated identifier node. */\n  get identifierNode(): IdentifierExpression {\n    return this.declaration.name;\n  }\n\n  /** Gets the signature node, if applicable, along the identifier node. */\n  get identifierAndSignatureRange(): Range {\n    let declaration = this.declaration;\n    let identifierNode = declaration.name;\n    if (declaration.kind == NodeKind.FunctionDeclaration || declaration.kind == NodeKind.MethodDeclaration) {\n      let signatureNode = (<FunctionDeclaration>declaration).signature;\n      if (identifierNode.range.source == signatureNode.range.source) {\n        return Range.join(identifierNode.range, signatureNode.range);\n      }\n    }\n    return identifierNode.range;\n  }\n\n  /** Gets the assiciated decorator nodes. */\n  get decoratorNodes(): DecoratorNode[] | null {\n    return this.declaration.decorators;\n  }\n}\n\n// Kinds of all typed elements\nlet typedElements = new Set<ElementKind>();\n\n/** Checks if the specified element kind indicates a typed element. */\nexport function isTypedElement(kind: ElementKind): bool {\n  return typedElements.has(kind);\n}\n\n/** Base class of elements that can be resolved to a concrete type. */\nexport abstract class TypedElement extends DeclaredElement {\n\n  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */\n  type: Type = Type.void;\n\n  constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent, declaration);\n    typedElements.add(kind);\n  }\n\n  /** Sets the resolved type of this element. */\n  setType(type: Type): void {\n    assert(!this.is(CommonFlags.Resolved));\n    this.type = type;\n    this.set(CommonFlags.Resolved);\n  }\n}\n\n/** A file representing the implicit top-level namespace of a source. */\nexport class File extends Element {\n\n  /** File exports. */\n  exports: Map<string,DeclaredElement> | null = null;\n  /** File re-exports. */\n  exportsStar: File[] | null = null;\n  /** Top-level start function of this file. */\n  startFunction!: Function;\n  /** Array of `import * as X` alias namespaces of this file. */\n  aliasNamespaces: Array<Namespace> = new Array<Namespace>();\n\n  /** Constructs a new file. */\n  constructor(\n    /** Program this file belongs to. */\n    program: Program,\n    /** Source of this file. */\n    public source: Source\n  ) {\n    super(\n      ElementKind.File,\n      source.normalizedPath,\n      source.internalPath,\n      program,\n      null // special case for files\n    );\n    this.source = source;\n    assert(!program.filesByName.has(this.internalName));\n    program.filesByName.set(this.internalName, this);\n    let startFunction = this.program.makeNativeFunction(\n      `start:${this.internalName}`,\n      Signature.create(program, [], Type.void),\n      this\n    );\n    startFunction.internalName = startFunction.name;\n    this.startFunction = startFunction;\n  }\n\n  /* @override */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    if (element.hasDecorator(DecoratorFlags.Global)) {\n      element = this.program.ensureGlobal(name, element); // possibly merged globally\n    }\n    if (!super.add(name, element, localIdentifierIfImport)) return false;\n    element = assert(this.getMember(name)); // possibly merged locally\n    if (element.is(CommonFlags.Export) && !localIdentifierIfImport) {\n      this.ensureExport(\n        element.name,\n        element\n      );\n    }\n    return true;\n  }\n\n  /* @override */\n  getMember(name: string): DeclaredElement | null {\n    let element = super.getMember(name);\n    if (element) return element;\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        if (element = exportsStar[i].getMember(name)) return element;\n      }\n    }\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let element = this.getMember(name);\n    if (element) return element;\n    return this.program.lookup(name); // has no meaningful parent\n  }\n\n  /** Ensures that an element is an export of this file. */\n  ensureExport(name: string, element: DeclaredElement): void {\n    let exports = this.exports;\n    if (!exports) this.exports = exports = new Map();\n    exports.set(name, element);\n    if (this.source.sourceKind == SourceKind.LibraryEntry) this.program.ensureGlobal(name, element);\n\n    // Also, add to the namespaces that capture our exports\n    for(let i = 0; i < this.aliasNamespaces.length; i++) {\n      let ns = this.aliasNamespaces[i];\n      ns.add(name, element);\n    }\n  }\n\n  /** Ensures that another file is a re-export of this file. */\n  ensureExportStar(file: File): void {\n    let exportsStar = this.exportsStar;\n    if (!exportsStar) this.exportsStar = exportsStar = [];\n    else if (exportsStar.includes(file)) return;\n    exportsStar.push(file);\n  }\n\n  /** Looks up the export of the specified name. */\n  lookupExport(name: string): DeclaredElement | null {\n    let exports = this.exports;\n    if (exports && exports.has(name)) return assert(exports.get(name));\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = exportsStar[i].lookupExport(name);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Creates an imported namespace from this file. */\n  asAliasNamespace(\n    name: string,\n    parent: Element,\n    localIdentifier: IdentifierExpression\n  ): Namespace {\n    let declaration = this.program.makeNativeNamespaceDeclaration(name);\n    declaration.name = localIdentifier;\n    let ns = new Namespace(name, parent, declaration);\n    ns.set(CommonFlags.Scoped);\n    this.copyExportsToNamespace(ns);\n    // NOTE: Some exports are still queued, and can't yet be added here,\n    // so we remember all the alias namespaces and add to them as well\n    // when adding an element to the file.\n    this.aliasNamespaces.push(ns);\n    return ns;\n  }\n\n  /** Recursively copies the exports of this file to the specified namespace. */\n  private copyExportsToNamespace(ns: Namespace): void {\n    let exports = this.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        ns.add(memberName, member);\n      }\n    }\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        exportsStar[i].copyExportsToNamespace(ns);\n      }\n    }\n  }\n}\n\n/** A type definition. */\nexport class TypeDefinition extends TypedElement {\n\n  /** Constructs a new type definition. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: TypeDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.TypeDefinition,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<TypeDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode {\n    return (<TypeDeclaration>this.declaration).type;\n  }\n}\n\n/** A namespace that differs from a file in being user-declared with a name. */\nexport class Namespace extends DeclaredElement {\n\n  /** Constructs a new namespace. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: NamespaceDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.Namespace,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** An enum. */\nexport class Enum extends TypedElement {\n\n  /** Constructs a new enum. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: EnumDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.Enum,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** Indicates the kind of an inlined constant value. */\nexport const enum ConstantValueKind {\n  /** No constant value. */\n  None,\n  /** Constant integer value. */\n  Integer,\n  /** Constant float value. */\n  Float\n}\n\n/** Base class of all variable-like program elements. */\nexport abstract class VariableLikeElement extends TypedElement {\n\n  /** Constant value kind. */\n  constantValueKind: ConstantValueKind = ConstantValueKind.None;\n  /** Constant integer value, if applicable. */\n  constantIntegerValue: i64 = i64_zero;\n  /** Constant float value, if applicable. */\n  constantFloatValue: f64 = 0;\n\n  /** Constructs a new variable-like element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or class. */\n    parent: Element,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      kind,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.flags = declaration.flags;\n  }\n\n  /** Gets the associated type node.s */\n  get typeNode(): TypeNode | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).initializer;\n  }\n\n  /** Applies a constant integer value to this element. */\n  setConstantIntegerValue(value: i64, type: Type): void {\n    assert(type.isIntegerInclReference);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.Integer;\n    this.constantIntegerValue = value;\n    this.set(CommonFlags.Const | CommonFlags.Inlined | CommonFlags.Resolved);\n  }\n\n  /** Applies a constant float value to this element. */\n  setConstantFloatValue(value: f64, type: Type): void {\n    assert(type.isFloatValue);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.Float;\n    this.constantFloatValue = value;\n    this.set(CommonFlags.Const | CommonFlags.Inlined | CommonFlags.Resolved);\n  }\n}\n\n/** An enum value. */\nexport class EnumValue extends VariableLikeElement {\n\n  /** Constructs a new enum value. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent enum. */\n    parent: Enum,\n    /** Declaration reference. */\n    declaration: EnumValueDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.EnumValue,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /** Whether this enum value is immutable. */\n  isImmutable: bool = false;\n\n  /** Gets the associated value node. */\n  get valueNode(): Expression | null {\n    return (<EnumValueDeclaration>this.declaration).initializer;\n  }\n}\n\n/** A global variable. */\nexport class Global extends VariableLikeElement {\n\n  /** Constructs a new global variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or static class. */\n    parent: Element,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.Global,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n}\n\n/** A function parameter. */\nexport class Parameter {\n  /** Constructs a new function parameter. */\n  constructor(\n    /** Parameter name. */\n    public name: string,\n    /** Parameter type. */\n    public type: Type,\n    /** Parameter initializer, if present. */\n    public initializer: Expression | null = null\n  ) {}\n}\n\n/** A local variable. */\nexport class Local extends VariableLikeElement {\n\n  /** Original name of the (temporary) local. */\n  private originalName: string;\n\n  /** Constructs a new local variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Zero-based index within the enclosing function. `-1` indicates a dummy local. */\n    public index: i32,\n    /** Resolved type. */\n    type: Type,\n    /** Parent function. */\n    parent: Function,\n    /** Declaration reference. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.Local,\n      name,\n      parent,\n      declaration\n    );\n    this.originalName = name;\n    this.index = index;\n    assert(type != Type.void);\n    this.setType(type);\n  }\n}\n\n/** A yet unresolved function prototype. */\nexport class FunctionPrototype extends DeclaredElement {\n\n  /** Operator kind, if an overload. */\n  operatorKind: OperatorKind = OperatorKind.Invalid;\n  /** Already resolved instances. */\n  instances: Map<string,Function> | null = null;\n  /** Methods overriding this one, if any. These are unbound. */\n  unboundOverrides: Set<FunctionPrototype> | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;\n\n  /** Constructs a new function prototype. */\n  constructor(\n    /** Simple name */\n    name: string,\n    /** Parent element, usually a file, namespace or class (if a method). */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: FunctionDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.FunctionPrototype,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<FunctionDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated function type node. */\n  get functionTypeNode(): FunctionTypeNode {\n    return (<FunctionDeclaration>this.declaration).signature;\n  }\n\n  /** Gets the associated body node. */\n  get bodyNode(): Statement | null {\n    return (<FunctionDeclaration>this.declaration).body;\n  }\n\n  /** Gets the arrow function kind. */\n  get arrowKind(): ArrowKind {\n    return (<FunctionDeclaration>this.declaration).arrowKind;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): FunctionPrototype {\n    assert(this.is(CommonFlags.Instance));\n    assert(!this.isBound);\n    let boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    let declaration = this.declaration;\n    assert(declaration.kind == NodeKind.MethodDeclaration);\n    let bound = new FunctionPrototype(\n      this.name,\n      classInstance, // now bound\n      <MethodDeclaration>declaration,\n      this.decoratorFlags\n    );\n    bound.flags = this.flags;\n    bound.operatorKind = this.operatorKind;\n    bound.unboundOverrides = this.unboundOverrides;\n    // NOTE: this.instances holds instances per bound class / unbound\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Function | null {\n    let instances = this.instances;\n    if (instances && instances.has(instanceKey)) return assert(instances.get(instanceKey));\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Function): void {\n    let instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved function. */\nexport class Function extends TypedElement {\n\n  /** Function prototype. */\n  prototype: FunctionPrototype;\n  /** Function signature. */\n  signature: Signature;\n  /** Array of locals by index. */\n  localsByIndex: Local[] = [];\n  /** Concrete type arguments. */\n  typeArguments: Type[] | null;\n  /** Contextual type arguments. */\n  contextualTypeArguments: Map<string,Type> | null;\n  /** Default control flow. */\n  flow!: Flow;\n  /** Remembered debug locations. */\n  debugLocations: Range[] = [];\n  /** Function reference, if compiled. */\n  ref: FunctionRef = 0;\n  /** Varargs stub for calling with omitted arguments. */\n  varargsStub: Function | null = null;\n  /** Stub for calling overrides. */\n  overrideStub: Function | null = null;\n  /** Runtime memory segment, if created. */\n  memorySegment: MemorySegment | null = null;\n  /** Original function, if a stub. Otherwise `this`. */\n  original!: Function;\n\n  /** Counting id of inline operations involving this function. */\n  nextInlineId: i32 = 0;\n  /** Counting id of anonymous inner functions. */\n  nextAnonymousId: i32 = 0;\n\n  /** Constructs a new concrete function. */\n  constructor(\n    /** Name incl. type parameters, i.e. `foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** Respective function prototype. */\n    prototype: FunctionPrototype,\n    /** Concrete type arguments. */\n    typeArguments: Type[] | null,\n    /** Concrete signature. */\n    signature: Signature, // pre-resolved\n    /** Contextual type arguments inherited from its parent class, if any. */\n    contextualTypeArguments: Map<string,Type> | null = null\n  ) {\n    super(\n      ElementKind.Function,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.Instance)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.typeArguments = typeArguments;\n    this.signature = signature;\n    this.flags = prototype.flags | CommonFlags.Resolved;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.contextualTypeArguments = contextualTypeArguments;\n    this.original = this;\n    let program = prototype.program;\n    this.type = signature.type;\n    let flow = Flow.createDefault(this);\n    this.flow = flow;\n    if (!prototype.is(CommonFlags.Ambient)) {\n      let localIndex = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        let local = new Local(\n          CommonNames.this_,\n          localIndex++,\n          thisType,\n          this\n        );\n        let scopedLocals = this.flow.scopedLocals;\n        if (!scopedLocals) this.flow.scopedLocals = scopedLocals = new Map();\n        scopedLocals.set(CommonNames.this_, local);\n        this.localsByIndex[local.index] = local;\n        flow.setLocalFlag(local.index, LocalFlags.Initialized);\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let parameterType = parameterTypes[i];\n        let parameterName = this.getParameterName(i);\n        let local = new Local(\n          parameterName,\n          localIndex++,\n          parameterType,\n          this\n        );\n        let scopedLocals = this.flow.scopedLocals;\n        if (!scopedLocals) this.flow.scopedLocals = scopedLocals = new Map();\n        scopedLocals.set(parameterName, local);\n        this.localsByIndex[local.index] = local;\n        flow.setLocalFlag(local.index, LocalFlags.Initialized);\n      }\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Gets the types of additional locals that are not parameters. */\n  getNonParameterLocalTypes(): Type[] {\n    let localsByIndex = this.localsByIndex;\n    let signature = this.signature;\n    let numTotal = localsByIndex.length;\n    let numFixed = signature.parameterTypes.length;\n    if (signature.thisType) ++numFixed;\n    let numAdditional = numTotal - numFixed;\n    let types = new Array<Type>(numAdditional);\n    for (let i = 0; i < numAdditional; ++i) {\n      types[i] = localsByIndex[numFixed + i].type;\n    }\n    return types;\n  }\n\n  /** Gets the name of the parameter at the specified index. */\n  getParameterName(index: i32): string {\n    let parameters = (<FunctionDeclaration>this.declaration).signature.parameters;\n    return parameters.length > index\n      ? parameters[index].name.text\n      : getDefaultParameterName(index);\n  }\n\n  /** Creates a stub for use with this function, i.e. for varargs or override calls. */\n  newStub(postfix: string, requiredParameters: i32 = this.signature.requiredParameters): Function {\n    let stub = new Function(\n      this.original.name + STUB_DELIMITER + postfix,\n      this.prototype,\n      this.typeArguments,\n      this.signature.clone(requiredParameters),\n      this.contextualTypeArguments\n    );\n    stub.original = this.original;\n    stub.set(this.flags & ~CommonFlags.Compiled | CommonFlags.Stub);\n    return stub;\n  }\n\n  /** Adds a local of the specified type, with an optional name. */\n  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {\n    // if it has a name, check previously as this method will throw otherwise\n    let localsByIndex = this.localsByIndex;\n    let localIndex = localsByIndex.length;\n    let localName = name != null ? name : localIndex.toString();\n    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);\n    let local = new Local(localName, localIndex, type, this, declaration);\n    if (name) {\n      let defaultFlow = this.flow;\n      let scopedLocals = defaultFlow.scopedLocals;\n      if (!scopedLocals) defaultFlow.scopedLocals = scopedLocals = new Map();\n      if (scopedLocals.has(name)) throw new Error(\"duplicate local name\");\n      scopedLocals.set(name, local);\n    }\n    localsByIndex[localIndex] = local;\n    return local;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    if (!isType) {\n      let scopedLocals = this.flow.scopedLocals;\n      if (scopedLocals && scopedLocals.has(name)) {\n        return assert(scopedLocals.get(name));\n      }\n    }\n    return super.lookup(name, isType);\n  }\n\n  // used by flows to keep track of break labels\n  nextBreakId: i32 = 0;\n  breakStack: i32[] | null = null;\n\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\n  finalize(module: Module, ref: FunctionRef): void {\n    this.ref = ref;\n    let breakStack = this.breakStack;\n    assert(!breakStack || !breakStack.length); // should be empty\n    this.breakStack = null;\n    this.addDebugInfo(module, ref);\n  }\n\n  addDebugInfo(module: Module, ref: FunctionRef): void {\n    if (this.program.options.sourceMap) {\n      let debugLocations = this.debugLocations;\n      for (let i = 0, k = debugLocations.length; i < k; ++i) {\n        let range = debugLocations[i];\n        let source = range.source;\n        module.setDebugLocation(\n          ref,\n          range.debugInfoRef,\n          source.debugInfoIndex,\n          source.lineAt(range.start),\n          source.columnAt() - 1 // source maps are 0-based\n        );\n      }\n    }\n    if (this.program.options.debugInfo) {\n      let localNameMap = new Set<string>();\n      let localsByIndex = this.localsByIndex;\n      for (let i = 0, k = localsByIndex.length; i < k; i++) {\n        let localName = localsByIndex[i].name;\n        if (localNameMap.has(localName)) {\n          localName = `${localName}|${i}`;\n        }\n        localNameMap.add(localName);\n        module.setLocalName(ref, i, localName);\n      }\n    }\n  }\n}\n\n/** A property comprised of a getter and a setter function. */\nexport class PropertyPrototype extends DeclaredElement {\n\n  /** Field declaration, if a field. */\n  fieldDeclaration: FieldDeclaration | null = null;\n  /** Getter prototype. */\n  getterPrototype: FunctionPrototype | null = null;\n  /** Setter prototype. */\n  setterPrototype: FunctionPrototype | null = null;\n  /** Property instance, if resolved. */\n  instance: Property | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;\n\n  /** Creates a property prototype representing a field. */\n  static forField(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Always a class prototype. */\n    parent: ClassPrototype,\n    /** Declaration of the field. */\n    fieldDeclaration: FieldDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n  ): PropertyPrototype {\n    // A field is a property with an attached memory offset. Unlike normal\n    // properties, accessors for fields are not explicitly declared, so we\n    // declare them implicitly here and compile them as built-ins when used.\n    // As a result, explicit and implicit accessors can override each other,\n    // which is useful when implementing interfaces declaring \"fields\". Such\n    // fields are satisfied by either a field or a normal property, so the\n    // override stub at the interface needs to handle both interchangeably.\n    let nativeRange = Source.native.range;\n    let typeNode = fieldDeclaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(fieldDeclaration.name.range.atEnd);\n    let getterDeclaration = new MethodDeclaration( // get name(): type\n      fieldDeclaration.name,\n      fieldDeclaration.decorators,\n      fieldDeclaration.flags | CommonFlags.Instance | CommonFlags.Get,\n      null,\n      new FunctionTypeNode([], typeNode, null, false, nativeRange),\n      null,\n      nativeRange\n    );\n    let setterDeclaration = new MethodDeclaration( // set name(name: type)\n      fieldDeclaration.name,\n      fieldDeclaration.decorators,\n      fieldDeclaration.flags | CommonFlags.Instance | CommonFlags.Set,\n      null,\n      new FunctionTypeNode(\n        [\n          new ParameterNode(\n            ParameterKind.Default,\n            fieldDeclaration.name,\n            typeNode, null, nativeRange\n          )\n        ],\n        new NamedTypeNode(\n          new TypeName(\n            new IdentifierExpression(\"\", false, nativeRange),\n            null, nativeRange\n          ),\n          null, false, nativeRange\n        ),\n        null, false, nativeRange\n      ),\n      null, nativeRange\n    );\n    let prototype = new PropertyPrototype(name, parent, getterDeclaration);\n    prototype.fieldDeclaration = fieldDeclaration;\n    prototype.decoratorFlags = decoratorFlags;\n    prototype.getterPrototype = new FunctionPrototype(GETTER_PREFIX + name, parent, getterDeclaration, decoratorFlags);\n    prototype.setterPrototype = new FunctionPrototype(SETTER_PREFIX + name, parent, setterDeclaration, decoratorFlags);\n    return prototype;\n  }\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Either a class prototype or instance. */\n    parent: Element,\n    /** Declaration of the getter or setter introducing the property. */\n    firstDeclaration: FunctionDeclaration\n  ) {\n    super(\n      ElementKind.PropertyPrototype,\n      name,\n      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      firstDeclaration\n    );\n    this.flags &= ~(CommonFlags.Get | CommonFlags.Set);\n  }\n\n  /** Tests if this property prototype represents a field. */\n  get isField(): bool {\n    return this.fieldDeclaration != null;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode | null {\n    let fieldDeclaration = this.fieldDeclaration;\n    if (fieldDeclaration) return fieldDeclaration.type;\n    let getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      let getterDeclaration = getterPrototype.declaration;\n      if (getterDeclaration.kind == NodeKind.FunctionDeclaration) {\n        return (<FunctionDeclaration>getterDeclaration).signature.returnType;\n      }\n    }\n    let setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      let setterDeclaration = setterPrototype.declaration;\n      if (setterDeclaration.kind == NodeKind.FunctionDeclaration) {\n        let setterParameters = (<FunctionDeclaration>setterDeclaration).signature.parameters;\n        if (setterParameters.length) return setterParameters[0].type;\n      }\n    }\n    return null;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    let fieldDeclaration = this.fieldDeclaration;\n    if (fieldDeclaration) return fieldDeclaration.initializer;\n    return null;\n  }\n\n  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */\n  get parameterIndex(): i32 {\n    let fieldDeclaration = this.fieldDeclaration;\n    if (fieldDeclaration) return fieldDeclaration.parameterIndex;\n    return -1;\n  }\n\n  /** Gets the respective `this` type. */\n  get thisType(): Type {\n    let parent = this.parent;\n    assert(parent.kind == ElementKind.Class);\n    return (<Class>parent).type;\n  }\n\n  /** Creates a clone of this property prototype that is bound to a concrete class. */\n  toBound(classInstance: Class): PropertyPrototype {\n    assert(this.is(CommonFlags.Instance));\n    assert(!this.isBound);\n    let boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    let firstDeclaration = this.declaration;\n    assert(firstDeclaration.kind == NodeKind.MethodDeclaration);\n    let bound = new PropertyPrototype(\n      this.name,\n      classInstance, // now bound\n      <MethodDeclaration>firstDeclaration\n    );\n    bound.flags = this.flags;\n    bound.fieldDeclaration = this.fieldDeclaration;\n    let getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      bound.getterPrototype = getterPrototype.toBound(classInstance);\n    }\n    let setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      bound.setterPrototype = setterPrototype.toBound(classInstance);\n    }\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n}\n\n/** A resolved property. */\nexport class Property extends VariableLikeElement {\n\n  /** Prototype reference. */\n  prototype: PropertyPrototype;\n  /** Getter instance. */\n  getterInstance: Function | null = null;\n  /** Setter instance. */\n  setterInstance: Function | null = null;\n  /** Field memory offset, if a (layed out) instance field. */\n  memoryOffset: i32 = -1;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Respective property prototype. */\n    prototype: PropertyPrototype,\n    /** Parent element, usually a static class prototype or class instance. */\n    parent: Element\n  ) {\n    super(\n      ElementKind.Property,\n      prototype.name,\n      parent,\n      prototype.isField\n        ? <VariableLikeDeclarationStatement>assert(prototype.fieldDeclaration)\n        : Node.createVariableDeclaration(\n            prototype.identifierNode,\n            null,\n            prototype.flags & CommonFlags.Instance,\n            null, null,\n            prototype.identifierNode.range\n          )\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    if (this.is(CommonFlags.Instance)) {\n      registerConcreteElement(this.program, this);\n    }\n  }\n\n  /** Tests if this property represents a field. */\n  get isField(): bool {\n    return this.prototype.isField;\n  }\n}\n\n/** A resolved index signature. */\nexport class IndexSignature extends TypedElement {\n\n  /** Constructs a new index prototype. */\n  constructor(\n    /** Parent class. */\n    parent: Class\n  ) {\n    super(\n      ElementKind.IndexSignature,\n      \"[]\",\n      parent.internalName + \"[]\",\n      parent.program,\n      parent,\n      parent.program.makeNativeVariableDeclaration(\"[]\") // is fine\n    );\n  }\n\n  /** Obtains the getter instance. */\n  getGetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n  }\n\n  /** Obtains the setter instance. */\n  getSetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n  }\n}\n\n/** A yet unresolved class prototype. */\nexport class ClassPrototype extends DeclaredElement {\n\n  /** Instance member prototypes. */\n  instanceMembers: Map<string,DeclaredElement> | null = null;\n  /** Base class prototype, if applicable. */\n  basePrototype: ClassPrototype | null = null;\n  /** Interface prototypes, if applicable. */\n  interfacePrototypes: InterfacePrototype[] | null = null;\n  /** Constructor prototype. */\n  constructorPrototype: FunctionPrototype | null = null;\n  /** Operator overload prototypes. */\n  operatorOverloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();\n  /** Already resolved instances. */\n  instances: Map<string,Class> | null = null;\n  /** Classes extending this class. */\n  extenders: Set<ClassPrototype> = new Set();\n  /** Whether this class implicitly extends `Object`. */\n  implicitlyExtendsObject: bool = false;\n\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: ClassDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.InterfacePrototype : ElementKind.ClassPrototype,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<ClassDeclaration>this.declaration).typeParameters;\n  }\n  /** Gets the associated extends node. */\n  get extendsNode(): NamedTypeNode | null {\n    return (<ClassDeclaration>this.declaration).extendsType;\n  }\n  /** Gets the associated implements nodes. */\n  get implementsNodes(): NamedTypeNode[] | null {\n    return (<ClassDeclaration>this.declaration).implementsTypes;\n  }\n\n  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    let arrayBufferViewInstance = this.program.arrayBufferViewInstance;\n    return arrayBufferViewInstance && this.extends(arrayBufferViewInstance.prototype);\n  }\n\n  /** Tests if this prototype extends the specified. */\n  extends(basePtototype: ClassPrototype | null): bool {\n    let current: ClassPrototype | null = this;\n    let seen = new Set<ClassPrototype>();\n    do {\n      // cannot directly or indirectly extend itself\n      if (seen.has(current)) break;\n      seen.add(current);\n      if (current == basePtototype) return true;\n      current = current.basePrototype;\n    } while (current);\n    return false;\n  }\n\n  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */\n  addInstance(name: string, element: DeclaredElement): bool {\n    let originalDeclaration = element.declaration;\n    let instanceMembers = this.instanceMembers;\n    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();\n    else if (instanceMembers.has(name)) {\n      let existing = assert(instanceMembers.get(name));\n      let merged = tryMerge(existing, element);\n      if (!merged) {\n        if (isDeclaredElement(existing.kind)) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range,\n            (<DeclaredElement>existing).declaration.name.range,\n            element.identifierNode.text\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range, element.identifierNode.text\n          );\n        }\n        return false;\n      }\n      element = merged;\n    }\n    instanceMembers.set(name, element);\n    if (element.is(CommonFlags.Export) && this.is(CommonFlags.ModuleExport)) {\n      element.set(CommonFlags.ModuleExport); // propagate\n    }\n    this.program.elementsByDeclaration.set(originalDeclaration, element);\n    return true;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Class | null {\n    let instances = this.instances;\n    if (instances && instances.has(instanceKey)) return <Class>instances.get(instanceKey);\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Class): void {\n    let instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved class. */\nexport class Class extends TypedElement {\n\n  /** Class prototype. */\n  prototype: ClassPrototype;\n  /** Resolved type arguments. */\n  typeArguments: Type[] | null;\n  /** Base class, if any. */\n  base: Class | null = null;\n  /** Directly implemented interfaces, if any. */\n  interfaces: Set<Interface> | null = null;\n  /** Contextual type arguments for fields and methods. */\n  contextualTypeArguments: Map<string,Type> | null = null;\n  /** Current member memory offset. */\n  nextMemoryOffset: u32 = 0;\n  /** Constructor instance. */\n  constructorInstance: Function | null = null;\n  /** Operator overloads. */\n  operatorOverloads: Map<OperatorKind,Function> | null = null;\n  /** Index signature, if present. */\n  indexSignature: IndexSignature | null = null;\n  /** Unique class id. */\n  private _id: u32 = 0;\n  /** Runtime type information flags. */\n  rttiFlags: u32 = 0;\n  /** Wrapped type, if a wrapper for a basic type. */\n  wrappedType: Type | null = null;\n  /** Classes directly or indirectly extending this class, if any. */\n  extenders: Set<Class> | null = null;\n  /** Classes directly or indirectly implementing this interface, if any. */\n  implementers: Set<Class> | null = null;\n  /** Whether the field initialization check has already been performed. */\n  didCheckFieldInitialization: bool = false;\n  /** Runtime visitor function reference. */\n  visitRef: FunctionRef = 0;\n\n  /** Gets the unique runtime id of this class. */\n  get id(): u32 {\n    return this._id; // unmanaged remains 0 (=ArrayBuffer)\n  }\n\n  /** Tests if this class is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    return this.prototype.isBuiltinArray;\n  }\n\n  /** Tests if this class is array-like. */\n  get isArrayLike(): bool {\n    if (this.isBuiltinArray) return true;\n    let lengthField = this.getMember(\"length\");\n    if (!lengthField) return false;\n    return (\n      (\n        lengthField.kind == ElementKind.Property &&\n        (<Property>lengthField).getterInstance != null\n      ) || (\n        lengthField.kind == ElementKind.PropertyPrototype &&\n        (<PropertyPrototype>lengthField).getterPrototype != null // TODO: resolve & check type?\n      )\n    ) && (\n      this.lookupOverload(OperatorKind.IndexedGet) != null ||\n      this.lookupOverload(OperatorKind.UncheckedIndexedGet) != null\n    );\n  }\n\n  /** Tests if this is an interface. */\n  get isInterface(): bool {\n    return this.kind == ElementKind.Interface;\n  }\n\n  /** Constructs a new class. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: ClassPrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.Interface : ElementKind.Class,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.Instance)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.typeArguments = typeArguments;\n    let program = this.program;\n    let usizeType = program.options.usizeType;\n    let type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.Value | TypeFlags.Reference, usizeType.size);\n    type.classReference = this;\n    this.setType(type);\n\n    if (!this.hasDecorator(DecoratorFlags.Unmanaged)) {\n      let id = program.nextClassId++;\n      this._id = id;\n      program.managedClasses.set(id, this);\n    }\n\n    // apply pre-checked instance-specific contextual type arguments\n    let typeParameters = prototype.typeParameterNodes;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (!typeParameters || numTypeArguments != typeParameters.length) {\n        throw new Error(\"type argument count mismatch\");\n      }\n      if (numTypeArguments) {\n        let contextualTypeArguments = this.contextualTypeArguments;\n        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();\n        for (let i = 0; i < numTypeArguments; ++i) {\n          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\n        }\n      }\n    } else if (typeParameters && typeParameters.length > 0) {\n      throw new Error(\"type argument count mismatch\");\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Sets the base class. */\n  setBase(base: Class): void {\n    assert(!this.base);\n    this.base = base;\n\n    // Inherit contextual type arguments from base class\n    let inheritedTypeArguments = base.contextualTypeArguments;\n    if (inheritedTypeArguments) {\n      let contextualTypeArguments = this.contextualTypeArguments;\n      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {\n      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {\n        let baseName = unchecked(_keys[i]);\n        let baseType = assert(inheritedTypeArguments.get(baseName));\n        if (!contextualTypeArguments) {\n          this.contextualTypeArguments = contextualTypeArguments = new Map();\n          contextualTypeArguments.set(baseName, baseType);\n        } else if (!contextualTypeArguments.has(baseName)) {\n          contextualTypeArguments.set(baseName, baseType);\n        }\n      }\n    }\n\n    // This class and its extenders now extend each direct or indirect base class\n    base.propagateExtenderUp(this);\n    let extenders = this.extenders;\n    if (extenders) {\n      for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n        let extender = _values[i];\n        base.propagateExtenderUp(extender);\n      }\n    }\n\n    // Direct or indirect base interfaces are now implemented by this class and its extenders\n    let nextBase: Class | null = base;\n    do {\n      let baseInterfaces = nextBase.interfaces;\n      if (baseInterfaces) {\n        for (let _values = Set_values(baseInterfaces), i = 0, k = _values.length; i < k; ++i) {\n          let baseInterface = _values[i];\n          this.propagateInterfaceDown(baseInterface);\n        }\n      }\n      nextBase = nextBase.base;\n    } while (nextBase);\n  }\n\n  /** Propagates an extender to this class and its base classes. */\n  private propagateExtenderUp(extender: Class): void {\n    // Start with this class, adding the extender to it. Repeat for the class's\n    // bases that are indirectly extended by the extender.\n    let nextBase: Class | null = this;\n    do {\n      let extenders = nextBase.extenders;\n      if (!extenders) nextBase.extenders = extenders = new Set();\n      extenders.add(extender);\n      nextBase = nextBase.base;\n    } while (nextBase);\n  }\n\n  /** Propagates an interface and its base interfaces to this class and its extenders. */\n  private propagateInterfaceDown(iface: Interface): void {\n    // Start with the interface itself, adding this class and its extenders to\n    // its implementers. Repeat for the interface's bases that are indirectly\n    // implemented by means of being extended by the interface.\n    let nextIface: Interface | null = iface;\n    let extenders = this.extenders;\n    do {\n      let implementers = nextIface.implementers;\n      if (!implementers) nextIface.implementers = implementers = new Set();\n      implementers.add(this);\n      if (extenders) {\n        for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n          let extender = _values[i];\n          implementers.add(extender);\n        }\n      }\n      nextIface = <Interface | null>nextIface.base;\n    } while (nextIface);\n  }\n\n  /** Adds an interface. */\n  addInterface(iface: Interface): void {\n    let interfaces = this.interfaces;\n    if (!interfaces) this.interfaces = interfaces = new Set();\n    interfaces.add(iface);\n\n    // This class and its extenders now implement the interface and its bases\n    this.propagateInterfaceDown(iface);\n  }\n\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\n  isAssignableTo(target: Class): bool {\n    // Q: When does the assignment in the comment below succeed?\n    if (target.isInterface) {\n      if (this.isInterface) {\n        // targetInterface = thisInterface\n        return this == target || this.extends(target);\n      } else {\n        // targetInterface = thisClass\n        return this.implements(<Interface>target);\n      }\n    } else {\n      if (this.isInterface) {\n        // targetClass = thisInterface\n        return target == this.program.objectInstance;\n      } else {\n        // targetClass = thisClass\n        return this == target || this.extends(target);\n      }\n    }\n  }\n\n  /** Tests if any subclass of this class is assignable to a target of the specified class type. */\n  hasSubclassAssignableTo(target: Class): bool {\n    // Q: When can the cast in the comment below succeed? (while an assignment would not)\n    if (target.isInterface) {\n      if (this.isInterface) {\n        // <TargetInterface>thisInterface\n        return this.hasImplementerImplementing(<Interface>target);\n      } else {\n        // <TargetInterface>thisClass\n        return this.hasExtenderImplementing(<Interface>target);\n      }\n    } else {\n      if (this.isInterface) {\n        // <TargetClass>thisInterface\n        return this.hasImplementer(target);\n      } else {\n        // <TargetClass>thisClass\n        return this.hasExtender(target);\n      }\n    }\n  }\n\n  /** Looks up the operator overload of the specified kind. */\n  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {\n    if (unchecked) {\n      switch (kind) {\n        case OperatorKind.IndexedGet: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UncheckedIndexedGet);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        case OperatorKind.IndexedSet: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UncheckedIndexedSet);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    let instance: Class | null = this;\n    do {\n      let overloads = instance.operatorOverloads;\n      if (overloads != null && overloads.has(kind)) {\n        return assert(overloads.get(kind));\n      }\n      instance = instance.base;\n    } while (instance);\n    return null;\n  }\n\n  /** Gets the method of the specified name, resolved with the given type arguments. */\n  getMethod(name: string, typeArguments: Type[] | null = null): Function | null {\n    let member = this.getMember(name);\n    if (member && member.kind == ElementKind.FunctionPrototype) {\n      return this.program.resolver.resolveFunction(<FunctionPrototype>member, typeArguments);\n    }\n    return null;\n  }\n\n  /** Calculates the memory offset of the specified field. */\n  offsetof(fieldName: string): u32 {\n    let member = assert(this.getMember(fieldName));\n    assert(member.kind == ElementKind.PropertyPrototype);\n    let prototype = <PropertyPrototype>member;\n    let property = prototype.instance;\n    if (property) { // would have failed before\n      assert(property.isField && property.memoryOffset >= 0);\n      return property.memoryOffset;\n    }\n    return 0;\n  }\n\n  /** Creates a buffer suitable to hold a runtime instance of this class. */\n  createBuffer(overhead: i32 = 0): Uint8Array {\n    let program = this.program;\n    let payloadSize = this.nextMemoryOffset + overhead;\n    let blockSize = program.computeBlockSize(payloadSize, true); // excl. overhead\n    let buffer = new Uint8Array(program.blockOverhead + blockSize);\n    let OBJECT = program.OBJECTInstance;\n    OBJECT.writeField(\"mmInfo\", blockSize, buffer, 0);\n    OBJECT.writeField(\"gcInfo\", 0, buffer, 0);\n    OBJECT.writeField(\"gcInfo2\", 0, buffer, 0);\n    OBJECT.writeField(\"rtId\", this.id, buffer, 0);\n    OBJECT.writeField(\"rtSize\", payloadSize, buffer, 0);\n    return buffer;\n  }\n\n  /** Writes a field value to a buffer and returns the number of bytes written. */\n  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.totalOverhead): i32 {\n    let member = this.getMember(name);\n    if (member && member.kind == ElementKind.PropertyPrototype) {\n      let prototype = <PropertyPrototype>member;\n      let property = prototype.instance; // resolved during class finalization\n      if (!property) return 0; // failed before\n      assert(property.isField && property.memoryOffset >= 0);\n      let offset = baseOffset + property.memoryOffset;\n      let typeKind = property.type.kind;\n      switch (typeKind) {\n        case TypeKind.I8:\n        case TypeKind.U8: {\n          assert(!i64_is(value));\n          writeI8(i32(value), buffer, offset);\n          return 1;\n        }\n        case TypeKind.I16:\n        case TypeKind.U16: {\n          assert(!i64_is(value));\n          writeI16(i32(value), buffer, offset);\n          return 2;\n        }\n        case TypeKind.I32:\n        case TypeKind.U32: {\n          assert(!i64_is(value));\n          writeI32(i32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.Isize:\n        case TypeKind.Usize: {\n          if (this.program.options.isWasm64) {\n            if (i64_is(value)) {\n              writeI64(value, buffer, offset);\n            } else {\n              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.Usize);\n            }\n            return 8;\n          } else {\n            if (i64_is(value)) {\n              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.Usize);\n            } else {\n              writeI32(i32(value), buffer, offset);\n            }\n            return 4;\n          }\n        }\n        case TypeKind.I64:\n        case TypeKind.U64: {\n          if (i64_is(value)) {\n            writeI64(value, buffer, offset);\n          } else {\n            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);\n          }\n          return 8;\n        }\n        case TypeKind.F32: {\n          assert(!i64_is(value));\n          writeF32(f32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.F64: {\n          assert(!i64_is(value));\n          writeF64(f64(value), buffer, offset);\n          return 8;\n        }\n      }\n    }\n    assert(false);\n    return 0;\n  }\n\n  /** Tests if this class extends the specified prototype. */\n  extendsPrototype(prototype: ClassPrototype): bool {\n    return this.prototype.extends(prototype);\n  }\n\n  /** Gets the concrete type arguments to the specified extendend prototype. */\n  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {\n    let current: Class | null = this;\n    do {\n      if (current.prototype == extendedPrototype) return current.typeArguments;\n      current = current.base;\n    } while (current);\n    return null;\n  }\n\n  /** Gets the value type of an array. Must be an array. */\n  getArrayValueType(): Type {\n    let current: Class = this;\n    let program = this.program;\n    let arrayPrototype = program.arrayPrototype;\n    if (this.extendsPrototype(arrayPrototype)) {\n      return this.getTypeArgumentsTo(arrayPrototype)![0];\n    }\n    let staticArrayPrototype = program.staticArrayPrototype;\n    if (this.extendsPrototype(staticArrayPrototype)) {\n      return this.getTypeArgumentsTo(staticArrayPrototype)![0];\n    }\n    let abvInstance = program.arrayBufferViewInstance;\n    while (current.base != abvInstance) {\n      current = assert(current.base);\n    }\n    let prototype = current.prototype;\n    switch (prototype.name.charCodeAt(0)) {\n      case CharCode.F: {\n        if (prototype == program.float32ArrayPrototype) return Type.f32;\n        if (prototype == program.float64ArrayPrototype) return Type.f64;\n        break;\n      }\n      case CharCode.I: {\n        if (prototype == program.int8ArrayPrototype) return Type.i8;\n        if (prototype == program.int16ArrayPrototype) return Type.i16;\n        if (prototype == program.int32ArrayPrototype) return Type.i32;\n        if (prototype == program.int64ArrayPrototype) return Type.i64;\n        break;\n      }\n      case CharCode.U: {\n        if (prototype == program.uint8ArrayPrototype) return Type.u8;\n        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;\n        if (prototype == program.uint16ArrayPrototype) return Type.u16;\n        if (prototype == program.uint32ArrayPrototype) return Type.u32;\n        if (prototype == program.uint64ArrayPrototype) return Type.u64;\n        break;\n      }\n    }\n    assert(false);\n    return Type.void;\n  }\n\n  /** Tests if this class is pointerfree. Useful to know for the GC. */\n  get isPointerfree(): bool {\n    let program = this.program;\n\n    let instanceMembers = this.members;\n    if (instanceMembers) {\n\n      // Check that there are no managed instance fields\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind == ElementKind.PropertyPrototype) {\n          let prototype = <PropertyPrototype>member;\n          let property = prototype.instance; // resolved during class finalization\n          if (!property) continue; // failed earlier\n          if (property.isField && property.type.isManaged) return false;\n        }\n      }\n\n      // Check that this isn't a managed collection\n      if (instanceMembers.has(CommonNames.visit)) {\n        let prototype = this.prototype;\n        if (\n          prototype == program.arrayPrototype ||\n          prototype == program.staticArrayPrototype ||\n          prototype == program.setPrototype ||\n          prototype == program.mapPrototype\n        ) {\n          // Note that we cannot know for sure anymore as soon as the collection\n          // is extended, because user code may implement a custom visitor.\n          let typeArguments = assert(this.getTypeArgumentsTo(prototype));\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (typeArguments[i].isManaged) return false;\n          }\n          return true;\n        }\n        return false; // has a custom __visit\n      }\n    }\n    return true;\n  }\n\n  /** Tests if this class or interface extends the given class or interface. */\n  extends(other: Class): bool {\n    return other.hasExtender(this);\n  }\n\n  /** Tests if this class has a direct or indirect extender matching the given class. */\n  hasExtender(other: Class): bool {\n    let extenders = this.extenders;\n    return extenders != null && extenders.has(other);\n  }\n\n  /** Tests if this class has a direct or indirect extender that implements the given interface. */\n  hasExtenderImplementing(other: Interface): bool {\n    let extenders = this.extenders;\n    if (extenders) {\n      for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n        let extender = _values[i];\n        if (extender.implements(other)) return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests if this class directly or indirectly implements the given interface. */\n  implements(other: Interface): bool {\n    return other.hasImplementer(this);\n  }\n\n  /** Tests if this interface has a direct or indirect implementer matching the given class. */\n  hasImplementer(other: Class): bool {\n    let implementers = this.implementers;\n    return implementers != null && implementers.has(other);\n  }\n\n  /** Tests if this interface has an implementer implementing the given interface. */\n  hasImplementerImplementing(other: Interface): bool {\n    let implementers = this.implementers;\n    if (implementers) {\n      for (let _values = Set_values(implementers), i = 0, k = _values.length; i < k; ++i) {\n        let implementer = _values[i];\n        if (implementer.implements(other)) return true;\n      }\n    }\n    return false;\n  }\n}\n\n/** A yet unresolved interface. */\nexport class InterfacePrototype extends ClassPrototype {\n\n  /** Constructs a new interface prototype. */\n  constructor(\n    name: string,\n    parent: Element,\n    declaration: InterfaceDeclaration,\n    decoratorFlags: DecoratorFlags\n  ) {\n    super(\n      name,\n      parent,\n      declaration,\n      decoratorFlags,\n      true\n    );\n  }\n}\n\n/** A resolved interface. */\nexport class Interface extends Class { // FIXME\n\n  /** Constructs a new interface. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: InterfacePrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n  ) {\n    super(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      true\n    );\n  }\n}\n\n/** Registers a concrete element with a program. */\nfunction registerConcreteElement(program: Program, element: Element): void {\n  assert(!program.instancesByName.has(element.internalName));\n  program.instancesByName.set(element.internalName, element);\n}\n\n/** Attempts to merge two elements. Returns the merged element on success. */\nfunction tryMerge(older: Element, newer: Element): DeclaredElement | null {\n  // NOTE: some of the following cases are not supported by TS, not sure why exactly.\n  // suggesting to just merge what seems to be possible for now and revisit later.\n  assert(older.program == newer.program);\n  if (newer.members) return null;\n  let merged: DeclaredElement | null = null;\n  switch (older.kind) {\n    case ElementKind.FunctionPrototype: {\n      switch (newer.kind) {\n        case ElementKind.Namespace: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TypeDefinition: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.ClassPrototype:\n    case ElementKind.Enum: {\n      if (newer.kind == ElementKind.Namespace) {\n        copyMembers(newer, older);\n        merged = <DeclaredElement>older;\n        break;\n      }\n      break;\n    }\n    case ElementKind.Namespace: {\n      switch (newer.kind) {\n        case ElementKind.Enum:\n        case ElementKind.ClassPrototype:      // TS2434\n        case ElementKind.FunctionPrototype: { // TS2434\n          copyMembers(older, newer);\n          merged = <DeclaredElement>newer;\n          break;\n        }\n        case ElementKind.Namespace: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TypeDefinition: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.Global: {\n      if (newer.kind == ElementKind.TypeDefinition) {\n        if (!older.shadowType) {\n          older.shadowType = <TypeDefinition>newer;\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n        }\n      }\n      break;\n    }\n    case ElementKind.TypeDefinition: {\n      switch (newer.kind) {\n        case ElementKind.Global:\n        case ElementKind.FunctionPrototype:\n        case ElementKind.Namespace: {\n          if (!newer.shadowType) {\n            newer.shadowType = <TypeDefinition>older;\n            copyMembers(older, newer);\n            merged = <DeclaredElement>newer;\n          }\n          break;\n        }\n      }\n      break;\n    }\n  }\n  if (merged) {\n    let olderIsExport = older.is(CommonFlags.Export) || older.hasDecorator(DecoratorFlags.Global);\n    let newerIsExport = newer.is(CommonFlags.Export) || newer.hasDecorator(DecoratorFlags.Global);\n    if (olderIsExport != newerIsExport) {\n      older.program.error(\n        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,\n        merged.identifierNode.range, merged.identifierNode.text\n      );\n    }\n  }\n  return merged;\n}\n\n/** Copies the members of `src` to `dest`. */\nfunction copyMembers(src: Element, dest: Element): void {\n  let srcMembers = src.members;\n  if (srcMembers) {\n    let destMembers = dest.members;\n    if (!destMembers) dest.members = destMembers = new Map();\n    // TODO: for (let [memberName, member] of srcMembers) {\n    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {\n      let memberName = unchecked(_keys[i]);\n      let member = assert(srcMembers.get(memberName));\n      destMembers.set(memberName, member);\n    }\n  }\n}\n\n/** Mangles the internal name of an element with the specified name that is a child of the given parent. */\nexport function mangleInternalName(\n  name: string,\n  parent: Element,\n  isInstance: bool,\n  asGlobal: bool = false\n): string {\n  switch (parent.kind) {\n    case ElementKind.File: {\n      if (asGlobal) return name;\n      return parent.internalName + PATH_DELIMITER + name;\n    }\n    case ElementKind.Function: {\n      if (asGlobal) return name;\n      assert(!isInstance);\n      return parent.internalName + INNER_DELIMITER + name;\n    }\n    case ElementKind.PropertyPrototype: // properties are just containers\n    case ElementKind.Property: {         //\n      parent = parent.parent;\n      // fall-through\n    }\n    default: {\n      return (\n        mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.Instance), asGlobal) +\n        (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name\n      );\n    }\n  }\n}\n\n// Cached default parameter names used where names are unknown.\nlet cachedDefaultParameterNames: string[] = [];\n\n/** Gets the cached default parameter name for the specified index. */\nexport function getDefaultParameterName(index: i32): string {\n  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {\n    cachedDefaultParameterNames.push(`$${i}`);\n  }\n  return cachedDefaultParameterNames[index];\n}\n", "/**\n * @fileoverview Mappings from AssemblyScript types to WebAssembly types.\n * @license Apache-2.0\n */\n\nimport {\n  CommonNames\n} from \"./common\";\n\nimport {\n  Class,\n  Program,\n  DecoratorFlags\n} from \"./program\";\n\nimport {\n  TypeRef,\n  createType,\n  HeapTypeRef,\n  ensureType\n} from \"./module\";\n\nimport * as binaryen from \"./glue/binaryen\";\n\n/** Indicates the kind of a type. */\nexport const enum TypeKind {\n  /** A 1-bit unsigned integer. */\n  Bool,\n\n  // signed integers\n\n  /** An 8-bit signed integer. */\n  I8,\n  /** A 16-bit signed integer. */\n  I16,\n  /** A 32-bit signed integer. */\n  I32,\n  /** A 64-bit signed integer. */\n  I64,\n  /** A 32-bit/64-bit signed integer, depending on the target. */\n  Isize,\n\n  // unsigned integers\n\n  /** An 8-bit unsigned integer. */\n  U8,\n  /** A 16-bit unsigned integer. */\n  U16,\n  /** A 32-bit unsigned integer. Also the base of function types. */\n  U32,\n  /** A 64-bit unsigned integer. */\n  U64,\n  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */\n  Usize,\n\n  // floats\n\n  /** A 32-bit float. */\n  F32,\n  /** A 64-bit double. */\n  F64,\n\n  // vectors\n\n  /** A 128-bit vector. */\n  V128,\n\n  // references\n\n  /** Function reference. */\n  Funcref,\n  /** External reference. */\n  Externref,\n  /** Any reference. */\n  Anyref,\n  /** Equatable reference. */\n  Eqref,\n  /** 31-bit integer reference. */\n  I31ref,\n  /** Data reference. */\n  Dataref,\n  /** Array reference. */\n  Arrayref,\n  /** String reference. */\n  Stringref,\n  /** WTF8 string view. */\n  StringviewWTF8,\n  /** WTF16 string view. */\n  StringviewWTF16,\n  /** String iterator. */\n  StringviewIter,\n\n  // other\n\n  /** No return type. */\n  Void\n}\n\n/** Indicates capabilities of a type. */\nexport const enum TypeFlags {\n  None = 0,\n  /** Is a signed type that can represent negative values. */\n  Signed = 1 << 0,\n  /** Is an unsigned type that cannot represent negative values. */\n  Unsigned = 1 << 1,\n  /** Is an integer type. */\n  Integer = 1 << 2,\n  /** Is a floating point type. */\n  Float = 1 << 3,\n  /** Is a varying (in size) type. */\n  Varying = 1 << 4,\n  /** Is smaller than 32-bits. */\n  Short = 1 << 5,\n  /** Is larger than 32-bits. */\n  Long = 1 << 6,\n  /** Is a value type. */\n  Value = 1 << 7,\n  /** Is a reference type (either a class or a function type). */\n  Reference = 1 << 8,\n  /** Is a nullable type. */\n  Nullable = 1 << 9,\n  /** Is a vector type. */\n  Vector = 1 << 10,\n  /** Is an external type. */\n  External = 1 << 11,\n  /** Is a class. */\n  Class = 1 << 12,\n  /** Is a function. */\n  Function = 1 << 13\n}\n\n/** Represents a resolved type. */\nexport class Type {\n\n  /** Type kind. */\n  kind: TypeKind;\n  /** Type flags. */\n  flags: TypeFlags;\n  /** Size in bits. */\n  size: i32;\n  /** Underlying class reference, if a class type. */\n  classReference: Class | null = null;\n  /** Underlying signature reference, if a function type. */\n  signatureReference: Signature | null = null;\n  /** Respective non-nullable type, if nullable. */\n  private _nonNullableType: Type | null = null;\n  /** Respective nullable type, if non-nullable. */\n  private _nullableType: Type | null = null;\n  /** Cached Binaryen type reference. */\n  ref: TypeRef = 0;\n\n  /** Constructs a new resolved type. */\n  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {\n    this.kind = kind;\n    this.flags = flags;\n    this.size = size;\n    if (!(flags & TypeFlags.Nullable)) {\n      this._nonNullableType = this;\n    } else {\n      this._nullableType = this;\n    }\n  }\n\n  /** Returns the closest int type representing this type. */\n  get intType(): Type {\n    if (this == Type.auto) return this; // keep auto as a hint\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I32:\n      case TypeKind.F32:   return Type.i32;\n      case TypeKind.I8:    return Type.i8;\n      case TypeKind.I16:   return Type.i16;\n      case TypeKind.F64:\n      case TypeKind.I64:   return Type.i64;\n      case TypeKind.Isize: return this.size == 64 ? Type.isize64 : Type.isize32;\n      case TypeKind.U8:    return Type.u8;\n      case TypeKind.U16:   return Type.u16;\n      case TypeKind.U32:   return Type.u32;\n      case TypeKind.U64:   return Type.u64;\n      case TypeKind.Usize: return this.size == 64 ? Type.usize64 : Type.usize32;\n      default: return Type.i32;\n    }\n  }\n\n  /** Substitutes this type with the auto type if this type is void. */\n  get exceptVoid(): Type {\n    return this.kind == TypeKind.Void ? Type.auto : this;\n  }\n\n  /** Size in bytes. */\n  get byteSize(): i32 {\n    // ceiled div by 8\n    return this.size + 7 >>> 3;\n  }\n\n  /** Gets this type's logarithmic alignment in memory. */\n  get alignLog2(): i32 {\n    return 31 - clz<i32>(this.byteSize);\n  }\n\n  /** Tests if this type represents a basic value. */\n  get isValue(): bool {\n    return this.is(TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an integer value. */\n  get isIntegerValue(): bool {\n    return this.is(TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a small (< 32 bits) integer value. */\n  get isShortIntegerValue(): bool {\n    return this.is(TypeFlags.Short | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a long (> 32 bits) integer value. */\n  get isLongIntegerValue(): bool {\n    return this.is(TypeFlags.Long | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a signed integer value. */\n  get isSignedIntegerValue(): bool {\n    return this.is(TypeFlags.Signed | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an unsigned integer value. */\n  get isUnsignedIntegerValue(): bool {\n    return this.is(TypeFlags.Unsigned | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a varying (in size) integer value. */\n  get isVaryingIntegerValue(): bool {\n    return this.is(TypeFlags.Varying | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an integer, including references.  */\n  get isIntegerInclReference(): bool {\n    return this.is(TypeFlags.Integer);\n  }\n\n  /** Tests if this type represents a floating point value. */\n  get isFloatValue(): bool {\n    return this.is(TypeFlags.Float | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a numeric (integer or floating point) value. */\n  get isNumericValue(): bool {\n    return this.isIntegerValue || this.isFloatValue;\n  }\n\n  /** Tests if this type represents a boolean value. */\n  get isBooleanValue(): bool {\n    return this == Type.bool;\n  }\n\n  /** Tests if this type represents a vector value. */\n  get isVectorValue(): bool {\n    return this.is(TypeFlags.Vector | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an internal or external reference. */\n  get isReference(): bool {\n    return this.is(TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents a nullable internal or external reference. */\n  get isNullableReference(): bool {\n    return this.is(TypeFlags.Nullable | TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents an internal object. */\n  get isInternalReference(): bool {\n    return this.is(TypeFlags.Integer | TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents an external object. */\n  get isExternalReference(): bool {\n    return this.is(TypeFlags.External | TypeFlags.Reference);\n  }\n\n  /** Gets the underlying class of this type, if any. */\n  getClass(): Class | null {\n    return this.isInternalReference\n      ? this.classReference\n      : null;\n  }\n\n  /** Tests if this type represents a class. */\n  get isClass(): bool {\n    return this.getClass() != null;\n  }\n\n  /** Gets the underlying class or wrapper class of this type, if any. */\n  getClassOrWrapper(program: Program): Class | null {\n    let classReference = this.getClass();\n    if (classReference) {\n      // typical class\n      return classReference;\n    } else {\n      let signatureReference = this.getSignature();\n      if (signatureReference) {\n        // function wrapper\n        let type = signatureReference.type;\n        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));\n        wrapper.wrappedType = type;\n        return wrapper;\n      } else {\n        let wrapperClasses = program.wrapperClasses;\n        if (wrapperClasses.has(this)) {\n          // value wrapper\n          return assert(wrapperClasses.get(this));\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Gets the underlying function signature of this type, if any. */\n  getSignature(): Signature | null {\n    return this.isInternalReference\n      ? this.signatureReference\n      : null;\n  }\n\n  /** Tests if this type represents a function. */\n  get isFunction(): bool {\n    return this.getSignature() != null;\n  }\n\n  /** Tests if this is a managed type that needs GC hooks. */\n  get isManaged(): bool {\n    if (this.isInternalReference) {\n      let classReference = this.classReference;\n      if (classReference) return !classReference.hasDecorator(DecoratorFlags.Unmanaged);\n      return this.signatureReference != null; // function references are managed\n    }\n    return false;\n  }\n\n  /** Tests if this is a class type explicitly annotated as unmanaged. */\n  get isUnmanaged(): bool {\n    let classReference = this.classReference;\n    return classReference != null && classReference.hasDecorator(DecoratorFlags.Unmanaged);\n  }\n\n  get isMemory(): bool {\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize:\n      case TypeKind.F32:\n      case TypeKind.F64:\n      case TypeKind.V128: return true;\n    }\n    return false;\n  }\n\n  /** Gets the corresponding non-nullable type. */\n  get nonNullableType(): Type {\n    if (this.isExternalReference) {\n      return this; // TODO\n    }\n    return assert(this._nonNullableType); // set either in ctor or asNullable\n  }\n\n  /** Gets the corresponding nullable type, if applicable. */\n  get nullableType(): Type | null {\n    return this._nullableType; // set either in ctor or asNullable\n  }\n\n  /** Computes the sign-extending shift in the target type. */\n  computeSmallIntegerShift(targetType: Type): i32 {\n    return targetType.size - this.size;\n  }\n\n  /** Computes the truncating mask in the target type. */\n  computeSmallIntegerMask(targetType: Type): i32 {\n    let size = this.size;\n    if (!this.is(TypeFlags.Unsigned)) size -= 1;\n    return ~0 >>> (targetType.size - size);\n  }\n\n  /** Tests if this type has (all of) the specified flags. */\n  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }\n  /** Tests if this type has any of the specified flags. */\n  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }\n\n  /** Composes the respective nullable type of this type. */\n  asNullable(): Type {\n    assert(this.isInternalReference);\n    let nullableType = this._nullableType;\n    if (!nullableType) {\n      assert(!this.isNullableReference);\n      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.Nullable, this.size);\n      nullableType.classReference = this.classReference;         // either a class reference\n      nullableType.signatureReference = this.signatureReference; // or a function reference\n      nullableType._nonNullableType = this;\n    }\n    return nullableType;\n  }\n\n  /** Use unsigned type for according size if possible. */\n  toUnsigned(): Type {\n    switch (this.kind) {\n      case TypeKind.I8:    return Type.u8;\n      case TypeKind.I16:   return Type.u16;\n      case TypeKind.I32:   return Type.u32;\n      case TypeKind.I64:   return Type.u64;\n      case TypeKind.Isize: return this.size == 64 ? Type.usize64 : Type.usize32;\n    }\n    return this;\n  }\n\n  /** Tests if this type equals the specified. */\n  equals(other: Type): bool {\n    if (this.kind != other.kind) {\n      return false;\n    }\n    if (this.isReference) {\n      let selfSignatureReference = this.signatureReference;\n      let otherSignatureReference = other.signatureReference;\n\n      return (\n        this.classReference == other.classReference\n        && selfSignatureReference == otherSignatureReference\n        && this.isNullableReference == other.isNullableReference\n      );\n    }\n    return true;\n  }\n\n  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */\n  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    let currentClass: Class | null;\n    let targetClass: Class | null;\n    let currentFunction: Signature | null;\n    let targetFunction: Signature | null;\n    if (this.isReference) {\n      if (target.isReference) {\n        if (!this.isNullableReference || target.isNullableReference) {\n          if (currentClass = this.getClass()) {\n            if (targetClass = target.getClass()) {\n              return currentClass.isAssignableTo(targetClass);\n            }\n          } else if (currentFunction = this.getSignature()) {\n            if (targetFunction = target.getSignature()) {\n              return currentFunction.isAssignableTo(targetFunction);\n            }\n          } else if (this.isExternalReference) {\n            if (\n              this.kind == target.kind ||\n              (target.kind == TypeKind.Anyref && this.kind != TypeKind.Externref)\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n    } else if (!target.isReference) {\n      if (this.isIntegerValue) {\n        if (target.isIntegerValue) {\n          if (\n            !signednessIsRelevant ||\n            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers\n            this.isSignedIntegerValue == target.isSignedIntegerValue\n          ) {\n            return this.size <= target.size;\n          }\n        } else if (target.kind == TypeKind.F32) {\n          return this.size <= 23; // mantissa bits\n        } else if (target.kind == TypeKind.F64) {\n          return this.size <= 52; // ^\n        }\n      } else if (this.isFloatValue) {\n        if (target.isFloatValue) {\n          return this.size <= target.size;\n        }\n      } else if (this.isVectorValue) {\n        if (target.isVectorValue) {\n          return this.size == target.size;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */\n  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    if (this.isReference) return this.isAssignableTo(target);\n    else if (target.isReference) return false;\n    // not dealing with references from here on\n    if (this.isIntegerValue) {\n      return target.isIntegerValue && target.size == this.size && (\n        !signednessIsRelevant ||\n        this.isSignedIntegerValue == target.isSignedIntegerValue\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if this type has a subtype assignable to the target type. */\n  hasSubtypeAssignableTo(target: Type): bool {\n    let thisClass = this.getClass();\n    let targetClass = target.getClass();\n    if (!thisClass || !targetClass) return false; // TODO: what about basic types?\n    return thisClass.hasSubclassAssignableTo(targetClass);\n  }\n\n  /** Tests if a value of this type can be changed to the target type using `changetype`. */\n  isChangeableTo(target: Type): bool {\n    // special in that it allows integer references as well\n    if (this.is(TypeFlags.Integer) && target.is(TypeFlags.Integer)) {\n      let size = this.size;\n      return size == target.size && (\n        size >= 32 ||\n        this.is(TypeFlags.Signed) == target.is(TypeFlags.Signed)\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if this type can extend or implement the given type. */\n  canExtendOrImplement(base: Type): bool {\n    // Both must be class types\n    let thisClass = this.getClass();\n    let baseClass = base.getClass();\n    if (!thisClass || !baseClass) return false;\n    // Both types must be either managed or unmanaged\n    if (this.isManaged != base.isManaged) return false;\n    // Both types must be either internal or external references\n    if (this.isInternalReference) {\n      if (!base.isInternalReference) return false;\n    } else if (this.isExternalReference) {\n      if (!base.isExternalReference) return false;\n    } else {\n      return false;\n    }\n    return true;\n  }\n\n  /** Determines the common denominator type of two types, if there is any. */\n  static commonDenominator(left: Type, right: Type, signednessIsImportant: bool): Type | null {\n    if (right.isAssignableTo(left, signednessIsImportant)) return left;\n    else if (left.isAssignableTo(right, signednessIsImportant)) return right;\n    return null;\n  }\n\n  /** Converts this type to a string. */\n  toString(validWat: bool = false): string {\n    const nullablePostfix = validWat ? \"|null\" : \" | null\";\n    if (this.isReference) {\n      let classReference = this.getClass();\n      if (classReference) {\n        return this.isNullableReference\n          ? classReference.internalName + nullablePostfix\n          : classReference.internalName;\n      } else {\n        let signatureReference = this.getSignature();\n        if (signatureReference) {\n          return this.isNullableReference\n            ? `(${signatureReference.toString(validWat)})${nullablePostfix}`\n            : signatureReference.toString(validWat);\n        }\n      }\n    }\n    switch (this.kind) {\n      case TypeKind.Bool: return CommonNames.bool;\n      case TypeKind.I8: return CommonNames.i8;\n      case TypeKind.I16: return CommonNames.i16;\n      case TypeKind.I32: return CommonNames.i32;\n      case TypeKind.I64: return CommonNames.i64;\n      case TypeKind.Isize: return CommonNames.isize;\n      case TypeKind.U8: return CommonNames.u8;\n      case TypeKind.U16: return CommonNames.u16;\n      case TypeKind.U32: return CommonNames.u32;\n      case TypeKind.U64: return CommonNames.u64;\n      case TypeKind.Usize: return CommonNames.usize;\n      case TypeKind.F32: return CommonNames.f32;\n      case TypeKind.F64: return CommonNames.f64;\n      case TypeKind.V128: return CommonNames.v128;\n      case TypeKind.Funcref: return CommonNames.funcref;\n      case TypeKind.Externref: return CommonNames.externref;\n      case TypeKind.Anyref: return CommonNames.anyref;\n      case TypeKind.Eqref: return CommonNames.eqref;\n      case TypeKind.I31ref: return CommonNames.i31ref;\n      case TypeKind.Dataref: return CommonNames.dataref;\n      case TypeKind.Arrayref: return CommonNames.arrayref;\n      case TypeKind.Stringref: return CommonNames.stringref;\n      case TypeKind.StringviewWTF8: return CommonNames.stringview_wtf8;\n      case TypeKind.StringviewWTF16: return CommonNames.stringview_wtf16;\n      case TypeKind.StringviewIter: return CommonNames.stringview_iter;\n      default: assert(false);\n      case TypeKind.Void: return CommonNames.void_;\n    }\n  }\n\n  // Binaryen specific\n\n  /** Converts this type to its respective type reference. */\n  toRef(): TypeRef {\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return TypeRef.I32;\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (this.size != 64) return TypeRef.I32;\n      case TypeKind.I64:\n      case TypeKind.U64:  return TypeRef.I64;\n      case TypeKind.F32:  return TypeRef.F32;\n      case TypeKind.F64:  return TypeRef.F64;\n      case TypeKind.V128: return TypeRef.V128;\n      case TypeKind.Funcref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Func, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Externref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Extern, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Anyref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Any, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Eqref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Eq, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.I31ref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.I31, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Dataref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Data, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Arrayref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Array, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Stringref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.String, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.StringviewWTF8: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF8, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.StringviewWTF16: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF16, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.StringviewIter: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewIter, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Void: return TypeRef.None;\n    }\n    // TODO: not used yet\n    assert(false);\n    return ensureType(this);\n  }\n\n  // Types\n\n  /** An 8-bit signed integer. */\n  static readonly i8: Type  = new Type(TypeKind.I8,\n    TypeFlags.Signed   |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   8\n  );\n\n  /** A 16-bit signed integer. */\n  static readonly i16: Type = new Type(TypeKind.I16,\n    TypeFlags.Signed   |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  16\n  );\n\n  /** A 32-bit signed integer. */\n  static readonly i32: Type = new Type(TypeKind.I32,\n    TypeFlags.Signed   |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit signed integer. */\n  static readonly i64: Type = new Type(TypeKind.I64,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 32-bit signed size. WASM32 only. */\n  static readonly isize32: Type = new Type(TypeKind.Isize,\n    TypeFlags.Signed   |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit signed size. WASM64 only. */\n  static readonly isize64: Type = new Type(TypeKind.Isize,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  64\n  );\n\n  /** An 8-bit unsigned integer. */\n  static readonly u8: Type = new Type(TypeKind.U8,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   8\n  );\n\n  /** A 16-bit unsigned integer. */\n  static readonly u16: Type = new Type(TypeKind.U16,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  16\n  );\n\n  /** A 32-bit unsigned integer. */\n  static readonly u32: Type = new Type(TypeKind.U32,\n    TypeFlags.Unsigned |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit unsigned integer. */\n  static readonly u64: Type = new Type(TypeKind.U64,\n    TypeFlags.Unsigned |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 32-bit unsigned size. WASM32 only. */\n  static readonly usize32: Type = new Type(TypeKind.Usize,\n    TypeFlags.Unsigned |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit unsigned size. WASM64 only. */\n  static readonly usize64: Type = new Type(TypeKind.Usize,\n    TypeFlags.Unsigned |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 1-bit unsigned integer. */\n  static readonly bool: Type = new Type(TypeKind.Bool,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   1\n  );\n\n  /** A 32-bit float. */\n  static readonly f32: Type = new Type(TypeKind.F32,\n    TypeFlags.Signed   |\n    TypeFlags.Float    |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit float. */\n  static readonly f64: Type = new Type(TypeKind.F64,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Float    |\n    TypeFlags.Value,  64\n  );\n\n  /** A 128-bit vector. */\n  static readonly v128: Type = new Type(TypeKind.V128,\n    TypeFlags.Vector   |\n    TypeFlags.Value, 128\n  );\n\n  /** Function reference. */\n  static readonly funcref: Type = new Type(TypeKind.Funcref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** External reference. */\n  static readonly externref: Type = new Type(TypeKind.Externref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Any reference. */\n  static readonly anyref: Type = new Type(TypeKind.Anyref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Equatable reference. */\n  static readonly eqref: Type = new Type(TypeKind.Eqref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** 31-bit integer reference. */\n  static readonly i31ref: Type = new Type(TypeKind.I31ref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Data reference. */\n  static readonly dataref: Type = new Type(TypeKind.Dataref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Array reference. */\n  static readonly arrayref: Type = new Type(TypeKind.Arrayref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** String reference. */\n  static readonly stringref: Type = new Type(TypeKind.Stringref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** WTF8 string view. */\n  static readonly stringview_wtf8: Type = new Type(TypeKind.StringviewWTF8,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** WTF16 string view. */\n  static readonly stringview_wtf16: Type = new Type(TypeKind.StringviewWTF16,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** String iterator. */\n  static readonly stringview_iter: Type = new Type(TypeKind.StringviewIter,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** No return type. */\n  static readonly void: Type = new Type(TypeKind.Void, TypeFlags.None, 0);\n\n  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */\n  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);\n}\n\n/** Converts an array of types to an array of type references. */\nexport function typesToRefs(types: Type[]): TypeRef[] {\n  let numTypes = types.length;\n  let ret = new Array<TypeRef>(numTypes);\n  for (let i = 0; i < numTypes; ++i) {\n    unchecked(ret[i] = types[i].toRef());\n  }\n  return ret;\n}\n\n/** Converts an array of types to its combined string representation. */\nexport function typesToString(types: Type[]): string {\n  let numTypes = types.length;\n  if (!numTypes) return \"\";\n  let sb = new Array<string>(numTypes);\n  for (let i = 0; i < numTypes; ++i) {\n    unchecked(sb[i] = types[i].toString(true));\n  }\n  return sb.join(\",\");\n}\n\n/** Represents a fully resolved function signature. */\nexport class Signature {\n  /** Construct a new signature. */\n  public static create(\n    /** The program that created this signature. */\n    program: Program,\n    /** Parameter types, if any, excluding `this`. */\n    parameterTypes: Type[] = [],\n    /** Return type. */\n    returnType: Type = Type.void,\n    /** This type, if an instance signature. */\n    thisType: Type | null = null,\n    /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n    requiredParameters: i32 = parameterTypes ? parameterTypes.length : 0,\n    /** Whether the last parameter is a rest parameter. */\n    hasRest: bool = false,\n  ): Signature {\n    // get the usize type, and the type of the signature\n    let usizeType = program.options.usizeType;\n    let type = new Type(\n      usizeType.kind,\n      usizeType.flags & ~TypeFlags.Value | TypeFlags.Reference,\n      usizeType.size\n    );\n\n    // calculate the properties\n    let signatureTypes = program.uniqueSignatures;\n    let nextId = program.nextSignatureId;\n    \n    // construct the signature and calculate it's unique key\n    let signature = new Signature(program, parameterTypes, returnType, thisType, requiredParameters, hasRest, nextId, type);\n    let uniqueKey = signature.toString();\n\n    // check if it exists, and return it\n    if (signatureTypes.has(uniqueKey)) {\n      let existing = assert(signatureTypes.get(uniqueKey));\n      assert(signature.equals(existing));\n      return existing;\n    }\n\n    // otherwise increment the program's signature id, set the signature reference of the type, and memoize the signature\n    program.nextSignatureId = nextId + 1;\n    type.signatureReference = signature;\n    signatureTypes.set(uniqueKey, signature);\n    return signature;\n  }\n\n  /** Constructs a new signature. */\n  private constructor(\n    /** The program that created this signature. */\n    public readonly program: Program,\n    /** Parameter types, if any, excluding `this`. */\n    public readonly parameterTypes: Type[],\n    /** Return type. */\n    public readonly returnType: Type,\n    /** This type, if an instance signature. */\n    public readonly thisType: Type | null,\n    /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n    public readonly requiredParameters: i32,\n    /** Whether the last parameter is a rest parameter. */\n    public readonly hasRest: bool,\n    /** Unique id representing this signature. */\n    public readonly id: u32,\n    /** Respective function type. */\n    public readonly type: Type,\n  ) {}\n\n  get paramRefs(): TypeRef {\n    let thisType = this.thisType;\n    let parameterTypes = this.parameterTypes;\n    let numParameterTypes = parameterTypes.length;\n    if (!numParameterTypes) {\n      return thisType ? thisType.toRef() : TypeRef.None;\n    }\n    if (thisType) {\n      let typeRefs = new Array<TypeRef>(1 + numParameterTypes);\n      unchecked(typeRefs[0] = thisType.toRef());\n      for (let i = 0; i < numParameterTypes; ++i) {\n        unchecked(typeRefs[i + 1] = parameterTypes[i].toRef());\n      }\n      return createType(typeRefs);\n    }\n    return createType(typesToRefs(parameterTypes));\n  }\n\n  get resultRefs(): TypeRef {\n    return this.returnType.toRef();\n  }\n\n  /** Tests if this signature equals the specified. */\n  equals(other: Signature): bool {\n\n    // check `this` type\n    let thisThisType = this.thisType;\n    let otherThisType = other.thisType;\n    if (thisThisType) {\n      if (!otherThisType || !thisThisType.equals(otherThisType)) return false;\n    } else if (otherThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != other.hasRest) return false;\n\n    // check return type\n    if (!this.returnType.equals(other.returnType)) return false;\n\n    // check parameter types\n    let selfParameterTypes = this.parameterTypes;\n    let otherParameterTypes = other.parameterTypes;\n    let numParameters = selfParameterTypes.length;\n    if (numParameters != otherParameterTypes.length)  return false;\n\n    for (let i = 0; i < numParameters; ++i) {\n      let selfParameterType = unchecked(selfParameterTypes[i]);\n      let otherParameterType = unchecked(otherParameterTypes[i]);\n      if (!selfParameterType.equals(otherParameterType)) return false;\n    }\n    return true;\n  }\n\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\n  isAssignableTo(target: Signature, checkCompatibleOverride: bool = false): bool {\n    let thisThisType = this.thisType;\n    let targetThisType = target.thisType;\n    if (checkCompatibleOverride) {\n      // check kind of `this` type\n      if (thisThisType) {\n        if (!targetThisType || !thisThisType.canExtendOrImplement(targetThisType)) {\n          return false;\n        }\n      } else if (targetThisType) {\n        return false;\n      }\n    } else {\n      // check `this` type (invariant)\n      if (thisThisType) {\n        if (targetThisType != targetThisType) return false;\n      } else if (targetThisType) {\n        return false;\n      }\n    }\n\n    // check rest parameter\n    if (this.hasRest != target.hasRest) return false; // TODO\n\n    // check return type (covariant)\n    let thisReturnType = this.returnType;\n    let targetReturnType = target.returnType;\n    if (!(thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType))) {\n      return false;\n    }\n    // check parameter types (invariant)\n    let thisParameterTypes = this.parameterTypes;\n    let targetParameterTypes = target.parameterTypes;\n    let numParameters = thisParameterTypes.length;\n    if (numParameters != targetParameterTypes.length) return false; // TODO\n\n    for (let i = 0; i < numParameters; ++i) {\n      let thisParameterType = unchecked(thisParameterTypes[i]);\n      let targetParameterType = unchecked(targetParameterTypes[i]);\n      if (thisParameterType != targetParameterType) return false;\n    }\n    return true;\n  }\n\n  /** Tests if this signature has at least one managed operand. */\n  get hasManagedOperands(): bool {\n    let thisType = this.thisType;\n    if (thisType && thisType.isManaged) {\n      return true;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isManaged) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all managed operands. */\n  getManagedOperandIndices(): i32[] {\n    let indices = new Array<i32>();\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isManaged) indices.push(index);\n      ++index;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isManaged) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Tests if this signature has at least one v128 operand. */\n  get hasVectorValueOperands(): bool {\n    let thisType = this.thisType;\n    if (thisType && thisType.isVectorValue) {\n      return true;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isVectorValue) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all v128 operands. */\n  getVectorValueOperandIndices(): i32[] {\n    let indices = new Array<i32>();\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isVectorValue) indices.push(index);\n      ++index;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isVectorValue) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Converts this signature to a string. */\n  toString(validWat: bool = false): string {\n    let sb = new Array<string>();\n    sb.push(validWat ? \"%28\" : \"(\");\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      sb.push(validWat ? \"this:\" : \"this: \");\n      sb.push(thisType.toString(validWat));\n      index = 1;\n    }\n    let parameters = this.parameterTypes;\n    let numParameters = parameters.length;\n    if (numParameters) {\n      let optionalStart = this.requiredParameters;\n      let restIndex = this.hasRest ? numParameters - 1 : -1;\n      for (let i = 0; i < numParameters; ++i, ++index) {\n        if (index) sb.push(validWat ? \"%2C\" : \", \");\n        if (i == restIndex) sb.push(\"...\");\n        sb.push(parameters[i].toString(validWat));\n        if (i >= optionalStart && i != restIndex) sb.push(\"?\");\n      }\n    }\n    sb.push(validWat ? \"%29=>\" : \") => \");\n    sb.push(this.returnType.toString(validWat));\n    return sb.join(\"\");\n  }\n\n  /** Creates a clone of this signature that is safe to modify. */\n  clone(requiredParameters: i32 = this.requiredParameters, hasRest: bool = this.hasRest): Signature {\n    let parameterTypes = this.parameterTypes;\n    let numParameterTypes = parameterTypes.length;\n    let cloneParameterTypes = new Array<Type>(numParameterTypes);\n    for (let i = 0; i < numParameterTypes; ++i) {\n      unchecked(cloneParameterTypes[i] = parameterTypes[i]);\n    }\n    return Signature.create(\n      this.program,\n      cloneParameterTypes,\n      this.returnType,\n      this.thisType,\n      requiredParameters,\n      hasRest\n    );\n  }\n}\n", "/**\n * @fileoverview Built-in elements providing core WebAssembly functionality.\n *\n * Each builtin is linked to its definition in std/assembly/builtins.ts.\n * When its prototype is called, the compiler recognizes the `@builtin`\n * decorator, looks up the respective handler in the global builtins map\n * and executes it, with the handler directly emitting WebAssembly code\n * according to context.\n *\n * Builtins can be categorized into core builtins that typically are generic\n * and emit code directly and aliases calling core builtins with overridden\n * contexts. The latter is used by inline assembler aliases of WebAssembly\n * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.\n *\n * The `contextIsExact` modifier is used to force a specific instruction\n * family. A `i32.store8` deferring to `<i32>store<i8>` for example is\n * ambiguous in that the input can still be an i32 or an i64, leading to\n * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.\n * This behavior is indicated by `from i32/i64` in the comments below.\n *\n * @license Apache-2.0\n */\n\n// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.\n\nimport {\n  Compiler,\n  Constraints,\n  RuntimeFeatures,\n  UncheckedBehavior\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticCategory\n} from \"./diagnostics\";\n\nimport {\n  Expression,\n  LiteralKind,\n  StringLiteralExpression,\n  CallExpression,\n  NodeKind,\n  LiteralExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  BinaryOp,\n  UnaryOp,\n  AtomicRMWOp,\n  SIMDExtractOp,\n  SIMDReplaceOp,\n  SIMDShiftOp,\n  SIMDTernaryOp,\n  SIMDLoadOp,\n  SIMDLoadStoreLaneOp,\n  RefIsOp,\n  TypeRef,\n  ExpressionRef,\n  ExpressionId,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI64High,\n  getConstValueI64Low,\n  getConstValueI32,\n  getConstValueF32,\n  getConstValueF64,\n  getLocalGetIndex,\n  createType,\n  ExpressionRunnerFlags,\n  mustPreserveSideEffects\n} from \"./module\";\n\nimport {\n  ElementKind,\n  FunctionPrototype,\n  Global,\n  DecoratorFlags,\n  Class,\n  PropertyPrototype\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  CommonFlags,\n  Feature,\n  featureToString,\n  TypeinfoFlags\n} from \"./common\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  isPowerOf2\n} from \"./util\";\n\n/** Internal names of various compiler built-ins. */\nexport namespace BuiltinNames {\n\n  // compiler-generated\n  export const start = \"~start\";\n  export const started = \"~started\";\n  export const argumentsLength = \"~argumentsLength\";\n  export const setArgumentsLength = \"~setArgumentsLength\";\n\n  // std/builtins.ts\n  export const abort = \"~lib/builtins/abort\";\n  export const trace = \"~lib/builtins/trace\";\n  export const seed = \"~lib/builtins/seed\";\n\n  export const isBoolean = \"~lib/builtins/isBoolean\";\n  export const isInteger = \"~lib/builtins/isInteger\";\n  export const isSigned = \"~lib/builtins/isSigned\";\n  export const isFloat = \"~lib/builtins/isFloat\";\n  export const isVector = \"~lib/builtins/isVector\";\n  export const isReference = \"~lib/builtins/isReference\";\n  export const isString = \"~lib/builtins/isString\";\n  export const isArray = \"~lib/builtins/isArray\";\n  export const isArrayLike = \"~lib/builtins/isArrayLike\";\n  export const isFunction = \"~lib/builtins/isFunction\";\n  export const isNullable = \"~lib/builtins/isNullable\";\n  export const isDefined = \"~lib/builtins/isDefined\";\n  export const isConstant = \"~lib/builtins/isConstant\";\n  export const isManaged = \"~lib/builtins/isManaged\";\n  export const isVoid = \"~lib/builtins/isVoid\";\n\n  export const bswap = \"~lib/builtins/bswap\";\n\n  export const add = \"~lib/builtins/add\";\n  export const sub = \"~lib/builtins/sub\";\n  export const mul = \"~lib/builtins/mul\";\n  export const div = \"~lib/builtins/div\";\n  export const clz = \"~lib/builtins/clz\";\n  export const ctz = \"~lib/builtins/ctz\";\n  export const popcnt = \"~lib/builtins/popcnt\";\n  export const rotl = \"~lib/builtins/rotl\";\n  export const rotr = \"~lib/builtins/rotr\";\n  export const abs = \"~lib/builtins/abs\";\n  export const max = \"~lib/builtins/max\";\n  export const min = \"~lib/builtins/min\";\n  export const ceil = \"~lib/builtins/ceil\";\n  export const floor = \"~lib/builtins/floor\";\n  export const copysign = \"~lib/builtins/copysign\";\n  export const nearest = \"~lib/builtins/nearest\";\n  export const reinterpret = \"~lib/builtins/reinterpret\";\n  export const sqrt = \"~lib/builtins/sqrt\";\n  export const trunc = \"~lib/builtins/trunc\";\n  export const eq = \"~lib/builtins/eq\";\n  export const ne = \"~lib/builtins/ne\";\n  export const rem = \"~lib/builtins/rem\";\n  export const load = \"~lib/builtins/load\";\n  export const store = \"~lib/builtins/store\";\n  export const atomic_load = \"~lib/builtins/atomic.load\";\n  export const atomic_store = \"~lib/builtins/atomic.store\";\n  export const atomic_add = \"~lib/builtins/atomic.add\";\n  export const atomic_sub = \"~lib/builtins/atomic.sub\";\n  export const atomic_and = \"~lib/builtins/atomic.and\";\n  export const atomic_or = \"~lib/builtins/atomic.or\";\n  export const atomic_xor = \"~lib/builtins/atomic.xor\";\n  export const atomic_xchg = \"~lib/builtins/atomic.xchg\";\n  export const atomic_cmpxchg = \"~lib/builtins/atomic.cmpxchg\";\n  export const atomic_wait = \"~lib/builtins/atomic.wait\";\n  export const atomic_notify = \"~lib/builtins/atomic.notify\";\n  export const atomic_fence = \"~lib/builtins/atomic.fence\";\n\n  export const sizeof = \"~lib/builtins/sizeof\";\n  export const alignof = \"~lib/builtins/alignof\";\n  export const offsetof = \"~lib/builtins/offsetof\";\n  export const nameof = \"~lib/builtins/nameof\";\n  export const lengthof = \"~lib/builtins/lengthof\";\n  export const select = \"~lib/builtins/select\";\n  export const unreachable = \"~lib/builtins/unreachable\";\n  export const changetype = \"~lib/builtins/changetype\";\n  export const assert = \"~lib/builtins/assert\";\n  export const call_indirect = \"~lib/builtins/call_indirect\";\n  export const unchecked = \"~lib/builtins/unchecked\";\n  export const instantiate = \"~lib/builtins/instantiate\";\n  export const idof = \"~lib/builtins/idof\";\n\n  export const i8 = \"~lib/builtins/i8\";\n  export const i16 = \"~lib/builtins/i16\";\n  export const i32 = \"~lib/builtins/i32\";\n  export const i64 = \"~lib/builtins/i64\";\n  export const isize = \"~lib/builtins/isize\";\n  export const u8 = \"~lib/builtins/u8\";\n  export const u16 = \"~lib/builtins/u16\";\n  export const u32 = \"~lib/builtins/u32\";\n  export const u64 = \"~lib/builtins/u64\";\n  export const usize = \"~lib/builtins/usize\";\n  export const bool = \"~lib/builtins/bool\";\n  export const f32 = \"~lib/builtins/f32\";\n  export const f64 = \"~lib/builtins/f64\";\n  export const v128 = \"~lib/builtins/v128\";\n\n  export const i32_clz = \"~lib/builtins/i32.clz\";\n  export const i64_clz = \"~lib/builtins/i64.clz\";\n  export const i32_ctz = \"~lib/builtins/i32.ctz\";\n  export const i64_ctz = \"~lib/builtins/i64.ctz\";\n  export const i32_popcnt = \"~lib/builtins/i32.popcnt\";\n  export const i64_popcnt = \"~lib/builtins/i64.popcnt\";\n  export const i32_rotl = \"~lib/builtins/i32.rotl\";\n  export const i64_rotl = \"~lib/builtins/i64.rotl\";\n  export const i32_rotr = \"~lib/builtins/i32.rotr\";\n  export const i64_rotr = \"~lib/builtins/i64.rotr\";\n\n  export const f32_abs = \"~lib/builtins/f32.abs\";\n  export const f64_abs = \"~lib/builtins/f64.abs\";\n  export const f32_max = \"~lib/builtins/f32.max\";\n  export const f64_max = \"~lib/builtins/f64.max\";\n  export const f32_min = \"~lib/builtins/f32.min\";\n  export const f64_min = \"~lib/builtins/f64.min\";\n  export const f32_ceil = \"~lib/builtins/f32.ceil\";\n  export const f64_ceil = \"~lib/builtins/f64.ceil\";\n  export const f32_floor = \"~lib/builtins/f32.floor\";\n  export const f64_floor = \"~lib/builtins/f64.floor\";\n  export const f32_copysign = \"~lib/builtins/f32.copysign\";\n  export const f64_copysign = \"~lib/builtins/f64.copysign\";\n  export const f32_nearest = \"~lib/builtins/f32.nearest\";\n  export const f64_nearest = \"~lib/builtins/f64.nearest\";\n  export const i32_reinterpret_f32 = \"~lib/builtins/i32.reinterpret_f32\";\n  export const i64_reinterpret_f64 = \"~lib/builtins/i64.reinterpret_f64\";\n  export const f32_reinterpret_i32 = \"~lib/builtins/f32.reinterpret_i32\";\n  export const f64_reinterpret_i64 = \"~lib/builtins/f64.reinterpret_i64\";\n  export const f32_sqrt = \"~lib/builtins/f32.sqrt\";\n  export const f64_sqrt = \"~lib/builtins/f64.sqrt\";\n  export const f32_trunc = \"~lib/builtins/f32.trunc\";\n  export const f64_trunc = \"~lib/builtins/f64.trunc\";\n\n  export const i32_add = \"~lib/builtins/i32.add\";\n  export const i64_add = \"~lib/builtins/i64.add\";\n  export const f32_add = \"~lib/builtins/f32.add\";\n  export const f64_add = \"~lib/builtins/f64.add\";\n  export const i32_sub = \"~lib/builtins/i32.sub\";\n  export const i64_sub = \"~lib/builtins/i64.sub\";\n  export const f32_sub = \"~lib/builtins/f32.sub\";\n  export const f64_sub = \"~lib/builtins/f64.sub\";\n  export const i32_mul = \"~lib/builtins/i32.mul\";\n  export const i64_mul = \"~lib/builtins/i64.mul\";\n  export const f32_mul = \"~lib/builtins/f32.mul\";\n  export const f64_mul = \"~lib/builtins/f64.mul\";\n  export const i32_div_s = \"~lib/builtins/i32.div_s\";\n  export const i32_div_u = \"~lib/builtins/i32.div_u\";\n  export const i64_div_s = \"~lib/builtins/i64.div_s\";\n  export const i64_div_u = \"~lib/builtins/i64.div_u\";\n  export const f32_div = \"~lib/builtins/f32.div\";\n  export const f64_div = \"~lib/builtins/f64.div\";\n\n  export const i32_eq = \"~lib/builtins/i32.eq\";\n  export const i64_eq = \"~lib/builtins/i64.eq\";\n  export const f32_eq = \"~lib/builtins/f32.eq\";\n  export const f64_eq = \"~lib/builtins/f64.eq\";\n  export const i32_ne = \"~lib/builtins/i32.ne\";\n  export const i64_ne = \"~lib/builtins/i64.ne\";\n  export const f32_ne = \"~lib/builtins/f32.ne\";\n  export const f64_ne = \"~lib/builtins/f64.ne\";\n\n  export const i32_rem_s = \"~lib/builtins/i32.rem_s\";\n  export const i32_rem_u = \"~lib/builtins/i32.rem_u\";\n  export const i64_rem_s = \"~lib/builtins/i64.rem_s\";\n  export const i64_rem_u = \"~lib/builtins/i64.rem_u\";\n\n  export const i32_load8_s = \"~lib/builtins/i32.load8_s\";\n  export const i32_load8_u = \"~lib/builtins/i32.load8_u\";\n  export const i32_load16_s = \"~lib/builtins/i32.load16_s\";\n  export const i32_load16_u = \"~lib/builtins/i32.load16_u\";\n  export const i32_load = \"~lib/builtins/i32.load\";\n  export const i64_load8_s = \"~lib/builtins/i64.load8_s\";\n  export const i64_load8_u = \"~lib/builtins/i64.load8_u\";\n  export const i64_load16_s = \"~lib/builtins/i64.load16_s\";\n  export const i64_load16_u = \"~lib/builtins/i64.load16_u\";\n  export const i64_load32_s = \"~lib/builtins/i64.load32_s\";\n  export const i64_load32_u = \"~lib/builtins/i64.load32_u\";\n  export const i64_load = \"~lib/builtins/i64.load\";\n  export const f32_load = \"~lib/builtins/f32.load\";\n  export const f64_load = \"~lib/builtins/f64.load\";\n  export const i32_store8 = \"~lib/builtins/i32.store8\";\n  export const i32_store16 = \"~lib/builtins/i32.store16\";\n  export const i32_store = \"~lib/builtins/i32.store\";\n  export const i64_store8 = \"~lib/builtins/i64.store8\";\n  export const i64_store16 = \"~lib/builtins/i64.store16\";\n  export const i64_store32 = \"~lib/builtins/i64.store32\";\n  export const i64_store = \"~lib/builtins/i64.store\";\n  export const f32_store = \"~lib/builtins/f32.store\";\n  export const f64_store = \"~lib/builtins/f64.store\";\n\n  export const i32_atomic_load8_u = \"~lib/builtins/i32.atomic.load8_u\";\n  export const i32_atomic_load16_u = \"~lib/builtins/i32.atomic.load16_u\";\n  export const i32_atomic_load = \"~lib/builtins/i32.atomic.load\";\n  export const i64_atomic_load8_u = \"~lib/builtins/i64.atomic.load8_u\";\n  export const i64_atomic_load16_u = \"~lib/builtins/i64.atomic.load16_u\";\n  export const i64_atomic_load32_u = \"~lib/builtins/i64.atomic.load32_u\";\n  export const i64_atomic_load = \"~lib/builtins/i64.atomic.load\";\n  export const i32_atomic_store8 = \"~lib/builtins/i32.atomic.store8\";\n  export const i32_atomic_store16 = \"~lib/builtins/i32.atomic.store16\";\n  export const i32_atomic_store = \"~lib/builtins/i32.atomic.store\";\n  export const i64_atomic_store8 = \"~lib/builtins/i64.atomic.store8\";\n  export const i64_atomic_store16 = \"~lib/builtins/i64.atomic.store16\";\n  export const i64_atomic_store32 = \"~lib/builtins/i64.atomic.store32\";\n  export const i64_atomic_store = \"~lib/builtins/i64.atomic.store\";\n  export const i32_atomic_rmw8_add_u = \"~lib/builtins/i32.atomic.rmw8.add_u\";\n  export const i32_atomic_rmw16_add_u = \"~lib/builtins/i32.atomic.rmw16.add_u\";\n  export const i32_atomic_rmw_add = \"~lib/builtins/i32.atomic.rmw.add\";\n  export const i64_atomic_rmw8_add_u = \"~lib/builtins/i64.atomic.rmw8.add_u\";\n  export const i64_atomic_rmw16_add_u = \"~lib/builtins/i64.atomic.rmw16.add_u\";\n  export const i64_atomic_rmw32_add_u = \"~lib/builtins/i64.atomic.rmw32.add_u\";\n  export const i64_atomic_rmw_add = \"~lib/builtins/i64.atomic.rmw.add\";\n  export const i32_atomic_rmw8_sub_u = \"~lib/builtins/i32.atomic.rmw8.sub_u\";\n  export const i32_atomic_rmw16_sub_u = \"~lib/builtins/i32.atomic.rmw16.sub_u\";\n  export const i32_atomic_rmw_sub = \"~lib/builtins/i32.atomic.rmw.sub\";\n  export const i64_atomic_rmw8_sub_u = \"~lib/builtins/i64.atomic.rmw8.sub_u\";\n  export const i64_atomic_rmw16_sub_u = \"~lib/builtins/i64.atomic.rmw16.sub_u\";\n  export const i64_atomic_rmw32_sub_u = \"~lib/builtins/i64.atomic.rmw32.sub_u\";\n  export const i64_atomic_rmw_sub = \"~lib/builtins/i64.atomic.rmw.sub\";\n  export const i32_atomic_rmw8_and_u = \"~lib/builtins/i32.atomic.rmw8.and_u\";\n  export const i32_atomic_rmw16_and_u = \"~lib/builtins/i32.atomic.rmw16.and_u\";\n  export const i32_atomic_rmw_and = \"~lib/builtins/i32.atomic.rmw.and\";\n  export const i64_atomic_rmw8_and_u = \"~lib/builtins/i64.atomic.rmw8.and_u\";\n  export const i64_atomic_rmw16_and_u = \"~lib/builtins/i64.atomic.rmw16.and_u\";\n  export const i64_atomic_rmw32_and_u = \"~lib/builtins/i64.atomic.rmw32.and_u\";\n  export const i64_atomic_rmw_and = \"~lib/builtins/i64.atomic.rmw.and\";\n  export const i32_atomic_rmw8_or_u = \"~lib/builtins/i32.atomic.rmw8.or_u\";\n  export const i32_atomic_rmw16_or_u = \"~lib/builtins/i32.atomic.rmw16.or_u\";\n  export const i32_atomic_rmw_or = \"~lib/builtins/i32.atomic.rmw.or\";\n  export const i64_atomic_rmw8_or_u = \"~lib/builtins/i64.atomic.rmw8.or_u\";\n  export const i64_atomic_rmw16_or_u = \"~lib/builtins/i64.atomic.rmw16.or_u\";\n  export const i64_atomic_rmw32_or_u = \"~lib/builtins/i64.atomic.rmw32.or_u\";\n  export const i64_atomic_rmw_or = \"~lib/builtins/i64.atomic.rmw.or\";\n  export const i32_atomic_rmw8_xor_u = \"~lib/builtins/i32.atomic.rmw8.xor_u\";\n  export const i32_atomic_rmw16_xor_u = \"~lib/builtins/i32.atomic.rmw16.xor_u\";\n  export const i32_atomic_rmw_xor = \"~lib/builtins/i32.atomic.rmw.xor\";\n  export const i64_atomic_rmw8_xor_u = \"~lib/builtins/i64.atomic.rmw8.xor_u\";\n  export const i64_atomic_rmw16_xor_u = \"~lib/builtins/i64.atomic.rmw16.xor_u\";\n  export const i64_atomic_rmw32_xor_u = \"~lib/builtins/i64.atomic.rmw32.xor_u\";\n  export const i64_atomic_rmw_xor = \"~lib/builtins/i64.atomic.rmw.xor\";\n  export const i32_atomic_rmw8_xchg_u = \"~lib/builtins/i32.atomic.rmw8.xchg_u\";\n  export const i32_atomic_rmw16_xchg_u = \"~lib/builtins/i32.atomic.rmw16.xchg_u\";\n  export const i32_atomic_rmw_xchg = \"~lib/builtins/i32.atomic.rmw.xchg\";\n  export const i64_atomic_rmw8_xchg_u = \"~lib/builtins/i64.atomic.rmw8.xchg_u\";\n  export const i64_atomic_rmw16_xchg_u = \"~lib/builtins/i64.atomic.rmw16.xchg_u\";\n  export const i64_atomic_rmw32_xchg_u = \"~lib/builtins/i64.atomic.rmw32.xchg_u\";\n  export const i64_atomic_rmw_xchg = \"~lib/builtins/i64.atomic.rmw.xchg\";\n  export const i32_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw8.cmpxchg_u\";\n  export const i32_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw16.cmpxchg_u\";\n  export const i32_atomic_rmw_cmpxchg = \"~lib/builtins/i32.atomic.rmw.cmpxchg\";\n  export const i64_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw8.cmpxchg_u\";\n  export const i64_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw16.cmpxchg_u\";\n  export const i64_atomic_rmw32_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw32.cmpxchg_u\";\n  export const i64_atomic_rmw_cmpxchg = \"~lib/builtins/i64.atomic.rmw.cmpxchg\";\n  export const i32_wait = \"~lib/builtins/i32.wait\";\n  export const i64_wait = \"~lib/builtins/i64.wait\";\n\n  export const v128_splat = \"~lib/builtins/v128.splat\";\n  export const v128_extract_lane = \"~lib/builtins/v128.extract_lane\";\n  export const v128_replace_lane = \"~lib/builtins/v128.replace_lane\";\n  export const v128_shuffle = \"~lib/builtins/v128.shuffle\";\n  export const v128_swizzle = \"~lib/builtins/v128.swizzle\";\n  export const v128_load_splat = \"~lib/builtins/v128.load_splat\";\n  export const v128_load_ext = \"~lib/builtins/v128.load_ext\";\n  export const v128_load_zero = \"~lib/builtins/v128.load_zero\";\n  export const v128_load_lane = \"~lib/builtins/v128.load_lane\";\n  export const v128_store_lane = \"~lib/builtins/v128.store_lane\";\n  export const v128_load = \"~lib/builtins/v128.load\";\n  export const v128_load8x8_s = \"~lib/builtins/v128.load8x8_s\";\n  export const v128_load8x8_u = \"~lib/builtins/v128.load8x8_u\";\n  export const v128_load16x4_s = \"~lib/builtins/v128.load16x4_s\";\n  export const v128_load16x4_u = \"~lib/builtins/v128.load16x4_u\";\n  export const v128_load32x2_s = \"~lib/builtins/v128.load32x2_s\";\n  export const v128_load32x2_u = \"~lib/builtins/v128.load32x2_u\";\n  export const v128_load8_splat = \"~lib/builtins/v128.load8_splat\";\n  export const v128_load16_splat = \"~lib/builtins/v128.load16_splat\";\n  export const v128_load32_splat = \"~lib/builtins/v128.load32_splat\";\n  export const v128_load64_splat = \"~lib/builtins/v128.load64_splat\";\n  export const v128_load32_zero = \"~lib/builtins/v128.load32_zero\";\n  export const v128_load64_zero = \"~lib/builtins/v128.load64_zero\";\n  export const v128_load8_lane = \"~lib/builtins/v128.load8_lane\";\n  export const v128_load16_lane = \"~lib/builtins/v128.load16_lane\";\n  export const v128_load32_lane = \"~lib/builtins/v128.load32_lane\";\n  export const v128_load64_lane = \"~lib/builtins/v128.load64_lane\";\n  export const v128_store8_lane = \"~lib/builtins/v128.store8_lane\";\n  export const v128_store16_lane = \"~lib/builtins/v128.store16_lane\";\n  export const v128_store32_lane = \"~lib/builtins/v128.store32_lane\";\n  export const v128_store64_lane = \"~lib/builtins/v128.store64_lane\";\n  export const v128_store = \"~lib/builtins/v128.store\";\n  export const v128_add = \"~lib/builtins/v128.add\";\n  export const v128_sub = \"~lib/builtins/v128.sub\";\n  export const v128_mul = \"~lib/builtins/v128.mul\";\n  export const v128_div = \"~lib/builtins/v128.div\";\n  export const v128_neg = \"~lib/builtins/v128.neg\";\n  export const v128_add_sat = \"~lib/builtins/v128.add_sat\";\n  export const v128_sub_sat = \"~lib/builtins/v128.sub_sat\";\n  export const v128_shl = \"~lib/builtins/v128.shl\";\n  export const v128_shr = \"~lib/builtins/v128.shr\";\n  export const v128_and = \"~lib/builtins/v128.and\";\n  export const v128_or = \"~lib/builtins/v128.or\";\n  export const v128_xor = \"~lib/builtins/v128.xor\";\n  export const v128_andnot = \"~lib/builtins/v128.andnot\";\n  export const v128_not = \"~lib/builtins/v128.not\";\n  export const v128_bitselect = \"~lib/builtins/v128.bitselect\";\n  export const v128_any_true = \"~lib/builtins/v128.any_true\";\n  export const v128_all_true = \"~lib/builtins/v128.all_true\";\n  export const v128_bitmask = \"~lib/builtins/v128.bitmask\";\n  export const v128_popcnt = \"~lib/builtins/v128.popcnt\";\n  export const v128_min = \"~lib/builtins/v128.min\";\n  export const v128_max = \"~lib/builtins/v128.max\";\n  export const v128_pmin = \"~lib/builtins/v128.pmin\";\n  export const v128_pmax = \"~lib/builtins/v128.pmax\";\n  export const v128_dot = \"~lib/builtins/v128.dot\";\n  export const v128_avgr = \"~lib/builtins/v128.avgr\";\n  export const v128_abs = \"~lib/builtins/v128.abs\";\n  export const v128_sqrt = \"~lib/builtins/v128.sqrt\";\n  export const v128_ceil = \"~lib/builtins/v128.ceil\";\n  export const v128_floor = \"~lib/builtins/v128.floor\";\n  export const v128_trunc = \"~lib/builtins/v128.trunc\";\n  export const v128_nearest = \"~lib/builtins/v128.nearest\";\n  export const v128_eq = \"~lib/builtins/v128.eq\";\n  export const v128_ne = \"~lib/builtins/v128.ne\";\n  export const v128_lt = \"~lib/builtins/v128.lt\";\n  export const v128_le = \"~lib/builtins/v128.le\";\n  export const v128_gt = \"~lib/builtins/v128.gt\";\n  export const v128_ge = \"~lib/builtins/v128.ge\";\n  export const v128_convert = \"~lib/builtins/v128.convert\";\n  export const v128_convert_low = \"~lib/builtins/v128.convert_low\";\n  export const v128_trunc_sat = \"~lib/builtins/v128.trunc_sat\";\n  export const v128_trunc_sat_zero = \"~lib/builtins/v128.trunc_sat_zero\";\n  export const v128_narrow = \"~lib/builtins/v128.narrow\";\n  export const v128_extend_low = \"~lib/builtins/v128.extend_low\";\n  export const v128_extend_high = \"~lib/builtins/v128.extend_high\";\n  export const v128_extadd_pairwise = \"~lib/builtins/v128.extadd_pairwise\";\n  export const v128_demote_zero = \"~lib/builtins/v128.demote_zero\";\n  export const v128_promote_low = \"~lib/builtins/v128.promote_low\";\n  export const v128_q15mulr_sat = \"~lib/builtins/v128.q15mulr_sat\";\n  export const v128_extmul_low = \"~lib/builtins/v128.extmul_low\";\n  export const v128_extmul_high = \"~lib/builtins/v128.extmul_high\";\n\n  export const i8x16 = \"~lib/builtins/i8x16\";\n  export const i16x8 = \"~lib/builtins/i16x8\";\n  export const i32x4 = \"~lib/builtins/i32x4\";\n  export const i64x2 = \"~lib/builtins/i64x2\";\n  export const f32x4 = \"~lib/builtins/f32x4\";\n  export const f64x2 = \"~lib/builtins/f64x2\";\n\n  export const i8x16_splat = \"~lib/builtins/i8x16.splat\";\n  export const i8x16_extract_lane_s = \"~lib/builtins/i8x16.extract_lane_s\";\n  export const i8x16_extract_lane_u = \"~lib/builtins/i8x16.extract_lane_u\";\n  export const i8x16_replace_lane = \"~lib/builtins/i8x16.replace_lane\";\n  export const i8x16_add = \"~lib/builtins/i8x16.add\";\n  export const i8x16_sub = \"~lib/builtins/i8x16.sub\";\n  export const i8x16_mul = \"~lib/builtins/i8x16.mul\";\n  export const i8x16_min_s = \"~lib/builtins/i8x16.min_s\";\n  export const i8x16_min_u = \"~lib/builtins/i8x16.min_u\";\n  export const i8x16_max_s = \"~lib/builtins/i8x16.max_s\";\n  export const i8x16_max_u = \"~lib/builtins/i8x16.max_u\";\n  export const i8x16_avgr_u = \"~lib/builtins/i8x16.avgr_u\";\n  export const i8x16_abs = \"~lib/builtins/i8x16.abs\";\n  export const i8x16_neg = \"~lib/builtins/i8x16.neg\";\n  export const i8x16_add_sat_s = \"~lib/builtins/i8x16.add_sat_s\";\n  export const i8x16_add_sat_u = \"~lib/builtins/i8x16.add_sat_u\";\n  export const i8x16_sub_sat_s = \"~lib/builtins/i8x16.sub_sat_s\";\n  export const i8x16_sub_sat_u = \"~lib/builtins/i8x16.sub_sat_u\";\n  export const i8x16_shl = \"~lib/builtins/i8x16.shl\";\n  export const i8x16_shr_s = \"~lib/builtins/i8x16.shr_s\";\n  export const i8x16_shr_u = \"~lib/builtins/i8x16.shr_u\";\n  export const i8x16_all_true = \"~lib/builtins/i8x16.all_true\";\n  export const i8x16_bitmask = \"~lib/builtins/i8x16.bitmask\";\n  export const i8x16_popcnt = \"~lib/builtins/i8x16.popcnt\";\n  export const i8x16_eq = \"~lib/builtins/i8x16.eq\";\n  export const i8x16_ne = \"~lib/builtins/i8x16.ne\";\n  export const i8x16_lt_s = \"~lib/builtins/i8x16.lt_s\";\n  export const i8x16_lt_u = \"~lib/builtins/i8x16.lt_u\";\n  export const i8x16_le_s = \"~lib/builtins/i8x16.le_s\";\n  export const i8x16_le_u = \"~lib/builtins/i8x16.le_u\";\n  export const i8x16_gt_s = \"~lib/builtins/i8x16.gt_s\";\n  export const i8x16_gt_u = \"~lib/builtins/i8x16.gt_u\";\n  export const i8x16_ge_s = \"~lib/builtins/i8x16.ge_s\";\n  export const i8x16_ge_u = \"~lib/builtins/i8x16.ge_u\";\n  export const i8x16_narrow_i16x8_s = \"~lib/builtins/i8x16.narrow_i16x8_s\";\n  export const i8x16_narrow_i16x8_u = \"~lib/builtins/i8x16.narrow_i16x8_u\";\n  export const i8x16_shuffle = \"~lib/builtins/i8x16.shuffle\";\n  export const i8x16_swizzle = \"~lib/builtins/i8x16.swizzle\";\n\n  export const i16x8_splat = \"~lib/builtins/i16x8.splat\";\n  export const i16x8_extract_lane_s = \"~lib/builtins/i16x8.extract_lane_s\";\n  export const i16x8_extract_lane_u = \"~lib/builtins/i16x8.extract_lane_u\";\n  export const i16x8_replace_lane = \"~lib/builtins/i16x8.replace_lane\";\n  export const i16x8_add = \"~lib/builtins/i16x8.add\";\n  export const i16x8_sub = \"~lib/builtins/i16x8.sub\";\n  export const i16x8_mul = \"~lib/builtins/i16x8.mul\";\n  export const i16x8_min_s = \"~lib/builtins/i16x8.min_s\";\n  export const i16x8_min_u = \"~lib/builtins/i16x8.min_u\";\n  export const i16x8_max_s = \"~lib/builtins/i16x8.max_s\";\n  export const i16x8_max_u = \"~lib/builtins/i16x8.max_u\";\n  export const i16x8_avgr_u = \"~lib/builtins/i16x8.avgr_u\";\n  export const i16x8_abs = \"~lib/builtins/i16x8.abs\";\n  export const i16x8_neg = \"~lib/builtins/i16x8.neg\";\n  export const i16x8_add_sat_s = \"~lib/builtins/i16x8.add_sat_s\";\n  export const i16x8_add_sat_u = \"~lib/builtins/i16x8.add_sat_u\";\n  export const i16x8_sub_sat_s = \"~lib/builtins/i16x8.sub_sat_s\";\n  export const i16x8_sub_sat_u = \"~lib/builtins/i16x8.sub_sat_u\";\n  export const i16x8_shl = \"~lib/builtins/i16x8.shl\";\n  export const i16x8_shr_s = \"~lib/builtins/i16x8.shr_s\";\n  export const i16x8_shr_u = \"~lib/builtins/i16x8.shr_u\";\n  export const i16x8_all_true = \"~lib/builtins/i16x8.all_true\";\n  export const i16x8_bitmask = \"~lib/builtins/i16x8.bitmask\";\n  export const i16x8_eq = \"~lib/builtins/i16x8.eq\";\n  export const i16x8_ne = \"~lib/builtins/i16x8.ne\";\n  export const i16x8_lt_s = \"~lib/builtins/i16x8.lt_s\";\n  export const i16x8_lt_u = \"~lib/builtins/i16x8.lt_u\";\n  export const i16x8_le_s = \"~lib/builtins/i16x8.le_s\";\n  export const i16x8_le_u = \"~lib/builtins/i16x8.le_u\";\n  export const i16x8_gt_s = \"~lib/builtins/i16x8.gt_s\";\n  export const i16x8_gt_u = \"~lib/builtins/i16x8.gt_u\";\n  export const i16x8_ge_s = \"~lib/builtins/i16x8.ge_s\";\n  export const i16x8_ge_u = \"~lib/builtins/i16x8.ge_u\";\n  export const i16x8_narrow_i32x4_s = \"~lib/builtins/i16x8.narrow_i32x4_s\";\n  export const i16x8_narrow_i32x4_u = \"~lib/builtins/i16x8.narrow_i32x4_u\";\n  export const i16x8_extend_low_i8x16_s = \"~lib/builtins/i16x8.extend_low_i8x16_s\";\n  export const i16x8_extend_low_i8x16_u = \"~lib/builtins/i16x8.extend_low_i8x16_u\";\n  export const i16x8_extend_high_i8x16_s = \"~lib/builtins/i16x8.extend_high_i8x16_s\";\n  export const i16x8_extend_high_i8x16_u = \"~lib/builtins/i16x8.extend_high_i8x16_u\";\n  export const i16x8_extadd_pairwise_i8x16_s = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_s\";\n  export const i16x8_extadd_pairwise_i8x16_u = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_u\";\n  export const i16x8_q15mulr_sat_s = \"~lib/builtins/i16x8.q15mulr_sat_s\";\n  export const i16x8_extmul_low_i8x16_s = \"~lib/builtins/i16x8.extmul_low_i8x16_s\";\n  export const i16x8_extmul_low_i8x16_u = \"~lib/builtins/i16x8.extmul_low_i8x16_u\";\n  export const i16x8_extmul_high_i8x16_s = \"~lib/builtins/i16x8.extmul_high_i8x16_s\";\n  export const i16x8_extmul_high_i8x16_u = \"~lib/builtins/i16x8.extmul_high_i8x16_u\";\n  export const i16x8_shuffle = \"~lib/builtins/i16x8.shuffle\";\n  export const i16x8_swizzle = \"~lib/builtins/i16x8.swizzle\";\n\n  export const i32x4_splat = \"~lib/builtins/i32x4.splat\";\n  export const i32x4_extract_lane = \"~lib/builtins/i32x4.extract_lane\";\n  export const i32x4_replace_lane = \"~lib/builtins/i32x4.replace_lane\";\n  export const i32x4_add = \"~lib/builtins/i32x4.add\";\n  export const i32x4_sub = \"~lib/builtins/i32x4.sub\";\n  export const i32x4_mul = \"~lib/builtins/i32x4.mul\";\n  export const i32x4_min_s = \"~lib/builtins/i32x4.min_s\";\n  export const i32x4_min_u = \"~lib/builtins/i32x4.min_u\";\n  export const i32x4_max_s = \"~lib/builtins/i32x4.max_s\";\n  export const i32x4_max_u = \"~lib/builtins/i32x4.max_u\";\n  export const i32x4_dot_i16x8_s = \"~lib/builtins/i32x4.dot_i16x8_s\";\n  export const i32x4_abs = \"~lib/builtins/i32x4.abs\";\n  export const i32x4_neg = \"~lib/builtins/i32x4.neg\";\n  export const i32x4_shl = \"~lib/builtins/i32x4.shl\";\n  export const i32x4_shr_s = \"~lib/builtins/i32x4.shr_s\";\n  export const i32x4_shr_u = \"~lib/builtins/i32x4.shr_u\";\n  export const i32x4_all_true = \"~lib/builtins/i32x4.all_true\";\n  export const i32x4_bitmask = \"~lib/builtins/i32x4.bitmask\";\n  export const i32x4_eq = \"~lib/builtins/i32x4.eq\";\n  export const i32x4_ne = \"~lib/builtins/i32x4.ne\";\n  export const i32x4_lt_s = \"~lib/builtins/i32x4.lt_s\";\n  export const i32x4_lt_u = \"~lib/builtins/i32x4.lt_u\";\n  export const i32x4_le_s = \"~lib/builtins/i32x4.le_s\";\n  export const i32x4_le_u = \"~lib/builtins/i32x4.le_u\";\n  export const i32x4_gt_s = \"~lib/builtins/i32x4.gt_s\";\n  export const i32x4_gt_u = \"~lib/builtins/i32x4.gt_u\";\n  export const i32x4_ge_s = \"~lib/builtins/i32x4.ge_s\";\n  export const i32x4_ge_u = \"~lib/builtins/i32x4.ge_u\";\n  export const i32x4_trunc_sat_f32x4_s = \"~lib/builtins/i32x4.trunc_sat_f32x4_s\";\n  export const i32x4_trunc_sat_f32x4_u = \"~lib/builtins/i32x4.trunc_sat_f32x4_u\";\n  export const i32x4_trunc_sat_f64x2_s_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_s_zero\";\n  export const i32x4_trunc_sat_f64x2_u_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_u_zero\";\n  export const i32x4_extend_low_i16x8_s = \"~lib/builtins/i32x4.extend_low_i16x8_s\";\n  export const i32x4_extend_low_i16x8_u = \"~lib/builtins/i32x4.extend_low_i16x8_u\";\n  export const i32x4_extend_high_i16x8_s = \"~lib/builtins/i32x4.extend_high_i16x8_s\";\n  export const i32x4_extend_high_i16x8_u = \"~lib/builtins/i32x4.extend_high_i16x8_u\";\n  export const i32x4_extadd_pairwise_i16x8_s = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_s\";\n  export const i32x4_extadd_pairwise_i16x8_u = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_u\";\n  export const i32x4_extmul_low_i16x8_s = \"~lib/builtins/i32x4.extmul_low_i16x8_s\";\n  export const i32x4_extmul_low_i16x8_u = \"~lib/builtins/i32x4.extmul_low_i16x8_u\";\n  export const i32x4_extmul_high_i16x8_s = \"~lib/builtins/i32x4.extmul_high_i16x8_s\";\n  export const i32x4_extmul_high_i16x8_u = \"~lib/builtins/i32x4.extmul_high_i16x8_u\";\n  export const i32x4_shuffle = \"~lib/builtins/i32x4.shuffle\";\n  export const i32x4_swizzle = \"~lib/builtins/i32x4.swizzle\";\n\n  export const i64x2_splat = \"~lib/builtins/i64x2.splat\";\n  export const i64x2_extract_lane = \"~lib/builtins/i64x2.extract_lane\";\n  export const i64x2_replace_lane = \"~lib/builtins/i64x2.replace_lane\";\n  export const i64x2_add = \"~lib/builtins/i64x2.add\";\n  export const i64x2_sub = \"~lib/builtins/i64x2.sub\";\n  export const i64x2_mul = \"~lib/builtins/i64x2.mul\";\n  export const i64x2_abs = \"~lib/builtins/i64x2.abs\";\n  export const i64x2_neg = \"~lib/builtins/i64x2.neg\";\n  export const i64x2_shl = \"~lib/builtins/i64x2.shl\";\n  export const i64x2_shr_s = \"~lib/builtins/i64x2.shr_s\";\n  export const i64x2_shr_u = \"~lib/builtins/i64x2.shr_u\";\n  export const i64x2_all_true = \"~lib/builtins/i64x2.all_true\";\n  export const i64x2_bitmask = \"~lib/builtins/i64x2.bitmask\";\n  export const i64x2_eq = \"~lib/builtins/i64x2.eq\";\n  export const i64x2_ne = \"~lib/builtins/i64x2.ne\";\n  export const i64x2_lt_s = \"~lib/builtins/i64x2.lt_s\";\n  export const i64x2_lt_u = \"~lib/builtins/i64x2.lt_u\";\n  export const i64x2_le_s = \"~lib/builtins/i64x2.le_s\";\n  export const i64x2_le_u = \"~lib/builtins/i64x2.le_u\";\n  export const i64x2_gt_s = \"~lib/builtins/i64x2.gt_s\";\n  export const i64x2_gt_u = \"~lib/builtins/i64x2.gt_u\";\n  export const i64x2_ge_s = \"~lib/builtins/i64x2.ge_s\";\n  export const i64x2_ge_u = \"~lib/builtins/i64x2.ge_u\";\n  export const i64x2_extend_low_i32x4_s = \"~lib/builtins/i64x2.extend_low_i32x4_s\";\n  export const i64x2_extend_low_i32x4_u = \"~lib/builtins/i64x2.extend_low_i32x4_u\";\n  export const i64x2_extend_high_i32x4_s = \"~lib/builtins/i64x2.extend_high_i32x4_s\";\n  export const i64x2_extend_high_i32x4_u = \"~lib/builtins/i64x2.extend_high_i32x4_u\";\n  export const i64x2_extmul_low_i32x4_s = \"~lib/builtins/i64x2.extmul_low_i32x4_s\";\n  export const i64x2_extmul_low_i32x4_u = \"~lib/builtins/i64x2.extmul_low_i32x4_u\";\n  export const i64x2_extmul_high_i32x4_s = \"~lib/builtins/i64x2.extmul_high_i32x4_s\";\n  export const i64x2_extmul_high_i32x4_u = \"~lib/builtins/i64x2.extmul_high_i32x4_u\";\n  export const i64x2_shuffle = \"~lib/builtins/i64x2.shuffle\";\n  export const i64x2_swizzle = \"~lib/builtins/i64x2.swizzle\";\n\n  export const f32x4_splat = \"~lib/builtins/f32x4.splat\";\n  export const f32x4_extract_lane = \"~lib/builtins/f32x4.extract_lane\";\n  export const f32x4_replace_lane = \"~lib/builtins/f32x4.replace_lane\";\n  export const f32x4_add = \"~lib/builtins/f32x4.add\";\n  export const f32x4_sub = \"~lib/builtins/f32x4.sub\";\n  export const f32x4_mul = \"~lib/builtins/f32x4.mul\";\n  export const f32x4_div = \"~lib/builtins/f32x4.div\";\n  export const f32x4_neg = \"~lib/builtins/f32x4.neg\";\n  export const f32x4_min = \"~lib/builtins/f32x4.min\";\n  export const f32x4_max = \"~lib/builtins/f32x4.max\";\n  export const f32x4_pmin = \"~lib/builtins/f32x4.pmin\";\n  export const f32x4_pmax = \"~lib/builtins/f32x4.pmax\";\n  export const f32x4_abs = \"~lib/builtins/f32x4.abs\";\n  export const f32x4_sqrt = \"~lib/builtins/f32x4.sqrt\";\n  export const f32x4_ceil = \"~lib/builtins/f32x4.ceil\";\n  export const f32x4_floor = \"~lib/builtins/f32x4.floor\";\n  export const f32x4_trunc = \"~lib/builtins/f32x4.trunc\";\n  export const f32x4_nearest = \"~lib/builtins/f32x4.nearest\";\n  export const f32x4_eq = \"~lib/builtins/f32x4.eq\";\n  export const f32x4_ne = \"~lib/builtins/f32x4.ne\";\n  export const f32x4_lt = \"~lib/builtins/f32x4.lt\";\n  export const f32x4_le = \"~lib/builtins/f32x4.le\";\n  export const f32x4_gt = \"~lib/builtins/f32x4.gt\";\n  export const f32x4_ge = \"~lib/builtins/f32x4.ge\";\n  export const f32x4_convert_i32x4_s = \"~lib/builtins/f32x4.convert_i32x4_s\";\n  export const f32x4_convert_i32x4_u = \"~lib/builtins/f32x4.convert_i32x4_u\";\n  export const f32x4_demote_f64x2_zero = \"~lib/builtins/f32x4.demote_f64x2_zero\";\n  export const f32x4_shuffle = \"~lib/builtins/f32x4.shuffle\";\n  export const f32x4_swizzle = \"~lib/builtins/f32x4.swizzle\";\n\n  export const f64x2_splat = \"~lib/builtins/f64x2.splat\";\n  export const f64x2_extract_lane = \"~lib/builtins/f64x2.extract_lane\";\n  export const f64x2_replace_lane = \"~lib/builtins/f64x2.replace_lane\";\n  export const f64x2_add = \"~lib/builtins/f64x2.add\";\n  export const f64x2_sub = \"~lib/builtins/f64x2.sub\";\n  export const f64x2_mul = \"~lib/builtins/f64x2.mul\";\n  export const f64x2_div = \"~lib/builtins/f64x2.div\";\n  export const f64x2_neg = \"~lib/builtins/f64x2.neg\";\n  export const f64x2_min = \"~lib/builtins/f64x2.min\";\n  export const f64x2_max = \"~lib/builtins/f64x2.max\";\n  export const f64x2_pmin = \"~lib/builtins/f64x2.pmin\";\n  export const f64x2_pmax = \"~lib/builtins/f64x2.pmax\";\n  export const f64x2_abs = \"~lib/builtins/f64x2.abs\";\n  export const f64x2_sqrt = \"~lib/builtins/f64x2.sqrt\";\n  export const f64x2_ceil = \"~lib/builtins/f64x2.ceil\";\n  export const f64x2_floor = \"~lib/builtins/f64x2.floor\";\n  export const f64x2_trunc = \"~lib/builtins/f64x2.trunc\";\n  export const f64x2_nearest = \"~lib/builtins/f64x2.nearest\";\n  export const f64x2_eq = \"~lib/builtins/f64x2.eq\";\n  export const f64x2_ne = \"~lib/builtins/f64x2.ne\";\n  export const f64x2_lt = \"~lib/builtins/f64x2.lt\";\n  export const f64x2_le = \"~lib/builtins/f64x2.le\";\n  export const f64x2_gt = \"~lib/builtins/f64x2.gt\";\n  export const f64x2_ge = \"~lib/builtins/f64x2.ge\";\n  export const f64x2_convert_low_i32x4_s = \"~lib/builtins/f64x2.convert_low_i32x4_s\";\n  export const f64x2_convert_low_i32x4_u = \"~lib/builtins/f64x2.convert_low_i32x4_u\";\n  export const f64x2_promote_low_f32x4 = \"~lib/builtins/f64x2.promote_low_f32x4\";\n  export const f64x2_shuffle = \"~lib/builtins/f64x2.shuffle\";\n  export const f64x2_swizzle = \"~lib/builtins/f64x2.swizzle\";\n\n  export const i31_new = \"~lib/builtins/i31.new\";\n  export const i31_get = \"~lib/builtins/i31.get\";\n\n  // internals\n  export const data_end = \"~lib/memory/__data_end\";\n  export const stack_pointer = \"~lib/memory/__stack_pointer\";\n  export const heap_base = \"~lib/memory/__heap_base\";\n  export const rtti_base = \"~lib/rt/__rtti_base\";\n  export const visit_globals = \"~lib/rt/__visit_globals\";\n  export const visit_members = \"~lib/rt/__visit_members\";\n  export const tostack = \"~lib/rt/__tostack\";\n\n  // std/number.ts\n  export const isNaN = \"~lib/number/isNaN\";\n  export const isFinite = \"~lib/number/isFinite\";\n\n  // std/diagnostics.ts\n  export const ERROR = \"~lib/diagnostics/ERROR\";\n  export const WARNING = \"~lib/diagnostics/WARNING\";\n  export const INFO = \"~lib/diagnostics/INFO\";\n\n  // std/function.ts\n  export const Function = \"~lib/function/Function\";\n\n  // std/memory.ts\n  export const memory_size = \"~lib/memory/memory.size\";\n  export const memory_grow = \"~lib/memory/memory.grow\";\n  export const memory_copy = \"~lib/memory/memory.copy\";\n  export const memory_fill = \"~lib/memory/memory.fill\";\n  export const memory_data = \"~lib/memory/memory.data\";\n\n  // std/typedarray.ts\n  export const Int8Array = \"~lib/typedarray/Int8Array\";\n  export const Uint8Array = \"~lib/typedarray/Uint8Array\";\n  export const Uint8ClampedArray = \"~lib/typedarray/Uint8ClampedArray\";\n  export const Int16Array = \"~lib/typedarray/Int16Array\";\n  export const Uint16Array = \"~lib/typedarray/Uint16Array\";\n  export const Int32Array = \"~lib/typedarray/Int32Array\";\n  export const Uint32Array = \"~lib/typedarray/Uint32Array\";\n  export const Int64Array = \"~lib/typedarray/Int64Array\";\n  export const Uint64Array = \"~lib/typedarray/Uint64Array\";\n  export const Float32Array = \"~lib/typedarray/Float32Array\";\n  export const Float64Array = \"~lib/typedarray/Float64Array\";\n\n  // std/string.ts\n  export const String_raw = \"~lib/string/String.raw\";\n  export const String_eq = \"~lib/string/String.__eq\";\n  export const String_ne = \"~lib/string/String.__ne\";\n  export const String_not = \"~lib/string/String.__not\";\n\n  // std/object.ts\n  export const Object = \"~lib/object/Object\";\n}\n\n/** Builtin compilation context. */\nexport class BuiltinContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Prototype being called. */\n    public prototype: FunctionPrototype,\n    /** Provided type arguments. */\n    public typeArguments: Type[] | null,\n    /** Provided operands. */\n    public operands: Expression[],\n    /** Provided this operand, if any. */\n    public thisOperand: Expression | null,\n    /** Contextual type. */\n    public contextualType: Type,\n    /** Respective call expression. */\n    public reportNode: CallExpression,\n    /** Whether originating from inline assembly. */\n    public contextIsExact: bool\n  ) {}\n}\n\n/** Global builtins map. */\nexport const builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n/** Function builtins map. */\nexport const function_builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n// === Static type evaluation =================================================================\n\n// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool\nfunction builtin_isBoolean(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isBooleanValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isBoolean, builtin_isBoolean);\n\n// isInteger<T!>() / isInteger<T?>(value: T) -> bool\nfunction builtin_isInteger(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isIntegerValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isInteger, builtin_isInteger);\n\n// isSigned<T!>() / isSigned<T?>(value: T) -> bool\nfunction builtin_isSigned(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isSignedIntegerValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isSigned, builtin_isSigned);\n\n// isFloat<T!>() / isFloat<T?>(value: T) -> bool\nfunction builtin_isFloat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isFloatValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isFloat, builtin_isFloat);\n\n// isVector<T!>() / isVector<T?>(value: T) -> bool\nfunction builtin_isVector(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isVectorValue ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isVector, builtin_isVector);\n\n// isReference<T!>() / isReference<T?>(value: T) -> bool\nfunction builtin_isReference(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isReference ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isReference, builtin_isReference);\n\n// isString<T!>() / isString<T?>(value: T) -> bool\nfunction builtin_isString(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.isAssignableTo(compiler.program.stringInstance)\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltins.set(BuiltinNames.isString, builtin_isString);\n\n// isArray<T!>() / isArray<T?>(value: T) -> bool\nfunction builtin_isArray(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.extendsPrototype(compiler.program.arrayPrototype)\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltins.set(BuiltinNames.isArray, builtin_isArray);\n\n// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool\nfunction builtin_isArrayLike(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.isArrayLike\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltins.set(BuiltinNames.isArrayLike, builtin_isArrayLike);\n\n// isFunction<T!> / isFunction<T?>(value: T) -> bool\nfunction builtin_isFunction(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isFunction ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isFunction, builtin_isFunction);\n\n// isNullable<T!> / isNullable<T?>(value: T) -> bool\nfunction builtin_isNullable(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isNullableReference ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isNullable, builtin_isNullable);\n\n// isDefined(expression) -> bool\nfunction builtin_isDefined(ctx: BuiltinContext): ExpressionRef {\n  // Note that `isDefined` neither compiles nor evaluates the given expression\n  // but exclusively performs a check whether it can be compiled in theory.\n  // This is not exactly unsafe due to only seemingly having side effects which\n  // actually never happen, but may confuse tooling unaware of its semantics.\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let element = compiler.resolver.lookupExpression(\n    ctx.operands[0],\n    compiler.currentFlow,\n    Type.auto,\n    ReportMode.Swallow\n  );\n  return module.i32(element ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isDefined, builtin_isDefined);\n\n// isConstant(expression) -> bool\nfunction builtin_isConstant(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let expr = compiler.compileExpression(ctx.operands[0], Type.auto);\n  compiler.currentType = Type.bool;\n  if (!mustPreserveSideEffects(expr, module.ref)) {\n    return module.i32(module.isConstExpression(expr) ? 1 : 0);\n  }\n  return module.block(null, [\n    module.maybeDrop(expr),\n    module.i32(0)\n  ], getExpressionType(expr));\n}\nbuiltins.set(BuiltinNames.isConstant, builtin_isConstant);\n\n// isManaged<T!>() -> bool\nfunction builtin_isManaged(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isManaged ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isManaged, builtin_isManaged);\n\n// isVoid<T!>() -> bool\nfunction builtin_isVoid(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.kind == TypeKind.Void ? 1 : 0));\n}\nbuiltins.set(BuiltinNames.isVoid, builtin_isVoid);\n\n// lengthof<T!>() -> i32\nfunction builtin_lengthof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.i32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.signatureReference;\n  if (!signatureReference) {\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_call_signatures,\n      ctx.reportNode.range, type.toString()\n    );\n    return module.unreachable();\n  }\n  return reifyConstantType(ctx, module.i32(signatureReference.parameterTypes.length));\n}\nbuiltins.set(BuiltinNames.lengthof, builtin_lengthof);\n\n// sizeof<T!>() -> usize*\nfunction builtin_sizeof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  let type = ctx.typeArguments![0];\n  let byteSize = type.byteSize;\n  if (!byteSize) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"sizeof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.sizeof, builtin_sizeof);\n\n// alignof<T!>() -> usize*\nfunction builtin_alignof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  let type = ctx.typeArguments![0];\n  let byteSize = type.byteSize;\n  if (!isPowerOf2(byteSize)) { // implies == 0\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"alignof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.alignof, builtin_alignof);\n\n// offsetof<T!>(fieldName?: string) -> usize*\nfunction builtin_offsetof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 0, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let contextualType = ctx.contextualType;\n  let type = ctx.typeArguments![0];\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (!classReference) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"offsetof\", type.toString()\n    );\n    if (compiler.options.isWasm64) {\n      if (contextualType.isIntegerValue && contextualType.size <= 32) {\n        compiler.currentType = Type.u32;\n      }\n    } else {\n      if (contextualType.isIntegerValue && contextualType.size == 64) {\n        compiler.currentType = Type.u64;\n      }\n    }\n    return module.unreachable();\n  }\n  if (operands.length) {\n    let firstOperand = operands[0];\n    if (!firstOperand.isLiteralKind(LiteralKind.String)) {\n      compiler.error(\n        DiagnosticCode.String_literal_expected,\n        operands[0].range\n      );\n      return module.unreachable();\n    }\n    let fieldName = (<StringLiteralExpression>firstOperand).value;\n    let fieldMember = classReference.getMember(fieldName);\n    if (fieldMember && fieldMember.kind == ElementKind.PropertyPrototype) {\n      let property = (<PropertyPrototype>fieldMember).instance;\n      if (property && property.isField) {\n        assert(property.memoryOffset >= 0);\n        return contextualUsize(compiler, i64_new(property.memoryOffset), contextualType);\n      }\n    }\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_property_1,\n      firstOperand.range, classReference.internalName, fieldName\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);\n}\nbuiltins.set(BuiltinNames.offsetof, builtin_offsetof);\n\n// nameof<T> -> string\nfunction builtin_nameof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let resultType = checkConstantType(ctx);\n  if (!resultType) {\n    compiler.currentType = compiler.program.stringInstance.type;\n    return module.unreachable();\n  }\n  let value: string;\n  if (resultType.isInternalReference) {\n    let classReference = resultType.getClass();\n    if (classReference) {\n      value = classReference.name;\n    } else {\n      assert(resultType.getSignature());\n      value = \"Function\";\n    }\n  } else {\n    value = resultType.toString();\n  }\n  return reifyConstantType(ctx, compiler.ensureStaticString(value));\n}\nbuiltins.set(BuiltinNames.nameof, builtin_nameof);\n\n// idof<T> -> u32\nfunction builtin_idof(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.u32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n    return reifyConstantType(ctx, module.i32(signatureReference.id));\n  }\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (classReference && !classReference.hasDecorator(DecoratorFlags.Unmanaged)) {\n    return reifyConstantType(ctx, module.i32(classReference.id));\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"idof\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.idof, builtin_idof);\n\n// bswap<T?>(value: T) -> T\nfunction builtin_bswap(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        ctx.operands[0],\n        typeArguments[0].toUnsigned(),\n        Constraints.ConvImplicit | Constraints.MustWrap\n      )\n    : compiler.compileExpression(\n        ctx.operands[0],\n        Type.u32,\n        Constraints.MustWrap\n      );\n\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.U8: return arg0;\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        // <T>(x << 8 | x >> 8)\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.Wrapped);\n\n        let res = module.binary(\n          BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp.index, arg0, false),\n            module.i32(8)\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp.index, TypeRef.I32),\n            module.i32(8)\n          )\n        );\n        // avoid wrapping for u16 due to it's already done for input arg\n        if (type.kind == TypeKind.I16) {\n          res = compiler.ensureSmallIntegerWrap(res, Type.i16);\n        }\n        return res;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (type.size == 32) {\n          // rotl(x & 0xFF00FF00, 8) | rotr(x & 0x00FF00FF, 8)\n          let flow = compiler.currentFlow;\n          let temp = flow.getTempLocal(type);\n          flow.setLocalFlag(temp.index, LocalFlags.Wrapped);\n\n          let res = module.binary(\n            BinaryOp.OrI32,\n            module.binary(\n              BinaryOp.RotlI32,\n              module.binary(\n                BinaryOp.AndI32,\n                module.local_tee(temp.index, arg0, false),\n                module.i32(0xFF00FF00)\n              ),\n              module.i32(8)\n            ),\n            module.binary(\n              BinaryOp.RotrI32,\n              module.binary(\n                BinaryOp.AndI32,\n                module.local_get(temp.index, TypeRef.I32),\n                module.i32(0x00FF00FF)\n              ),\n              module.i32(8)\n            ),\n          );\n          return res;\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        // let t =\n        //   ((x >>> 8) & 0x00FF00FF00FF00FF) |\n        //   ((x & 0x00FF00FF00FF00FF) << 8)\n        //\n        // let res =\n        //   ((t >>> 16) & 0x0000FFFF0000FFFF) |\n        //   ((t & 0x0000FFFF0000FFFF) << 16)\n        //\n        // rotr(res, 32)\n\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        // t = ((x >>> 8) & 0x00FF00FF00FF00FF) | ((x & 0x00FF00FF00FF00FF) << 8)\n        let expr = module.local_tee(\n          temp2.index,\n          module.binary(\n            BinaryOp.OrI64,\n            module.binary(\n              BinaryOp.AndI64,\n              module.binary(\n                BinaryOp.ShrU64,\n                module.local_tee(temp1.index, arg0, false),\n                module.i64(8)\n              ),\n              module.i64(0x00FF00FF, 0x00FF00FF)\n            ),\n            module.binary(\n              BinaryOp.ShlI64,\n              module.binary(\n                BinaryOp.AndI64,\n                module.local_get(temp1.index, TypeRef.I64),\n                module.i64(0x00FF00FF, 0x00FF00FF)\n              ),\n              module.i64(8)\n            ),\n          ),\n          false\n        );\n\n        // ((t >>> 16) & 0x0000FFFF0000FFFF) | ((t & 0x0000FFFF0000FFFF) << 16)\n        let res = module.binary(\n          BinaryOp.OrI64,\n          module.binary(\n            BinaryOp.AndI64,\n            module.binary(\n              BinaryOp.ShrU64,\n              expr,\n              module.i64(16)\n            ),\n            module.i64(0x0000FFFF, 0x0000FFFF)\n          ),\n          module.binary(\n            BinaryOp.ShlI64,\n            module.binary(\n              BinaryOp.AndI64,\n              module.local_get(temp2.index, TypeRef.I64),\n              module.i64(0x0000FFFF, 0x0000FFFF)\n            ),\n            module.i64(16)\n          ),\n        );\n\n        // rotr(res, 32)\n        res = module.binary(\n          BinaryOp.RotrI64,\n          res,\n          module.i64(32)\n        );\n        return res;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"bswap\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.bswap, builtin_bswap);\n\n// === Math ===================================================================================\n\n// clz<T?>(value: T) -> T\nfunction builtin_clz(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.ClzSize, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"clz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.clz, builtin_clz);\n\n// ctz<T?>(value: T) -> T\nfunction builtin_ctz(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.CtzSize, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ctz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ctz, builtin_ctz);\n\n// popcnt<T?>(value: T) -> T\nfunction builtin_popcnt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (compiler.currentType.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8: // not wrapped\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.PopcntSize, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.popcnt, builtin_popcnt);\n\n// rotl<T?>(value: T, shift: T) -> T\nfunction builtin_rotl(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.RotlSize, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotl, builtin_rotl);\n\n// rotr<T?>(value: T, shift: T) -> T\nfunction builtin_rotr(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.RotrSize, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotr, builtin_rotr);\n\n// abs<T?>(value: T) -> T\nfunction builtin_abs(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: {\n        let flow = compiler.currentFlow;\n\n        // possibly overflows, e.g. abs<i8>(-128) == 128\n        let temp1 = flow.getTempLocal(Type.i32);\n        let temp2 = flow.getTempLocal(Type.i32);\n        // (x + (x >> 31)) ^ (x >> 31)\n        let ret = module.binary(BinaryOp.XorI32,\n          module.binary(BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0, false), // i32\n                module.i32(31)\n              ),\n              false // i32\n            ),\n            module.local_get(temp1.index, TypeRef.I32)\n          ),\n          module.local_get(temp2.index, TypeRef.I32)\n        );\n        return ret;\n      }\n      case TypeKind.Isize: {\n        let options = compiler.options;\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(options.usizeType);\n        let temp2 = flow.getTempLocal(options.usizeType);\n        let ret = module.binary(BinaryOp.XorSize,\n          module.binary(BinaryOp.AddSize,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrISize,\n                module.local_tee(temp1.index, arg0, false), // i32/i64\n                compiler.options.isWasm64\n                  ? module.i64(63)\n                  : module.i32(31)\n              ),\n              false // i32/i64\n            ),\n            module.local_get(temp1.index, options.sizeTypeRef)\n          ),\n          module.local_get(temp2.index, options.sizeTypeRef)\n        );\n        return ret;\n      }\n      case TypeKind.I64: {\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(Type.i64);\n        let temp2 = flow.getTempLocal(Type.i64);\n        // (x + (x >> 63)) ^ (x >> 63)\n        let ret = module.binary(BinaryOp.XorI64,\n          module.binary(BinaryOp.AddI64,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI64,\n                module.local_tee(temp1.index, arg0, false), // i64\n                module.i64(63)\n              ),\n              false // i64\n            ),\n            module.local_get(temp1.index, TypeRef.I64)\n          ),\n          module.local_get(temp2.index, TypeRef.I64)\n        );\n        return ret;\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.abs, builtin_abs);\n\n// max<T?>(left: T, right: T) -> T\nfunction builtin_max(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MustWrap);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.ConvImplicit | Constraints.MustWrap);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit | Constraints.MustWrap);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:   { op = BinaryOp.GtI32; break; }\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:   { op = BinaryOp.GtU32; break; }\n      case TypeKind.I64:   { op = BinaryOp.GtI64; break; }\n      case TypeKind.U64:   { op = BinaryOp.GtU64; break; }\n      case TypeKind.Isize: { op = BinaryOp.GtISize; break; }\n      case TypeKind.Usize: { op = BinaryOp.GtUSize; break; }\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.max, builtin_max);\n\n// min<T?>(left: T, right: T) -> T\nfunction builtin_min(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MustWrap);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.ConvImplicit | Constraints.MustWrap);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit | Constraints.MustWrap);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:   { op = BinaryOp.LtI32; break; }\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:   { op = BinaryOp.LtU32; break; }\n      case TypeKind.I64:   { op = BinaryOp.LtI64; break; }\n      case TypeKind.U64:   { op = BinaryOp.LtU64; break; }\n      case TypeKind.Isize: { op = BinaryOp.LtISize; break; }\n      case TypeKind.Usize: { op = BinaryOp.LtUSize; break; }\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.min, builtin_min);\n\n// ceil<T?>(value: T) -> T\nfunction builtin_ceil(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ceil, builtin_ceil);\n\n// floor<T?>(value: T) -> T\nfunction builtin_floor(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.floor, builtin_floor);\n\n// copysign<T?>(left: T, right: T) -> T\nfunction builtin_copysign(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      // TODO: does an integer version make sense?\n      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"copysign\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.copysign, builtin_copysign);\n\n// nearest<T?>(value: T) -> T\nfunction builtin_nearest(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.nearest, builtin_nearest);\n\n// reinterpret<T!>(value: *) -> T\nfunction builtin_reinterpret(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments![0];\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.ConvImplicit);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF32ToI32, arg0);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.ConvImplicit);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF64ToI64, arg0);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let isWasm64 = compiler.options.isWasm64;\n        let arg0 = compiler.compileExpression(operands[0],\n          isWasm64 ? Type.f64 : Type.f32,\n          Constraints.ConvImplicit\n        );\n        compiler.currentType = type;\n        return module.unary(\n          isWasm64\n            ? UnaryOp.ReinterpretF64ToI64\n            : UnaryOp.ReinterpretF32ToI32,\n          arg0\n        );\n      }\n      case TypeKind.F32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n        compiler.currentType = Type.f32;\n        return module.unary(UnaryOp.ReinterpretI32ToF32, arg0);\n      }\n      case TypeKind.F64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.ConvImplicit);\n        compiler.currentType = Type.f64;\n        return module.unary(UnaryOp.ReinterpretI64ToF64, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"reinterpret\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.reinterpret, builtin_reinterpret);\n\n// sqrt<T?>(value: T) -> T\nfunction builtin_sqrt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      // TODO: integer versions (that return f64 or convert)?\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sqrt, builtin_sqrt);\n\n// trunc<T?>(value: T) -> T\nfunction builtin_trunc(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered truncated\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.trunc, builtin_trunc);\n\n// isNaN<T?>(value: T) -> bool\nfunction builtin_isNaN(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // never NaN\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: {\n        return module.maybeDropCondition(arg0, module.i32(0));\n      }\n      // (t = arg0) != t\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF32,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.NeF32,\n          module.local_tee(temp.index, arg0, false), // f32\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF64,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.NeF64,\n          module.local_tee(temp.index, arg0, false), // f64\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isNaN\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isNaN, builtin_isNaN);\n\n// isFinite<T?>(value: T) -> bool\nfunction builtin_isFinite(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // always finite\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: {\n        return module.maybeDropCondition(arg0, module.i32(1));\n      }\n      // (t = arg0) - t == 0\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF32,\n            module.binary(BinaryOp.SubF32,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n            ),\n            module.f32(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.EqF32,\n          module.binary(BinaryOp.SubF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.local_get(temp.index, TypeRef.F32)\n          ),\n          module.f32(0)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF64,\n            module.binary(BinaryOp.SubF64,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n            ),\n            module.f64(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.EqF64,\n          module.binary(BinaryOp.SubF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.local_get(temp.index, TypeRef.F64)\n          ),\n          module.f64(0)\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isFinite\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isFinite, builtin_isFinite);\n\n// === Memory access ==========================================================================\n\n// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*\nfunction builtin_load(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n\n  let outType = (\n    contextualType != Type.auto &&\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n\n  if (!outType.isMemory) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"load\", outType.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = outType;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = outType;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = outType;\n  return module.load(\n    type.byteSize,\n    type.isSignedIntegerValue,\n    arg0,\n    outType.toRef(),\n    immOffset,\n    immAlign\n  );\n}\nbuiltins.set(BuiltinNames.load, builtin_load);\n\n// store<T!>(ptr: usize, value: T*, immOffset?: usize, immAlign?: usize) -> void\nfunction builtin_store(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 4)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (!inType.isMemory) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"store\", inType.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 3) {\n    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.void;\n      return module.unreachable();\n    }\n    if (numOperands == 4) {\n      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.void;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.void;\n  return module.store(type.byteSize, arg0, arg1, inType.toRef(), immOffset, immAlign);\n}\nbuiltins.set(BuiltinNames.store, builtin_store);\n\n// rem<T?>(left: T, right: T) -> T\nfunction builtin_rem(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isIntegerValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isIntegerValue) {\n      return compiler.makeRem(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"rem\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rem, builtin_rem);\n\n// add<T?>(left: T, right: T) -> T\nfunction builtin_add(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeAdd(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"add\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.add, builtin_add);\n\n// sub<T?>(left: T, right: T) -> T\nfunction builtin_sub(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeSub(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"sub\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sub, builtin_sub);\n\n// mul<T?>(left: T, right: T) -> T\nfunction builtin_mul(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeMul(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"mul\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.mul, builtin_mul);\n\n// div<T?>(left: T, right: T) -> T\nfunction builtin_div(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeDiv(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"div\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.div, builtin_div);\n\n// eq<T?>(left: T, right: T) -> i32\nfunction builtin_eq(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      compiler.currentType = Type.i32;\n      return compiler.makeEq(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"eq\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.eq, builtin_eq);\n\n// ne<T?>(left: T, right: T) -> i32\nfunction builtin_ne(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      compiler.currentType = Type.i32;\n      return compiler.makeNe(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"ne\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ne, builtin_ne);\n\n// === Atomics ================================================================================\n\n// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*\nfunction builtin_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  let outType = (\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.load\", type.toString()\n    );\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  compiler.currentType = outType;\n  return module.atomic_load(\n    type.byteSize,\n    arg0,\n    outType.toRef(),\n    immOffset\n  );\n}\nbuiltins.set(BuiltinNames.atomic_load, builtin_atomic_load);\n\n// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void\nfunction builtin_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.store\", type.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(\n        operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue|| // float to int\n      inType.size < type.size  // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  compiler.currentType = Type.void;\n  return module.atomic_store(type.byteSize, arg0, arg1, inType.toRef(), immOffset);\n}\nbuiltins.set(BuiltinNames.atomic_store, builtin_atomic_store);\n\n// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_binary(ctx: BuiltinContext, op: AtomicRMWOp, opName: string): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, opName, type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.ConvImplicit\n  );\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toRef());\n}\n\n// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_add(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, \"atomic.add\");\n}\nbuiltins.set(BuiltinNames.atomic_add, builtin_atomic_add);\n\n// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_sub(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, \"atomic.sub\");\n}\nbuiltins.set(BuiltinNames.atomic_sub, builtin_atomic_sub);\n\n// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.And, \"atomic.and\");\n}\nbuiltins.set(BuiltinNames.atomic_and, builtin_atomic_and);\n\n// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, \"atomic.or\");\n}\nbuiltins.set(BuiltinNames.atomic_or, builtin_atomic_or);\n\n// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, \"atomic.xor\");\n}\nbuiltins.set(BuiltinNames.atomic_xor, builtin_atomic_xor);\n\n// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xchg(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, \"atomic.xchg\");\n}\nbuiltins.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);\n\n// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T\nfunction builtin_atomic_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 4)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.cmpxchg\", type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.ConvImplicit\n  );\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  let arg2 = compiler.compileExpression(operands[2],\n    inType,\n    Constraints.ConvImplicit\n  );\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);\n    inType = type;\n  }\n  let immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toRef());\n}\nbuiltins.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);\n\n// atomic.wait<T!>(ptr: usize, expected: T, timeout?: i64) -> i32\nfunction builtin_atomic_wait(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n  let arg2 = operands.length == 3\n    ? compiler.compileExpression(operands[2], Type.i64, Constraints.ConvImplicit)\n    : module.i64(-1, -1); // Infinite timeout\n  compiler.currentType = Type.i32;\n  switch (type.kind) {\n    case TypeKind.I32:\n    case TypeKind.I64:\n    case TypeKind.Isize:\n    case TypeKind.U32:\n    case TypeKind.U64:\n    case TypeKind.Usize: return module.atomic_wait(arg0, arg1, arg2, type.toRef());\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"atomic.wait\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.atomic_wait, builtin_atomic_wait);\n\n// atomic.notify(ptr: usize, count?: i32) -> i32\nfunction builtin_atomic_notify(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = operands.length == 2\n    ? compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit)\n    : module.i32(-1); // Inifinity count of waiters\n  compiler.currentType = Type.i32;\n  return module.atomic_notify(arg0, arg1);\n}\nbuiltins.set(BuiltinNames.atomic_notify, builtin_atomic_notify);\n\n// atomic.fence() -> void\nfunction builtin_atomic_fence(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.atomic_fence();\n}\nbuiltins.set(BuiltinNames.atomic_fence, builtin_atomic_fence);\n\n// === Control flow ===========================================================================\n\n// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\nfunction builtin_select(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (!type.isAny(TypeFlags.Value | TypeFlags.Reference)) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"select\", type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n  let arg2 = compiler.makeIsTrueish(\n    compiler.compileExpression(operands[2], Type.bool),\n    compiler.currentType, // ^\n    operands[2]\n  );\n  compiler.currentType = type;\n  return module.select(arg0, arg1, arg2, type.toRef());\n}\nbuiltins.set(BuiltinNames.select, builtin_select);\n\n// unreachable() -> *\nfunction builtin_unreachable(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  checkArgsRequired(ctx, 0);\n  return ctx.compiler.module.unreachable();\n}\nbuiltins.set(BuiltinNames.unreachable, builtin_unreachable);\n\n// === Memory =================================================================================\n\n// memory.size() -> i32\nfunction builtin_memory_size(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.memory_size();\n}\nbuiltins.set(BuiltinNames.memory_size, builtin_memory_size);\n\n// memory.grow(pages: i32) -> i32\nfunction builtin_memory_grow(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.ConvImplicit));\n}\nbuiltins.set(BuiltinNames.memory_grow, builtin_memory_grow);\n\n// memory.copy(dest: usize, src: usize: n: usize) -> void\nfunction builtin_memory_copy(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BulkMemory)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  let usizeType = compiler.options.usizeType;\n  let arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.ConvImplicit);\n  compiler.currentType = Type.void;\n  return module.memory_copy(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_copy, builtin_memory_copy);\n\n// memory.fill(dest: usize, value: u8, n: usize) -> void\nfunction builtin_memory_fill(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BulkMemory)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  let usizeType = compiler.options.usizeType;\n  let arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.ConvImplicit);\n  compiler.currentType = Type.void;\n  return module.memory_fill(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_fill, builtin_memory_fill);\n\n// memory.data(size[, align]) -> usize\n// memory.data<T>(values[, align]) -> usize\nfunction builtin_memory_data(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  let typeArguments = ctx.typeArguments;\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  let usizeType = compiler.options.usizeType;\n  let offset: i64;\n  if (typeArguments && typeArguments.length > 0) { // data<T>(values[, align])\n    let elementType = typeArguments[0];\n    if (!elementType.isValue) {\n      compiler.error(\n        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n        ctx.reportNode.typeArgumentsRange, \"memory.data\", elementType.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let valuesOperand = operands[0];\n    if (valuesOperand.kind != NodeKind.Literal || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.Array) {\n      compiler.error(\n        DiagnosticCode.Array_literal_expected,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;\n    let numElements = expressions.length;\n    let exprs = new Array<ExpressionRef>(numElements);\n    let isStatic = true;\n    for (let i = 0; i < numElements; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = compiler.compileExpression(elementExpression, elementType, Constraints.ConvImplicit);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        exprs[i] = expr;\n      } else {\n        exprs[i] = compiler.makeZero(elementType);\n      }\n    }\n    if (!isStatic) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        valuesOperand.range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = elementType.byteSize;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    let buf = new Uint8Array(numElements * elementType.byteSize);\n    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);\n    offset = compiler.addAlignedMemorySegment(buf, align).offset;\n  } else { // data(size[, align])\n    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);\n    if (!precomp) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let size = getConstValueI32(precomp);\n    if (size < 1) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[0].range, \"1\", i32.MAX_VALUE.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = 16;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;\n  }\n  // FIXME: what if recompiles happen? recompiles are bad.\n  compiler.currentType = usizeType;\n  if (usizeType == Type.usize32) {\n    assert(!i64_high(offset));\n    return module.i32(i64_low(offset));\n  } else {\n    return module.i64(i64_low(offset), i64_high(offset));\n  }\n}\nbuiltins.set(BuiltinNames.memory_data, builtin_memory_data);\n\n// === GC =====================================================================================\n\nfunction builtin_i31_new(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.i31ref;\n  return module.i31_new(arg0);\n}\nbuiltins.set(BuiltinNames.i31_new, builtin_i31_new);\n\nfunction builtin_i31_get(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.i31ref, Constraints.ConvImplicit);\n  if (ctx.contextualType.is(TypeFlags.Unsigned)) {\n    compiler.currentType = Type.u32;\n    return module.i31_get(arg0, false);\n  } else {\n    compiler.currentType = Type.i32;\n    return module.i31_get(arg0, true);\n  }\n}\nbuiltins.set(BuiltinNames.i31_get, builtin_i31_get);\n\n// === Helpers ================================================================================\n\n// changetype<T!>(value: *) -> T\nfunction builtin_changetype(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let toType = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.auto);\n  let fromType = compiler.currentType;\n  compiler.currentType = toType;\n  if (!fromType.isChangeableTo(toType)) {\n    compiler.error(\n      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,\n      ctx.reportNode.range, fromType.toString(), toType.toString()\n    );\n    return module.unreachable();\n  }\n  return arg0;\n}\nbuiltins.set(BuiltinNames.changetype, builtin_changetype);\n\n// assert<T?>(isTrueish: T, message?: string) -> T{!= null}\nfunction builtin_assert(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let typeArguments = ctx.typeArguments;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    if (typeArguments) {\n      assert(typeArguments.length); // otherwise invalid, should not been set at all\n      compiler.currentType = typeArguments[0].nonNullableType;\n    }\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let contextualType = ctx.contextualType;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.bool, Constraints.MustWrap);\n  let type = compiler.currentType;\n  compiler.currentType = type.nonNullableType;\n\n  // omit if assertions are disabled\n  if (compiler.options.noAssert) {\n    return arg0;\n  }\n\n  // omit if the assertion can be proven statically\n  let evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);\n  if (evaled) {\n    switch (<u32>getExpressionType(evaled)) {\n      case <u32>TypeRef.I32: {\n        if (getConstValueI32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        if (getConstValueF32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        if (getConstValueF64(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n    }\n  }\n\n  // otherwise call abort if the assertion is false-ish\n  let abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);\n  compiler.currentType = type.nonNullableType;\n  if (contextualType == Type.void) { // simplify if dropped anyway\n    compiler.currentType = Type.void;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.if(module.unary(UnaryOp.EqzSize, arg0), abort);\n      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\n      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);\n      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: return module.if(module.ref_is(RefIsOp.Null, arg0), abort);\n    }\n  } else {\n    compiler.currentType = type.nonNullableType;\n    let flow = compiler.currentFlow;\n    switch (compiler.currentType.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: {\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.Wrapped); // arg0 is wrapped\n        let ret = module.if(\n          module.local_tee(temp.index, arg0, false), // numeric\n          module.local_get(temp.index, TypeRef.I32),\n          abort\n        );\n        return ret;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let temp = flow.getTempLocal(Type.i64);\n        let ret = module.if(\n          module.unary(UnaryOp.EqzI64,\n            module.local_tee(temp.index, arg0, false) // i64\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.I64)\n        );\n        return ret;\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let temp = flow.getTempLocal(compiler.options.usizeType);\n        let ret = module.if(\n          module.unary(\n            UnaryOp.EqzSize,\n            module.local_tee(temp.index, arg0, type.isManaged)\n          ),\n          abort,\n          module.local_get(temp.index, compiler.options.sizeTypeRef)\n        );\n        return ret;\n      }\n      case TypeKind.F32: {\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.f32(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.f64(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        return ret;\n      }\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        let temp = flow.getTempLocal(type);\n        let ret = module.if(\n          module.ref_is(RefIsOp.Null,\n            module.local_tee(temp.index, arg0, false) // ref\n          ),\n          abort,\n          module.local_get(temp.index, type.toRef())\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"assert\", compiler.currentType.toString()\n  );\n  return abort;\n}\nbuiltins.set(BuiltinNames.assert, builtin_assert);\n\n// unchecked(expr: *) -> *\nfunction builtin_unchecked(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let flow = compiler.currentFlow;\n  let ignoreUnchecked = compiler.options.uncheckedBehavior === UncheckedBehavior.Never;\n  let alreadyUnchecked = flow.is(FlowFlags.UncheckedContext);\n  if (ignoreUnchecked) assert(!alreadyUnchecked);\n  else flow.set(FlowFlags.UncheckedContext);\n  // eliminate unnecessary tees by preferring contextualType(=void)\n  let expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\n  if (!alreadyUnchecked) flow.unset(FlowFlags.UncheckedContext);\n  return expr;\n}\nbuiltins.set(BuiltinNames.unchecked, builtin_unchecked);\n\n// call_indirect<T?>(index: u32, ...args: *[]) -> T\nfunction builtin_call_indirect(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, i32.MAX_VALUE)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let returnType: Type;\n  if (typeArguments) {\n    assert(typeArguments.length);\n    returnType = typeArguments[0];\n  } else {\n    returnType = ctx.contextualType;\n  }\n  let indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.ConvImplicit);\n  let numOperands = operands.length - 1;\n  let operandExprs = new Array<ExpressionRef>(numOperands);\n  let paramTypeRefs = new Array<TypeRef>(numOperands);\n  for (let i = 0; i < numOperands; ++i) {\n    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);\n    paramTypeRefs[i] = compiler.currentType.toRef();\n  }\n  compiler.currentType = returnType;\n  return module.call_indirect(null /* TODO */, indexArg, operandExprs, createType(paramTypeRefs), returnType.toRef());\n}\nbuiltins.set(BuiltinNames.call_indirect, builtin_call_indirect);\n\n// instantiate<T!>(...args: *[]) -> T\nfunction builtin_instantiate(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let typeArgument = typeArguments[0];\n  let classInstance = typeArgument.getClass();\n  if (!classInstance) {\n    compiler.error(\n      DiagnosticCode.This_expression_is_not_constructable,\n      ctx.reportNode.expression.range\n    );\n    return module.unreachable();\n  }\n  compiler.currentType = classInstance.type;\n  let ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);\n  compiler.checkFieldInitialization(classInstance, ctx.reportNode);\n  return compiler.compileInstantiate(ctor, operands, Constraints.None, ctx.reportNode);\n}\nbuiltins.set(BuiltinNames.instantiate, builtin_instantiate);\n\n// === User-defined diagnostics ===============================================================\n\nfunction builtin_diagnostic(ctx: BuiltinContext, category: DiagnosticCategory): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  checkTypeAbsent(ctx);\n  let operands = ctx.operands;\n  let reportNode = ctx.reportNode;\n  compiler.emitDiagnostic(\n    DiagnosticCode.User_defined_0,\n    category,\n    reportNode.range,\n    null,\n    operands.length\n      ? operands[0].range.toString()\n      : reportNode.range.toString()\n  );\n  return category == DiagnosticCategory.Error\n    ? module.unreachable()\n    : module.nop();\n}\n\n// ERROR(message?)\nfunction builtin_error(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Error);\n}\nbuiltins.set(BuiltinNames.ERROR, builtin_error);\n\n// WARNING(message?)\nfunction builtin_warning(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Warning);\n}\nbuiltins.set(BuiltinNames.WARNING, builtin_warning);\n\n// INFO(message?)\nfunction builtin_info(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Info);\n}\nbuiltins.set(BuiltinNames.INFO, builtin_info);\n\n// === Function builtins ======================================================================\n\n// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>\nfunction builtin_function_call(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let parent = ctx.prototype.parent;\n  assert(parent.kind == ElementKind.Class);\n  let classInstance = <Class>parent;\n  assert(classInstance.prototype == compiler.program.functionPrototype);\n  let typeArguments = assert(classInstance.typeArguments);\n  assert(typeArguments.length == 1);\n  let ftype = typeArguments[0];\n  let signature = assert(ftype.getSignature());\n  let returnType = signature.returnType;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)\n  ) {\n    compiler.currentType = returnType;\n    return compiler.module.unreachable();\n  }\n  let functionArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.ConvImplicit);\n  let thisOperand = assert(ctx.operands.shift());\n  let thisType = signature.thisType;\n  let thisArg: usize = 0;\n  if (thisType) {\n    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.ConvImplicit);\n  } else if (thisOperand.kind != NodeKind.Null) {\n    compiler.error(\n      DiagnosticCode._this_cannot_be_referenced_in_current_location,\n      thisOperand.range\n    );\n    return compiler.module.unreachable();\n  }\n  return compiler.compileCallIndirect(signature, functionArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);\n}\nfunction_builtins.set(\"call\", builtin_function_call);\n\n// String.raw(parts: TemplateStringsArray, ...values: unknown[]): string\nfunction builtin_string_raw(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = ctx.compiler.program.stringInstance.type;\n  compiler.error(\n    DiagnosticCode.Not_implemented_0,\n    ctx.reportNode.range, \"String.raw\"\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.String_raw, builtin_string_raw);\n\n// === Portable type conversions ==============================================================\n\nfunction builtin_conversion(ctx: BuiltinContext, toType: Type): ExpressionRef {\n  let compiler = ctx.compiler;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = toType;\n    return compiler.module.unreachable();\n  }\n  return compiler.compileExpression(ctx.operands[0], toType, Constraints.ConvExplicit);\n}\n\n// i8(*) -> i8\nfunction builtin_i8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i8);\n}\nbuiltins.set(BuiltinNames.i8, builtin_i8);\n\n// i16(*) -> i16\nfunction builtin_i16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i16);\n}\nbuiltins.set(BuiltinNames.i16, builtin_i16);\n\n// i32(*) -> i32\nfunction builtin_i32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i32);\n}\nbuiltins.set(BuiltinNames.i32, builtin_i32);\n\n// i64(*) -> i64\nfunction builtin_i64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i64);\n}\nbuiltins.set(BuiltinNames.i64, builtin_i64);\n\n// isize(*) -> isize\nfunction builtin_isize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.isizeType);\n}\nbuiltins.set(BuiltinNames.isize, builtin_isize);\n\n// u8(*) -> u8\nfunction builtin_u8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u8);\n}\nbuiltins.set(BuiltinNames.u8, builtin_u8);\n\n// u16(*) -> u16\nfunction builtin_u16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u16);\n}\nbuiltins.set(BuiltinNames.u16, builtin_u16);\n\n// u32(*) -> u32\nfunction builtin_u32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u32);\n}\nbuiltins.set(BuiltinNames.u32, builtin_u32);\n\n// u64(*) -> u64\nfunction builtin_u64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u64);\n}\nbuiltins.set(BuiltinNames.u64, builtin_u64);\n\n// usize(*) -> usize\nfunction builtin_usize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.usizeType);\n}\nbuiltins.set(BuiltinNames.usize, builtin_usize);\n\n// bool(*) -> bool\nfunction builtin_bool(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.bool);\n}\nbuiltins.set(BuiltinNames.bool, builtin_bool);\n\n// f32(*) -> f32\nfunction builtin_f32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f32);\n}\nbuiltins.set(BuiltinNames.f32, builtin_f32);\n\n// f64(*) -> f64\nfunction builtin_f64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f64);\n}\nbuiltins.set(BuiltinNames.f64, builtin_f64);\n\n// TODO: alias for now, splat input integer perhaps?\nfunction builtin_v128(ctx: BuiltinContext): ExpressionRef {\n  return builtin_i8x16(ctx);\n}\nbuiltins.set(BuiltinNames.v128, builtin_v128);\n\n// === SIMD ===================================================================================\n\n// i8x16(...values: i8[16]) -> v128\nfunction builtin_i8x16(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 16)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(16);\n  let numVars = 0;\n\n  for (let i = 0; i < 16; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI8(getConstValueI32(precomp), bytes, i);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 16;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI8x16, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 16; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.i8x16, builtin_i8x16);\n\n// i16x8(...values: i16[8]) -> v128\nfunction builtin_i16x8(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 8)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(8);\n  let numVars = 0;\n\n  for (let i = 0; i < 8; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI16(getConstValueI32(precomp), bytes, i << 1);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 8;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI16x8, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 8; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.i16x8, builtin_i16x8);\n\n// i32x4(...values: i32[4]) -> v128\nfunction builtin_i32x4(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(4);\n  let numVars = 0;\n\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI32(getConstValueI32(precomp), bytes, i << 2);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 4;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI32x4, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 4; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.i32x4, builtin_i32x4);\n\n// i64x2(...values: i64[2]) -> v128\nfunction builtin_i64x2(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(2);\n  let numVars = 0;\n\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      let off = i << 3;\n      writeI32(getConstValueI64Low(precomp),  bytes, off + 0);\n      writeI32(getConstValueI64High(precomp), bytes, off + 4);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 2;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI64x2, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 2; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.i64x2, builtin_i64x2);\n\n// f32x4(...values: f32[4]) -> v128\nfunction builtin_f32x4(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(4);\n  let numVars = 0;\n\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF32(getConstValueF32(precomp), bytes, i << 2);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 4;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatF32x4, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 4; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.f32x4, builtin_f32x4);\n\n// f64x2(...values: f64[2]) -> v128\nfunction builtin_f64x2(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(2);\n  let numVars = 0;\n\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF64(getConstValueF64(precomp), bytes, i << 3);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 2;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatF64x2, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 2; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltins.set(BuiltinNames.f64x2, builtin_f64x2);\n\n// v128.splat<T!>(x: T) -> v128\nfunction builtin_v128_splat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], type, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.SplatI64x2\n            : UnaryOp.SplatI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_splat, builtin_v128_splat);\n\n// v128.extract_lane<T!>(x: v128, idx: u8) -> T\nfunction builtin_v128_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  compiler.currentType = type;\n  let idx = 0;\n  let precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);\n      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);\n      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);\n      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_extract(\n          compiler.options.isWasm64\n            ? SIMDExtractOp.ExtractLaneI64x2\n            : SIMDExtractOp.ExtractLaneI32x4,\n          arg0, <u8>idx\n        );\n      }\n      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);\n      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extract_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);\n\n// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128\nfunction builtin_v128_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], type, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  let idx = 0;\n  let precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_replace(\n          compiler.options.isWasm64\n            ? SIMDReplaceOp.ReplaceLaneI64x2\n            : SIMDReplaceOp.ReplaceLaneI32x4,\n          arg0, <u8>idx, arg2\n        );\n      }\n      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);\n      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.replace_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);\n\n// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128\nfunction builtin_v128_shuffle(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  if (type.isValue) {\n    let laneWidth = type.byteSize;\n    let laneCount = 16 / laneWidth;\n    assert(Number.isInteger(laneCount) && isPowerOf2(laneCount));\n    if (\n      checkArgsRequired(ctx, 2 + laneCount)\n    ) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize:\n      case TypeKind.F32:\n      case TypeKind.F64: {\n        let mask = new Uint8Array(16);\n        let maxIdx = (laneCount << 1) - 1;\n        for (let i = 0; i < laneCount; ++i) {\n          let operand = operands[2 + i];\n          let argN = compiler.compileExpression(operand, Type.u8, Constraints.ConvImplicit);\n          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);\n          let idx = 0;\n          if (precomp) {\n            idx = getConstValueI32(precomp);\n            if (idx < 0 || idx > maxIdx) {\n              compiler.error(\n                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n                operand.range, \"Lane index\", \"0\", maxIdx.toString()\n              );\n              idx = 0;\n            }\n          } else {\n            compiler.error(\n              DiagnosticCode.Expression_must_be_a_compile_time_constant,\n              operand.range\n            );\n          }\n          switch (laneWidth) {\n            case 1: {\n              writeI8(idx, mask, i);\n              break;\n            }\n            case 2: {\n              let off8 = i << 1;\n              let idx8 = idx << 1;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              break;\n            }\n            case 4: {\n              let off8 = i << 2;\n              let idx8 = idx << 2;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              break;\n            }\n            case 8: {\n              let off8 = i << 3;\n              let idx8 = idx << 3;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              writeI8(idx8 + 4, mask, off8 + 4);\n              writeI8(idx8 + 5, mask, off8 + 5);\n              writeI8(idx8 + 6, mask, off8 + 6);\n              writeI8(idx8 + 7, mask, off8 + 7);\n              break;\n            }\n            default: assert(false);\n          }\n        }\n        compiler.currentType = Type.v128;\n        return module.simd_shuffle(arg0, arg1, mask);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shuffle\", type.toString()\n  );\n  compiler.currentType = Type.v128;\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);\n\n// v128.swizzle(a: v128, b: v128) -> v128\nfunction builtin_v128_swizzle(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  return module.binary(BinaryOp.SwizzleI8x16, arg0, arg1);\n}\nbuiltins.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);\n\n// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_splat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: {\n        return module.simd_load(SIMDLoadOp.Load8Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        return module.simd_load(SIMDLoadOp.Load16Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: {\n        return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (!compiler.options.isWasm64) {\n          return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: {\n        return module.simd_load(SIMDLoadOp.Load64Splat, arg0, immOffset, immAlign);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);\n\n// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_ext(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_load(SIMDLoadOp.Load8x8S, arg0, immOffset, immAlign);\n      case TypeKind.U8: return module.simd_load(SIMDLoadOp.Load8x8U, arg0, immOffset, immAlign);\n      case TypeKind.I16: return module.simd_load(SIMDLoadOp.Load16x4S, arg0, immOffset, immAlign);\n      case TypeKind.U16: return module.simd_load(SIMDLoadOp.Load16x4U, arg0, immOffset, immAlign);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.simd_load(SIMDLoadOp.Load32x2S, arg0, immOffset, immAlign);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.simd_load(SIMDLoadOp.Load32x2U, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_ext\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);\n\n// v128.load_zero<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_zero(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_load(SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_load(SIMDLoadOp.Load64Zero, arg0, immOffset, immAlign);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_load(\n          compiler.options.isWasm64\n            ? SIMDLoadOp.Load64Zero\n            : SIMDLoadOp.Load32Zero,\n          arg0,\n          immOffset,\n          immAlign\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_zero, builtin_v128_load_zero);\n\n// v128.load_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_lane(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.ConvImplicit);\n  let idx = 0;\n  let precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_loadstorelane(\n          compiler.options.isWasm64\n            ? SIMDLoadStoreLaneOp.Load64Lane\n            : SIMDLoadStoreLaneOp.Load32Lane,\n          arg0,\n          immOffset,\n          immAlign,\n          <u8>idx,\n          arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_lane, builtin_v128_load_lane);\n\n// v128.store_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_store_lane(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.ConvImplicit);\n  let idx = 0;\n  let precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_loadstorelane(\n          compiler.options.isWasm64\n            ? SIMDLoadStoreLaneOp.Store64Lane\n            : SIMDLoadStoreLaneOp.Store32Lane,\n          arg0,\n          immOffset,\n          immAlign,\n          <u8>idx,\n          arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.store_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_store_lane, builtin_v128_store_lane);\n\n// v128.add<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.AddI64x2\n            : BinaryOp.AddI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add, builtin_v128_add);\n\n// v128.sub<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.SubI64x2\n            : BinaryOp.SubI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub, builtin_v128_sub);\n\n// v128.mul<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_mul(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.MulI64x2 : BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.mul\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_mul, builtin_v128_mul);\n\n// v128.div<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_div(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.div\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_div, builtin_v128_div);\n\n// v128.add_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add_sat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add_sat, builtin_v128_add_sat);\n\n// v128.sub_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub_sat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub_sat, builtin_v128_sub_sat);\n\n// v128.min<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_min(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_min, builtin_v128_min);\n\n// v128.max<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_max(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_max, builtin_v128_max);\n\n// v128.pmin<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmin(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmin\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmin, builtin_v128_pmin);\n\n// v128.pmax<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmax(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmax\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmax, builtin_v128_pmax);\n\n// v128.dot<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_dot(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.dot\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_dot, builtin_v128_dot);\n\n// v128.avgr<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_avgr(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.avgr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_avgr, builtin_v128_avgr);\n\n// v128.eq<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_eq(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.EqI64x2 : BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.eq\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_eq, builtin_v128_eq);\n\n// v128.ne<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ne(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.NeI64x2 : BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ne\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ne, builtin_v128_ne);\n\n// v128.lt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_lt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64x2, arg0, arg1);\n      // no LtU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.LtI64x2 : BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.lt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_lt, builtin_v128_lt);\n\n// v128.le<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_le(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64x2, arg0, arg1);\n      // no LeU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.LeI64x2 : BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.le\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_le, builtin_v128_le);\n\n// v128.gt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_gt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64x2, arg0, arg1);\n      // no GtU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.GtI64x2 : BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.gt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_gt, builtin_v128_gt);\n\n// v128.ge<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ge(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64x2, arg0, arg1);\n      // no GeU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.GeI64x2 : BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ge\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ge, builtin_v128_ge);\n\n// v128.narrow<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_narrow(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.narrow\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_narrow, builtin_v128_narrow);\n\n// v128.neg<T!>(a: v128) -> v128\nfunction builtin_v128_neg(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.NegI64x2\n            : UnaryOp.NegI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.neg\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_neg, builtin_v128_neg);\n\n// v128.abs<T!>(a: v128) -> v128\nfunction builtin_v128_abs(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);\n      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.AbsI64x2, arg0);\n      case TypeKind.Isize: return module.unary(compiler.options.isWasm64 ? UnaryOp.AbsI64x2 : UnaryOp.AbsI32x4, arg0);\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_abs, builtin_v128_abs);\n\n// v128.sqrt<T!>(a: v128) -> v128\nfunction builtin_v128_sqrt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);\n\n// v128.ceil<T!>(a: v128) -> v128\nfunction builtin_v128_ceil(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ceil, builtin_v128_ceil);\n\n// v128.floor<T!>(a: v128) -> v128\nfunction builtin_v128_floor(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_floor, builtin_v128_floor);\n\n// v128.trunc<T!>(a: v128) -> v128\nfunction builtin_v128_trunc(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc, builtin_v128_trunc);\n\n// v128.nearest<T!>(a: v128) -> v128\nfunction builtin_v128_nearest(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_nearest, builtin_v128_nearest);\n\n// v128.convert<T!>(a: v128) -> v128\nfunction builtin_v128_convert(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert, builtin_v128_convert);\n\n// v128.convert_low<T!>(a: v128) -> v128\nfunction builtin_v128_convert_low(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertLowI32x4ToF64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertLowU32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert_low, builtin_v128_convert_low);\n\n// v128.trunc_sat<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);\n\n// v128.trunc_sat_zero<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat_zero(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF64x2ToI32x4Zero, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF64x2ToU32x4Zero, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat_zero, builtin_v128_trunc_sat_zero);\n\n// v128.extend_low<T!>(a: v128) -> v128\nfunction builtin_v128_extend_low(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendLowI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendLowU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendLowI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendLowU16x8ToU32x4, arg0);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendLowI32x4ToI64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendLowU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extend_low, builtin_v128_extend_low);\n\n// v128.extend_high<T!>(a: v128) -> v128\nfunction builtin_v128_extend_high(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendHighI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendHighU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendHighI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendHighU16x8ToU32x4, arg0);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendHighI32x4ToI64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendHighU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extend_high, builtin_v128_extend_high);\n\n// v128.shl<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shl(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShlI64x2\n            : SIMDShiftOp.ShlI32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shl, builtin_v128_shl);\n\n// v128.shr<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shr(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);\n      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);\n      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);\n      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);\n      case TypeKind.Isize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrI64x2\n            : SIMDShiftOp.ShrI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.Usize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrU64x2\n            : SIMDShiftOp.ShrU32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shr, builtin_v128_shr);\n\nfunction builtin_v128_bitwise_binary(ctx: BuiltinContext, op: BinaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  return module.binary(op, arg0, arg1);\n}\n\n// v128.and(a: v128, b: v128) -> v128\nfunction builtin_v128_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);\n}\nbuiltins.set(BuiltinNames.v128_and, builtin_v128_and);\n\n// v128.or(a: v128, b: v128) -> v128\nfunction builtin_v128_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);\n}\nbuiltins.set(BuiltinNames.v128_or, builtin_v128_or);\n\n// v128.xor(a: v128, b: v128) -> v128\nfunction builtin_v128_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);\n}\nbuiltins.set(BuiltinNames.v128_xor, builtin_v128_xor);\n\n// v128.andnot(a: v128, b: v128) -> v128\nfunction builtin_v128_andnot(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndnotV128);\n}\nbuiltins.set(BuiltinNames.v128_andnot, builtin_v128_andnot);\n\nfunction builtin_v128_bitwise_unary(ctx: BuiltinContext, op: UnaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  return module.unary(op, arg0);\n}\n\n// v128.not(a: v128) -> v128\nfunction builtin_v128_not(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);\n}\nbuiltins.set(BuiltinNames.v128_not, builtin_v128_not);\n\nfunction builtin_v128_bitwise_ternary(ctx: BuiltinContext, op: SIMDTernaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.ConvImplicit);\n  return module.simd_ternary(op, arg0, arg1, arg2);\n}\n\n// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128\nfunction builtin_v128_bitselect(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_ternary(ctx, SIMDTernaryOp.Bitselect);\n}\nbuiltins.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);\n\n// v128.any_true(a: v128) -> bool\nfunction builtin_v128_any_true(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.bool;\n  return module.unary(UnaryOp.AnyTrueV128, arg0);\n}\nbuiltins.set(BuiltinNames.v128_any_true, builtin_v128_any_true);\n\n// v128.all_true<T!>(a: v128) -> bool\nfunction builtin_v128_all_true(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.AllTrueI64x2\n            : UnaryOp.AllTrueI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.all_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_all_true, builtin_v128_all_true);\n\n// v128.bitmask<T!>(a: v128) -> i32\nfunction builtin_v128_bitmask(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.i32;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.BitmaskI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.BitmaskI64x2\n            : UnaryOp.BitmaskI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.bitmask\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);\n\n// v128.popcnt<T!>(a: v128) -> v128\nfunction builtin_v128_popcnt(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.PopcntI8x16, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_popcnt, builtin_v128_popcnt);\n\n// v128.extadd_pairwise<T!>(a: v128) -> v128\nfunction builtin_v128_extadd_pairwise(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtaddPairwiseI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtaddPairwiseU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtaddPairwiseI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtaddPairwiseU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extadd_pairwise\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extadd_pairwise, builtin_v128_extadd_pairwise);\n\n// v128.demote_zero<T?>(a: v128) -> v128\nfunction builtin_v128_demote_zero(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments ? typeArguments[0] : Type.f64;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F64: return module.unary(UnaryOp.DemoteZeroF64x2ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.demote_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_demote_zero, builtin_v128_demote_zero);\n\n// v128.promote_low<T?>(a: v128) -> v128\nfunction builtin_v128_promote_low(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments ? typeArguments[0] : Type.f32;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.PromoteLowF32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.promote_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_promote_low, builtin_v128_promote_low);\n\n// v128.q15mulr_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_q15mulr_sat(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.Q15mulrSatI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.q15mulr_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_q15mulr_sat, builtin_v128_q15mulr_sat);\n\n// v128.extmul_low<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_low(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulLowI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulLowU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulLowI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulLowU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulLowI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulLowU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extmul_low, builtin_v128_extmul_low);\n\n// v128.extmul_high<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_high(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulHighI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulHighU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulHighI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulHighU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulHighI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulHighU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extmul_high, builtin_v128_extmul_high);\n\n// === Internal runtime =======================================================================\n\n// __visit_globals(cookie: u32) -> void\nfunction builtin_visit_globals(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1) // cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.ConvImplicit);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_globals, [ arg0 ], TypeRef.None);\n}\nbuiltins.set(BuiltinNames.visit_globals, builtin_visit_globals);\n\n// __visit_members(ref: usize, cookie: u32) -> void\nfunction builtin_visit_members(ctx: BuiltinContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2) // ref, cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.ConvImplicit);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], TypeRef.None);\n}\nbuiltins.set(BuiltinNames.visit_members, builtin_visit_members);\n\n// === Inline assembler =======================================================================\n\n// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)\n//   add, sub, mul, div_s, div_u, rem_s, rem_u\n//   and, or, xor, shl, shr_u, shr_s\n//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u\n\n// i32.clz -> clz<i32>\nfunction builtin_i32_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_clz, builtin_i32_clz);\n\n// i64.clz -> clz<i64>\nfunction builtin_i64_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_clz, builtin_i64_clz);\n\n// i32.ctz -> ctz<i32>\nfunction builtin_i32_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_ctz, builtin_i32_ctz);\n\n// i64.ctz -> ctz<i64>\nfunction builtin_i64_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_ctz, builtin_i64_ctz);\n\n// i32.popcnt -> popcnt<i32>\nfunction builtin_i32_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);\n\n// i64.popcnt -> popcnt<i64>\nfunction builtin_i64_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);\n\n// i32.rotl -> rotl<i32>\nfunction builtin_i32_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotl, builtin_i32_rotl);\n\n// i64.rotl -> rotl<i64>\nfunction builtin_i64_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotl, builtin_i64_rotl);\n\n// i32.rotr -> rotr<i32>\nfunction builtin_i32_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotr, builtin_i32_rotr);\n\n// i64.rotr -> rotr<i64>\nfunction builtin_i64_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotr, builtin_i64_rotr);\n\n// f32.abs -> abs<f32>\nfunction builtin_f32_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32_abs, builtin_f32_abs);\n\n// f64.abs -> abs<f64>\nfunction builtin_f64_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64_abs, builtin_f64_abs);\n\n// f32.max -> max<f32>\nfunction builtin_f32_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32_max, builtin_f32_max);\n\n// f64.max -> max<f64>\nfunction builtin_f64_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64_max, builtin_f64_max);\n\n// f32.min -> min<f32>\nfunction builtin_f32_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32_min, builtin_f32_min);\n\n// f64.min -> min<f64>\nfunction builtin_f64_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64_min, builtin_f64_min);\n\n// f32.ceil -> ceil<f32>\nfunction builtin_f32_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32_ceil, builtin_f32_ceil);\n\n// f64.ceil -> ceil<f64>\nfunction builtin_f64_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64_ceil, builtin_f64_ceil);\n\n// f32.floor -> floor<f32>\nfunction builtin_f32_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32_floor, builtin_f32_floor);\n\n// f64.floor -> floor<f64>\nfunction builtin_f64_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64_floor, builtin_f64_floor);\n\n// f32.copysign -> copysign<f32>\nfunction builtin_f32_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f32_copysign, builtin_f32_copysign);\n\n// f64.copysign -> copysign<f64>\nfunction builtin_f64_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f64_copysign, builtin_f64_copysign);\n\n// f32.nearest -> nearest<f32>\nfunction builtin_f32_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32_nearest, builtin_f32_nearest);\n\n// f64.nearest -> nearest<f64>\nfunction builtin_f64_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64_nearest, builtin_f64_nearest);\n\n// i32.reinterpret_f32 -> reinterpret<i32>\nfunction builtin_i32_reinterpret_f32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);\n\n// i64.reinterpret_f64 -> reinterpret<i64>\nfunction builtin_i64_reinterpret_f64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);\n\n// f32.reinterpret_i32 -> reinterpret<f32>\nfunction builtin_f32_reinterpret_i32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);\n\n// f64.reinterpret_i64 -> reinterpret<f64>\nfunction builtin_f64_reinterpret_i64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);\n\n// f32.sqrt -> sqrt<f32>\nfunction builtin_f32_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);\n\n// f64.sqrt -> sqrt<f64>\nfunction builtin_f64_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);\n\n// f32.trunc -> trunc<f32>\nfunction builtin_f32_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32_trunc, builtin_f32_trunc);\n\n// f64.trunc -> trunc<f64>\nfunction builtin_f64_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64_trunc, builtin_f64_trunc);\n\n// i32.rem_s -> rem<i32>\nfunction builtin_i32_rem_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rem(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rem_s, builtin_i32_rem_s);\n\n// i32.rem_u -> rem<u32>\nfunction builtin_i32_rem_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_rem(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rem_u, builtin_i32_rem_u);\n\n// i64.rem_s -> rem<i64>\nfunction builtin_i64_rem_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rem(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rem_s, builtin_i64_rem_s);\n\n// i64.rem_u -> rem<u64>\nfunction builtin_i64_rem_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_rem(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rem_u, builtin_i64_rem_u);\n\n// i32.add -> add<i32>\nfunction builtin_i32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_add, builtin_i32_add);\n\n// i64.add -> add<i64>\nfunction builtin_i64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_add, builtin_i64_add);\n\n// f32.add -> add<f32>\nfunction builtin_f32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32_add, builtin_f32_add);\n\n// f64.add -> add<f64>\nfunction builtin_f64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64_add, builtin_f64_add);\n\n// i32.sub -> sub<i32>\nfunction builtin_i32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_sub, builtin_i32_sub);\n\n// i64.sub -> sub<i64>\nfunction builtin_i64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_sub, builtin_i64_sub);\n\n// f32.sub -> sub<f32>\nfunction builtin_f32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sub, builtin_f32_sub);\n\n// f64.sub -> sub<f64>\nfunction builtin_f64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sub, builtin_f64_sub);\n\n// i32.mul -> mul<i32>\nfunction builtin_i32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32_mul, builtin_i32_mul);\n\n// i64.mul -> mul<i64>\nfunction builtin_i64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64_mul, builtin_i64_mul);\n\n// f32.mul -> mul<f32>\nfunction builtin_f32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32_mul, builtin_f32_mul);\n\n// f64.mul -> mul<f64>\nfunction builtin_f64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64_mul, builtin_f64_mul);\n\n// i32.div_s -> div<i32>\nfunction builtin_i32_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_s, builtin_i32_div_s);\n\n// i32.div_u -> div<u32>\nfunction builtin_i32_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_u, builtin_i32_div_u);\n\n// i64.div_s -> div_s<i64>\nfunction builtin_i64_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_s, builtin_i64_div_s);\n\n// i64.div_u -> div_u<u64>\nfunction builtin_i64_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_u, builtin_i64_div_u);\n\n// f32.div -> div<f32>\nfunction builtin_f32_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32_div, builtin_f32_div);\n\n// f64.div -> div<f64>\nfunction builtin_f64_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64_div, builtin_f64_div);\n\n// i32.eq -> eq<i32>\nfunction builtin_i32_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i32_eq, builtin_i32_eq);\n\n// i64.eq -> eq<i64>\nfunction builtin_i64_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i64_eq, builtin_i64_eq);\n\n// f32.eq -> eq<f32>\nfunction builtin_f32_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f32_eq, builtin_f32_eq);\n\n// f64.eq -> eq<f64>\nfunction builtin_f64_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f64_eq, builtin_f64_eq);\n\n// i32.ne -> ne<i32>\nfunction builtin_i32_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i32_ne, builtin_i32_ne);\n\n// i64.ne -> ne<i64>\nfunction builtin_i64_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i64_ne, builtin_i64_ne);\n\n// f32.ne -> ne<f32>\nfunction builtin_f32_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f32_ne, builtin_f32_ne);\n\n// f64.ne-> ne<f64>\nfunction builtin_f64_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f64_ne, builtin_f64_ne);\n\n// i32.load8_s -> <i32>load<i8>\nfunction builtin_i32_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);\n\n// i32.load8_u -> <i32>load<u8>\nfunction builtin_i32_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);\n\n// i32.load16_s -> <i32>load<i16>\nfunction builtin_i32_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);\n\n// i32.load16_u -> <i32>load<u16>\nfunction builtin_i32_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);\n\n// i32.load -> <i32>load<i32>\nfunction builtin_i32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load, builtin_i32_load);\n\n// i64.load8_s -> <i64>load<i8>\nfunction builtin_i64_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);\n\n// i64.load8_u -> <i64>load<u8>\nfunction builtin_i64_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);\n\n// i64.load16_s -> <i64>load<i16>\nfunction builtin_i64_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);\n\n// i64.load16_u -> <i64>load<u16>\nfunction builtin_i64_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);\n\n// i64.load32_s -> <i64>load<i32>\nfunction builtin_i64_load32_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);\n\n// i64.load32_u -> <i64>load<u32>\nfunction builtin_i64_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);\n\n// i64.load -> <i64>load<i64>\nfunction builtin_i64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load, builtin_i64_load);\n\n// f32.load -> <f32>load<f32>\nfunction builtin_f32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f32_load, builtin_f32_load);\n\n// f64.load -> <f64>load<f64>\nfunction builtin_f64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f64_load, builtin_f64_load);\n\n// i32.store8 -> store<i8 from i32>\nfunction builtin_i32_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store8, builtin_i32_store8);\n\n// i32.store16 -> store<i16 from i32>\nfunction builtin_i32_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store16, builtin_i32_store16);\n\n// i32.store -> store<i32 from i32>\nfunction builtin_i32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store, builtin_i32_store);\n\n// i64.store8 -> store<i8 from i64>\nfunction builtin_i64_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store8, builtin_i64_store8);\n\n// i64.store16 -> store<i16 from i64>\nfunction builtin_i64_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store16, builtin_i64_store16);\n\n// i64.store32 -> store<i32 from i64>\nfunction builtin_i64_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store32, builtin_i64_store32);\n\n// i64.store -> store<i64 from i64>\nfunction builtin_i64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store, builtin_i64_store);\n\n// f32.store -> store<f32 from f64>\nfunction builtin_f32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f32_store, builtin_f32_store);\n\n// f64.store -> store<f64 from f64>\nfunction builtin_f64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f64_store, builtin_f64_store);\n\n// i32.atomic.load8_u -> <i32>atomic.load<u8>\nfunction builtin_i32_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);\n\n// i32.atomic.load16_u -> <i32>atomic.load<u16>\nfunction builtin_i32_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);\n\n// i32.atomic.load -> <i32>atomic.load<i32>\nfunction builtin_i32_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);\n\n// i64.atomic.load8_u -> <i64>atomic.load<u8>\nfunction builtin_i64_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);\n\n// i64.atomic.load16_u -> <i64>atomic.load<u16>\nfunction builtin_i64_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);\n\n// i64.atomic.load32_u -> <i64>atomic.load<u32>\nfunction builtin_i64_atomic_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);\n\n// i64.atomic.load -> <i64>atomic.load<i64>\nfunction builtin_i64_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);\n\n// i32.atomic.store8 -> atomic.store<i8 from i32>\nfunction builtin_i32_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);\n\n// i32.atomic.store16 -> atomic.store<i16 from i32>\nfunction builtin_i32_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);\n\n// i32.atomic.store -> atomic.store<i32 from i32>\nfunction builtin_i32_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);\n\n// i64.atomic.store8 -> atomic.store<i8 from i64>\nfunction builtin_i64_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);\n\n// i64.atomic.store16 -> atomic.store<i16 from i64>\nfunction builtin_i64_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);\n\n// i64.atomic.store32 -> atomic.store<i32 from i64>\nfunction builtin_i64_atomic_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);\n\n// i64.atomic.store -> atomic.store<i64 from i64>\nfunction builtin_i64_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);\n\n// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>\nfunction builtin_i32_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);\n\n// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>\nfunction builtin_i32_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);\n\n// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>\nfunction builtin_i32_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);\n\n// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>\nfunction builtin_i64_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);\n\n// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>\nfunction builtin_i64_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);\n\n// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>\nfunction builtin_i64_atomic_rmw32_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);\n\n// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>\nfunction builtin_i64_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);\n\n// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>\nfunction builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);\n\n// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>\nfunction builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);\n\n// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>\nfunction builtin_i32_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);\n\n// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>\nfunction builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);\n\n// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>\nfunction builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);\n\n// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>\nfunction builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);\n\n// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>\nfunction builtin_i64_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);\n\n// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>\nfunction builtin_i32_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);\n\n// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>\nfunction builtin_i32_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);\n\n// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>\nfunction builtin_i32_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);\n\n// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>\nfunction builtin_i64_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);\n\n// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>\nfunction builtin_i64_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);\n\n// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>\nfunction builtin_i64_atomic_rmw32_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);\n\n// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>\nfunction builtin_i64_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);\n\n// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>\nfunction builtin_i32_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);\n\n// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>\nfunction builtin_i32_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);\n\n// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>\nfunction builtin_i32_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);\n\n// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>\nfunction builtin_i64_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);\n\n// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>\nfunction builtin_i64_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);\n\n// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>\nfunction builtin_i64_atomic_rmw32_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);\n\n// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>\nfunction builtin_i64_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);\n\n// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);\n\n// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);\n\n// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>\nfunction builtin_i32_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);\n\n// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);\n\n// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);\n\n// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);\n\n// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>\nfunction builtin_i64_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);\n\n// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);\n\n// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);\n\n// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);\n\n// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);\n\n// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);\n\n// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);\n\n// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);\n\n// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);\n\n// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);\n\n// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);\n\n// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);\n\n// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);\n\n// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);\n\n// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);\n\n// i32.wait -> atomic.wait<i32>\nfunction builtin_i32_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i32_wait, builtin_i32_wait);\n\n// i64.wait -> atomic.wait<i64>\nfunction builtin_i64_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i64_wait, builtin_i64_wait);\n\n// v128.load -> load<v128>\nfunction builtin_v128_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load, builtin_v128_load);\n\n// v128.load8x8_s -> v128.load_ext<i8>\nfunction builtin_v128_load8x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8x8_s, builtin_v128_load8x8_s);\n\n// v128.load8x8_u -> v128.load_ext<u8>\nfunction builtin_v128_load8x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8x8_u, builtin_v128_load8x8_u);\n\n// v128.load16x4_s -> v128.load_ext<i16>\nfunction builtin_v128_load16x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16x4_s, builtin_v128_load16x4_s);\n\n// v128.load16x4_u -> v128.load_ext<u16>\nfunction builtin_v128_load16x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16x4_u, builtin_v128_load16x4_u);\n\n// v128.load32x2_s -> v128.load_ext<i32>\nfunction builtin_v128_load32x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32x2_s, builtin_v128_load32x2_s);\n\n// v128.load32x2_u -> v128.load_ext<u32>\nfunction builtin_v128_load32x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32x2_u, builtin_v128_load32x2_u);\n\n// v128.load8_splat -> v128.load_splat<u8>\nfunction builtin_v128_load8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8_splat, builtin_v128_load8_splat);\n\n// v128.load16_splat -> v128.load_splat<u16>\nfunction builtin_v128_load16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16_splat, builtin_v128_load16_splat);\n\n// v128.load32_splat -> v128.load_splat<u32>\nfunction builtin_v128_load32_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_splat, builtin_v128_load32_splat);\n\n// v128.load64_splat -> v128.load_splat<u64>\nfunction builtin_v128_load64_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_splat, builtin_v128_load64_splat);\n\n// v128.load32_zero -> v128.load_zero<u32>\nfunction builtin_v128_load32_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_zero, builtin_v128_load32_zero);\n\n// v128.load64_zero -> v128.load_zero<u64>\nfunction builtin_v128_load64_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_zero, builtin_v128_load64_zero);\n\n// v128.load8_lane -> v128.load_lane<u8>\nfunction builtin_v128_load8_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8_lane, builtin_v128_load8_lane);\n\n// v128.load16_lane -> v128.load_lane<u16>\nfunction builtin_v128_load16_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16_lane, builtin_v128_load16_lane);\n\n// v128.load32_lane -> v128.load_lane<u32>\nfunction builtin_v128_load32_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_lane, builtin_v128_load32_lane);\n\n// v128.load64_lane -> v128.load_lane<u64>\nfunction builtin_v128_load64_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_lane, builtin_v128_load64_lane);\n\n// v128.store8_lane -> v128.store_lane<u8>\nfunction builtin_v128_store8_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store8_lane, builtin_v128_store8_lane);\n\n// v128.store16_lane -> v128.store_lane<u16>\nfunction builtin_v128_store16_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store16_lane, builtin_v128_store16_lane);\n\n// v128.store32_lane -> v128.store_lane<u32>\nfunction builtin_v128_store32_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store32_lane, builtin_v128_store32_lane);\n\n// v128.store64_lane -> v128.store_lane<u64>\nfunction builtin_v128_store64_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store64_lane, builtin_v128_store64_lane);\n\n// v128.store -> store<v128 from v128>\nfunction builtin_v128_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store, builtin_v128_store);\n\n// i8x16_splat -> v128.splat<i8>\nfunction builtin_i8x16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);\n\n// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>\nfunction builtin_i8x16_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);\n\n// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>\nfunction builtin_i8x16_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);\n\n// i8x16.replace_lane -> v128.replace_lane<i8>\nfunction builtin_i8x16_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);\n\n// i8x16.add -> v128.add<i8>\nfunction builtin_i8x16_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add, builtin_i8x16_add);\n\n// i8x16.sub -> v128.sub<i8>\nfunction builtin_i8x16_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);\n\n// i8x16.min_s -> v128.min<i8>\nfunction builtin_i8x16_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);\n\n// i8x16.min_u -> v128.min<u8>\nfunction builtin_i8x16_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);\n\n// i8x16.max_s -> v128.max<i8>\nfunction builtin_i8x16_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);\n\n// i8x16.max_u -> v128.max<u8>\nfunction builtin_i8x16_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);\n\n// i8x16.avgr_u -> v128.avgr<u8>\nfunction builtin_i8x16_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);\n\n// i8x16.abs -> v128.abs<i8>\nfunction builtin_i8x16_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);\n\n// i8x16.neg -> v128.neg<i8>\nfunction builtin_i8x16_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);\n\n// i8x16.add_sat_s -> v128.add_sat<i8>\nfunction builtin_i8x16_add_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_sat_s, builtin_i8x16_add_sat_s);\n\n// i8x16.add_sat_u -> v128.add_sat<u8>\nfunction builtin_i8x16_add_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_sat_u, builtin_i8x16_add_sat_u);\n\n// i8x16.sub_sat_s -> v128.sub_sat<i8>\nfunction builtin_i8x16_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_sat_s, builtin_i8x16_sub_sat_s);\n\n// i8x16.sub_sat_u -> v128.sub_sat<u8>\nfunction builtin_i8x16_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_sat_u, builtin_i8x16_sub_sat_u);\n\n// i8x16.shl -> v128.shl<i8>\nfunction builtin_i8x16_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);\n\n// i8x16.shr_s -> v128.shr<i8>\nfunction builtin_i8x16_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);\n\n// i8x16.shr_u -> v128.shr<u8>\nfunction builtin_i8x16_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);\n\n// i8x16.all_true -> v128.all_true<i8>\nfunction builtin_i8x16_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);\n\n// i8x16.bitmask -> v128.bitmask<i8>\nfunction builtin_i8x16_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);\n\n// i8x16.popcnt -> v128.popcnt<i8>\nfunction builtin_i8x16_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_popcnt, builtin_i8x16_popcnt);\n\n// i8x16.eq -> v128.eq<i8>\nfunction builtin_i8x16_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);\n\n// i8x16.ne -> v128.ne<i8>\nfunction builtin_i8x16_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);\n\n// i8x16.lt_s -> v128.lt<i8>\nfunction builtin_i8x16_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);\n\n// i8x16.lt_u -> v128.lt<u8>\nfunction builtin_i8x16_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);\n\n// i8x16.le_s -> v128.le<i8>\nfunction builtin_i8x16_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);\n\n// i8x16.le_u -> v128.le<u8>\nfunction builtin_i8x16_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);\n\n// i8x16.gt_s -> v128.gt<i8>\nfunction builtin_i8x16_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);\n\n// i8x16.gt_u -> v128.gt<u8>\nfunction builtin_i8x16_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);\n\n// i8x16.ge_s -> v128.ge<i8>\nfunction builtin_i8x16_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);\n\n// i8x16.ge_u -> v128.ge<u8>\nfunction builtin_i8x16_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);\n\n// i8x16.narrow_i16x8_s -> v128.narrow<i16>\nfunction builtin_i8x16_narrow_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);\n\n// i8x16.narrow_i16x8_u -> v128.narrow<u16>\nfunction builtin_i8x16_narrow_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);\n\n// i8x16.shuffle -> v128.shuffle<i8>\nfunction builtin_i8x16_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shuffle, builtin_i8x16_shuffle);\n\n// i8x16.swizzle -> v128.swizzle\nfunction builtin_i8x16_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_swizzle, builtin_i8x16_swizzle);\n\n// i16x8.splat -> v128.splat<i16>\nfunction builtin_i16x8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);\n\n// i16x8.extract_lane_s -> v128.extract_lane<i16>\nfunction builtin_i16x8_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);\n\n// i16x8..extract_lane_u -> v128.extract_lane<u16>\nfunction builtin_i16x8_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);\n\n// i16x8.replace_lane -> v128.replace_lane<i16>\nfunction builtin_i16x8_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);\n\n// i16x8.add -> v128.add<i16>\nfunction builtin_i16x8_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add, builtin_i16x8_add);\n\n// i16x8.sub -> v128.sub<i16>\nfunction builtin_i16x8_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);\n\n// i16x8.mul -> v128.mul<i16>\nfunction builtin_i16x8_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);\n\n// i16x8.min_s -> v128.min<i16>\nfunction builtin_i16x8_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);\n\n// i16x8.min_u -> v128.min<u16>\nfunction builtin_i16x8_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);\n\n// i16x8.max_s -> v128.max<i16>\nfunction builtin_i16x8_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);\n\n// i16x8.max_u -> v128.max<u16>\nfunction builtin_i16x8_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);\n\n// i16x8.avgr_u -> v128.avgr<u16>\nfunction builtin_i16x8_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);\n\n// i16x8.abs -> v128.abs<i16>\nfunction builtin_i16x8_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);\n\n// i16x8.neg -> v128.neg<i16>\nfunction builtin_i16x8_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);\n\n// i16x8.add_sat_s -> v128.add_sat<i16>\nfunction builtin_i16x8_add_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_sat_s, builtin_i16x8_add_sat_s);\n\n// i16x8.add_sat_u -> v128.add_sat<u16>\nfunction builtin_i16x8_add_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_sat_u, builtin_i16x8_add_sat_u);\n\n// i16x8.sub_sat_s -> v128.sub_sat<i16>\nfunction builtin_i16x8_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_sat_s, builtin_i16x8_sub_sat_s);\n\n// i16x8.sub_sat_u -> v128.sub_sat<u16>\nfunction builtin_i16x8_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_sat_u, builtin_i16x8_sub_sat_u);\n\n// i16x8.shl -> v128.shl<i16>\nfunction builtin_i16x8_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);\n\n// i16x8.shr_s -> v128.shr<i16>\nfunction builtin_i16x8_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);\n\n// i16x8.shr_u -> v128.shr<u16>\nfunction builtin_i16x8_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);\n\n// i16x8.all_true -> v128.all_true<i16>\nfunction builtin_i16x8_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);\n\n// i16x8.bitmask -> v128.bitmask<i16>\nfunction builtin_i16x8_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);\n\n// i16x8.eq -> v128.eq<i16>\nfunction builtin_i16x8_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);\n\n// i16x8.ne -> v128.ne<i16>\nfunction builtin_i16x8_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);\n\n// i16x8.lt_s -> v128.lt<i16>\nfunction builtin_i16x8_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);\n\n// i16x8.lt_u -> v128.lt<u16>\nfunction builtin_i16x8_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);\n\n// i16x8.le_s -> v128.le<i16>\nfunction builtin_i16x8_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);\n\n// i16x8.le_u -> v128.le<u16>\nfunction builtin_i16x8_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);\n\n// i16x8.gt_s -> v128.gt<i16>\nfunction builtin_i16x8_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);\n\n// i16x8.gt_u -> v128.gt<u16>\nfunction builtin_i16x8_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);\n\n// i16x8.ge_s -> v128.ge<i16>\nfunction builtin_i16x8_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);\n\n// i16x8.ge_u -> v128.ge<u16>\nfunction builtin_i16x8_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);\n\n// i16x8.narrow_i32x4_s -> v128.narrow<i32>\nfunction builtin_i16x8_narrow_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);\n\n// i16x8.narrow_i32x4_u -> v128.narrow<u32>\nfunction builtin_i16x8_narrow_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);\n\n// i16x8.extend_low_i8x16_s -> v128.extend_low<i8>\nfunction builtin_i16x8_extend_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_s, builtin_i16x8_extend_low_i8x16_s);\n\n// i16x8.extend_low_i8x16_u -> v128.extend_low<u8>\nfunction builtin_i16x8_extend_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_u, builtin_i16x8_extend_low_i8x16_u);\n\n// i16x8.extend_high_i8x16_s -> v128.extend_high<i8>\nfunction builtin_i16x8_extend_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_s, builtin_i16x8_extend_high_i8x16_s);\n\n// i16x8.extend_high_i8x16_u -> v128.extend_high<u8>\nfunction builtin_i16x8_extend_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_u, builtin_i16x8_extend_high_i8x16_u);\n\n// i16x8.extadd_pairwise_i8x16_s -> v128.extadd_pairwise<i8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_s, builtin_i16x8_extadd_pairwise_i8x16_s);\n\n// i16x8.extadd_pairwise_i8x16_u -> v128.extadd_pairwise<u8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_u, builtin_i16x8_extadd_pairwise_i8x16_u);\n\n// i16x8.q15mulr_sat_s -> v128.q15mulr_sat<i16>\nfunction builtin_i16x8_q15mulr_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_q15mulr_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_q15mulr_sat_s, builtin_i16x8_q15mulr_sat_s);\n\n// i16x8.extmul_low_i8x16_s -> v128.extmul_low<i16>\nfunction builtin_i16x8_extmul_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_s, builtin_i16x8_extmul_low_i8x16_s);\n\n// i16x8.extmul_low_i8x16_u -> v128.extmul_low<u16>\nfunction builtin_i16x8_extmul_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_u, builtin_i16x8_extmul_low_i8x16_u);\n\n// i16x8.extmul_high_i8x16_s -> v128.extmul_high<i16>\nfunction builtin_i16x8_extmul_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_s, builtin_i16x8_extmul_high_i8x16_s);\n\n// i16x8.extmul_high_i8x16_u -> v128.extmul_high<u16>\nfunction builtin_i16x8_extmul_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_u, builtin_i16x8_extmul_high_i8x16_u);\n\n// i16x8.shuffle -> v128.shuffle<i16>\nfunction builtin_i16x8_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shuffle, builtin_i16x8_shuffle);\n\n// i16x8.swizzle -> v128.swizzle\nfunction builtin_i16x8_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_swizzle, builtin_i16x8_swizzle);\n\n// i32x4.splat -> v128.splat<i32>\nfunction builtin_i32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);\n\n// i32x4.extract_lane -> <i32>v128.extract_lane<i32>\nfunction builtin_i32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);\n\n// i32x4.replace_lane -> v128.replace_lane<i32>\nfunction builtin_i32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);\n\n// i32x4.add -> v128.add<i32>\nfunction builtin_i32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_add, builtin_i32x4_add);\n\n// i32x4.sub -> v128.sub<i32>\nfunction builtin_i32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);\n\n// i32x4.mul -> v128.mul<i32>\nfunction builtin_i32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);\n\n// i32x4.min_s -> v128.min<i32>\nfunction builtin_i32x4_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);\n\n// i32x4.min_u -> v128.min<u32>\nfunction builtin_i32x4_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);\n\n// i32x4.max_s -> v128.max<i32>\nfunction builtin_i32x4_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);\n\n// i32x4.max_u -> v128.max<u32>\nfunction builtin_i32x4_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);\n\n// i32x4.dot_i16x8_s -> v128.dot<i16>\nfunction builtin_i32x4_dot_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_dot(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);\n\n// i32x4.abs -> v128.abs<i32>\nfunction builtin_i32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);\n\n// i32x4.neg -> v128.neg<i32>\nfunction builtin_i32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);\n\n// i32x4.shl -> v128.shl<i32>\nfunction builtin_i32x4_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);\n\n// i32x4.shr_s -> v128.shr<i32>\nfunction builtin_i32x4_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);\n\n// i32x4.shr_u -> v128.shr<u32>\nfunction builtin_i32x4_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);\n\n// i32x4.all_true -> v128.all_true<i32>\nfunction builtin_i32x4_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);\n\n// i32x4.bitmask -> v128.bitmask<i32>\nfunction builtin_i32x4_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);\n\n// i32x4.eq -> v128.eq<i32>\nfunction builtin_i32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);\n\n// i32x4.ne -> v128.ne<i32>\nfunction builtin_i32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);\n\n// i32x4.lt_s -> v128.lt<i32>\nfunction builtin_i32x4_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);\n\n// i32x4.lt_u -> v128.lt<u32>\nfunction builtin_i32x4_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);\n\n// i32x4.le_s -> v128.le<i32>\nfunction builtin_i32x4_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);\n\n// i32x4.le_u -> v128.le<u32>\nfunction builtin_i32x4_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);\n\n// i32x4.gt_s -> v128.gt<i32>\nfunction builtin_i32x4_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);\n\n// i32x4.gt_u -> v128.gt<u32>\nfunction builtin_i32x4_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);\n\n// i32x4.ge_s -> v128.ge<i32>\nfunction builtin_i32x4_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);\n\n// i32x4.ge_u -> v128.ge<u32>\nfunction builtin_i32x4_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);\n\n// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>\nfunction builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);\n\n// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>\nfunction builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);\n\n// i32x4.trunc_sat_f64x2_s_zero -> v128.trunc_sat_zero<i32>\nfunction builtin_i32x4_trunc_sat_f64x2_s_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_s_zero, builtin_i32x4_trunc_sat_f64x2_s_zero);\n\n// i32x4.trunc_sat_f64x2_u_zero -> v128.trunc_sat_zero<u32>\nfunction builtin_i32x4_trunc_sat_f64x2_u_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_u_zero, builtin_i32x4_trunc_sat_f64x2_u_zero);\n\n// i32x4.extend_low_i16x8_s -> // v128.extend_low<i16>\nfunction builtin_i32x4_extend_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_s, builtin_i32x4_extend_low_i16x8_s);\n\n// i32x4.extend_low_i16x8_u -> v128.extend_low<u16>\nfunction builtin_i32x4_extend_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_u, builtin_i32x4_extend_low_i16x8_u);\n\n// i32x4.extend_high_i16x8_s -> v128.extend_high<i16>\nfunction builtin_i32x4_extend_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_s, builtin_i32x4_extend_high_i16x8_s);\n\n// i32x4.extend_high_i16x8_u -> v128.extend_high<u16>\nfunction builtin_i32x4_extend_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_u, builtin_i32x4_extend_high_i16x8_u);\n\n// i32x4.extadd_pairwise_i16x8_s -> v128.extadd_pairwise<i16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_s, builtin_i32x4_extadd_pairwise_i16x8_s);\n\n// i32x4.extadd_pairwise_i16x8_u -> v128.extadd_pairwise<u16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_u, builtin_i32x4_extadd_pairwise_i16x8_u);\n\n// i32x4.extmul_low_i16x8_s -> v128.extmul_low<i16>\nfunction builtin_i32x4_extmul_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_s, builtin_i32x4_extmul_low_i16x8_s);\n\n// i32x4.extmul_low_i16x8_u -> v128.extmul_low<u16>\nfunction builtin_i32x4_extmul_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_u, builtin_i32x4_extmul_low_i16x8_u);\n\n// i32x4.extmul_high_i16x8_s -> v128.extmul_high<i16>\nfunction builtin_i32x4_extmul_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_s, builtin_i32x4_extmul_high_i16x8_s);\n\n// i32x4.extmul_high_i16x8_u -> v128.extmul_high<u16>\nfunction builtin_i32x4_extmul_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_u, builtin_i32x4_extmul_high_i16x8_u);\n\n// i32x4.shuffle -> v128.shuffle<i32>\nfunction builtin_i32x4_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shuffle, builtin_i32x4_shuffle);\n\n// i32x4.swizzle -> v128.swizzle\nfunction builtin_i32x4_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_swizzle, builtin_i32x4_swizzle);\n\n// i64x2.splat -> v128.splat<i64>\nfunction builtin_i64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);\n\n// i64x2.extract_lane -> <i64>v128.extract_lane<i64>\nfunction builtin_i64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);\n\n// i64x2.replace_lane -> v128.replace_lane<i64>\nfunction builtin_i64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);\n\n// i64x2.add -> v128.add<i64>\nfunction builtin_i64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_add, builtin_i64x2_add);\n\n// i64x2.sub -> v128.sub<i64>\nfunction builtin_i64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);\n\n// i64x2.mul -> v128.mul<i64>\nfunction builtin_i64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_mul, builtin_i64x2_mul);\n\n// i64x2.abs -> v128.abs<i64>\nfunction builtin_i64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_abs, builtin_i64x2_abs);\n\n// i64x2.neg -> v128.neg<i64>\nfunction builtin_i64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);\n\n// i64x2.shl -> v128.shl<i64>\nfunction builtin_i64x2_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);\n\n// i64x2.shr_s -> v128.shr<i64>\nfunction builtin_i64x2_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);\n\n// i64x2.shr_u -> v128.shr<u64>\nfunction builtin_i64x2_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);\n\n// i64x2.all_true -> v128.all_true<i64>\nfunction builtin_i64x2_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);\n\n// i64x2.bitmask -> v128.bitmask<i64>\nfunction builtin_i64x2_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_bitmask, builtin_i64x2_bitmask);\n\n// i64x2.eq -> v128.eq<i64>\nfunction builtin_i64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_eq, builtin_i64x2_eq);\n\n// i64x2.ne -> v128.ne<i64>\nfunction builtin_i64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_ne, builtin_i64x2_ne);\n\n// i64x2.lt_s -> v128.lt<i64>\nfunction builtin_i64x2_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_lt_s, builtin_i64x2_lt_s);\n\n// i64x2.le_s -> v128.le<i64>\nfunction builtin_i64x2_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_le_s, builtin_i64x2_le_s);\n\n// i64x2.gt_s -> v128.gt<i64>\nfunction builtin_i64x2_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_gt_s, builtin_i64x2_gt_s);\n\n// i64x2.ge_s -> v128.ge<i64>\nfunction builtin_i64x2_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_ge_s, builtin_i64x2_ge_s);\n\n// i64x2.extend_low_i32x4_s -> // v128.extend_low<i32>\nfunction builtin_i64x2_extend_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_s, builtin_i64x2_extend_low_i32x4_s);\n\n// i64x2.extend_low_i32x4_u -> v128.extend_low<u32>\nfunction builtin_i64x2_extend_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_u, builtin_i64x2_extend_low_i32x4_u);\n\n// i64x2.extend_high_i32x4_s -> v128.extend_high<i32>\nfunction builtin_i64x2_extend_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_s, builtin_i64x2_extend_high_i32x4_s);\n\n// i64x2.extend_high_i32x4_u -> v128.extend_high<u32>\nfunction builtin_i64x2_extend_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_u, builtin_i64x2_extend_high_i32x4_u);\n\n// i64x2.extmul_low_i32x4_s -> v128.extmul_low<i32>\nfunction builtin_i64x2_extmul_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_s, builtin_i64x2_extmul_low_i32x4_s);\n\n// i64x2.extmul_low_i32x4_u -> v128.extmul_low<u32>\nfunction builtin_i64x2_extmul_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_u, builtin_i64x2_extmul_low_i32x4_u);\n\n// i64x2.extmul_high_i32x4_s -> v128.extmul_high<i32>\nfunction builtin_i64x2_extmul_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_s, builtin_i64x2_extmul_high_i32x4_s);\n\n// i64x2.extmul_high_i32x4_u -> v128.extmul_high<u32>\nfunction builtin_i64x2_extmul_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_u, builtin_i64x2_extmul_high_i32x4_u);\n\n// i64x2.shuffle -> v128.shuffle<i64>\nfunction builtin_i64x2_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shuffle, builtin_i64x2_shuffle);\n\n// i64x2.swizzle -> v128.swizzle\nfunction builtin_i64x2_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_swizzle, builtin_i64x2_swizzle);\n\n// f32x4.splat -> v128.splat<f32>\nfunction builtin_f32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);\n\n// f32x4.extract_lane -> <f32>v128.extract_lane<f32>\nfunction builtin_f32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);\n\n// f32x4.replace_lane -> v128.replace_lane<f32>\nfunction builtin_f32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);\n\n// f32x4.add -> v128.add<f32>\nfunction builtin_f32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_add, builtin_f32x4_add);\n\n// f32x4.sub -> v128.sub<f32>\nfunction builtin_f32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);\n\n// f32x4.mul -> v128.mul<f32>\nfunction builtin_f32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);\n\n// f32x4.div -> v128.div<f32>\nfunction builtin_f32x4_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_div, builtin_f32x4_div);\n\n// f32x4.neg -> v128.neg<f32>\nfunction builtin_f32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);\n\n// f32x4.min -> v128.min<f32>\nfunction builtin_f32x4_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_min, builtin_f32x4_min);\n\n// f32x4.max -> v128.max<f32>\nfunction builtin_f32x4_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_max, builtin_f32x4_max);\n\n// f32x4.pmin -> v128.pmin<f32>\nfunction builtin_f32x4_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);\n\n// f32x4.pmax -> v128.pmax<f32>\nfunction builtin_f32x4_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);\n\n// f32x4.abs -> v128.abs<f32>\nfunction builtin_f32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);\n\n// f32x4.sqrt -> v128.sqrt<f32>\nfunction builtin_f32x4_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);\n\n// f32x4.ceil -> v128.ceil<f32>\nfunction builtin_f32x4_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);\n\n// f32x4.floor -> v128.floor<f32>\nfunction builtin_f32x4_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);\n\n// f32x4.trunc -> v128.trunc<f32>\nfunction builtin_f32x4_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);\n\n// f32x4.nearest -> v128.nearest<f32>\nfunction builtin_f32x4_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);\n\n// f32x4.eq -> v128.eq<f32>\nfunction builtin_f32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);\n\n// f32x4.ne -> v128.ne<f32>\nfunction builtin_f32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);\n\n// f32x4.lt -> v128.lt<f32>\nfunction builtin_f32x4_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);\n\n// f32x4.le -> v128.le<f32>\nfunction builtin_f32x4_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_le, builtin_f32x4_le);\n\n// f32x4.gt -> v128.gt<f32>\nfunction builtin_f32x4_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);\n\n// f32x4.ge -> v128.ge<f32>\nfunction builtin_f32x4_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);\n\n// f32x4.convert_i32x4_s -> v128.convert<i32>\nfunction builtin_f32x4_convert_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);\n\n// f32x4.convert_i32x4_u -> v128.convert<u32>\nfunction builtin_f32x4_convert_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);\n\n// f32x4.demote_f64x2_zero -> v128.demote_zero<f64>\nfunction builtin_f32x4_demote_f64x2_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_demote_zero(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_demote_f64x2_zero, builtin_f32x4_demote_f64x2_zero);\n\n// f32x4.shuffle -> v128.shuffle<f32>\nfunction builtin_f32x4_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_shuffle, builtin_f32x4_shuffle);\n\n// f32x4.swizzle -> v128.swizzle\nfunction builtin_f32x4_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_swizzle, builtin_f32x4_swizzle);\n\n// f64x2.splat -> v128.splat<f64>\nfunction builtin_f64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);\n\n// f64x2.extract_lane -> <f64>v128.extract_lane<f64>\nfunction builtin_f64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);\n\n// f64x2.replace_lane -> v128.replace_lane\nfunction builtin_f64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);\n\n// f64x2.add -> v128.add<f64>\nfunction builtin_f64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_add, builtin_f64x2_add);\n\n// f64x2.sub -> v128.sub<f64>\nfunction builtin_f64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);\n\n// f64x2.mul -> v128.mul<f64>\nfunction builtin_f64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);\n\n// f64x2.div -> v128.div<f64>\nfunction builtin_f64x2_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_div, builtin_f64x2_div);\n\n// f64x2.neg -> v128.neg<f64>\nfunction builtin_f64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);\n\n// f64x2.min -> v128.min<f64>\nfunction builtin_f64x2_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_min, builtin_f64x2_min);\n\n// f64x2.max -> v128.max<f64>\nfunction builtin_f64x2_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_max, builtin_f64x2_max);\n\n// f64x2.pmin -> v128.pmin<f64>\nfunction builtin_f64x2_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);\n\n// f64x2.pmax -> v128.pmax<f64>\nfunction builtin_f64x2_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);\n\n// f64x2.abs -> v128.abs<f64>\nfunction builtin_f64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);\n\n// f64x2.sqrt -> v128.sqrt<f64>\nfunction builtin_f64x2_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);\n\n// f64x2.ceil -> v128.ceil<f64>\nfunction builtin_f64x2_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);\n\n// f64x2.floor -> v128.floor<f64>\nfunction builtin_f64x2_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);\n\n// f64x2.trunc -> v128.trunc<f64>\nfunction builtin_f64x2_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);\n\n// f64x2.nearest -> v128.nearest<f64>\nfunction builtin_f64x2_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);\n\n// f64x2.eq -> v128.eq<f64>\nfunction builtin_f64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);\n\n// f64x2.ne -> v128.ne<f64>\nfunction builtin_f64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);\n\n// f64x2.lt -> v128.lt<f64>\nfunction builtin_f64x2_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);\n\n// f64x2.le -> v128.le<f64>\nfunction builtin_f64x2_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_le, builtin_f64x2_le);\n\n// f64x2.gt -> v128.gt<f64>\nfunction builtin_f64x2_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);\n\n// f64x2.ge -> v128.ge<f64>\nfunction builtin_f64x2_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);\n\n// f64x2.convert_low_i32x4_s -> v128.convert_low<i32>\nfunction builtin_f64x2_convert_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_s, builtin_f64x2_convert_low_i32x4_s);\n\n// f64x2.convert_low_i32x4_u -> v128.convert_low<u32>\nfunction builtin_f64x2_convert_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_u, builtin_f64x2_convert_low_i32x4_u);\n\n// f64x2.promote_low_f32x4 -> v128.promote_low<f32>\nfunction builtin_f64x4_promote_low_f32x4(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_promote_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_promote_low_f32x4, builtin_f64x4_promote_low_f32x4);\n\n// f64x2.shuffle -> v128.shuffle<f32>\nfunction builtin_f64x2_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_shuffle, builtin_f64x2_shuffle);\n\n// f64x2.swizzle -> v128.swizzle\nfunction builtin_f64x2_swizzle(ctx: BuiltinContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_swizzle, builtin_f64x2_swizzle);\n\n// === Internal helpers =======================================================================\n\n/** Compiles the `visit_globals` function. */\nexport function compileVisitGlobals(compiler: Compiler): void {\n  let module = compiler.module;\n  let exprs = new Array<ExpressionRef>();\n  let sizeTypeRef = compiler.options.sizeTypeRef;\n  let visitInstance = assert(compiler.program.visitInstance);\n\n  // this function is @lazy: make sure it exists\n  compiler.compileFunction(visitInstance, true);\n\n  // TODO: for (let element of compiler.program.elementsByName.values()) {\n  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {\n    let element = unchecked(_values[i]);\n    if (element.kind != ElementKind.Global) continue;\n    let global = <Global>element;\n    let globalType = global.type;\n    let classReference = globalType.getClass();\n    if (\n      classReference &&\n      !classReference.hasDecorator(DecoratorFlags.Unmanaged) &&\n      global.is(CommonFlags.Compiled)\n    ) {\n      if (global.is(CommonFlags.Inlined)) {\n        let value = global.constantIntegerValue;\n        if (i64_low(value) || i64_high(value)) {\n          exprs.push(\n            module.call(visitInstance.internalName, [\n              compiler.options.isWasm64\n                ? module.i64(i64_low(value), i64_high(value))\n                : module.i32(i64_low(value)),\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          );\n        }\n      } else {\n        exprs.push(\n          module.if(\n            module.local_tee(1,\n              module.global_get(global.internalName, sizeTypeRef),\n              false // internal\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(1, sizeTypeRef), // tempRef != null\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          )\n        );\n      }\n    }\n  }\n  module.addFunction(BuiltinNames.visit_globals,\n    TypeRef.I32,  // cookie\n    TypeRef.None, // => void\n    [ sizeTypeRef ],\n    exprs.length\n      ? module.block(null, exprs)\n      : module.nop()\n  );\n}\n\n/** Ensures that the visitor function of the specified class is compiled. */\nfunction ensureVisitMembersOf(compiler: Compiler, instance: Class): void {\n  assert(instance.type.isManaged);\n  if (instance.visitRef) return;\n\n  let program = compiler.program;\n  let module = compiler.module;\n  let usizeType = program.options.usizeType;\n  let sizeTypeRef = usizeType.toRef();\n  let sizeTypeSize = usizeType.byteSize;\n  let visitInstance = assert(program.visitInstance);\n  let body = new Array<ExpressionRef>();\n\n  // If the class has a base class, call its visitor first\n  let base = instance.base;\n  if (base) {\n    body.push(\n      module.call(`${base.internalName}~visit`, [\n        module.local_get(0, sizeTypeRef), // this\n        module.local_get(1, TypeRef.I32)  // cookie\n      ], TypeRef.None)\n    );\n  }\n\n  // Some standard library components provide a custom visitor implementation,\n  // for example to visit all members of a collection, e.g. arrays and maps.\n  let hasVisitImpl = false;\n  if (instance.isDeclaredInLibrary) {\n    let visitPrototype = instance.getMember(\"__visit\");\n    if (visitPrototype) {\n      assert(visitPrototype.kind == ElementKind.FunctionPrototype);\n      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);\n      if (!visitInstance || !compiler.compileFunction(visitInstance)) {\n        body.push(\n          module.unreachable()\n        );\n      } else {\n        let visitSignature = visitInstance.signature;\n        let visitThisType = assert(visitSignature.thisType);\n        assert(\n          visitSignature.parameterTypes.length == 1 &&\n          visitSignature.parameterTypes[0] == Type.u32 &&\n          visitSignature.returnType == Type.void &&\n          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super\n        );\n        body.push(\n          module.call(visitInstance.internalName, [\n            module.local_get(0, sizeTypeRef), // this\n            module.local_get(1, TypeRef.I32)  // cookie\n          ], TypeRef.None)\n        );\n      }\n      hasVisitImpl = true;\n    }\n  }\n\n  // Otherwise, if there is no custom visitor, generate a visitor function\n  // according to class layout, visiting all _own_ managed members.\n  let needsTempValue = false;\n  if (!hasVisitImpl) {\n    let members = instance.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {\n        let member = unchecked(_values[j]);\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        // Class should have resolved fields during finalization\n        let property = (<PropertyPrototype>member).instance;\n        if (!property) continue;\n        let fieldType = property.type;\n        if (!property.isField || property.getBoundClassOrInterface() != instance || !fieldType.isManaged) continue;\n        let fieldOffset = property.memoryOffset;\n        assert(fieldOffset >= 0);\n        needsTempValue = true;\n        body.push(\n          // if ($2 = value) __visit($2, $1)\n          module.if(\n            module.local_tee(2,\n              module.load(sizeTypeSize, false,\n                module.local_get(0, sizeTypeRef),\n                sizeTypeRef, fieldOffset\n              ),\n              false // internal\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(2, sizeTypeRef), // value\n              module.local_get(1, TypeRef.I32)  // cookie\n            ], TypeRef.None)\n          )\n        );\n      }\n    }\n  }\n\n  // Create the visitor function\n  instance.visitRef = module.addFunction(`${instance.internalName}~visit`,\n    createType([sizeTypeRef, TypeRef.I32]),\n    TypeRef.None,\n    needsTempValue ? [ sizeTypeRef ] : null,\n    module.flatten(body, TypeRef.None)\n  );\n\n  // And make sure the base visitor function exists\n  if (base && base.type.isManaged) {\n    // errored earlier if not managed\n    ensureVisitMembersOf(compiler, base);\n  }\n}\n\n/** Compiles the `__visit_members` function. */\nexport function compileVisitMembers(compiler: Compiler): void {\n  let program = compiler.program;\n  let module = compiler.module;\n  let usizeType = program.options.usizeType;\n  let sizeTypeRef = usizeType.toRef();\n  let managedClasses = program.managedClasses;\n  let visitInstance = assert(program.visitInstance);\n  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled\n\n  // Prepare a mapping of class names to visitor calls. Each name corresponds to\n  // the respective sequential (0..N) class id.\n  let names = new Array<string>();\n  let cases = new Array<ExpressionRef>();\n  let nextId = 0;\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = _keys[i];\n    assert(instanceId == nextId++);\n    let instance = assert(managedClasses.get(instanceId));\n    names[i] = instance.internalName;\n    if (instance.isPointerfree) {\n      cases[i] = module.return();\n    } else {\n      cases[i] = module.block(null, [\n        module.call(`${instance.internalName}~visit`, [\n          module.local_get(0, sizeTypeRef), // this\n          module.local_get(1, TypeRef.I32)  // cookie\n        ], TypeRef.None),\n        module.return()\n      ], TypeRef.None);\n      ensureVisitMembersOf(compiler, instance);\n    }\n  }\n\n  // Make a br_table of the mapping, calling visitor functions by unique class id\n  let current = module.block(names[0], [\n    module.switch(names, \"invalid\",\n      // load<u32>(changetype<usize>(this) - 8)\n      module.load(4, false,\n        sizeTypeRef == TypeRef.I64\n          ? module.binary(BinaryOp.SubI64,\n              module.local_get(0, sizeTypeRef),\n              module.i64(8)\n            )\n          : module.binary(BinaryOp.SubI32,\n              module.local_get(0, sizeTypeRef),\n              module.i32(8) // rtId is at -8\n            ),\n        TypeRef.I32, 0\n      )\n    )\n  ], TypeRef.None);\n\n  // Wrap blocks in order\n  for (let i = 0, k = names.length - 1; i < k; ++i) {\n    current = module.block(names[i + 1], [\n      current,\n      cases[i]\n    ], TypeRef.None);\n  }\n\n  // Wrap the last id in an 'invalid' block to break out of on invalid ids\n  current = module.block(\"invalid\", [\n    current,\n    cases[names.length - 1]\n  ], TypeRef.None);\n\n  // Add the function, executing an unreachable if breaking to 'invalid'\n  module.addFunction(BuiltinNames.visit_members,\n    createType([ sizeTypeRef, TypeRef.I32 ]), // this, cookie\n    TypeRef.None, // => void\n    null,\n    module.flatten([\n      current,\n      module.unreachable()\n    ])\n  );\n}\n\nfunction typeToRuntimeFlags(type: Type): TypeinfoFlags {\n  let flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);\n  if (type.is(TypeFlags.Signed))   flags |= TypeinfoFlags.VALUE_SIGNED;\n  if (type.is(TypeFlags.Float))    flags |= TypeinfoFlags.VALUE_FLOAT;\n  if (type.is(TypeFlags.Nullable)) flags |= TypeinfoFlags.VALUE_NULLABLE;\n  if (type.isManaged)              flags |= TypeinfoFlags.VALUE_MANAGED;\n  return flags / TypeinfoFlags.VALUE_ALIGN_0;\n}\n\n/** Compiles runtime type information for use by stdlib. */\nexport function compileRTTI(compiler: Compiler): void {\n  let program = compiler.program;\n  let module = compiler.module;\n  let managedClasses = program.managedClasses;\n  let count = managedClasses.size;\n  let size = 4 + 4 * count; // count | TypeInfo*\n  let data = new Uint8Array(size);\n  writeI32(count, data, 0);\n  let off = 4;\n  let abvInstance = program.arrayBufferViewInstance;\n  let abvPrototype = abvInstance.prototype;\n  let arrayPrototype = program.arrayPrototype;\n  let setPrototype = program.setPrototype;\n  let mapPrototype = program.mapPrototype;\n  let staticArrayPrototype = program.staticArrayPrototype;\n  let lastId = 0;\n  // TODO: for (let [instanceId, instance] of managedClasses) {\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = unchecked(_keys[i]);\n    let instance = assert(managedClasses.get(instanceId));\n    assert(instanceId == lastId++);\n    let flags: TypeinfoFlags = 0;\n    if (instance.isPointerfree) flags |= TypeinfoFlags.POINTERFREE;\n    if (instance != abvInstance && instance.extendsPrototype(abvPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extendsPrototype(arrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extendsPrototype(setPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));\n      assert(typeArguments.length == 1);\n      flags |= TypeinfoFlags.SET;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n    } else if (instance.extendsPrototype(mapPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));\n      assert(typeArguments.length == 2);\n      flags |= TypeinfoFlags.MAP;\n      flags |= TypeinfoFlags.KEY_ALIGN_0   * typeToRuntimeFlags(typeArguments[0]);\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);\n    } else if (instance.extendsPrototype(staticArrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.STATICARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    }\n    writeI32(flags, data, off); off += 4;\n    instance.rttiFlags = flags;\n  }\n  assert(off == size);\n  let usizeType = program.options.usizeType;\n  let segment = compiler.addAlignedMemorySegment(data);\n  if (usizeType.size == 8) {\n    let offset = segment.offset;\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, false, module.i64(i64_low(offset), i64_high(offset)));\n  } else {\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, false, module.i32(i64_low(segment.offset)));\n  }\n}\n\n// Helpers\n\nlet checkConstantType_expr: ExpressionRef = 0;\n\n/** Checks the constant type of a type argument *or* expression. */\nfunction checkConstantType(ctx: BuiltinContext): Type | null {\n  let compiler = ctx.compiler;\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  checkConstantType_expr = 0;\n  if (operands.length == 0) { // requires type argument\n    if (!typeArguments || typeArguments.length != 1) {\n      compiler.error(\n        DiagnosticCode.Expected_0_type_arguments_but_got_1,\n        ctx.reportNode.typeArgumentsRange, \"1\", typeArguments ? typeArguments.length.toString() : \"0\"\n      );\n      return null;\n    }\n    return typeArguments[0];\n  }\n  if (operands.length == 1) { // optional type argument\n    if (typeArguments && typeArguments.length > 0) {\n      if (typeArguments.length > 1) {\n        compiler.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n        );\n        return null;\n      }\n      checkConstantType_expr = compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit);\n    } else {\n      checkConstantType_expr = compiler.compileExpression(operands[0], Type.auto);\n    }\n    return compiler.currentType;\n  }\n  if (typeArguments && typeArguments.length > 1) {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n    );\n  }\n  compiler.error(\n    DiagnosticCode.Expected_0_arguments_but_got_1,\n    ctx.reportNode.argumentsRange, \"1\", operands.length.toString()\n  );\n  return null;\n}\n\n/** Reifies a constant type check potentially involving an expression. */\nfunction reifyConstantType(ctx: BuiltinContext, expr: ExpressionRef): ExpressionRef {\n  let module = ctx.compiler.module;\n  if (checkConstantType_expr && mustPreserveSideEffects(checkConstantType_expr, module.ref)) {\n    expr = module.block(null, [\n      module.maybeDrop(checkConstantType_expr),\n      expr\n    ], getExpressionType(expr));\n  }\n  return expr;\n}\n\n/** Evaluates a compile-time constant immediate offset argument.*/\nfunction evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {\n  let module = compiler.module;\n  let value: i32;\n  if (compiler.options.isWasm64) {\n    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      assert(getConstValueI64High(precomp) == 0); // TODO\n      value = getConstValueI64Low(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  } else {\n    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      value = getConstValueI32(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  }\n  return value;\n}\n\n/** Evaluates a compile-time constant immediate align argument. */\nfunction evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {\n  let align = evaluateImmediateOffset(expression, compiler);\n  if (align < 0) return align;\n  if (align < 1 || naturalAlign > 16) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n      expression.range, \"Alignment\", \"1\", naturalAlign.toString()\n    );\n    return -1;\n  }\n  if (!isPowerOf2(align)) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_power_of_two,\n      expression.range, \"Alignment\"\n    );\n    return -1;\n  }\n  return align;\n}\n\n/** Checks that the specified feature is enabled. */\nfunction checkFeatureEnabled(ctx: BuiltinContext, feature: Feature): i32 {\n  let compiler = ctx.compiler;\n  if (!compiler.options.hasFeature(feature)) {\n    compiler.error(\n      DiagnosticCode.Feature_0_is_not_enabled,\n      ctx.reportNode.range, featureToString(feature)\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call with a single required type argument. Returns `1` on error. */\nfunction checkTypeRequired(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  let compiler = ctx.compiler;\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n  } else {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.range, \"1\", \"0\"\n    );\n  }\n  return 1;\n}\n\n/** Checks a call with a single optional type argument. Returns `1` on error. */\nfunction checkTypeOptional(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let compiler = ctx.compiler;\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that is not generic. Returns `1` on error. */\nfunction checkTypeAbsent(ctx: BuiltinContext): i32 {\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let prototype = ctx.prototype;\n    prototype.program.error(\n      DiagnosticCode.Type_0_is_not_generic,\n      ctx.reportNode.typeArgumentsRange, prototype.internalName\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */\nfunction checkArgsRequired(ctx: BuiltinContext, expected: i32): i32 {\n  let operands = ctx.operands;\n  if (operands.length != expected) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expected.toString(), operands.length.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a variable number of arguments. Returns `1` on error. */\nfunction checkArgsOptional(ctx: BuiltinContext, expectedMinimum: i32, expectedMaximum: i32): i32 {\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  if (numOperands < expectedMinimum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()\n    );\n    return 1;\n  } else if (numOperands > expectedMaximum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Makes an usize constant matching contextual type if reasonable. */\nfunction contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {\n  let module = compiler.module;\n  // Check if contextual type fits\n  if (contextualType != Type.auto && contextualType.isIntegerValue) {\n    switch (contextualType.kind) {\n      case TypeKind.I32: {\n        if (i64_is_i32(value)) {\n          compiler.currentType = Type.i32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.U32: {\n        if (i64_is_u32(value)) {\n          compiler.currentType = Type.u32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        compiler.currentType = contextualType;\n        return module.i64(i64_low(value), i64_high(value));\n      }\n      // isize/usize falls through\n      // small int is probably not intended\n    }\n  }\n  // Default to usize\n  if (compiler.options.isWasm64) {\n    compiler.currentType = Type.usize64;\n    return module.i64(i64_low(value), i64_high(value));\n  } else {\n    compiler.currentType = Type.usize32;\n    assert(!i64_high(value));\n    return module.i32(i64_low(value));\n  }\n}\n", "/**\n * @fileoverview Infrastructure for custom Binaryen passes.\n * @license Apache-2.0\n */\n\nimport {\n  Module,\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  GlobalRef,\n  Index,\n  StringRef\n} from \"../module\";\n\nimport {\n  _BinaryenExpressionGetId,\n  _BinaryenBlockGetNumChildren,\n  _BinaryenBlockGetChildAt,\n  _BinaryenIfGetCondition,\n  _BinaryenIfGetIfTrue,\n  _BinaryenIfGetIfFalse,\n  _BinaryenLoopGetBody,\n  _BinaryenBreakGetCondition,\n  _BinaryenBreakGetValue,\n  _BinaryenGetNumFunctions,\n  _BinaryenGetFunctionByIndex,\n  _BinaryenGetNumGlobals,\n  _BinaryenGetGlobalByIndex,\n  _BinaryenFunctionGetBody,\n  _BinaryenSwitchGetCondition,\n  _BinaryenSwitchGetValue,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenLocalSetGetValue,\n  _BinaryenGlobalSetGetValue,\n  _BinaryenGlobalGetInitExpr,\n  _BinaryenLoadGetPtr,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreGetValue,\n  _BinaryenUnaryGetValue,\n  _BinaryenBinaryGetLeft,\n  _BinaryenBinaryGetRight,\n  _BinaryenSelectGetIfTrue,\n  _BinaryenSelectGetIfFalse,\n  _BinaryenSelectGetCondition,\n  _BinaryenDropGetValue,\n  _BinaryenBlockSetChildAt,\n  _BinaryenCallIndirectGetTarget,\n  _BinaryenReturnGetValue,\n  _BinaryenMemoryGrowGetDelta,\n  _BinaryenAtomicRMWGetPtr,\n  _BinaryenAtomicRMWGetValue,\n  _BinaryenAtomicCmpxchgGetPtr,\n  _BinaryenAtomicCmpxchgGetExpected,\n  _BinaryenAtomicCmpxchgGetReplacement,\n  _BinaryenAtomicWaitGetPtr,\n  _BinaryenAtomicWaitGetExpected,\n  _BinaryenAtomicWaitGetTimeout,\n  _BinaryenAtomicNotifyGetPtr,\n  _BinaryenSIMDExtractGetVec,\n  _BinaryenSIMDReplaceGetVec,\n  _BinaryenSIMDReplaceGetValue,\n  _BinaryenSIMDShuffleGetLeft,\n  _BinaryenSIMDShuffleGetRight,\n  _BinaryenSIMDTernaryGetA,\n  _BinaryenSIMDTernaryGetB,\n  _BinaryenSIMDTernaryGetC,\n  _BinaryenSIMDShiftGetVec,\n  _BinaryenSIMDShiftGetShift,\n  _BinaryenSIMDLoadGetPtr,\n  _BinaryenMemoryInitGetDest,\n  _BinaryenMemoryInitGetOffset,\n  _BinaryenMemoryInitGetSize,\n  _BinaryenMemoryCopyGetDest,\n  _BinaryenMemoryCopyGetSource,\n  _BinaryenMemoryCopyGetSize,\n  _BinaryenMemoryFillGetDest,\n  _BinaryenMemoryFillGetValue,\n  _BinaryenMemoryFillGetSize,\n  _BinaryenRefIsGetValue,\n  _BinaryenRefAsGetValue,\n  _BinaryenTryGetBody,\n  _BinaryenTryGetNumCatchBodies,\n  _BinaryenTryGetCatchBodyAt,\n  _BinaryenThrowGetNumOperands,\n  _BinaryenThrowGetOperandAt,\n  _BinaryenTupleMakeGetOperandAt,\n  _BinaryenTupleMakeGetNumOperands,\n  _BinaryenIfSetCondition,\n  _BinaryenIfSetIfTrue,\n  _BinaryenIfSetIfFalse,\n  _BinaryenLoopSetBody,\n  _BinaryenBreakSetCondition,\n  _BinaryenBreakSetValue,\n  _BinaryenSwitchSetCondition,\n  _BinaryenSwitchSetValue,\n  _BinaryenCallSetOperandAt,\n  _BinaryenCallIndirectSetTarget,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenLocalSetSetValue,\n  _BinaryenGlobalSetSetValue,\n  _BinaryenLoadSetPtr,\n  _BinaryenStoreSetPtr,\n  _BinaryenStoreSetValue,\n  _BinaryenUnarySetValue,\n  _BinaryenExpressionFinalize,\n  _BinaryenBinarySetLeft,\n  _BinaryenBinarySetRight,\n  _BinaryenSelectSetIfTrue,\n  _BinaryenSelectSetIfFalse,\n  _BinaryenSelectSetCondition,\n  _BinaryenDropSetValue,\n  _BinaryenReturnSetValue,\n  _BinaryenMemoryGrowSetDelta,\n  _BinaryenAtomicRMWSetPtr,\n  _BinaryenAtomicRMWSetValue,\n  _BinaryenAtomicCmpxchgSetPtr,\n  _BinaryenAtomicCmpxchgSetExpected,\n  _BinaryenAtomicCmpxchgSetReplacement,\n  _BinaryenAtomicWaitSetPtr,\n  _BinaryenAtomicWaitSetExpected,\n  _BinaryenAtomicWaitSetTimeout,\n  _BinaryenAtomicNotifySetPtr,\n  _BinaryenSIMDExtractSetVec,\n  _BinaryenSIMDReplaceSetVec,\n  _BinaryenSIMDReplaceSetValue,\n  _BinaryenSIMDShuffleSetLeft,\n  _BinaryenSIMDShuffleSetRight,\n  _BinaryenSIMDTernarySetA,\n  _BinaryenSIMDTernarySetB,\n  _BinaryenSIMDTernarySetC,\n  _BinaryenSIMDShiftSetVec,\n  _BinaryenSIMDShiftSetShift,\n  _BinaryenSIMDLoadSetPtr,\n  _BinaryenSIMDLoadStoreLaneGetPtr,\n  _BinaryenSIMDLoadStoreLaneGetVec,\n  _BinaryenSIMDLoadStoreLaneSetPtr,\n  _BinaryenSIMDLoadStoreLaneSetVec,\n  _BinaryenMemoryInitSetDest,\n  _BinaryenMemoryInitSetOffset,\n  _BinaryenMemoryInitSetSize,\n  _BinaryenMemoryCopySetDest,\n  _BinaryenMemoryCopySetSource,\n  _BinaryenMemoryCopySetSize,\n  _BinaryenMemoryFillSetDest,\n  _BinaryenMemoryFillSetValue,\n  _BinaryenMemoryFillSetSize,\n  _BinaryenRefIsSetValue,\n  _BinaryenTrySetBody,\n  _BinaryenTrySetCatchBodyAt,\n  _BinaryenThrowSetOperandAt,\n  _BinaryenTupleMakeSetOperandAt,\n  _BinaryenBlockGetName,\n  _BinaryenLoopGetName,\n  _BinaryenBreakGetName,\n  _BinaryenSwitchGetDefaultName,\n  _BinaryenSwitchGetNumNames,\n  _BinaryenSwitchGetNameAt,\n  _BinaryenCallGetTarget,\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenGlobalGetGetName,\n  _BinaryenGlobalSetGetName,\n  _BinaryenAtomicNotifyGetNotifyCount,\n  _BinaryenAtomicNotifySetNotifyCount,\n  _BinaryenRefFuncGetFunc,\n  _BinaryenThrowGetTag,\n  _BinaryenTupleExtractGetTuple,\n  _BinaryenTupleExtractSetTuple,\n  _BinaryenRefEqGetLeft,\n  _BinaryenRefEqGetRight,\n  _BinaryenRefEqSetLeft,\n  _BinaryenRefEqSetRight,\n  _BinaryenFunctionSetBody,\n  _BinaryenI31NewGetValue,\n  _BinaryenI31GetGetI31,\n  _BinaryenI31NewSetValue,\n  _BinaryenI31GetSetI31,\n  _BinaryenCallRefGetNumOperands,\n  _BinaryenCallRefGetOperandAt,\n  _BinaryenCallRefGetTarget,\n  _BinaryenRefTestGetRef,\n  _BinaryenRefCastGetRef,\n  _BinaryenBrOnGetName,\n  _BinaryenBrOnGetRef,\n  _BinaryenStructNewGetNumOperands,\n  _BinaryenStructNewGetOperandAt,\n  _BinaryenStructGetGetRef,\n  _BinaryenStructSetGetRef,\n  _BinaryenStructSetGetValue,\n  _BinaryenStructSetGetIndex,\n  _BinaryenStructGetGetIndex,\n  _BinaryenArrayNewGetSize,\n  _BinaryenArrayNewGetInit,\n  _BinaryenArrayInitGetNumValues,\n  _BinaryenArrayInitGetValueAt,\n  _BinaryenArrayGetGetRef,\n  _BinaryenArrayGetGetIndex,\n  _BinaryenArraySetGetRef,\n  _BinaryenArraySetGetIndex,\n  _BinaryenArraySetGetValue,\n  _BinaryenArrayLenGetRef,\n  _BinaryenArrayCopyGetDestRef,\n  _BinaryenArrayCopyGetDestIndex,\n  _BinaryenArrayCopyGetSrcRef,\n  _BinaryenArrayCopyGetSrcIndex,\n  _BinaryenArrayCopyGetLength,\n  _BinaryenStringNewGetPtr,\n  _BinaryenStringNewGetLength,\n  _BinaryenStringNewGetStart,\n  _BinaryenStringNewGetEnd,\n  _BinaryenStringMeasureGetRef,\n  _BinaryenStringEncodeGetPtr,\n  _BinaryenStringEncodeGetRef,\n  _BinaryenStringEncodeGetStart,\n  _BinaryenStringConcatGetLeft,\n  _BinaryenStringConcatGetRight,\n  _BinaryenStringEqGetLeft,\n  _BinaryenStringEqGetRight,\n  _BinaryenStringAsGetRef,\n  _BinaryenStringWTF8AdvanceGetRef,\n  _BinaryenStringWTF8AdvanceGetPos,\n  _BinaryenStringWTF8AdvanceGetBytes,\n  _BinaryenStringWTF16GetGetRef,\n  _BinaryenStringWTF16GetGetPos,\n  _BinaryenStringIterNextGetRef,\n  _BinaryenStringIterMoveGetRef,\n  _BinaryenStringIterMoveGetNum,\n  _BinaryenStringSliceWTFGetRef,\n  _BinaryenStringSliceWTFGetStart,\n  _BinaryenStringSliceWTFGetEnd,\n  _BinaryenStringSliceIterGetRef,\n  _BinaryenStringSliceIterGetNum,\n  _BinaryenCallRefSetOperandAt,\n  _BinaryenCallRefSetTarget,\n  _BinaryenRefTestSetRef,\n  _BinaryenRefCastSetRef,\n  _BinaryenBrOnSetRef,\n  _BinaryenStructNewSetOperandAt,\n  _BinaryenStructGetSetRef,\n  _BinaryenStructSetSetRef,\n  _BinaryenStructSetSetValue,\n  _BinaryenArrayNewSetSize,\n  _BinaryenArrayNewSetInit,\n  _BinaryenArrayGetSetRef,\n  _BinaryenArrayGetSetIndex,\n  _BinaryenArraySetSetRef,\n  _BinaryenArraySetSetIndex,\n  _BinaryenArraySetSetValue,\n  _BinaryenArrayLenSetRef,\n  _BinaryenArrayCopySetDestRef,\n  _BinaryenArrayCopySetDestIndex,\n  _BinaryenArrayCopySetSrcRef,\n  _BinaryenArrayCopySetSrcIndex,\n  _BinaryenArrayCopySetLength,\n  _BinaryenRefAsSetValue,\n  _BinaryenStringNewSetPtr,\n  _BinaryenStringNewSetLength,\n  _BinaryenStringNewSetStart,\n  _BinaryenStringNewSetEnd,\n  _BinaryenStringMeasureSetRef,\n  _BinaryenStringEncodeSetRef,\n  _BinaryenStringEncodeSetPtr,\n  _BinaryenStringEncodeSetStart,\n  _BinaryenStringConcatSetLeft,\n  _BinaryenStringConcatSetRight,\n  _BinaryenStringEqSetLeft,\n  _BinaryenStringEqSetRight,\n  _BinaryenStringAsSetRef,\n  _BinaryenStringWTF8AdvanceSetRef,\n  _BinaryenStringWTF8AdvanceSetPos,\n  _BinaryenStringWTF8AdvanceSetBytes,\n  _BinaryenStringWTF16GetSetRef,\n  _BinaryenStringWTF16GetSetPos,\n  _BinaryenStringIterNextSetRef,\n  _BinaryenStringIterMoveSetRef,\n  _BinaryenStringIterMoveSetNum,\n  _BinaryenStringSliceWTFSetRef,\n  _BinaryenStringSliceWTFSetStart,\n  _BinaryenStringSliceWTFSetEnd,\n  _BinaryenStringSliceIterSetRef,\n  _BinaryenStringSliceIterSetNum,\n  _BinaryenArrayInitSetValueAt\n} from \"../glue/binaryen\";\n\n/** Base class of custom Binaryen visitors. */\nexport abstract class Visitor {\n  /** Expression stack. */\n  private stack: ExpressionRef[] = new Array<ExpressionRef>();\n\n  /** Gets the current expression being walked. */\n  get currentExpression(): ExpressionRef {\n    let currentExpression = this._currentExpression;\n    if (!currentExpression) throw new Error(\"not walking expressions\");\n    return currentExpression;\n  }\n  _currentExpression: ExpressionRef = 0;\n\n  /** Gets the parent expression of the current expression being walked. Returns zero if already the top-most expression. */\n  get parentExpressionOrNull(): ExpressionRef {\n    let stack = this.stack;\n    let length = stack.length;\n    return length ? stack[length - 1] : 0;\n  }\n\n  // Expressions\n\n  visitBlock(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitIf(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBreak(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSwitch(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCall(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirectPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStore(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBinary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSelect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitReturn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemorySize(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryGrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitNop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnreachable(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicRMW(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicCmpxchg(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicWait(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicNotify(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicFence(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDReplace(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShuffle(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDTernary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShift(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoadStoreLane(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryInit(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDataDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryFill(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitPop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefNull(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefIs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefFunc(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTry(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitThrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRethrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleMake(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31New(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallRef(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefTest(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefCast(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBrOn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayInit(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArraySet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayLen(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringMeasure(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringEncode(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringConcat(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringWTF8Advance(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringWTF16Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringIterNext(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringIterMove(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringSliceWTF(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringSliceIter(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  // Immediates\n\n  visitName(name: StringRef): void {\n    // unimp\n  }\n\n  visitLabel(name: StringRef): void {\n    // unimp\n  }\n\n  visitIndex(index: Index): void {\n    // unimp\n  }\n\n  visitTag(name: StringRef): void {\n    // unimp\n  }\n\n  // Delegate\n\n  /** Visits any expression, delegating to the respective visitor methods. */\n  visit(expr: ExpressionRef): void {\n    let previousExpression = this._currentExpression;\n    this._currentExpression = assert(expr);\n    switch (_BinaryenExpressionGetId(expr)) {\n      case ExpressionId.Block: {\n        this.stack.push(expr);\n        let name = _BinaryenBlockGetName(expr);\n        if (name) this.visitLabel(name);\n        for (let i: Index = 0, n = _BinaryenBlockGetNumChildren(expr); i < n; ++i) {\n          this.visit(_BinaryenBlockGetChildAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitBlock(expr);\n        break;\n      }\n      case ExpressionId.If: {\n        this.stack.push(expr);\n        this.visit(_BinaryenIfGetCondition(expr));\n        this.visit(_BinaryenIfGetIfTrue(expr));\n        let ifFalse = _BinaryenIfGetIfFalse(expr);\n        if (ifFalse) this.visit(ifFalse);\n        assert(this.stack.pop() == expr);\n        this.visitIf(expr);\n        break;\n      }\n      case ExpressionId.Loop: {\n        this.stack.push(expr);\n        let name = _BinaryenLoopGetName(expr);\n        if (name) this.visitLabel(name);\n        this.visit(_BinaryenLoopGetBody(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoop(expr);\n        break;\n      }\n      case ExpressionId.Break: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBreakGetName(expr));\n        let condition = _BinaryenBreakGetCondition(expr);\n        if (condition) this.visit(condition);\n        let value = _BinaryenBreakGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitBreak(expr);\n        break;\n      }\n      case ExpressionId.Switch: {\n        this.stack.push(expr);\n        let defaultName = _BinaryenSwitchGetDefaultName(expr);\n        if (defaultName) this.visitLabel(defaultName);\n        let numNames = _BinaryenSwitchGetNumNames(expr);\n        for (let i: Index = 0; i < numNames; ++i) {\n          this.visitLabel(_BinaryenSwitchGetNameAt(expr, i));\n        }\n        this.visit(_BinaryenSwitchGetCondition(expr));\n        let value = _BinaryenSwitchGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitSwitch(expr);\n        break;\n      }\n      case ExpressionId.Call: {\n        this.visitCallPre(expr);\n        this.stack.push(expr);\n        this.visitName(_BinaryenCallGetTarget(expr));\n        let numOperands = _BinaryenCallGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenCallGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCall(expr);\n        break;\n      }\n      case ExpressionId.CallIndirect: {\n        this.visitCallIndirectPre(expr);\n        this.stack.push(expr);\n        this.visit(_BinaryenCallIndirectGetTarget(expr));\n        for (let i: Index = 0, k = _BinaryenCallIndirectGetNumOperands(expr); i < k; ++i) {\n          this.visit(_BinaryenCallIndirectGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCallIndirect(expr);\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalGet(expr);\n        break;\n      }\n      case ExpressionId.LocalSet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalSetGetIndex(expr));\n        this.visit(_BinaryenLocalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalSet(expr);\n        break;\n      }\n      case ExpressionId.GlobalGet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalGetGetName(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalGet(expr);\n        break;\n      }\n      case ExpressionId.GlobalSet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalSetGetName(expr));\n        this.visit(_BinaryenGlobalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalSet(expr);\n        break;\n      }\n      case ExpressionId.Load: {\n        this.stack.push(expr);\n        this.visit(_BinaryenLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoad(expr);\n        break;\n      }\n      case ExpressionId.Store: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStoreGetPtr(expr));\n        this.visit(_BinaryenStoreGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStore(expr);\n        break;\n      }\n      case ExpressionId.Const: {\n        this.visitConst(expr);\n        break;\n      }\n      case ExpressionId.Unary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenUnaryGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitUnary(expr);\n        break;\n      }\n      case ExpressionId.Binary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenBinaryGetLeft(expr));\n        this.visit(_BinaryenBinaryGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBinary(expr);\n        break;\n      }\n      case ExpressionId.Select: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSelectGetIfTrue(expr));\n        this.visit(_BinaryenSelectGetIfFalse(expr));\n        this.visit(_BinaryenSelectGetCondition(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSelect(expr);\n        break;\n      }\n      case ExpressionId.Drop: {\n        this.stack.push(expr);\n        this.visit(_BinaryenDropGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitDrop(expr);\n        break;\n      }\n      case ExpressionId.Return: {\n        let value = _BinaryenReturnGetValue(expr);\n        if (value) {\n          this.stack.push(expr);\n          this.visit(value);\n          assert(this.stack.pop() == expr);\n        }\n        this.visitReturn(expr);\n        break;\n      }\n      case ExpressionId.MemorySize: {\n        this.visitMemorySize(expr);\n        break;\n      }\n      case ExpressionId.MemoryGrow: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryGrowGetDelta(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryGrow(expr);\n        break;\n      }\n      case ExpressionId.Nop: {\n        this.visitNop(expr);\n        break;\n      }\n      case ExpressionId.Unreachable: {\n        this.visitUnreachable(expr);\n        break;\n      }\n      case ExpressionId.AtomicRMW: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicRMWGetPtr(expr));\n        this.visit(_BinaryenAtomicRMWGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicRMW(expr);\n        break;\n      }\n      case ExpressionId.AtomicCmpxchg: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicCmpxchgGetPtr(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetExpected(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetReplacement(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicCmpxchg(expr);\n        break;\n      }\n      case ExpressionId.AtomicWait: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicWaitGetPtr(expr));\n        this.visit(_BinaryenAtomicWaitGetExpected(expr));\n        this.visit(_BinaryenAtomicWaitGetTimeout(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicWait(expr);\n        break;\n      }\n      case ExpressionId.AtomicNotify: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicNotifyGetPtr(expr));\n        this.visit(_BinaryenAtomicNotifyGetNotifyCount(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicNotify(expr);\n        break;\n      }\n      case ExpressionId.AtomicFence: {\n        this.visitAtomicFence(expr);\n        break;\n      }\n      case ExpressionId.SIMDExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDExtractGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDExtract(expr);\n        break;\n      }\n      case ExpressionId.SIMDReplace: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDReplaceGetVec(expr));\n        this.visit(_BinaryenSIMDReplaceGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDReplace(expr);\n        break;\n      }\n      case ExpressionId.SIMDShuffle: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShuffleGetLeft(expr));\n        this.visit(_BinaryenSIMDShuffleGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShuffle(expr);\n        break;\n      }\n      case ExpressionId.SIMDTernary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDTernaryGetA(expr));\n        this.visit(_BinaryenSIMDTernaryGetB(expr));\n        this.visit(_BinaryenSIMDTernaryGetC(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDTernary(expr);\n        break;\n      }\n      case ExpressionId.SIMDShift: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShiftGetVec(expr));\n        this.visit(_BinaryenSIMDShiftGetShift(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShift(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoad: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoad(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoadStoreLane: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadStoreLaneGetPtr(expr));\n        this.visit(_BinaryenSIMDLoadStoreLaneGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoadStoreLane(expr);\n        break;\n      }\n      case ExpressionId.MemoryInit: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryInitGetDest(expr));\n        this.visit(_BinaryenMemoryInitGetOffset(expr));\n        this.visit(_BinaryenMemoryInitGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryInit(expr);\n        break;\n      }\n      case ExpressionId.DataDrop: {\n        this.visitDataDrop(expr);\n        break;\n      }\n      case ExpressionId.MemoryCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryCopyGetDest(expr));\n        this.visit(_BinaryenMemoryCopyGetSource(expr));\n        this.visit(_BinaryenMemoryCopyGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryCopy(expr);\n        break;\n      }\n      case ExpressionId.MemoryFill: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryFillGetDest(expr));\n        this.visit(_BinaryenMemoryFillGetValue(expr));\n        this.visit(_BinaryenMemoryFillGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryFill(expr);\n        break;\n      }\n      case ExpressionId.Pop: {\n        this.visitPop(expr);\n        break;\n      }\n      case ExpressionId.RefNull: {\n        this.visitRefNull(expr);\n        break;\n      }\n      case ExpressionId.RefIs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefIsGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefIs(expr);\n        break;\n      }\n      case ExpressionId.RefFunc: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenRefFuncGetFunc(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefFunc(expr);\n        break;\n      }\n      case ExpressionId.RefEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefEqGetLeft(expr));\n        this.visit(_BinaryenRefEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefEq(expr);\n        break;\n      }\n      case ExpressionId.Try: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTryGetBody(expr));\n        let numCatchBodies = _BinaryenTryGetNumCatchBodies(expr);\n        for (let i: Index = 0; i < numCatchBodies; ++i) {\n          this.visit(_BinaryenTryGetCatchBodyAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitTry(expr);\n        break;\n      }\n      case ExpressionId.Throw: {\n        this.stack.push(expr);\n        this.visitTag(_BinaryenThrowGetTag(expr));\n        let numOperands = _BinaryenThrowGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenThrowGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitThrow(expr);\n        break;\n      }\n      case ExpressionId.Rethrow: {\n        this.visitRethrow(expr);\n        break;\n      }\n      case ExpressionId.TupleMake: {\n        let numOperands = _BinaryenTupleMakeGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenTupleMakeGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitTupleMake(expr);\n        break;\n      }\n      case ExpressionId.TupleExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTupleExtractGetTuple(expr));\n        assert(this.stack.pop() == expr);\n        this.visitTupleExtract(expr);\n        break;\n      }\n      case ExpressionId.I31New: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31NewGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31New(expr);\n        break;\n      }\n      case ExpressionId.I31Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31GetGetI31(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31Get(expr);\n        break;\n      }\n      case ExpressionId.CallRef: {\n        this.stack.push(expr);\n        let numOperands = _BinaryenCallRefGetNumOperands(expr);\n        if (numOperands) {\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenCallRefGetOperandAt(expr, i));\n          }\n        }\n        this.visit(_BinaryenCallRefGetTarget(expr));\n        assert(this.stack.pop() == expr);\n        this.visitCallRef(expr);\n        break;\n      }\n      case ExpressionId.RefTest: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefTestGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefTest(expr);\n        break;\n      }\n      case ExpressionId.RefCast: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefCastGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefCast(expr);\n        break;\n      }\n      case ExpressionId.BrOn: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBrOnGetName(expr));\n        this.visit(_BinaryenBrOnGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBrOn(expr);\n        break;\n      }\n      case ExpressionId.StructNew: {\n        let numOperands = _BinaryenStructNewGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenStructNewGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitStructNew(expr);\n        break;\n      }\n      case ExpressionId.StructGet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStructGetGetRef(expr));\n        this.visitIndex(_BinaryenStructGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStructGet(expr);\n        break;\n      }\n      case ExpressionId.StructSet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStructSetGetRef(expr));\n        this.visitIndex(_BinaryenStructSetGetIndex(expr));\n        this.visit(_BinaryenStructSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStructSet(expr);\n        break;\n      }\n      case ExpressionId.ArrayNew: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayNewGetSize(expr));\n        let init = _BinaryenArrayNewGetInit(expr);\n        if (init) this.visit(init);\n        assert(this.stack.pop() == expr);\n        this.visitArrayNew(expr);\n        break;\n      }\n      case ExpressionId.ArrayInit: {\n        let numValues = _BinaryenArrayInitGetNumValues(expr);\n        if (numValues) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numValues; ++i) {\n            this.visit(_BinaryenArrayInitGetValueAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitArrayInit(expr);\n        break;\n      }\n      case ExpressionId.ArrayGet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayGetGetRef(expr));\n        this.visit(_BinaryenArrayGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayGet(expr);\n        break;\n      }\n      case ExpressionId.ArraySet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArraySetGetRef(expr));\n        this.visit(_BinaryenArraySetGetIndex(expr));\n        this.visit(_BinaryenArraySetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArraySet(expr);\n        break;\n      }\n      case ExpressionId.ArrayLen: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayLenGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayLen(expr);\n        break;\n      }\n      case ExpressionId.ArrayCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayCopyGetDestRef(expr));\n        this.visit(_BinaryenArrayCopyGetDestIndex(expr));\n        this.visit(_BinaryenArrayCopyGetSrcRef(expr));\n        this.visit(_BinaryenArrayCopyGetSrcIndex(expr));\n        this.visit(_BinaryenArrayCopyGetLength(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayCopy(expr);\n        break;\n      }\n      case ExpressionId.RefAs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefAsGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefAs(expr);\n        break;\n      }\n      case ExpressionId.StringNew: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringNewGetPtr(expr));\n        let length = _BinaryenStringNewGetLength(expr); // LM only\n        if (length) this.visit(length);\n        let start = _BinaryenStringNewGetStart(expr); // GC only\n        if (start) this.visit(start);\n        let end = _BinaryenStringNewGetEnd(expr); // GC only\n        if (end) this.visit(end);\n        assert(this.stack.pop() == expr);\n        this.visitStringNew(expr);\n        break;\n      }\n      case ExpressionId.StringConst: {\n        this.stack.push(expr);\n        assert(this.stack.pop() == expr);\n        this.visitStringConst(expr);\n        break;\n      }\n      case ExpressionId.StringMeasure: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringMeasureGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringMeasure(expr);\n        break;\n      }\n      case ExpressionId.StringEncode: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringEncodeGetRef(expr));\n        this.visit(_BinaryenStringEncodeGetPtr(expr));\n        let start = _BinaryenStringEncodeGetStart(expr); // GC only\n        if (start) this.visit(start);\n        assert(this.stack.pop() == expr);\n        this.visitStringEncode(expr);\n        break;\n      }\n      case ExpressionId.StringConcat: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringConcatGetLeft(expr));\n        this.visit(_BinaryenStringConcatGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringConcat(expr);\n        break;\n      }\n      case ExpressionId.StringEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringEqGetLeft(expr));\n        this.visit(_BinaryenStringEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringEq(expr);\n        break;\n      }\n      case ExpressionId.StringAs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringAsGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringAs(expr);\n        break;\n      }\n      case ExpressionId.StringWTF8Advance: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringWTF8AdvanceGetRef(expr));\n        this.visit(_BinaryenStringWTF8AdvanceGetPos(expr));\n        this.visit(_BinaryenStringWTF8AdvanceGetBytes(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringWTF8Advance(expr);\n        break;\n      }\n      case ExpressionId.StringWTF16Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringWTF16GetGetRef(expr));\n        this.visit(_BinaryenStringWTF16GetGetPos(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringWTF16Get(expr);\n        break;\n      }\n      case ExpressionId.StringIterNext: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringIterNextGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringIterNext(expr);\n        break;\n      }\n      case ExpressionId.StringIterMove: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringIterMoveGetRef(expr));\n        this.visit(_BinaryenStringIterMoveGetNum(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringIterMove(expr);\n        break;\n      }\n      case ExpressionId.StringSliceWTF: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringSliceWTFGetRef(expr));\n        this.visit(_BinaryenStringSliceWTFGetStart(expr));\n        this.visit(_BinaryenStringSliceWTFGetEnd(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringSliceWTF(expr);\n        break;\n      }\n      case ExpressionId.StringSliceIter: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringSliceIterGetRef(expr));\n        this.visit(_BinaryenStringSliceIterGetNum(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringSliceIter(expr);\n        break;\n      }\n      default: throw new Error(\"unexpected expression kind\");\n    }\n    this._currentExpression = previousExpression;\n  }\n}\n\n/** Base class of custom Binaryen passes. */\nexport abstract class Pass extends Visitor {\n\n  /** Gets the current function being walked. */\n  get currentFunction(): FunctionRef {\n    let currentFunction = this._currentFunction;\n    if (!currentFunction) throw new Error(\"not walking a function\");\n    return currentFunction;\n  }\n  private _currentFunction: FunctionRef = 0;\n\n  /** Gets the current global being walked. */\n  get currentGlobal(): GlobalRef {\n    let currentGlobal = this._currentGlobal;\n    if (!currentGlobal) throw new Error(\"not walking a global\");\n    return currentGlobal;\n  }\n  private _currentGlobal: GlobalRef = 0;\n\n  /** Constructs a new Binaryen pass. */\n  constructor(readonly module: Module) {\n    super();\n  }\n\n  // Walking\n\n  /** Walks the entire module. */\n  walkModule(): void {\n    this.walkFunctions();\n    this.walkGlobals();\n  }\n\n  /** Walks all functions. */\n  walkFunctions(): void {\n    let moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumFunctions(moduleRef); i < k; ++i) {\n      this.walkFunction(_BinaryenGetFunctionByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific function. */\n  walkFunction(func: FunctionRef): void {\n    let body = _BinaryenFunctionGetBody(func);\n    if (body) {\n      this._currentFunction = func;\n      this.visit(body);\n      this._currentFunction = 0;\n    }\n  }\n\n  /** Walks all global variables. */\n  walkGlobals(): void {\n    let moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumGlobals(moduleRef); i < k; ++i) {\n      this.walkGlobal(_BinaryenGetGlobalByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific global variable. */\n  walkGlobal(global: GlobalRef): void {\n    this._currentGlobal = global;\n    let init = _BinaryenGlobalGetInitExpr(global);\n    if (init) this.visit(init);\n    this._currentGlobal = 0;\n  }\n\n  // Utility\n\n  /** Replaces the current expression with the specified replacement. */\n  replaceCurrent(replacement: ExpressionRef): void {\n    let search = this.currentExpression;\n    let func = this.currentFunction;\n    let body = _BinaryenFunctionGetBody(func);\n    if (body == search) {\n      _BinaryenFunctionSetBody(func, replacement);\n    } else {\n      let parent = assert(this.parentExpressionOrNull);\n      let replaced = replaceChild(parent, search, replacement);\n      if (!replaced) throw Error(\"failed to replace expression\");\n      _BinaryenExpressionFinalize(parent);\n    }\n  }\n}\n\n/** Replaces an expression within a parent expression. Returns the replaced expression on success, otherwise `0`. */\nexport function replaceChild(\n  /** Parent expression containing `search`. */\n  parent: ExpressionRef,\n  /** Expression to replace. */\n  search: ExpressionRef,\n  /** Expression to replace `search` with. */\n  replacement: ExpressionRef\n): ExpressionRef {\n  switch (_BinaryenExpressionGetId(parent)) {\n    case ExpressionId.Block: {\n      let numChildren = _BinaryenBlockGetNumChildren(parent);\n      for (let i: Index = 0; i < numChildren; ++i) {\n        let child = _BinaryenBlockGetChildAt(parent, i);\n        if (child == search) {\n          _BinaryenBlockSetChildAt(parent, i, replacement);\n          return child;\n        }\n      }\n      break;\n    }\n    case ExpressionId.If: {\n      let condition = _BinaryenIfGetCondition(parent);\n      if (condition == search) {\n        _BinaryenIfSetCondition(parent, replacement);\n        return condition;\n      }\n      let ifTrue = _BinaryenIfGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenIfSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenIfGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenIfSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      break;\n    }\n    case ExpressionId.Loop: {\n      let body = _BinaryenLoopGetBody(parent);\n      if (body == search) {\n        _BinaryenLoopSetBody(parent, replacement);\n        return body;\n      }\n      break;\n    }\n    case ExpressionId.Break: {\n      let condition = _BinaryenBreakGetCondition(parent);\n      if (condition == search) {\n        _BinaryenBreakSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenBreakGetValue(parent);\n      if (value == search) {\n        _BinaryenBreakSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Switch: {\n      let condition = _BinaryenSwitchGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSwitchSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenSwitchGetValue(parent);\n      if (value == search) {\n        _BinaryenSwitchSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Call: {\n      let numOperands = _BinaryenCallGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.CallIndirect: {\n      let target = _BinaryenCallIndirectGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallIndirectSetTarget(parent, replacement);\n        return target;\n      }\n      let numOperands = _BinaryenCallIndirectGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallIndirectGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallIndirectSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.LocalGet: {\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      let value = _BinaryenLocalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenLocalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.GlobalGet: {\n      break;\n    }\n    case ExpressionId.GlobalSet: {\n      let value = _BinaryenGlobalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenGlobalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Load: {\n      let ptr = _BinaryenLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.Store: {\n      let ptr = _BinaryenStoreGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStoreSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenStoreGetValue(parent);\n      if (value == search) {\n        _BinaryenStoreSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Const: {\n      break;\n    }\n    case ExpressionId.Unary: {\n      let value = _BinaryenUnaryGetValue(parent);\n      if (value == search) {\n        _BinaryenUnarySetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Binary: {\n      let left = _BinaryenBinaryGetLeft(parent);\n      if (left == search) {\n        _BinaryenBinarySetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenBinaryGetRight(parent);\n      if (right == search) {\n        _BinaryenBinarySetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Select: {\n      let ifTrue = _BinaryenSelectGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenSelectSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenSelectGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenSelectSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      let condition = _BinaryenSelectGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSelectSetCondition(parent, replacement);\n        return condition;\n      }\n      break;\n    }\n    case ExpressionId.Drop: {\n      let value = _BinaryenDropGetValue(parent);\n      if (value == search) {\n        _BinaryenDropSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Return: {\n      let value = _BinaryenReturnGetValue(parent);\n      if (value == search) {\n        _BinaryenReturnSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.MemorySize: {\n      break;\n    }\n    case ExpressionId.MemoryGrow: {\n      let delta = _BinaryenMemoryGrowGetDelta(parent);\n      if (delta == search) {\n        _BinaryenMemoryGrowSetDelta(parent, replacement);\n        return delta;\n      }\n      break;\n    }\n    case ExpressionId.Nop: {\n      break;\n    }\n    case ExpressionId.Unreachable: {\n      break;\n    }\n    case ExpressionId.AtomicRMW: {\n      let ptr = _BinaryenAtomicRMWGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicRMWSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenAtomicRMWGetValue(parent);\n      if (value == search) {\n        _BinaryenAtomicRMWSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.AtomicCmpxchg: {\n      let ptr = _BinaryenAtomicCmpxchgGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicCmpxchgSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicCmpxchgGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicCmpxchgSetExpected(parent, replacement);\n        return expected;\n      }\n      let repl = _BinaryenAtomicCmpxchgGetReplacement(parent);\n      if (repl == search) {\n        _BinaryenAtomicCmpxchgSetReplacement(parent, replacement);\n        return repl;\n      }\n      break;\n    }\n    case ExpressionId.AtomicWait: {\n      let ptr = _BinaryenAtomicWaitGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicWaitSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicWaitGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicWaitSetExpected(parent, replacement);\n        return expected;\n      }\n      let timeout = _BinaryenAtomicWaitGetTimeout(parent);\n      if (timeout == search) {\n        _BinaryenAtomicWaitSetTimeout(parent, replacement);\n        return timeout;\n      }\n      break;\n    }\n    case ExpressionId.AtomicNotify: {\n      let ptr = _BinaryenAtomicNotifyGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicNotifySetPtr(parent, replacement);\n        return ptr;\n      }\n      let notifyCount = _BinaryenAtomicNotifyGetNotifyCount(parent);\n      if (notifyCount == search) {\n        _BinaryenAtomicNotifySetNotifyCount(parent, replacement);\n        return notifyCount;\n      }\n      break;\n    }\n    case ExpressionId.AtomicFence: {\n      break;\n    }\n    case ExpressionId.SIMDExtract: {\n      let vec = _BinaryenSIMDExtractGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDExtractSetVec(parent, replacement);\n        return vec;\n      }\n      break;\n    }\n    case ExpressionId.SIMDReplace: {\n      let vec = _BinaryenSIMDReplaceGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDReplaceSetVec(parent, replacement);\n        return vec;\n      }\n      let value = _BinaryenSIMDReplaceGetValue(parent);\n      if (value == search) {\n        _BinaryenSIMDReplaceSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShuffle: {\n      let left = _BinaryenSIMDShuffleGetLeft(parent);\n      if (left == search) {\n        _BinaryenSIMDShuffleSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenSIMDShuffleGetRight(parent);\n      if (right == search) {\n        _BinaryenSIMDShuffleSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.SIMDTernary: {\n      let a = _BinaryenSIMDTernaryGetA(parent);\n      if (a == search) {\n        _BinaryenSIMDTernarySetA(parent, replacement);\n        return a;\n      }\n      let b = _BinaryenSIMDTernaryGetB(parent);\n      if (b == search) {\n        _BinaryenSIMDTernarySetB(parent, replacement);\n        return b;\n      }\n      let c = _BinaryenSIMDTernaryGetC(parent);\n      if (c == search) {\n        _BinaryenSIMDTernarySetC(parent, replacement);\n        return c;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShift: {\n      let vec = _BinaryenSIMDShiftGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDShiftSetVec(parent, replacement);\n        return vec;\n      }\n      let shift = _BinaryenSIMDShiftGetShift(parent);\n      if (shift == search) {\n        _BinaryenSIMDShiftSetShift(parent, replacement);\n        return shift;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoad: {\n      let ptr = _BinaryenSIMDLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoadStoreLane: {\n      let ptr = _BinaryenSIMDLoadStoreLaneGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadStoreLaneSetPtr(parent, replacement);\n        return ptr;\n      }\n      let vec = _BinaryenSIMDLoadStoreLaneGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDLoadStoreLaneSetVec(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.MemoryInit: {\n      let dest = _BinaryenMemoryInitGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryInitSetDest(parent, replacement);\n        return dest;\n      }\n      let offset = _BinaryenMemoryInitGetOffset(parent);\n      if (offset == search) {\n        _BinaryenMemoryInitSetOffset(parent, replacement);\n        return offset;\n      }\n      let size = _BinaryenMemoryInitGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryInitSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.DataDrop: {\n      break;\n    }\n    case ExpressionId.MemoryCopy: {\n      let dest = _BinaryenMemoryCopyGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryCopySetDest(parent, replacement);\n        return dest;\n      }\n      let source = _BinaryenMemoryCopyGetSource(parent);\n      if (source == search) {\n        _BinaryenMemoryCopySetSource(parent, replacement);\n        return source;\n      }\n      let size = _BinaryenMemoryCopyGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryCopySetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.MemoryFill: {\n      let dest = _BinaryenMemoryFillGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryFillSetDest(parent, replacement);\n        return dest;\n      }\n      let value = _BinaryenMemoryFillGetValue(parent);\n      if (value == search) {\n        _BinaryenMemoryFillSetValue(parent, replacement);\n        return value;\n      }\n      let size = _BinaryenMemoryFillGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryFillSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.Pop: {\n      break;\n    }\n    case ExpressionId.RefNull: {\n      break;\n    }\n    case ExpressionId.RefIs: {\n      let value = _BinaryenRefIsGetValue(parent);\n      if (value == search) {\n        _BinaryenRefIsSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.RefFunc: {\n      break;\n    }\n    case ExpressionId.RefEq: {\n      let left = _BinaryenRefEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenRefEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenRefEqGetRight(parent);\n      if (right == search) {\n        _BinaryenRefEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Try: {\n      let body = _BinaryenTryGetBody(parent);\n      if (body == search) {\n        _BinaryenTrySetBody(parent, replacement);\n        return body;\n      }\n      let numCatchBodies = _BinaryenTryGetNumCatchBodies(parent);\n      for (let i: Index = 0; i < numCatchBodies; ++i) {\n        let catchBody = _BinaryenTryGetCatchBodyAt(parent, i);\n        if (catchBody == search) {\n          _BinaryenTrySetCatchBodyAt(parent, i, replacement);\n          return catchBody;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Throw: {\n      let numOperands = _BinaryenThrowGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenThrowGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenThrowSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Rethrow: {\n      break;\n    }\n    case ExpressionId.TupleMake: {\n      let numOperands = _BinaryenTupleMakeGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenTupleMakeGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenTupleMakeSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.TupleExtract: {\n      let tuple = _BinaryenTupleExtractGetTuple(parent);\n      if (tuple == search) {\n        _BinaryenTupleExtractSetTuple(parent, replacement);\n        return tuple;\n      }\n      break;\n    }\n    case ExpressionId.I31New: {\n      let value = _BinaryenI31NewGetValue(parent);\n      if (value == search) {\n        _BinaryenI31NewSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.I31Get: {\n      let i31Expr = _BinaryenI31GetGetI31(parent);\n      if (i31Expr == search) {\n        _BinaryenI31GetSetI31(parent, replacement);\n        return i31Expr;\n      }\n      break;\n    }\n    case ExpressionId.CallRef: {\n      let numOperands = _BinaryenCallRefGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallRefGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallRefSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      let target = _BinaryenCallRefGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallRefSetTarget(parent, replacement);\n        return target;\n      }\n      break;\n    }\n    case ExpressionId.RefTest: {\n      let ref = _BinaryenRefTestGetRef(parent);\n      if (ref == search) {\n        _BinaryenRefTestSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.RefCast: {\n      let ref = _BinaryenRefCastGetRef(parent);\n      if (ref == search) {\n        _BinaryenRefCastSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.BrOn: {\n      let ref = _BinaryenBrOnGetRef(parent);\n      if (ref == search) {\n        _BinaryenBrOnSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StructNew: {\n      let numOperands = _BinaryenStructNewGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenStructNewGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenStructNewSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.StructGet: {\n      let ref = _BinaryenStructGetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStructGetSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StructSet: {\n      let ref = _BinaryenStructSetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStructSetSetRef(parent, replacement);\n        return ref;\n      }\n      let value = _BinaryenStructSetGetValue(parent);\n      if (value == search) {\n        _BinaryenStructSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.ArrayNew: {\n      let size = _BinaryenArrayNewGetSize(parent);\n      if (size == search) {\n        _BinaryenArrayNewSetSize(parent, replacement);\n        return size;\n      }\n      let init = _BinaryenArrayNewGetInit(parent);\n      if (init == search) {\n        _BinaryenArrayNewSetInit(parent, replacement);\n        return init;\n      }\n      break;\n    }\n    case ExpressionId.ArrayInit: {\n      let numValues = _BinaryenArrayInitGetNumValues(parent);\n      for (let i: Index = 0; i < numValues; ++i) {\n        let value = _BinaryenArrayInitGetValueAt(parent, i);\n        if (value == search) {\n          _BinaryenArrayInitSetValueAt(parent, i, replacement);\n          return value;\n        }\n      }\n      break;\n    }\n    case ExpressionId.ArrayGet: {\n      let ref = _BinaryenArrayGetGetRef(parent);\n      if (ref == search) {\n        _BinaryenArrayGetSetRef(parent, replacement);\n        return ref;\n      }\n      let index = _BinaryenArrayGetGetIndex(parent);\n      if (index == search) {\n        _BinaryenArrayGetSetIndex(parent, replacement);\n        return index;\n      }\n      break;\n    }\n    case ExpressionId.ArraySet: {\n      let ref = _BinaryenArraySetGetRef(parent);\n      if (ref == search) {\n        _BinaryenArraySetSetRef(parent, replacement);\n        return ref;\n      }\n      let index = _BinaryenArraySetGetIndex(parent);\n      if (index == search) {\n        _BinaryenArraySetSetIndex(parent, replacement);\n        return index;\n      }\n      let value = _BinaryenArraySetGetValue(parent);\n      if (value == search) {\n        _BinaryenArraySetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.ArrayLen: {\n      let ref = _BinaryenArrayLenGetRef(parent);\n      if (ref == search) {\n        _BinaryenArrayLenSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.ArrayCopy: {\n      let destRef = _BinaryenArrayCopyGetDestRef(parent);\n      if (destRef == search) {\n        _BinaryenArrayCopySetDestRef(parent, replacement);\n        return destRef;\n      }\n      let destIndex = _BinaryenArrayCopyGetDestIndex(parent);\n      if (destIndex == search) {\n        _BinaryenArrayCopySetDestIndex(parent, replacement);\n        return destIndex;\n      }\n      let srcRef = _BinaryenArrayCopyGetSrcRef(parent);\n      if (srcRef == search) {\n        _BinaryenArrayCopySetSrcRef(parent, replacement);\n        return srcRef;\n      }\n      let srcIndex = _BinaryenArrayCopyGetSrcIndex(parent);\n      if (srcIndex == search) {\n        _BinaryenArrayCopySetSrcIndex(parent, replacement);\n        return srcIndex;\n      }\n      let length = _BinaryenArrayCopyGetLength(parent);\n      if (length == search) {\n        _BinaryenArrayCopySetLength(parent, replacement);\n        return length;\n      }\n      break;\n    }\n    case ExpressionId.RefAs: {\n      let value = _BinaryenRefAsGetValue(parent);\n      if (value == search) {\n        _BinaryenRefAsSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.StringNew: {\n      let ptr = _BinaryenStringNewGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStringNewSetPtr(parent, replacement);\n        return ptr;\n      }\n      let length = _BinaryenStringNewGetLength(parent);\n      if (length == search) {\n        _BinaryenStringNewSetLength(parent, replacement);\n        return length;\n      }\n      let start = _BinaryenStringNewGetStart(parent);\n      if (start == search) {\n        _BinaryenStringNewSetStart(parent, replacement);\n        return start;\n      }\n      let end = _BinaryenStringNewGetEnd(parent);\n      if (end == search) {\n        _BinaryenStringNewSetEnd(parent, replacement);\n        return end;\n      }\n      break;\n    }\n    case ExpressionId.StringConst: {\n      break;\n    }\n    case ExpressionId.StringMeasure: {\n      let ref = _BinaryenStringMeasureGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringMeasureSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringEncode: {\n      let ref = _BinaryenStringEncodeGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringEncodeSetRef(parent, replacement);\n        return ref;\n      }\n      let ptr = _BinaryenStringEncodeGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStringEncodeSetPtr(parent, replacement);\n        return ptr;\n      }\n      let start = _BinaryenStringEncodeGetStart(parent);\n      if (start == search) {\n        _BinaryenStringEncodeSetStart(parent, replacement);\n        return start;\n      }\n      break;\n    }\n    case ExpressionId.StringConcat: {\n      let left = _BinaryenStringConcatGetLeft(parent);\n      if (left == search) {\n        _BinaryenStringConcatSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenStringConcatGetRight(parent);\n      if (right == search) {\n        _BinaryenStringConcatSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.StringEq: {\n      let left = _BinaryenStringEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenStringEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenStringEqGetRight(parent);\n      if (right == search) {\n        _BinaryenStringEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.StringAs: {\n      let ref = _BinaryenStringAsGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringAsSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringWTF8Advance: {\n      let ref = _BinaryenStringWTF8AdvanceGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringWTF8AdvanceSetRef(parent, replacement);\n        return ref;\n      }\n      let pos = _BinaryenStringWTF8AdvanceGetPos(parent);\n      if (pos == search) {\n        _BinaryenStringWTF8AdvanceSetPos(parent, replacement);\n        return pos;\n      }\n      let bytes = _BinaryenStringWTF8AdvanceGetBytes(parent);\n      if (bytes == search) {\n        _BinaryenStringWTF8AdvanceSetBytes(parent, replacement);\n        return bytes;\n      }\n      break;\n    }\n    case ExpressionId.StringWTF16Get: {\n      let ref = _BinaryenStringWTF16GetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringWTF16GetSetRef(parent, replacement);\n        return ref;\n      }\n      let pos = _BinaryenStringWTF16GetGetPos(parent);\n      if (pos == search) {\n        _BinaryenStringWTF16GetSetPos(parent, replacement);\n        return pos;\n      }\n      break;\n    }\n    case ExpressionId.StringIterNext: {\n      let ref = _BinaryenStringIterNextGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringIterNextSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringIterMove: {\n      let ref = _BinaryenStringIterMoveGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringIterMoveSetRef(parent, replacement);\n        return ref;\n      }\n      let num = _BinaryenStringIterMoveGetNum(parent);\n      if (num == search) {\n        _BinaryenStringIterMoveSetNum(parent, replacement);\n        return num;\n      }\n      break;\n    }\n    case ExpressionId.StringSliceWTF: {\n      let ref = _BinaryenStringSliceWTFGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringSliceWTFSetRef(parent, replacement);\n        return ref;\n      }\n      let start = _BinaryenStringSliceWTFGetStart(parent);\n      if (start == search) {\n        _BinaryenStringSliceWTFSetStart(parent, replacement);\n        return start;\n      }\n      let end = _BinaryenStringSliceWTFGetEnd(parent);\n      if (end == search) {\n        _BinaryenStringSliceWTFSetEnd(parent, replacement);\n        return end;\n      }\n      break;\n    }\n    case ExpressionId.StringSliceIter: {\n      let ref = _BinaryenStringSliceIterGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringSliceIterSetRef(parent, replacement);\n        return ref;\n      }\n      let num = _BinaryenStringSliceIterGetNum(parent);\n      if (num == search) {\n        _BinaryenStringSliceIterSetNum(parent, replacement);\n        return num;\n      }\n      break;\n    }\n    default: throw new Error(\"unexpected expression id\");\n  }\n  return 0;\n}\n", "/**\n * @fileoverview A lightweight store instrumentation pass.\n * \n * Can be used to find rogue stores to protected memory addresses like object\n * headers or similar, without going overboard with instrumentation. Also\n * passes a flag whether a store originates within the runtime or other code.\n * \n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  Compiler\n} from \"../compiler\";\n\nimport {\n  createType,\n  ExpressionRef,\n  TypeRef\n} from \"../module\";\n\nimport {\n  _BinaryenFunctionGetName,\n  _BinaryenStoreGetBytes,\n  _BinaryenStoreGetOffset,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreSetPtr\n} from \"../glue/binaryen\";\n\n/** Instruments stores to also call an import. */\nexport class RtraceMemory extends Pass {\n  /** Whether we've seen any stores. */\n  seenStores: bool = false;\n  /** Target pointer type. */\n  ptrType: TypeRef;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.ptrType = compiler.options.sizeTypeRef;\n  }\n\n  checkRT(): bool {\n    let functionName = this.module.readStringCached(_BinaryenFunctionGetName(this.currentFunction))!;\n    return functionName.startsWith(\"~lib/rt/\");\n  }\n\n  /** @override */\n  visitStore(store: ExpressionRef): void {\n    let module = this.module;\n    let ptr = _BinaryenStoreGetPtr(store);\n    let offset = _BinaryenStoreGetOffset(store);\n    let bytes = _BinaryenStoreGetBytes(store);\n    // onstore(ptr: usize, offset: i32, bytes: i32, isRT: bool) -> ptr\n    _BinaryenStoreSetPtr(store,\n      module.call(\"~onstore\", [\n        ptr,\n        module.i32(offset),\n        module.i32(bytes),\n        module.i32(i32(this.checkRT()))\n      ], this.ptrType)\n    );\n    this.seenStores = true;\n  }\n\n  // TODO: MemoryFill, Atomics\n\n  /** @override */\n  walkModule(): void {\n    super.walkModule();\n    if (this.seenStores) {\n      this.module.addFunctionImport(\"~onstore\", \"rtrace\", \"onstore\",\n        createType([ this.ptrType, TypeRef.I32, TypeRef.I32, TypeRef.I32 ]),\n        this.ptrType\n      );\n    }\n  }\n}\n", "/**\n * @fileoverview Shadow stack instrumentation for a precise GC.\n *\n * Instruments function arguments and local assignments marked with a 'tostack'\n * call to also do stores to a shadow stack of managed values only.\n *\n * Consider a simple call to a function looking like the following, taking\n * managed arguments, plus assigning managed values to locals:\n *\n *   function foo(a: Obj, b: Obj): Obj {\n *     let c = __tostack(a) // slot 2\n *     __collect()\n *     return b\n *   }\n *\n *   foo(__tostack(a), __tostack(b)) // slot 0, 1\n *\n * At the call to `__collect()` the 32-bit stack frame of the function is:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed argument 'a'\n *      4   | Second managed argument 'b'\n *   -------|----------------------------\n *      8   | First managed local 'c'\n *\n * We are splitting the frame in two halves as annotated since both halves are\n * only known separately for indirect calls, with the first half becoming an\n * extension of the calling function's stack frame by means of treating the\n * arguments as if these were locals beyond the caller's `numLocals`. Function\n * arguments stay a bit longer on the stack than usually, but we also don't have\n * to modify the stack pointer pre-call at all this way. The caller's amended\n * stack frame when assuming one managed local may look like this:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local '?'\n *      4   | Extended with first managed argument 'a'\n *      8   | Extended with second managed argument 'b'\n *\n * with the callee's stack frame becoming just:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local 'c'\n *\n * Instrumentation added below looks about like the following, with the stack\n * growing downwards and 't' and 'r' being new temporary locals:\n *\n *   // callee frameSize = 1 * sizeof<usize>()\n *   function foo(a: usize, b: usize): usize {\n *     memory.fill(__stack_pointer -= frameSize, 0, frameSize)\n *     store<usize>(__stack_pointer, c = a, 0 * sizeof<usize>())\n *     __collect()\n *     let r = b\n *     __stack_pointer += frameSize\n *     return r\n *   }\n *\n *   // caller frameSize = (numLocalSlots + 2 [by extension]) * sizeof<usize>()\n *   (\n *     r = foo(\n *       ( t = a,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 0) * sizeof<usize>()),\n *         t ),\n *       ( t = b,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 1) * sizeof<usize>()),\n *         t )\n *     ),\n *     r\n *   )\n *\n * Also note that we have to `memory.fill` the second half because the first\n * assignment to a local may happen at a later point within the function. The\n * invariant we need to maintain for a precise GC is that it only sees zeroes\n * or valid pointers, but never an invalid pointer left on the stack earlier.\n * Since most frames are small, we unroll a sequence of `store`s up to a frame\n * size of 16 bytes, and `memory.fill`, if available, beyond.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  _BinaryenAddFunction,\n  _BinaryenAddFunctionExport,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallGetTarget,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenCallSetOperandAt,\n  _BinaryenExportGetKind,\n  _BinaryenExportGetName,\n  _BinaryenExportGetValue,\n  _BinaryenExpressionGetId,\n  _BinaryenExpressionGetType,\n  _BinaryenFunctionGetBody,\n  _BinaryenFunctionGetName,\n  _BinaryenFunctionGetNumLocals,\n  _BinaryenFunctionGetNumVars,\n  _BinaryenFunctionGetParams,\n  _BinaryenFunctionGetResults,\n  _BinaryenFunctionGetVar,\n  _BinaryenFunctionSetBody,\n  _BinaryenGetExport,\n  _BinaryenGetFunction,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenLocalSetGetValue,\n  _BinaryenLocalSetIsTee,\n  _BinaryenLocalSetSetValue,\n  _BinaryenRemoveExport,\n  _BinaryenRemoveFunction,\n  _BinaryenReturnGetValue,\n  _BinaryenReturnSetValue,\n  _free\n} from \"../glue/binaryen\";\n\nimport {\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  Index,\n  BinaryOp,\n  TypeRef,\n  allocPtrArray,\n  Module,\n  ExternalKind,\n  ExportRef,\n  expandType,\n  isConstZero,\n} from \"../module\";\n\nimport {\n  Compiler,\n  Options\n} from \"../compiler\";\n\nimport {\n  Feature\n} from \"../common\";\n\nimport {\n  BuiltinNames\n} from \"../builtins\";\n\nimport {\n  Source\n} from \"../ast\";\n\ntype LocalIndex = Index;\ntype SlotIndex = Index;\ntype SlotMap = Map<LocalIndex,SlotIndex>;\ntype TempMap = Map<TypeRef,LocalIndex>;\n\n/** Attempts to match the `__tostack(value)` pattern. Returns `value` if a match, otherwise `0`.  */\nfunction matchPattern(module: Module, expr: ExpressionRef): ExpressionRef {\n  if (\n    _BinaryenExpressionGetId(expr) == ExpressionId.Call &&\n    module.readStringCached(_BinaryenCallGetTarget(expr)) == BuiltinNames.tostack\n  ) {\n    assert(_BinaryenCallGetNumOperands(expr) == 1);\n    return _BinaryenCallGetOperandAt(expr, 0);\n  }\n  return 0;\n}\n\n/** Tests whether a `value` matched by `matchTostack` needs a slot. */\nfunction needsSlot(module: Module, value: ExpressionRef): bool {\n  switch (_BinaryenExpressionGetId(value)) {\n    // no need to stack null pointers\n    case ExpressionId.Const: return !isConstZero(value);\n    // note: can't omit a slot when assigning from another local since the other\n    // local might have shorter lifetime and become reassigned, say in a loop,\n    // then no longer holding on to the previous value in its stack slot.\n  }\n  return true;\n}\n\n/** Instruments a module with a shadow stack for precise GC. */\nexport class ShadowStackPass extends Pass {\n  /** Stack frame slots, per function. */\n  slotMaps: Map<FunctionRef, SlotMap> = new Map();\n  /** Temporary locals, per function. */\n  tempMaps: Map<FunctionRef, TempMap> = new Map();\n  /** Exports (with managed operands) map. */\n  exportMap: Map<string,i32[]> = new Map();\n  /** Compiler reference. */\n  compiler: Compiler;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.compiler = compiler;\n  }\n\n  /** Compiler options. */\n  get options(): Options { return this.compiler.options; }\n  /** Target pointer type. */\n  get ptrType(): TypeRef { return this.options.sizeTypeRef; }\n  /** Target pointer size. */\n  get ptrSize(): i32 { return this.ptrType == TypeRef.I64 ? 8 : 4; }\n  /** Target pointer addition operation. */\n  get ptrBinaryAdd(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.AddI64 : BinaryOp.AddI32; }\n  /** Target pointer subtraction operation. */\n  get ptrBinarySub(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.SubI64 : BinaryOp.SubI32; }\n\n  /** Gets a constant with the specified value of the target pointer type. */\n  ptrConst(value: i32): ExpressionRef {\n    return this.ptrType == TypeRef.I64\n      ? this.module.i64(value)\n      : this.module.i32(value);\n  }\n\n  /** Notes the presence of a slot for the specified (imaginary) local, returning the slot index. */\n  noteSlot(func: FunctionRef, localIndex: Index): i32 {\n    let slotMap: SlotMap;\n    if (this.slotMaps.has(func)) {\n      slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      if (slotMap.has(localIndex)) {\n        return changetype<i32>(slotMap.get(localIndex));\n      }\n    } else {\n      slotMap = new Map();\n      this.slotMaps.set(func, slotMap);\n    }\n    let slotIndex = slotMap.size;\n    slotMap.set(localIndex, slotIndex);\n    return slotIndex;\n  }\n\n  /** Notes the presence of an exported function taking managed operands. */\n  noteExport(name: string, managedOperandIndices: i32[]): void {\n    if (!managedOperandIndices.length) return;\n    this.exportMap.set(name, managedOperandIndices);\n  }\n\n  /** Gets a shared temporary local of the given type in the specified functions. */\n  getSharedTemp(func: FunctionRef, type: TypeRef): Index {\n    let tempMap: TempMap;\n    if (this.tempMaps.has(func)) {\n      tempMap = changetype<TempMap>(this.tempMaps.get(func));\n      if (tempMap.has(type)) {\n        return changetype<Index>(tempMap.get(type));\n      }\n    } else {\n      tempMap = new Map();\n      this.tempMaps.set(func, tempMap);\n    }\n    let numLocals = _BinaryenFunctionGetNumLocals(func);\n    let localIndex = numLocals + tempMap.size;\n    tempMap.set(type, localIndex);\n    return localIndex;\n  }\n\n  /** Makes an expression modifying the stack pointer by the given offset. */\n  makeStackOffset(offset: i32): ExpressionRef {\n    assert(offset != 0);\n    let module = this.module;\n    let expr = module.global_set(BuiltinNames.stack_pointer,\n      module.binary(offset >= 0 ? this.ptrBinaryAdd : this.ptrBinarySub,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        this.ptrConst(abs(offset))\n      )\n    );\n    if (offset > 0) return expr;\n    return module.block(null, [\n      expr,\n      this.makeStackCheck()\n    ], TypeRef.None);\n  }\n\n  /** Makes a sequence of expressions zeroing the stack frame. */\n  makeStackFill(frameSize: i32, stmts: ExpressionRef[]): void {\n    assert(frameSize > 0);\n    let module = this.module;\n    if (this.options.hasFeature(Feature.BulkMemory) && frameSize > 16) {\n      stmts.push(\n        module.memory_fill(\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.i32(0), // TODO: Wasm64 also i32?\n          this.ptrConst(frameSize)\n        )\n      );\n    } else {\n      let remain = frameSize;\n      while (remain >= 8) {\n        // store<i64>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(8,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i64(0),\n            TypeRef.I64,\n            frameSize - remain\n          )\n        );\n        remain -= 8;\n      }\n      if (remain) {\n        assert(remain == 4);\n        // store<i32>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(4,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i32(0),\n            TypeRef.I32,\n            frameSize - remain\n          )\n        );\n      }\n    }\n  }\n\n  private hasStackCheckFunction: bool = false;\n\n  /** Makes a check that the current stack pointer is valid. */\n  makeStackCheck(): ExpressionRef {\n    let module = this.module;\n    if (!this.hasStackCheckFunction) {\n      this.hasStackCheckFunction = true;\n      module.addFunction(\"~stack_check\", TypeRef.None, TypeRef.None, null,\n        module.if(\n          module.binary(BinaryOp.LtI32,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.global_get(BuiltinNames.data_end, this.ptrType)\n          ),\n          this.compiler.makeStaticAbort(\n            this.compiler.ensureStaticString(\"stack overflow\"),\n            Source.native\n          )\n        )\n      );\n    }\n    return module.call(\"~stack_check\", null, TypeRef.None);\n  }\n\n  private updateCallOperands(operands: ExpressionRef[]): i32 {\n    let module = this.module;\n    let numSlots = 0;\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      let operand = operands[i];\n      let match = matchPattern(module, operand);\n      if (!match) continue;\n      if (!needsSlot(module, match)) {\n        operands[i] = match;\n        continue;\n      }\n      let currentFunction = this.currentFunction;\n      let numLocals = _BinaryenFunctionGetNumLocals(currentFunction);\n      let slotIndex = this.noteSlot(currentFunction, numLocals + this.callSlotOffset + i);\n      let temp = this.getSharedTemp(currentFunction, this.ptrType);\n      let stmts = new Array<ExpressionRef>();\n      // t = value\n      stmts.push(\n        module.local_set(temp, match, false)\n      );\n      // store<usize>(__stack_pointer, t, slotIndex * ptrSize)\n      stmts.push(\n        module.store(this.ptrSize,\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.local_get(temp, this.ptrType),\n          this.ptrType, slotIndex * this.ptrSize\n        )\n      );\n      // -> t\n      stmts.push(\n        module.local_get(temp, this.ptrType)\n      );\n      operands[i] = module.block(null, stmts, this.ptrType);\n      ++numSlots;\n    }\n    return numSlots;\n  }\n\n  /** Slot offset accounting for nested calls. */\n  private callSlotOffset: i32 = 0;\n  /** Slot offset stack in nested calls. */\n  private callSlotStack: i32[] = new Array();\n\n  /** @override */\n  visitCallPre(call: ExpressionRef): void {\n    let numOperands = _BinaryenCallGetNumOperands(call);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallGetOperandAt(call, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallSetOperandAt(call, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCall(call: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitCallIndirectPre(callIndirect: ExpressionRef): void {\n    let numOperands = _BinaryenCallIndirectGetNumOperands(callIndirect);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallIndirectGetOperandAt(callIndirect, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallIndirectSetOperandAt(callIndirect, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCallIndirect(callIndirect: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitLocalSet(localSet: ExpressionRef): void {\n    let module = this.module;\n    let value = _BinaryenLocalSetGetValue(localSet);\n    let match = matchPattern(module, value);\n    if (!match) return;\n    if (!needsSlot(module, match)) {\n      _BinaryenLocalSetSetValue(localSet, match);\n      return;\n    }\n    let index = _BinaryenLocalSetGetIndex(localSet);\n    let slotIndex = this.noteSlot(this.currentFunction, index);\n    let stmts = new Array<ExpressionRef>();\n    // store<usize>(__stack_pointer, local = match, slotIndex * ptrSize)\n    stmts.push(\n      module.store(this.ptrSize,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        module.local_tee(index, match, false),\n        this.ptrType, slotIndex * this.ptrSize\n      )\n    );\n    if (_BinaryenLocalSetIsTee(localSet)) {\n      // -> local\n      stmts.push(\n        module.local_get(index, this.ptrType)\n      );\n      this.replaceCurrent(module.flatten(stmts, this.ptrType));\n    } else {\n      this.replaceCurrent(module.flatten(stmts, TypeRef.None));\n    }\n  }\n\n  /** Updates a function with additional locals etc. */\n  updateFunction(funcRef: FunctionRef): void {\n    let name = _BinaryenFunctionGetName(funcRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let body = assert(_BinaryenFunctionGetBody(funcRef));\n    let numVars = _BinaryenFunctionGetNumVars(funcRef);\n    let vars = new Array<TypeRef>();\n    for (let i: Index = 0; i < numVars; ++i) {\n      vars[i] = _BinaryenFunctionGetVar(funcRef, i);\n    }\n    let tempMaps = this.tempMaps;\n    if (tempMaps.has(funcRef)) {\n      let tempMap = changetype<TempMap>(tempMaps.get(funcRef));\n      for (let _keys = Map_keys(tempMap), i = 0, k = _keys.length; i < k; ++i) {\n        vars.push(_keys[i]);\n      }\n    }\n    let moduleRef = this.module.ref;\n    _BinaryenRemoveFunction(moduleRef, name);\n    let cArr = allocPtrArray(vars);\n    let newFuncRef = _BinaryenAddFunction(moduleRef, name, params, results, cArr, vars.length, body);\n    if (this.options.sourceMap || this.options.debugInfo) {\n      let func = this.compiler.program.searchFunctionByRef(newFuncRef);\n      if (func) func.addDebugInfo(this.module, newFuncRef);\n    }\n    _free(cArr);\n  }\n\n  /** Updates a function export taking managed arguments. */\n  updateExport(exportRef: ExportRef, managedOperandIndices: i32[]): void {\n    let module = this.module;\n    let moduleRef = module.ref;\n    assert(_BinaryenExportGetKind(exportRef) == ExternalKind.Function);\n\n    let internalNameRef = _BinaryenExportGetValue(exportRef);\n    let internalName = module.readStringCached(internalNameRef)!;\n    let externalNameRef = _BinaryenExportGetName(exportRef);\n    let funcRef = _BinaryenGetFunction(moduleRef, internalNameRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let paramTypes = expandType(params);\n    let numParams = paramTypes.length;\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let numLocals = numParams;\n    let vars = new Array<TypeRef>();\n    let numSlots = assert(managedOperandIndices.length);\n    let frameSize = numSlots * this.ptrSize;\n    let wrapperName = \"export:\" + internalName;\n    let wrapperNameRef = module.allocStringCached(wrapperName);\n\n    if (_BinaryenGetFunction(moduleRef, wrapperNameRef) == 0) {\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      for (let slotIndex = 0; slotIndex < numSlots; ++slotIndex) {\n        // store<usize>(__stack_pointer, $local, slotIndex * ptrSize)\n        stmts.push(\n          module.store(this.ptrSize,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.local_get(managedOperandIndices[slotIndex], this.ptrType),\n            this.ptrType, slotIndex * this.ptrSize\n          )\n        );\n      }\n      let forwardedOperands = new Array<ExpressionRef>(numParams);\n      for (let i = 0; i < numParams; ++i) {\n        forwardedOperands[i] = module.local_get(i, paramTypes[i]);\n      }\n      if (results != TypeRef.None) {\n        let tempIndex = numLocals++;\n        vars.push(results);\n        // t = original(...)\n        stmts.push(\n          module.local_set(tempIndex,\n            module.call(internalName, forwardedOperands, results),\n            false // internal\n          )\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(tempIndex, results)\n        );\n      } else {\n        // original(...)\n        stmts.push(\n          module.call(internalName, forwardedOperands, results)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      }\n      let cArr = allocPtrArray(vars);\n      _BinaryenAddFunction(moduleRef, wrapperNameRef, params, results, cArr, vars.length,\n        module.block(null, stmts, results)\n      );\n      _free(cArr);\n    }\n    _BinaryenRemoveExport(moduleRef, externalNameRef);\n    _BinaryenAddFunctionExport(moduleRef, wrapperNameRef, externalNameRef);\n  }\n\n  /** @override */\n  walkModule(): void {\n    // Run the pass normally\n    super.walkModule();\n\n    // Instrument returns in functions utilizing stack slots\n    let module = this.module;\n    let instrumentReturns = new InstrumentReturns(this);\n    for (let _keys = Map_keys(this.slotMaps), i = 0, k = _keys.length; i < k; ++i) {\n      let func = _keys[i];\n      let slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      let frameSize = slotMap.size * this.ptrSize;\n\n      // Instrument function returns\n      instrumentReturns.frameSize = frameSize;\n      instrumentReturns.walkFunction(func);\n\n      // Instrument function entry\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      // memory.fill(__stack_pointer, 0, frameSize)\n      this.makeStackFill(frameSize, stmts);\n\n      // Handle implicit return\n      let body = _BinaryenFunctionGetBody(func);\n      let bodyType = _BinaryenExpressionGetType(body);\n      if (bodyType == TypeRef.Unreachable) {\n        // body\n        stmts.push(\n          body\n        );\n      } else if (bodyType == TypeRef.None) {\n        // body\n        stmts.push(\n          body\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      } else {\n        let temp = this.getSharedTemp(func, bodyType);\n        // t = body\n        stmts.push(\n          module.local_set(temp, body, false)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(temp, bodyType)\n        );\n      }\n      _BinaryenFunctionSetBody(func, module.flatten(stmts, bodyType));\n    }\n\n    // Update functions we added more locals to\n    // TODO: _BinaryenFunctionAddVar ?\n    for (let _keys = Map_keys(this.tempMaps), i = 0, k = _keys.length; i < k; ++i) {\n      this.updateFunction(_keys[i]);\n    }\n\n    // Update exports taking managed arguments\n    let exportMap = this.exportMap;\n    for (let _keys = Map_keys(exportMap), i = 0, k = _keys.length; i < k; ++i) {\n      let exportName = _keys[i];\n      let exportRef = _BinaryenGetExport(module.ref, module.allocStringCached(exportName));\n      let managedOperandIndices = changetype<i32[]>(exportMap.get(exportName));\n      this.updateExport(exportRef, managedOperandIndices);\n    }\n  }\n}\n\n/** Companion pass instrumenting `return` statements to restore the stack frame. */\nclass InstrumentReturns extends Pass {\n  /** Parent pass. */\n  parentPass: ShadowStackPass;\n  /** Frame size of the current function being processed. */\n  frameSize: i32 = 0;\n\n  constructor(shadowStack: ShadowStackPass) {\n    super(shadowStack.module);\n    this.parentPass = shadowStack;\n  }\n\n  /** @override */\n  visitReturn(ret: ExpressionRef): void {\n    assert(this.frameSize);\n    let module = this.module;\n    let value = _BinaryenReturnGetValue(ret);\n    let stmts = new Array<ExpressionRef>();\n    if (value) {\n      let returnType = _BinaryenExpressionGetType(value);\n      if (returnType == TypeRef.Unreachable) return;\n      let temp = this.parentPass.getSharedTemp(this.currentFunction, returnType);\n      // t = value\n      stmts.push(\n        module.local_set(temp, value, false)\n      );\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return t\n      _BinaryenReturnSetValue(ret, module.local_get(temp, returnType));\n    } else {\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return\n    }\n    stmts.push(\n      ret\n    );\n    this.replaceCurrent(module.flatten(stmts, TypeRef.Unreachable));\n  }\n}\n", "import {\n  SourceKind\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  ClassPrototype,\n  Element,\n  ElementKind,\n  Function,\n  Enum,\n  Class,\n  Interface,\n  File,\n  FunctionPrototype,\n  Global,\n  Program,\n  Property,\n  PropertyPrototype\n} from \"../program\";\n\n/** Walker base class. */\nexport abstract class ExportsWalker {\n\n  /** Program reference. */\n  program: Program;\n  /** Whether to include private members */\n  includePrivate: bool;\n  /** Already seen elements. */\n  seen: Map<Element,string> = new Map();\n\n  /** Constructs a new Element walker. */\n  constructor(program: Program, includePrivate: bool = false) {\n    this.program = program;\n    this.includePrivate = includePrivate;\n  }\n\n  /** Walks all elements and calls the respective handlers. */\n  walk(): void {\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) this.visitFile(file);\n    }\n  }\n\n  /** Visits all exported elements of a file. */\n  visitFile(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        this.visitElement(memberName, member);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.visitFile(exportStar);\n      }\n    }\n  }\n\n  /** Visits an element.*/\n  visitElement(name: string, element: Element): void {\n    if (element.is(CommonFlags.Private) && !this.includePrivate) return;\n    let seen = this.seen;\n    if (!element.is(CommonFlags.Instance) && seen.has(element)) {\n      this.visitAlias(name, element, assert(seen.get(element)));\n      return;\n    }\n    seen.set(element, name);\n    switch (element.kind) {\n      case ElementKind.Global: {\n        if (element.is(CommonFlags.Compiled)) this.visitGlobal(name, <Global>element);\n        break;\n      }\n      case ElementKind.Enum: {\n        if (element.is(CommonFlags.Compiled)) this.visitEnum(name, <Enum>element);\n        break;\n      }\n      case ElementKind.EnumValue: break; // handled by visitEnum\n      case ElementKind.FunctionPrototype: {\n        this.visitFunctionInstances(name, <FunctionPrototype>element);\n        break;\n      }\n      case ElementKind.ClassPrototype: {\n        this.visitClassInstances(name, <ClassPrototype>element);\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (!propertyInstance) break;\n        element = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.visitFunction(name, getterInstance);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.visitFunction(name, setterInstance);\n        break;\n      }\n      case ElementKind.Namespace: {\n        if (hasCompiledMember(element)) this.visitNamespace(name, element);\n        break;\n      }\n      case ElementKind.TypeDefinition: break;\n      default: assert(false);\n    }\n  }\n\n  private visitFunctionInstances(name: string, element: FunctionPrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.Compiled)) this.visitFunction(name, instance);\n      }\n    }\n  }\n\n  private visitClassInstances(name: string, element: ClassPrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.Compiled)) this.visitClass(name, instance);\n      }\n    }\n  }\n\n  abstract visitGlobal(name: string, element: Global): void;\n  abstract visitEnum(name: string, element: Enum): void;\n  abstract visitFunction(name: string, element: Function): void;\n  abstract visitClass(name: string, element: Class): void;\n  abstract visitInterface(name: string, element: Interface): void;\n  abstract visitNamespace(name: string, element: Element): void;\n  abstract visitAlias(name: string, element: Element, originalName: string): void;\n}\n\n// Helpers\n\n/** Tests if a namespace-like element has at least one compiled member. */\nexport function hasCompiledMember(element: Element): bool {\n  let members = element.members;\n  if (members) {\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      switch (member.kind) {\n        case ElementKind.FunctionPrototype: {\n          let instances = (<FunctionPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.Compiled)) return true;\n            }\n          }\n          break;\n        }\n        case ElementKind.ClassPrototype: {\n          let instances = (<ClassPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.Compiled)) return true;\n            }\n          }\n          break;\n        }\n        default: {\n          if (member.is(CommonFlags.Compiled) || hasCompiledMember(member)) return true;\n          break;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "import {\n  NodeKind,\n  DecoratorKind,\n  LiteralKind,\n  LiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  findDecorator,\n  Source\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  ElementKind,\n  Element,\n  Program,\n  Function,\n  Global,\n  Class,\n  Interface,\n  Enum,\n  EnumValue,\n  PropertyPrototype\n} from \"../program\";\n\nimport {\n  Type,\n  TypeFlags,\n  Signature\n} from \"../types\";\n\nimport {\n  CharCode,\n  escapeString,\n  indent,\n  isIdentifier\n} from \"../util\";\n\nimport {\n  ExportsWalker\n} from \"./util\";\n\n// Limitations\n//\n// - Instrumented globals are no longer WebAssembly.Global, hence cannot be\n//   imported the same way as non-instrumented globals would allow. Affects both\n//   globals imported here and globals imported elsewhere.\n//\n// - Since little is known about how class imports and exports will behave,\n//   there is currently no glue generated for them. In IT there appears to be\n//   a concept of protocols that may or may not map in the future. In GC there\n//   doesn't appear to be a connection between classes and their methods so far.\n//\n//   Instead, generated bindings are limited to lifting and lowering of plain\n//   objects when the class has no constructor and no non-public elements. In\n//   any other sitation an internal or external reference is passed.\n//\n// - Linking two instrumented modules with separate bindings produces\n//   intermediate garbage (i.e. goes through a temporary JS object). Any native\n//   mechanism enabling communication between modules directly would help here.\n//\n// - Cycles between the internal and the external GC cannot be resolved. Using\n//   a common GC as envisioned by the GC proposal can help here, but so far it\n//   seems that the same limitations as for IT will remain.\n//\n// - Duplicate Wasm imports don't yet work when instrumentation is required as\n//   provided argument types cannot be told apart when these only come in as\n//   numbers. It might be possible to modify the binary post compilation, but\n//   this has not been attempted yet.\n//\n// Oddities\n//\n// - Interface Types `string` will be incompatible with JavaScript `String` and\n//   it remains unclear how to proceed on this front. We could either use the IT\n//   mechanism and accept potential hazards or keep using unfortunate glue code.\n//\n// - Functions with a variable number of arguments need some special glue to\n//   inform the binary how many arguments have been provided so it can fill in\n//   defaults for the omitted arguments. No native mechanism in sight, yet.\n//\n// - Optional BigInt arguments must be coerced to 0n since JS does not\n//   implicitly coerce from `null` or `undefined`. Numbers do, however.\n//\n// - Generated bindings assume little endian architecture with typed arrays as\n//   it appears to be more efficient than using a DataView and BE use cases\n//   haven't been seen in the wild so far.\n//\n// - It is assumed that generated import bindings call JavaScript and that the\n//   callee expects a properly coerced integer value, leading to more `>>> 0`\n//   coercions than necessary when the import is actually another Wasm module.\n\n/** Maps special imports to their actual modules. */\nfunction importToModule(moduleName: string): string {\n  // Map rtrace via `imports` in package.json\n  if (moduleName == \"rtrace\") return \"#rtrace\";\n  return moduleName;\n}\n\n/** Determines whether a module's imports should be instrumented. */\nfunction shouldInstrument(moduleName: string): bool {\n  return moduleName != \"rtrace\";\n}\n\n/** A JavaScript bindings builder. */\nexport class JSBuilder extends ExportsWalker {\n\n  /** Builds JavaScript bindings for the specified program. */\n  static build(program: Program, esm: bool = true): string {\n    return new JSBuilder(program, esm).build();\n  }\n\n  private esm: bool;\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  private needsLiftBuffer: bool = false;\n  private needsLowerBuffer: bool = false;\n  private needsLiftString: bool = false;\n  private needsLowerString: bool = false;\n  private needsLiftArray: bool = false;\n  private needsLowerArray: bool = false;\n  private needsLiftTypedArray: bool = false;\n  private needsLowerTypedArray: bool = false;\n  private needsLiftStaticArray: bool = false;\n  private needsLowerStaticArray: bool = false;\n  private needsLiftInternref: bool = false;\n  private needsLowerInternref: bool = false;\n  private needsRetain: bool = false;\n  private needsRelease: bool = false;\n  private needsNotNull: bool = false;\n  private needsStoreRef: bool = false;\n\n  private deferredLifts: Set<Element> = new Set();\n  private deferredLowers: Set<Element> = new Set();\n  private deferredCode: string[] = new Array<string>();\n\n  private exports: string[] = new Array();\n  private importMappings: Map<string,i32> = new Map();\n\n  /** Constructs a new JavaScript bindings builder. */\n  constructor(program: Program, esm: bool, includePrivate: bool = false) {\n    super(program, includePrivate);\n    this.esm = esm;\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    this.exports.push(name);\n    if (!isPlainValue(type, Mode.Export)) {\n      indent(sb, this.indentLevel);\n      sb.push(name);\n      sb.push(\": {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"valueOf() { return this.value; },\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"get value() {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"return \");\n      this.makeLiftFromValue(\"exports.\" + name + \".value\", type, sb);\n      sb.push(\";\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n      if (!element.is(CommonFlags.Const)) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        sb.push(\"set value(value) {\\n\");\n        indent(sb, ++this.indentLevel);\n        sb.push(\"exports.\");\n        sb.push(name);\n        sb.push(\".value = \");\n        this.makeLowerToValue(\"value\", type, sb);\n        sb.push(\";\\n\");\n        indent(sb, --this.indentLevel);\n        sb.push(\"}\");\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"},\\n\");\n    }\n    this.visitNamespace(name, element);\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    let sb = this.sb;\n    this.exports.push(name);\n    indent(sb, this.indentLevel);\n    sb.push(name);\n    sb.push(\": (values => (\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(element.internalName);\n    sb.push(\"\\n\");\n    let members = element.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let value = _values[i];\n        if (value.kind != ElementKind.EnumValue) continue;\n        indent(sb, this.indentLevel);\n        sb.push(\"values[values.\");\n        sb.push(value.name);\n        if (value.is(CommonFlags.Inlined)) {\n          sb.push(\" = \");\n          sb.push(i64_low((<EnumValue>value).constantIntegerValue).toString());\n        } else {\n          sb.push(\" = exports[\\\"\");\n          sb.push(escapeString(name + \".\" + value.name, CharCode.DoubleQuote));\n          sb.push(\"\\\"].valueOf()\");\n        }\n        sb.push(\"] = \\\"\");\n        sb.push(escapeString(value.name, CharCode.DoubleQuote));\n        sb.push(\"\\\",\\n\");\n      }\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"values\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"))({}),\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  makeGlobalImport(moduleName: string, name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    indent(sb, this.indentLevel);\n    if (isIdentifier(name)) {\n      sb.push(name);\n    } else {\n      sb.push(\"\\\"\");\n      sb.push(escapeString(name, CharCode.DoubleQuote));\n      sb.push(\"\\\": \");\n    }\n    let moduleId = this.ensureModuleId(moduleName);\n    if (isPlainValue(type, Mode.Import)) {\n      sb.push(\"(\\n\");\n      indent(sb, this.indentLevel + 1);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(element.type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel + 1);\n      if (moduleName != \"env\") {\n        sb.push(\"__module\");\n        sb.push(moduleId.toString());\n        sb.push(\".\");\n      }\n      sb.push(name);\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\")\");\n    } else {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(element.type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"// not supported: cannot lower before instantiate completes\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    }\n    sb.push(\",\\n\");\n  }\n\n  makeFunctionImport(moduleName: string, name: string, element: Function, code: string | null = null): void {\n    let sb = this.sb;\n    let signature = element.signature;\n    indent(sb, this.indentLevel);\n    if (isIdentifier(name)) {\n      sb.push(name);\n    } else {\n      sb.push(\"\\\"\");\n      sb.push(escapeString(name, CharCode.DoubleQuote));\n      sb.push(\"\\\"\");\n    }\n    if (isPlainFunction(signature, Mode.Import) && !code) {\n      sb.push(\": (\\n\");\n      indent(sb, this.indentLevel + 1);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(element.signature.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel + 1);\n      if (moduleName != \"env\") {\n        sb.push(moduleName);\n        sb.push(\".\");\n      }\n      sb.push(name);\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\")\");\n    } else {\n      sb.push(\"(\");\n      let parameterTypes = signature.parameterTypes;\n      let parameterNames = new Array<string>();\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        parameterNames.push(element.getParameterName(i));\n      }\n      sb.push(parameterNames.join(\", \"));\n      sb.push(\") {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(element.signature.toString());\n      sb.push(\"\\n\");\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let type = parameterTypes[i];\n        if (!isPlainValue(type, Mode.Export)) {\n          let name = element.getParameterName(i);\n          indent(sb, this.indentLevel);\n          sb.push(name);\n          sb.push(\" = \");\n          this.makeLiftFromValue(name, type, sb);\n          sb.push(\";\\n\");\n        }\n      }\n      let expr = new Array<string>();\n      let moduleId = this.ensureModuleId(moduleName);\n      if (code) {\n        expr.push(\"(() => {\\n\");\n        indent(expr, 1);\n        expr.push(\"// @external.js\\n\");\n        indentText(code, 1, expr);\n        expr.push(\"\\n})()\");\n      } else {\n        if (moduleName != \"env\") {\n          expr.push(\"__module\");\n          expr.push(moduleId.toString());\n          expr.push(\".\");\n        }\n        expr.push(name);\n        expr.push(\"(\");\n        expr.push(parameterNames.join(\", \"));\n        expr.push(\")\");\n      }\n      code = expr.join(\"\");\n      expr.length = 0;\n      indentText(code, this.indentLevel, expr, true);\n      code = expr.join(\"\");\n      indent(sb, this.indentLevel);\n      if (signature.returnType != Type.void) {\n        sb.push(\"return \");\n        this.makeLowerToValue(code, signature.returnType, sb);\n        sb.push(\";\\n\");\n      } else {\n        sb.push(code);\n        sb.push(\";\\n\");\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    }\n    sb.push(\",\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    if (element.is(CommonFlags.Private)) return;\n    let sb = this.sb;\n    let signature = element.signature;\n    this.exports.push(name);\n    if (!isPlainFunction(signature, Mode.Export)) {\n      indent(sb, this.indentLevel);\n      sb.push(name);\n      sb.push(\"(\");\n      let parameterTypes = signature.parameterTypes;\n      let numReferences = 0;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        if (parameterTypes[i].isInternalReference) numReferences++;\n        if (i > 0) sb.push(\", \");\n        sb.push(element.getParameterName(i));\n      }\n      sb.push(\") {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(signature.toString());\n      sb.push(\"\\n\");\n      let releases = new Array<string>();\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let type = parameterTypes[i];\n        if (!isPlainValue(type, Mode.Import)) {\n          let name = element.getParameterName(i);\n          indent(sb, this.indentLevel);\n          sb.push(name);\n          sb.push(\" = \");\n          let needsRetainRelease = type.isInternalReference && --numReferences > 0;\n          if (needsRetainRelease) {\n            this.needsRetain = true;\n            this.needsRelease = true;\n            sb.push(\"__retain(\");\n            releases.push(name);\n          }\n          this.makeLowerToValue(name, type, sb);\n          if (needsRetainRelease) {\n            sb.push(\")\");\n          }\n          sb.push(\";\\n\");\n        }\n      }\n      if (releases.length) {\n        indent(sb, this.indentLevel++);\n        sb.push(\"try {\\n\");\n      }\n      if (signature.requiredParameters < parameterTypes.length) {\n        indent(sb, this.indentLevel);\n        sb.push(\"exports.__setArgumentsLength(arguments.length);\\n\");\n      }\n      const expr = new Array<string>();\n      expr.push(\"exports.\");\n      expr.push(name);\n      expr.push(\"(\");\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        if (i > 0) expr.push(\", \");\n        expr.push(element.getParameterName(i));\n      }\n      expr.push(\")\");\n      if (signature.returnType != Type.void) {\n        indent(sb, this.indentLevel);\n        sb.push(\"return \");\n        this.makeLiftFromValue(expr.join(\"\"), signature.returnType, sb);\n      } else {\n        indent(sb, this.indentLevel);\n        sb.push(expr.join(\"\"));\n      }\n      sb.push(\";\\n\");\n      if (releases.length) {\n        indent(sb, this.indentLevel - 1);\n        sb.push(\"} finally {\\n\");\n        for (let i = 0, k = releases.length; i < k; ++i) {\n          indent(sb, this.indentLevel);\n          sb.push(\"__release(\");\n          sb.push(releases[i]);\n          sb.push(\");\\n\");\n        }\n        indent(sb, --this.indentLevel);\n        sb.push(\"}\\n\");\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"},\\n\");\n    }\n    this.visitNamespace(name, element);\n  }\n\n  visitClass(name: string, element: Class): void {\n    // not implemented\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    // not implemented\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // not implemented\n    // let sb = this.sb;\n    // sb.push(\"export const \");\n    // sb.push(name);\n    // sb.push(\" = \");\n    // sb.push(originalName);\n    // sb.push(\";\\n\");\n  }\n\n  getExternalCode(element: Function): string | null {\n    let decorator = findDecorator(DecoratorKind.ExternalJs, element.decoratorNodes);\n    if (decorator) {\n      let args = decorator.args;\n      if (args && args.length == 1) {\n        let codeArg = args[0];\n        if (codeArg.kind == NodeKind.Literal) {\n          let literal = <LiteralExpression>codeArg;\n          if (literal.literalKind == LiteralKind.String) {\n            return (<StringLiteralExpression>literal).value;\n          }\n          if (literal.literalKind == LiteralKind.Template) {\n            let parts = (<TemplateLiteralExpression>literal).parts;\n            if (parts.length == 1) {\n              return parts[0];\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  build(): string {\n    let exports = this.exports;\n    let moduleImports = this.program.moduleImports;\n    let program = this.program;\n    let options = program.options;\n    let sb = this.sb;\n\n    sb.push(\"\"); // placeholder\n    indent(sb, this.indentLevel++);\n    if (!this.esm) sb.push(\"export \");\n    sb.push(\"async function instantiate(module, imports = {}) {\\n\");\n    const insertPos = sb.push(\"\") - 1;\n\n    // Instrument module imports. Keeps raw (JS) imports on the respective\n    // prototypes and overrides selectively where instrumentation is required.\n    indent(sb, this.indentLevel++);\n    sb.push(\"const adaptedImports = {\\n\");\n    let sbLengthBefore = sb.length;\n    for (let _keys = Map_keys(moduleImports), i = 0, k = _keys.length; i < k; ++i) {\n      let moduleName = _keys[i];\n      let moduleId = this.ensureModuleId(moduleName);\n      let module = <Map<string,Element>>moduleImports.get(moduleName);\n      indent(sb, this.indentLevel);\n      if (isIdentifier(moduleName)) {\n        sb.push(moduleName);\n      } else {\n        sb.push(\"\\\"\");\n        sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n        sb.push(\"\\\"\");\n      }\n      if (!shouldInstrument(moduleName)) {\n        sb.push(\": __module\");\n        sb.push(moduleId.toString());\n        sb.push(\",\\n\");\n        continue;\n      }\n      let resetPos = sb.length;\n      sb.push(\": Object.assign(Object.create(\");\n      if (moduleName == \"env\") {\n        sb.push(\"globalThis\");\n      } else {\n        sb.push(\"__module\");\n        sb.push(moduleId.toString());\n      }\n      sb.push(\"), \");\n      if (moduleName == \"env\") {\n        sb.push(\"imports.env || {}, \");\n      }\n      sb.push(\"{\\n\");\n      ++this.indentLevel;\n      let numInstrumented = 0;\n      for (let _keys2 = Map_keys(module), j = 0, l = _keys2.length; j < l; ++j) {\n        let name = _keys2[j];\n        let elem = assert(module.get(name));\n        if (elem.kind == ElementKind.Function) {\n          let func = <Function>elem;\n          let code = this.getExternalCode(func);\n          if (!isPlainFunction(func.signature, Mode.Import) || !isIdentifier(name) || code) {\n            this.makeFunctionImport(moduleName, name, <Function>elem, code);\n            ++numInstrumented;\n          }\n        } else if (elem.kind == ElementKind.Global) {\n          let global = <Global>elem;\n          if (!isPlainValue(global.type, Mode.Import) || !isIdentifier(name)) {\n            this.makeGlobalImport(moduleName, name, global);\n            ++numInstrumented;\n          }\n        }\n      }\n      --this.indentLevel;\n      if (!numInstrumented) {\n        sb.length = resetPos;\n        if (moduleName == \"env\") {\n          sb.push(\": Object.assign(Object.create(globalThis), imports.env || {})\");\n        } else {\n          sb.push(\": __module\");\n          sb.push(moduleId.toString());\n        }\n        sb.push(\",\\n\");\n      } else {\n        indent(sb, this.indentLevel);\n        sb.push(\"}),\\n\");\n      }\n    }\n    --this.indentLevel;\n    let hasAdaptedImports = sb.length > sbLengthBefore;\n    if (hasAdaptedImports) {\n      indent(sb, this.indentLevel);\n      sb.push(\"};\\n\");\n    } else {\n      sb.length = sbLengthBefore - 2; // incl. indent\n    }\n\n    let mappings = this.importMappings;\n    let map = new Array<string>();\n    for (let _keys = Map_keys(mappings), i = 0, k = _keys.length; i < k; ++i) {\n      let moduleName = _keys[i];\n      if (moduleName == \"env\") {\n        map.push(\"  const env = imports.env;\\n\");\n      } else {\n        let moduleId = <i32>mappings.get(moduleName);\n        if (moduleName == \"rtrace\") {\n          // Rtrace is special in that it needs to be installed on the imports\n          // object. Use sensible defaults and substitute the original import.\n          map.push(\"  ((rtrace) => {\\n\");\n          map.push(\"    delete imports.rtrace;\\n\");\n          map.push(\"    new rtrace.Rtrace({ getMemory() { return memory; }, onerror(err) { console.log(`RTRACE: ${err.stack}`); } }).install(imports);\\n\");\n          map.push(\"  })(imports.rtrace);\\n\");\n        }\n        map.push(\"  const __module\");\n        map.push(moduleId.toString());\n        map.push(\" = imports\");\n        if (isIdentifier(moduleName)) {\n          map.push(\".\");\n          map.push(moduleName);\n        } else {\n          map.push(\"[\\\"\");\n          map.push(escapeString(moduleName, CharCode.DoubleQuote));\n          map.push(\"\\\"]\");\n        }\n        map.push(\";\\n\");\n      }\n    }\n    sb[insertPos] = map.join(\"\");\n\n    indent(sb, this.indentLevel);\n    sb.push(\"const { exports } = await WebAssembly.instantiate(module\");\n    if (hasAdaptedImports) {\n      sb.push(\", adaptedImports);\\n\");\n    } else {\n      sb.push(\", imports);\\n\");\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"const memory = exports.memory || imports.env.memory;\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"const adaptedExports = Object.setPrototypeOf({\\n\");\n    sbLengthBefore = sb.length;\n\n    // Instrument module exports. Keeps raw (Wasm) exports on the prototype and\n    // overrides selectively where instrumentation is required.\n    this.walk();\n    --this.indentLevel;\n    let hasAdaptedExports = sb.length > sbLengthBefore;\n    if (hasAdaptedExports) {\n      indent(sb, this.indentLevel);\n      sb.push(\"}, exports);\\n\");\n    } else {\n      if (\n        this.needsLiftBuffer || this.needsLowerBuffer ||\n        this.needsLiftString || this.needsLowerString ||\n        this.needsLiftArray || this.needsLowerArray ||\n        this.needsLiftTypedArray || this.needsLowerTypedArray ||\n        this.needsLiftStaticArray\n      ) {\n        sb.length = sbLengthBefore - 2; // skip adaptedExports + 1x indent\n      } else {\n        sb.length = sbLengthBefore - 4; // skip memory and adaptedExports + 2x indent\n      }\n    }\n\n    // Add external JS code fragments\n    let deferredCode = this.deferredCode;\n    if (deferredCode.length) {\n      for (let i = 0, k = deferredCode.length; i < k; ++i) {\n        sb.push(deferredCode[i]);\n      }\n    }\n\n    // Add the respective lifting and lowering adapters\n    if (this.needsLiftBuffer) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      sb.push(`  function __liftBuffer(pointer) {\n    if (!pointer) return null;\n    return memory.buffer.slice(pointer, pointer + new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2]);\n  }\n`);\n    }\n    if (this.needsLowerBuffer) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      sb.push(`  function __lowerBuffer(value) {\n    if (value == null) return 0;\n    const pointer = exports.__new(value.byteLength, ${arrayBufferId}) >>> 0;\n    new Uint8Array(memory.buffer).set(new Uint8Array(value), pointer);\n    return pointer;\n  }\n`);\n    }\n    if (this.needsLiftString) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      let chunkSize = 1024;\n      sb.push(`  function __liftString(pointer) {\n    if (!pointer) return null;\n    const\n      end = pointer + new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2] >>> 1,\n      memoryU16 = new Uint16Array(memory.buffer);\n    let\n      start = pointer >>> 1,\n      string = \"\";\n    while (end - start > ${chunkSize}) string += String.fromCharCode(...memoryU16.subarray(start, start += ${chunkSize}));\n    return string + String.fromCharCode(...memoryU16.subarray(start, end));\n  }\n`);\n    }\n    if (this.needsLowerString) {\n      let stringId = program.stringInstance.id;\n      sb.push(`  function __lowerString(value) {\n    if (value == null) return 0;\n    const\n      length = value.length,\n      pointer = exports.__new(length << 1, ${stringId}) >>> 0,\n      memoryU16 = new Uint16Array(memory.buffer);\n    for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);\n    return pointer;\n  }\n`);\n    }\n    if (this.needsLiftArray) {\n      let dataStartOffset = program.arrayBufferViewInstance.offsetof(\"dataStart\");\n      let lengthOffset = program.arrayBufferViewInstance.nextMemoryOffset;\n      sb.push(`  function __liftArray(liftElement, align, pointer) {\n    if (!pointer) return null;\n    const\n      memoryU32 = new Uint32Array(memory.buffer),\n      dataStart = memoryU32[pointer + ${dataStartOffset} >>> 2],\n      length = memoryU32[pointer + ${lengthOffset} >>> 2],\n      values = new Array(length);\n    for (let i = 0; i < length; ++i) values[i] = liftElement(dataStart + (i << align >>> 0));\n    return values;\n  }\n`);\n    }\n    if (this.needsLowerArray) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let arraySize = arrayBufferViewInstance.nextMemoryOffset + 4; // + length\n      let bufferOffset = arrayBufferViewInstance.offsetof(\"buffer\");\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      let lengthOffset = byteLengthOffset + 4;\n      sb.push(`  function __lowerArray(lowerElement, id, align, values) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, ${arrayBufferId})) >>> 0,\n      header = exports.__pin(exports.__new(${arraySize}, id)) >>> 0,\n      memoryU32 = new Uint32Array(memory.buffer);\n    memoryU32[header + ${bufferOffset} >>> 2] = buffer;\n    memoryU32[header + ${dataStartOffset} >>> 2] = buffer;\n    memoryU32[header + ${byteLengthOffset} >>> 2] = length << align;\n    memoryU32[header + ${lengthOffset} >>> 2] = length;\n    for (let i = 0; i < length; ++i) lowerElement(buffer + (i << align >>> 0), values[i]);\n    exports.__unpin(buffer);\n    exports.__unpin(header);\n    return header;\n  }\n`);\n    }\n    if (this.needsLiftTypedArray) {\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      sb.push(`  function __liftTypedArray(constructor, pointer) {\n    if (!pointer) return null;\n    const memoryU32 = new Uint32Array(memory.buffer);\n    return new constructor(\n      memory.buffer,\n      memoryU32[pointer + ${dataStartOffset} >>> 2],\n      memoryU32[pointer + ${byteLengthOffset} >>> 2] / constructor.BYTES_PER_ELEMENT\n    ).slice();\n  }\n`);\n    }\n    if (this.needsLowerTypedArray) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let size = arrayBufferViewInstance.nextMemoryOffset;\n      let bufferOffset = arrayBufferViewInstance.offsetof(\"buffer\");\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      sb.push(`  function __lowerTypedArray(constructor, id, align, values) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, ${arrayBufferId})) >>> 0,\n      header = exports.__new(${size}, id) >>> 0,\n      memoryU32 = new Uint32Array(memory.buffer);\n    memoryU32[header + ${bufferOffset} >>> 2] = buffer;\n    memoryU32[header + ${dataStartOffset} >>> 2] = buffer;\n    memoryU32[header + ${byteLengthOffset} >>> 2] = length << align;\n    new constructor(memory.buffer, buffer, length).set(values);\n    exports.__unpin(buffer);\n    return header;\n  }\n`);\n    }\n    if (this.needsLiftStaticArray) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      sb.push(`  function __liftStaticArray(liftElement, align, pointer) {\n    if (!pointer) return null;\n    const\n      length = new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2] >>> align,\n      values = new Array(length);\n    for (let i = 0; i < length; ++i) values[i] = liftElement(pointer + (i << align >>> 0));\n    return values;\n  }\n`);\n    }\n    if (this.needsLowerStaticArray) {\n      sb.push(`  function __lowerStaticArray(lowerElement, id, align, values, typedConstructor) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, id)) >>> 0;\n    if (typedConstructor) {\n      new typedConstructor(memory.buffer, buffer, length).set(values);\n    } else {\n      for (let i = 0; i < length; i++) lowerElement(buffer + (i << align >>> 0), values[i]);\n    }\n    exports.__unpin(buffer);\n    return buffer;\n  }\n`);\n    }\n    if (this.needsLiftInternref || this.needsLowerInternref) {\n      sb.push(\"  class Internref extends Number {}\\n\");\n    }\n    if (this.needsLiftInternref) {\n      this.needsRetain = true;\n      this.needsRelease = true;\n      sb.push(`  const registry = new FinalizationRegistry(__release);\n  function __liftInternref(pointer) {\n    if (!pointer) return null;\n    const sentinel = new Internref(__retain(pointer));\n    registry.register(sentinel, pointer);\n    return sentinel;\n  }\n`);\n    }\n    if (this.needsLowerInternref) {\n      sb.push(`  function __lowerInternref(value) {\n    if (value == null) return 0;\n    if (value instanceof Internref) return value.valueOf();\n    throw TypeError(\"internref expected\");\n  }\n`);\n    }\n    if (this.needsRetain || this.needsRelease) {\n      sb.push(`  const refcounts = new Map();\n`);\n    }\n    if (this.needsRetain) {\n      sb.push(`  function __retain(pointer) {\n    if (pointer) {\n      const refcount = refcounts.get(pointer);\n      if (refcount) refcounts.set(pointer, refcount + 1);\n      else refcounts.set(exports.__pin(pointer), 1);\n    }\n    return pointer;\n  }\n`);\n    }\n    if (this.needsRelease) {\n      sb.push(`  function __release(pointer) {\n    if (pointer) {\n      const refcount = refcounts.get(pointer);\n      if (refcount === 1) exports.__unpin(pointer), refcounts.delete(pointer);\n      else if (refcount) refcounts.set(pointer, refcount - 1);\n      else throw Error(\\`invalid refcount '\\${refcount}' for reference '\\${pointer}'\\`);\n    }\n  }\n`);\n    }\n    if (this.needsNotNull) {\n      sb.push(`  function __notnull() {\n    throw TypeError(\"value must not be null\");\n  }\n`);\n    }\n    if (this.needsStoreRef) {\n      sb.push(`  function __store_ref(pointer, value) {\n    new Uint32Array(memory.buffer)[pointer >>> 2] = value;\n  }\n`);\n    }\n\n    let exportStart = options.exportStart;\n    if (exportStart) {\n      sb.push(`  exports.${exportStart}();\\n`);\n    }\n\n    if (hasAdaptedExports) {\n      sb.push(\"  return adaptedExports;\\n}\\n\");\n    } else {\n      sb.push(\"  return exports;\\n}\\n\");\n    }\n    --this.indentLevel;\n    assert(this.indentLevel == 0);\n\n    if (this.esm) {\n      sb.push(\"export const {\\n  \");\n      if (this.program.options.exportMemory) {\n        sb.push(\"memory,\\n  \");\n      }\n      if (this.program.options.exportTable) {\n        sb.push(\"table,\\n  \");\n      }\n      for (let i = 0, k = exports.length; i < k; ++i) {\n        if (i > 0) sb.push(\",\\n  \");\n        sb.push(exports[i]);\n      }\n      sb.push(`\n} = await (async url => instantiate(\n  await (async () => {\n    try { return await globalThis.WebAssembly.compileStreaming(globalThis.fetch(url)); }\n    catch { return globalThis.WebAssembly.compile(await (await import(\"node:fs/promises\")).readFile(url)); }\n  })(), {\n`);\n      let needsMaybeDefault = false;\n      let importExpr = new Array<string>();\n      for (let _keys = Map_keys(mappings), i = 0, k = _keys.length; i < k; ++i) {\n        let moduleName = _keys[i];\n        if (moduleName == \"env\") {\n          indent(sb, 2);\n          sb.push(\"env: globalThis,\\n\");\n        } else {\n          let moduleId = this.ensureModuleId(moduleName);\n          indent(sb, 2);\n          if (isIdentifier(moduleName)) {\n            sb.push(moduleName);\n          } else {\n            sb.push(\"\\\"\");\n            sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n            sb.push(\"\\\"\");\n          }\n          sb.push(\": __maybeDefault(__import\");\n          sb.push(moduleId.toString());\n          sb.push(\"),\\n\");\n          importExpr.push(\"import * as __import\");\n          importExpr.push(moduleId.toString());\n          importExpr.push(\" from \\\"\");\n          importExpr.push(escapeString(importToModule(moduleName), CharCode.DoubleQuote));\n          importExpr.push(\"\\\";\\n\");\n          needsMaybeDefault = true;\n        }\n      }\n      sb[0] = importExpr.join(\"\");\n      sb.push(`  }\n))(new URL(\"${escapeString(options.basenameHint, CharCode.DoubleQuote)}.wasm\", import.meta.url));\n`);\n      if (needsMaybeDefault) {\n        sb.push(`function __maybeDefault(module) {\n  return typeof module.default === \"object\" && Object.keys(module).length == 1\n    ? module.default\n    : module;\n}\n`);\n      }\n    }\n    return sb.join(\"\");\n  }\n\n  ensureModuleId(moduleName: string): i32 {\n    if (moduleName == \"env\") return -1;\n    let importMap = this.importMappings;\n    let moduleId = importMap.has(moduleName)\n      ? i32(importMap.get(moduleName))\n      : importMap.size;\n    importMap.set(moduleName, moduleId);\n    return moduleId;\n  }\n\n  /** Lifts a WebAssembly value to a JavaScript value. */\n  makeLiftFromValue(name: string, type: Type, sb: string[] = this.sb): void {\n    if (type.isInternalReference) {\n      // Lift reference types\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extendsPrototype(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"__liftBuffer(\");\n        this.needsLiftBuffer = true;\n      } else if (clazz.extendsPrototype(this.program.stringInstance.prototype)) {\n        sb.push(\"__liftString(\");\n        this.needsLiftString = true;\n      } else if (clazz.extendsPrototype(this.program.arrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__liftArray(\");\n        this.makeLiftFromMemory(valueType, sb);\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLiftArray = true;\n      } else if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__liftStaticArray(\");\n        this.makeLiftFromMemory(valueType, sb);\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLiftStaticArray = true;\n      } else if (clazz.extendsPrototype(this.program.arrayBufferViewInstance.prototype)) {\n        sb.push(\"__liftTypedArray(\");\n        if (clazz.name == \"Uint64Array\") {\n          sb.push(\"BigUint64Array\");\n        } else if (clazz.name == \"Int64Array\") {\n          sb.push(\"BigInt64Array\");\n        } else {\n          sb.push(clazz.name); // TODO: what if extended?\n        }\n        sb.push(\", \");\n        this.needsLiftTypedArray = true;\n      } else if (isPlainObject(clazz)) {\n        sb.push(\"__liftRecord\");\n        sb.push(clazz.id.toString());\n        sb.push(\"(\");\n        if (!this.deferredLifts.has(clazz)) {\n          this.deferredLifts.add(clazz);\n          let prevIndentLevel = this.indentLevel;\n          this.indentLevel = 1;\n          this.deferredCode.push(this.makeLiftRecord(clazz));\n          this.indentLevel = prevIndentLevel;\n        }\n      } else {\n        sb.push(\"__liftInternref(\");\n        this.needsLiftInternref = true;\n      }\n      sb.push(name);\n      if (!name.startsWith(\"new Uint32Array(\")) {\n        // no need to coerce when lifting with indirection\n        sb.push(\" >>> 0\");\n      }\n      sb.push(\")\");\n    } else {\n      // Lift basic plain types\n      if (type == Type.bool) {\n        sb.push(`${name} != 0`);\n      } else if (type.isUnsignedIntegerValue && type.size >= 32) {\n        sb.push(type.size == 64 ? `BigInt.asUintN(64, ${name})` : `${name} >>> 0`);\n      } else {\n        sb.push(name);\n      }\n    }\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly value. */\n  makeLowerToValue(name: string, type: Type, sb: string[] = this.sb): void {\n    if (type.isInternalReference) {\n      // Lower reference types\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extendsPrototype(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"__lowerBuffer(\");\n        this.needsLowerBuffer = true;\n      } else if (clazz.extendsPrototype(this.program.stringInstance.prototype)) {\n        sb.push(\"__lowerString(\");\n        this.needsLowerString = true;\n      } else if (clazz.extendsPrototype(this.program.arrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerArray(\");\n        this.makeLowerToMemory(valueType, sb);\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(clazz.getArrayValueType().alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerArray = true;\n      } else if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerStaticArray(\");\n        this.makeLowerToMemory(valueType, sb);\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerStaticArray = true;\n      } else if (clazz.extendsPrototype(this.program.arrayBufferViewInstance.prototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerTypedArray(\");\n        if (valueType == Type.u64) {\n          sb.push(\"BigUint64Array\");\n        } else if (valueType == Type.i64) {\n          sb.push(\"BigInt64Array\");\n        } else {\n          sb.push(clazz.name); // TODO: what if extended?\n        }\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(clazz.getArrayValueType().alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerTypedArray = true;\n      } else if (isPlainObject(clazz)) {\n        sb.push(\"__lowerRecord\");\n        sb.push(clazz.id.toString());\n        sb.push(\"(\");\n        if (!this.deferredLowers.has(clazz)) {\n          this.deferredLowers.add(clazz);\n          let prevIndentLevel = this.indentLevel;\n          this.indentLevel = 1;\n          this.deferredCode.push(this.makeLowerRecord(clazz));\n          this.indentLevel = prevIndentLevel;\n        }\n      } else {\n        sb.push(\"__lowerInternref(\");\n        this.needsLowerInternref = true;\n      }\n      sb.push(name);\n      if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        // optional last argument for __lowerStaticArray\n        let valueType = clazz.getArrayValueType();\n        if (valueType.isNumericValue) {\n          sb.push(\", \");\n          if (valueType == Type.u8 || valueType == Type.bool) {\n            sb.push(\"Uint8Array\");\n          } else if (valueType == Type.i8) {\n            sb.push(\"Int8Array\");\n          } else if (valueType == Type.u16) {\n            sb.push(\"Uint16Array\");\n          } else if (valueType == Type.i16) {\n            sb.push(\"Int16Array\");\n          } else if (valueType == Type.u32 || valueType == Type.usize32) {\n            sb.push(\"Uint32Array\");\n          } else if (valueType == Type.i32 || valueType == Type.isize32) {\n            sb.push(\"Int32Array\");\n          } else if (valueType == Type.u64 || valueType == Type.usize64) {\n            sb.push(\"BigUint64Array\");\n          } else if (valueType == Type.i64 || valueType == Type.isize64) {\n            sb.push(\"BigInt64Array\");\n          } else if (valueType == Type.f32) {\n            sb.push(\"Float32Array\");\n          } else if (valueType == Type.f64) {\n            sb.push(\"Float64Array\");\n          } else {\n            // unreachable\n            assert(false);\n          }\n        }\n      }\n      sb.push(\")\");\n      if (!type.is(TypeFlags.Nullable)) {\n        this.needsNotNull = true;\n        sb.push(\" || __notnull()\");\n      }\n    } else {\n      // Lower basic types\n      sb.push(name); // basic value\n      if (type.isIntegerValue && type.size == 64) {\n        sb.push(\" || 0n\");\n      } else if (type == Type.bool) {\n        // may be stored to an Uint8Array, make sure to store 1/0\n        sb.push(\" ? 1 : 0\");\n      }\n    }\n  }\n\n  /** Lifts a WebAssembly memory address to a JavaScript value. */\n  makeLiftFromMemory(valueType: Type, sb: string[] = this.sb, target: string | null = null): void {\n    if (!target) {\n      sb.push(\"pointer => \");\n      target = \"pointer\";\n    }\n    if (valueType.isInternalReference) {\n      let expr = new Array<string>();\n      expr.push(\"new Uint32Array(memory.buffer)[\");\n      expr.push(target);\n      expr.push(\" >>> 2]\");\n      this.makeLiftFromValue(expr.join(\"\"), valueType, sb);\n    } else {\n      if (valueType == Type.i8) {\n        sb.push(\"new Int8Array(memory.buffer)[\");\n      } else if (valueType == Type.u8 || valueType == Type.bool) {\n        sb.push(\"new Uint8Array(memory.buffer)[\");\n      } else if (valueType == Type.i16) {\n        sb.push(\"new Int16Array(memory.buffer)[\");\n      } else if (valueType == Type.u16) {\n        sb.push(\"new Uint16Array(memory.buffer)[\");\n      } else if (valueType == Type.i32 || valueType == Type.isize32) {\n        sb.push(\"new Int32Array(memory.buffer)[\");\n      } else if (valueType == Type.u32 || valueType == Type.usize32) {\n        sb.push(\"new Uint32Array(memory.buffer)[\");\n      } else if (valueType == Type.i64 || valueType == Type.isize64) {\n        sb.push(\"new BigInt64Array(memory.buffer)[\");\n      } else if (valueType == Type.u64 || valueType == Type.usize64) {\n        sb.push(\"new BigUint64Array(memory.buffer)[\");\n      } else if (valueType == Type.f32) {\n        sb.push(\"new Float32Array(memory.buffer)[\");\n      } else if (valueType == Type.f64) {\n        sb.push(\"new Float64Array(memory.buffer)[\");\n      } else {\n        sb.push(\"{ throw Error(\\\"unsupported type\\\"); }\");\n        return;\n      }\n      sb.push(target);\n      sb.push(\" >>> \");\n      sb.push(valueType.alignLog2.toString());\n      sb.push(\"]\");\n      if (valueType == Type.bool) {\n        sb.push(\" != 0\");\n      }\n    }\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly memory address. */\n  makeLowerToMemory(valueType: Type, sb: string[] = this.sb, targetName: string | null = null, valueName: string | null = null): void {\n    let skipTail = true;\n    if (!targetName  || !valueName) {\n      sb.push(\"(pointer, value) => { \");\n      targetName = \"pointer\";\n      valueName = \"value\";\n      skipTail = false;\n    }\n    if (valueType.isInternalReference) {\n      // The RHS is typically another lowering to memory, which may trigger\n      // memory growth. Use a helper closure to delay evaluation of `memory`.\n      this.needsStoreRef = true;\n      sb.push(\"__store_ref(\");\n      sb.push(targetName);\n      sb.push(\", \");\n      this.makeLowerToValue(valueName, valueType, sb);\n      sb.push(\")\");\n      if (!skipTail) sb.push(\"; }\");\n      return;\n    }\n    if (valueType == Type.i8) {\n      sb.push(\"new Int8Array(memory.buffer)[\");\n    } else if (valueType == Type.u8 || valueType == Type.bool) {\n      sb.push(\"new Uint8Array(memory.buffer)[\");\n    } else if (valueType == Type.i16) {\n      sb.push(\"new Int16Array(memory.buffer)[\");\n    } else if (valueType == Type.u16) {\n      sb.push(\"new Uint16Array(memory.buffer)[\");\n    } else if (valueType == Type.i32 || valueType == Type.isize32) {\n      sb.push(\"new Int32Array(memory.buffer)[\");\n    } else if (valueType == Type.u32 || valueType == Type.usize32) {\n      sb.push(\"new Uint32Array(memory.buffer)[\");\n    } else if (valueType == Type.i64 || valueType == Type.isize64) {\n      sb.push(\"new BigInt64Array(memory.buffer)[\");\n    } else if (valueType == Type.u64 || valueType == Type.usize64) {\n      sb.push(\"new BigUint64Array(memory.buffer)[\");\n    } else if (valueType == Type.f32) {\n      sb.push(\"new Float32Array(memory.buffer)[\");\n    } else if (valueType == Type.f64) {\n      sb.push(\"new Float64Array(memory.buffer)[\");\n    } else {\n      if (skipTail) {\n        sb.push(\"(() => { throw Error(\\\"unsupported type\\\") })()\");\n      } else {\n        sb.push(\"throw Error(\\\"unsupported type\\\"); }\");\n      }\n      return;\n    }\n    sb.push(targetName);\n    sb.push(\" >>> \");\n    sb.push(valueType.alignLog2.toString());\n    sb.push(\"] = \");\n    this.makeLowerToValue(valueName, valueType, sb);\n    if (!skipTail) sb.push(\"; }\");\n  }\n\n  makeLiftRecord(clazz: Class): string {\n    assert(isPlainObject(clazz));\n    let sb = new Array<string>();\n    indent(sb, this.indentLevel);\n    sb.push(\"function __liftRecord\");\n    sb.push(clazz.id.toString());\n    sb.push(\"(pointer) {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(clazz.type.toString());\n    sb.push(\"\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"// Hint: Opt-out from lifting as a record by providing an empty constructor\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"if (!pointer) return null;\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"return {\\n\");\n    let members = clazz.members;\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        let property = (<PropertyPrototype>member).instance; // resolved during class finalization\n        if (!property || !property.isField) continue;\n        assert(property.memoryOffset >= 0);\n        indent(sb, this.indentLevel);\n        sb.push(property.name);\n        sb.push(\": \");\n        this.makeLiftFromMemory(property.type, sb, \"pointer + \" + property.memoryOffset.toString());\n        sb.push(\",\\n\");\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"};\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n\n  makeLowerRecord(clazz: Class): string {\n    assert(isPlainObject(clazz));\n    let sb = new Array<string>();\n    indent(sb, this.indentLevel);\n    sb.push(\"function __lowerRecord\");\n    sb.push(clazz.id.toString());\n    sb.push(\"(value) {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(clazz.type.toString());\n    sb.push(\"\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"// Hint: Opt-out from lowering as a record by providing an empty constructor\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"if (value == null) return 0;\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"const pointer = exports.__pin(exports.__new(\");\n    sb.push(clazz.nextMemoryOffset.toString());\n    sb.push(\", \");\n    sb.push(clazz.id.toString());\n    sb.push(\"));\\n\");\n    let members = clazz.members;\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        let property = (<PropertyPrototype>member).instance; // resolved during class finalization\n        if (!property || !property.isField) continue;\n        assert(property.memoryOffset >= 0);\n        indent(sb, this.indentLevel);\n        this.makeLowerToMemory(property.type, sb, \"pointer + \" + property.memoryOffset.toString(), \"value.\" + memberName);\n        sb.push(\";\\n\");\n      }\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"exports.__unpin(pointer);\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"return pointer;\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n// Helpers\n\nenum Mode {\n  Import,\n  Export\n}\n\nfunction isPlainValue(type: Type, kind: Mode): bool {\n  if (kind == Mode.Import) {\n    // may be stored to an Uint8Array, make sure to store 1/0\n    if (type == Type.bool) return false;\n    // requires coercion of undefined to 0n\n    if (type.isIntegerValue && type.size == 64) return false;\n  } else {\n    // requires coercion from 1/0 to true/false\n    if (type == Type.bool) return false;\n    // requires coercion from signed to unsigned for u32 and u64.\n    // Note, u8 and u16 doesn't overflow in native type so mark as plain\n    if (type.isUnsignedIntegerValue && type.size >= 32) return false;\n  }\n  return !type.isInternalReference;\n}\n\nfunction isPlainFunction(signature: Signature, mode: Mode): bool {\n  let parameterTypes = signature.parameterTypes;\n  let inverseMode = mode == Mode.Import ? Mode.Export : Mode.Import;\n  if (!isPlainValue(signature.returnType, mode)) return false;\n  for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n    if (!isPlainValue(parameterTypes[i], inverseMode)) return false;\n  }\n  return true;\n}\n\nfunction isPlainObject(clazz: Class): bool {\n  // A plain object does not inherit and does not have a constructor or private properties\n  if (clazz.base && !clazz.prototype.implicitlyExtendsObject) return false;\n  let members = clazz.members;\n  if (members) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = _values[i];\n      if (member.isAny(CommonFlags.Private | CommonFlags.Protected)) return false;\n      if (member.is(CommonFlags.Constructor)) {\n        // a generated constructor is ok\n        if (member.declaration.range != Source.native.range) return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction indentText(text: string, indentLevel: i32, sb: string[], butFirst: bool = false): void {\n  let lineStart = 0;\n  let length = text.length;\n  let pos = 0;\n  while (pos < length) {\n    if (text.charCodeAt(pos) == CharCode.LineFeed) {\n      if (butFirst) butFirst = false;\n      else indent(sb, indentLevel);\n      sb.push(text.substring(lineStart, lineStart = pos + 1));\n    }\n    ++pos;\n  }\n  if (lineStart < length) {\n    if (!butFirst) indent(sb, indentLevel);\n    sb.push(text.substring(lineStart));\n  }\n}\n\nexport function liftRequiresExportRuntime(type: Type): bool {\n  // TODO: enable v128 in signatures in future\n  // if (type.isVectorValue) return true;\n  if (!type.isInternalReference) return false;\n  let clazz = type.classReference;\n  if (!clazz) {\n    // functions lift as internref using __pin\n    assert(type.signatureReference);\n    return true;\n  }\n  let program = clazz.program;\n  // flat collections lift via memory copy\n  if (\n    clazz.extendsPrototype(program.arrayBufferInstance.prototype) ||\n    clazz.extendsPrototype(program.stringInstance.prototype) ||\n    clazz.extendsPrototype(program.arrayBufferViewInstance.prototype)\n  ) {\n    return false;\n  }\n  // nested collections lift depending on element type\n  if (\n    clazz.extendsPrototype(program.arrayPrototype) ||\n    clazz.extendsPrototype(program.staticArrayPrototype)\n  ) {\n    return liftRequiresExportRuntime(clazz.getArrayValueType());\n  }\n  // complex objects lift as internref using __pin. plain objects may or may not\n  // involve the runtime: assume that they do to avoid potentially costly checks\n  return true;\n}\n\nexport function lowerRequiresExportRuntime(type: Type): bool {\n  // TODO: enable v128 in signatures in future\n  // if (type.isVectorValue) return true;\n  if (!type.isInternalReference) return false;\n  let clazz = type.classReference;\n  if (!clazz) {\n    // lowers by reference\n    assert(type.signatureReference);\n    return false;\n  }\n  // lowers using __new\n  let program = clazz.program;\n  if (\n    clazz.extendsPrototype(program.arrayBufferInstance.prototype) ||\n    clazz.extendsPrototype(program.stringInstance.prototype) ||\n    clazz.extendsPrototype(program.arrayBufferViewInstance.prototype) ||\n    clazz.extendsPrototype(program.arrayPrototype) ||\n    clazz.extendsPrototype(program.staticArrayPrototype)\n  ) {\n    return true;\n  }\n  // complex objects lower via internref by reference,\n  // while plain objects lower using __new\n  return isPlainObject(clazz);\n}\n", "/**\n * @fileoverview The AssemblyScript compiler.\n * @license Apache-2.0\n */\n\nimport {\n  BuiltinNames,\n  BuiltinContext,\n  builtins,\n  function_builtins,\n  compileVisitGlobals,\n  compileVisitMembers,\n  compileRTTI\n} from \"./builtins\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Module,\n  MemorySegment,\n  ExpressionRef,\n  UnaryOp,\n  BinaryOp,\n  TypeRef,\n  FunctionRef,\n  ExpressionId,\n  GlobalRef,\n  FeatureFlags,\n  Index,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI32,\n  getConstValueI64Low,\n  getConstValueI64High,\n  getConstValueF32,\n  getConstValueF64,\n  getConstValueV128,\n  getBlockChildCount,\n  getBlockChildAt,\n  getBlockName,\n  getLocalSetValue,\n  getGlobalGetName,\n  isGlobalMutable,\n  getSideEffects,\n  SideEffects,\n  SwitchBuilder,\n  ExpressionRunnerFlags,\n  isConstZero,\n  isConstNegZero,\n  isConstExpressionNaN,\n  ensureType,\n  createType\n} from \"./module\";\n\nimport {\n  CommonFlags,\n  STATIC_DELIMITER,\n  INDEX_SUFFIX,\n  CommonNames,\n  Feature,\n  Target,\n  Runtime\n} from \"./common\";\n\nimport {\n  Program,\n  ClassPrototype,\n  Class,\n  Element,\n  ElementKind,\n  DeclaredElement,\n  Enum,\n  FunctionPrototype,\n  Function,\n  Global,\n  Local,\n  EnumValue,\n  Property,\n  VariableLikeElement,\n  ConstantValueKind,\n  OperatorKind,\n  DecoratorFlags,\n  PropertyPrototype,\n  IndexSignature,\n  File,\n  mangleInternalName\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  Flow,\n  LocalFlags,\n  FieldFlags,\n  ConditionKind\n} from \"./flow\";\n\nimport {\n  Resolver,\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  DecoratorKind,\n  AssertionKind,\n  SourceKind,\n  FunctionTypeNode,\n  DecoratorNode,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DoStatement,\n  EmptyStatement,\n  EnumDeclaration,\n  ExportDefaultStatement,\n  ExportStatement,\n  ExpressionStatement,\n  FieldDeclaration,\n  ForStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  NamespaceDeclaration,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  VoidStatement,\n  WhileStatement,\n\n  Expression,\n  AssertionExpression,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FloatLiteralExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  IntegerLiteralExpression,\n  LiteralExpression,\n  LiteralKind,\n  NewExpression,\n  ObjectLiteralExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  ArrayLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  UnaryPostfixExpression,\n  UnaryPrefixExpression,\n  CompiledExpression,\n\n  TypeNode,\n  NamedTypeNode,\n\n  findDecorator,\n  isTypeOmitted,\n  Source\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags,\n  Signature,\n  typesToRefs\n} from \"./types\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeI64,\n  writeF32,\n  writeF64,\n  writeV128,\n  cloneMap,\n  isPowerOf2,\n  readI32,\n  isIdentifier,\n  accuratePow64,\n  v128_zero,\n  v128_ones,\n} from \"./util\";\n\nimport {\n  RtraceMemory\n} from \"./passes/rtrace\";\n\nimport {\n  ShadowStackPass\n} from \"./passes/shadowstack\";\n\nimport {\n  liftRequiresExportRuntime,\n  lowerRequiresExportRuntime\n} from \"./bindings/js\";\n\n/** Compiler options. */\nexport class Options {\n  constructor() { /* as internref */ }\n\n  /** WebAssembly target. Defaults to {@link Target.Wasm32}. */\n  target: Target = Target.Wasm32;\n  /** Runtime type. Defaults to Incremental GC. */\n  runtime: Runtime = Runtime.Incremental;\n  /** If true, indicates that debug information will be emitted by Binaryen. */\n  debugInfo: bool = false;\n  /** If true, replaces assertions with nops. */\n  noAssert: bool = false;\n  /** It true, exports the memory to the embedder. */\n  exportMemory: bool = true;\n  /** If true, imports the memory provided by the embedder. */\n  importMemory: bool = false;\n  /** Initial memory size, in pages. */\n  initialMemory: u32 = 0;\n  /** Maximum memory size, in pages. */\n  maximumMemory: u32 = 0;\n  /** If true, memory is declared as shared. */\n  sharedMemory: bool = false;\n  /** If true, imported memory is zero filled. */\n  zeroFilledMemory: bool = false;\n  /** If true, imports the function table provided by the embedder. */\n  importTable: bool = false;\n  /** If true, exports the function table. */\n  exportTable: bool = false;\n  /** If true, generates information necessary for source maps. */\n  sourceMap: bool = false;\n  /** Unchecked behavior. Defaults to only using unchecked operations inside unchecked(). */\n  uncheckedBehavior: UncheckedBehavior = UncheckedBehavior.Default;\n  /** If given, exports the start function instead of calling it implicitly. */\n  exportStart: string | null = null;\n  /** Static memory start offset. */\n  memoryBase: u32 = 0;\n  /** Static table start offset. */\n  tableBase: u32 = 0;\n  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */\n  globalAliases: Map<string,string> | null = null;\n  /** Features to activate by default. These are the finished proposals. */\n  features: Feature = Feature.MutableGlobals\n                    | Feature.SignExtension\n                    | Feature.NontrappingF2I\n                    | Feature.BulkMemory;\n  /** If true, disallows unsafe features in user code. */\n  noUnsafe: bool = false;\n  /** If true, enables pedantic diagnostics. */\n  pedantic: bool = false;\n  /** Indicates a very low (<64k) memory limit. */\n  lowMemoryLimit: u32 = 0;\n  /** If true, exports the runtime helpers. */\n  exportRuntime: bool = false;\n  /** Stack size in bytes, if using a stack. */\n  stackSize: i32 = 0;\n  /** Semantic major bundle version from root package.json */\n  bundleMajorVersion: i32 = 0;\n  /** Semantic minor bundle version from root package.json */\n  bundleMinorVersion: i32 = 0;\n  /** Semantic patch bundle version from root package.json */\n  bundlePatchVersion: i32 = 0;\n\n  /** Hinted optimize level. Not applied by the compiler itself. */\n  optimizeLevelHint: i32 = 0;\n  /** Hinted shrink level. Not applied by the compiler itself. */\n  shrinkLevelHint: i32 = 0;\n  /** Hinted basename. */\n  basenameHint: string = \"output\";\n  /** Hinted bindings generation. */\n  bindingsHint: bool = false;\n\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\n  get isWasm64(): bool {\n    return this.target == Target.Wasm64;\n  }\n\n  /** Gets the unsigned size type matching the target. */\n  get usizeType(): Type {\n    return this.target == Target.Wasm64 ? Type.usize64 : Type.usize32;\n  }\n\n  /** Gets the signed size type matching the target. */\n  get isizeType(): Type {\n    return this.target == Target.Wasm64 ? Type.isize64 : Type.isize32;\n  }\n\n  /** Gets the size type reference matching the target. */\n  get sizeTypeRef(): TypeRef {\n    return this.target == Target.Wasm64 ? TypeRef.I64 : TypeRef.I32;\n  }\n\n  /** Gets if any optimizations will be performed. */\n  get willOptimize(): bool {\n    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;\n  }\n\n  /** Tests if a specific feature is activated. */\n  hasFeature(feature: Feature): bool {\n    return (this.features & feature) != 0;\n  }\n}\n\n/** Behaviors regarding unchecked operations. */\nexport const enum UncheckedBehavior {\n  /** Only use unchecked operations inside unchecked(). */\n  Default = 0,\n  /** Never use unchecked operations. */\n  Never = 1,\n  /** Always use unchecked operations if possible. */\n  Always = 2\n}\n\n/** Various constraints in expression compilation. */\nexport const enum Constraints {\n  None = 0,\n\n  /** Must implicitly convert to the target type. */\n  ConvImplicit = 1 << 0,\n  /** Must explicitly convert to the target type. */\n  ConvExplicit = 1 << 1,\n  /** Must wrap small integer values to match the target type. */\n  MustWrap = 1 << 2,\n\n  /** Indicates that the value will be dropped immediately. */\n  WillDrop = 1 << 3,\n  /** Indicates that static data is preferred. */\n  PreferStatic = 1 << 4,\n  /** Indicates that the value will become `this` of a property access or instance call. */\n  IsThis = 1 << 5\n}\n\n/** Runtime features to be activated by the compiler. */\nexport const enum RuntimeFeatures {\n  None = 0,\n  /** Requires data setup. */\n  Data = 1 << 0,\n  /** Requires a stack. */\n  Stack = 1 << 1,\n  /** Requires heap setup. */\n  Heap = 1 << 2,\n  /** Requires runtime type information setup. */\n  Rtti = 1 << 3,\n  /** Requires the built-in globals visitor. */\n  visitGlobals = 1 << 4,\n  /** Requires the built-in members visitor. */\n  visitMembers = 1 << 5,\n  /** Requires the setArgumentsLength export. */\n  setArgumentsLength = 1 << 6\n}\n\n/** Imported default names of compiler-generated elements. */\nexport namespace ImportNames {\n  /** Name of the default namespace */\n  export const DefaultNamespace = \"env\";\n  /** Name of the memory instance, if imported. */\n  export const Memory = \"memory\";\n  /** Name of the table instance, if imported. */\n  export const Table = \"table\";\n}\n\n/** Exported names of compiler-generated elements. */\nexport namespace ExportNames {\n  /** Name of the memory instance, if exported. */\n  export const Memory = \"memory\";\n  /** Name of the table instance, if exported. */\n  export const Table = \"table\";\n  /** Name of the argumentsLength varargs helper global. */\n  export const argumentsLength = \"__argumentsLength\";\n  /** Name of the alternative argumentsLength setter function. */\n  export const setArgumentsLength = \"__setArgumentsLength\";\n}\n\n/** Functions to export if `--exportRuntime` is set. */\nconst runtimeFunctions = [ \"__new\", \"__pin\", \"__unpin\", \"__collect\" ];\n/** Globals to export if `--exportRuntime` is set. */\nconst runtimeGlobals = [ \"__rtti_base\" ];\n\n/** Compiler interface. */\nexport class Compiler extends DiagnosticEmitter {\n\n  /** Program reference. */\n  program: Program;\n  /** Module instance being compiled. */\n  get module(): Module { return this.program.module; }\n  /** Provided options. */\n  get options(): Options { return this.program.options; }\n  /** Resolver reference. */\n  get resolver(): Resolver { return this.program.resolver; }\n\n  /** Current control flow. */\n  currentFlow: Flow;\n  /** Current parent element if not a function, i.e. an enum or namespace. */\n  currentParent: Element | null = null;\n  /** Current type in compilation. */\n  currentType: Type = Type.void;\n  /** Start function statements. */\n  currentBody: ExpressionRef[];\n  /** Counting memory offset. */\n  memoryOffset: i64;\n  /** Memory segments being compiled. */\n  memorySegments: MemorySegment[] = [];\n  /** Map of already compiled static string segments. */\n  stringSegments: Map<string,MemorySegment> = new Map();\n  /** Function table being compiled. First elem is blank. */\n  functionTable: Function[] = [];\n  /** Arguments length helper global. */\n  builtinArgumentsLength: GlobalRef = 0;\n  /** Requires runtime features. */\n  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.None;\n  /** Current inline functions stack. */\n  inlineStack: Function[] = [];\n  /** Lazily compiled functions. */\n  lazyFunctions: Set<Function> = new Set();\n  /** Pending instanceof helpers and their names. */\n  pendingInstanceOf: Map<DeclaredElement, string> = new Map();\n  /** Stubs to defer calls to overridden methods. */\n  overrideStubs: Set<Function> = new Set();\n  /** Elements currently undergoing compilation. */\n  pendingElements: Set<Element> = new Set();\n  /** Elements, that are module exports, already processed */\n  doneModuleExports: Set<Element> = new Set();\n  /** Shadow stack reference. */\n  shadowStack!: ShadowStackPass;\n  /** Whether the module has custom function exports. */\n  hasCustomFunctionExports: bool = false;\n  /** Whether the module would use the exported runtime to lift/lower. */\n  desiresExportRuntime: bool = false;\n\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\n  static compile(program: Program): Module {\n    return new Compiler(program).compile();\n  }\n\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\n  constructor(program: Program) {\n    super(program.diagnostics);\n    this.program = program;\n    let module = program.module;\n    let options = program.options;\n    if (options.memoryBase) {\n      this.memoryOffset = i64_new(options.memoryBase);\n      module.setLowMemoryUnused(false);\n    } else {\n      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {\n        this.memoryOffset = i64_new(1024);\n        module.setLowMemoryUnused(true);\n      } else {\n        this.memoryOffset = i64_new(8);\n        module.setLowMemoryUnused(false);\n      }\n    }\n    let featureFlags: FeatureFlags = 0;\n    if (options.hasFeature(Feature.SignExtension)) featureFlags |= FeatureFlags.SignExt;\n    if (options.hasFeature(Feature.MutableGlobals)) featureFlags |= FeatureFlags.MutableGlobals;\n    if (options.hasFeature(Feature.NontrappingF2I)) featureFlags |= FeatureFlags.TruncSat;\n    if (options.hasFeature(Feature.BulkMemory)) featureFlags |= FeatureFlags.BulkMemory;\n    if (options.hasFeature(Feature.Simd)) featureFlags |= FeatureFlags.SIMD;\n    if (options.hasFeature(Feature.Threads)) featureFlags |= FeatureFlags.Atomics;\n    if (options.hasFeature(Feature.ExceptionHandling)) featureFlags |= FeatureFlags.ExceptionHandling;\n    if (options.hasFeature(Feature.TailCalls)) featureFlags |= FeatureFlags.TailCall;\n    if (options.hasFeature(Feature.ReferenceTypes)) featureFlags |= FeatureFlags.ReferenceTypes;\n    if (options.hasFeature(Feature.MultiValue)) featureFlags |= FeatureFlags.MultiValue;\n    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;\n    if (options.hasFeature(Feature.Memory64)) featureFlags |= FeatureFlags.Memory64;\n    if (options.hasFeature(Feature.RelaxedSimd)) featureFlags |= FeatureFlags.RelaxedSIMD;\n    if (options.hasFeature(Feature.ExtendedConst)) featureFlags |= FeatureFlags.ExtendedConst;\n    if (options.hasFeature(Feature.Stringref)) featureFlags |= FeatureFlags.Stringref;\n    module.setFeatures(featureFlags);\n\n    // set up the main start function\n    let startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, Signature.create(program, [], Type.void));\n    startFunctionInstance.internalName = BuiltinNames.start;\n    this.currentFlow = startFunctionInstance.flow;\n    this.currentBody = new Array<ExpressionRef>();\n    this.shadowStack = new ShadowStackPass(this);\n  }\n\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\n  compile(): Module {\n    let options = this.options;\n    let module = this.module;\n    let program = this.program;\n    let resolver = this.resolver;\n    let hasShadowStack = options.stackSize > 0; // implies runtime=incremental\n\n    // initialize lookup maps, built-ins, imports, exports, etc.\n    this.program.initialize();\n\n    // obtain the main start function\n    let startFunctionInstance = this.currentFlow.targetFunction;\n    assert(startFunctionInstance.internalName == BuiltinNames.start);\n    let startFunctionBody = this.currentBody;\n    assert(startFunctionBody.length == 0);\n\n    // add mutable data, heap and rtti offset dummies\n    if (options.isWasm64) {\n      module.addGlobal(BuiltinNames.data_end,  TypeRef.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, true, module.i64(0));\n    } else {\n      module.addGlobal(BuiltinNames.data_end,  TypeRef.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, true, module.i32(0));\n    }\n\n    // compile entry file(s) while traversing reachable elements\n    let files = program.filesByName;\n    // TODO: for (let file of files.values()) {\n    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) {\n        this.compileFile(file);\n        this.compileModuleExports(file);\n      }\n    }\n\n    // compile and export runtime if requested or necessary\n    if (this.options.exportRuntime || (this.options.bindingsHint && this.desiresExportRuntime)) {\n      for (let i = 0, k = runtimeFunctions.length; i < k; ++i) {\n        let name = runtimeFunctions[i];\n        let instance = program.requireFunction(name);\n        if (this.compileFunction(instance) && !module.hasExport(name)) {\n          module.addFunctionExport(instance.internalName, name);\n        }\n      }\n      for (let i = 0, k = runtimeGlobals.length; i < k; ++i) {\n        let name = runtimeGlobals[i];\n        let instance = program.requireGlobal(name);\n        if (this.compileGlobal(instance) && !module.hasExport(name)) {\n          module.addGlobalExport(instance.internalName, name);\n        }\n      }\n    }\n\n    // compile lazy functions\n    let lazyFunctions = this.lazyFunctions;\n    do {\n      let functionsToCompile = new Array<Function>();\n      // TODO: for (let instance of lazyLibraryFunctions) {\n      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        functionsToCompile.push(instance);\n      }\n      lazyFunctions.clear();\n      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {\n        this.compileFunction(unchecked(functionsToCompile[i]), true);\n      }\n    } while (lazyFunctions.size);\n\n    // compile pending instanceof helpers\n    for (let _keys = Map_keys(this.pendingInstanceOf), i = 0, k = _keys.length; i < k; ++i) {\n      let elem = _keys[i];\n      let name = assert(this.pendingInstanceOf.get(elem));\n      switch (elem.kind) {\n        case ElementKind.Class:\n        case ElementKind.Interface: {\n          this.finalizeInstanceOf(<Class>elem, name);\n          break;\n        }\n        case ElementKind.ClassPrototype:\n        case ElementKind.InterfacePrototype: {\n          this.finalizeAnyInstanceOf(<ClassPrototype>elem, name);\n          break;\n        }\n        default: assert(false);\n      }\n    }\n\n    // set up override stubs\n    let functionTable = this.functionTable;\n    let overrideStubs = this.overrideStubs;\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      let instance = functionTable[i];\n      if (instance.is(CommonFlags.Overridden)) {\n        assert(instance.is(CommonFlags.Instance));\n        functionTable[i] = this.ensureOverrideStub(instance); // includes varargs stub\n      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {\n        functionTable[i] = this.ensureVarargsStub(instance);\n      }\n    }\n    let overrrideStubsSeen = new Set<Function>();\n    do {\n      // override stubs and overrides have cross-dependencies on each other, in that compiling\n      // either may discover the respective other. do this in a loop until no more are found.\n      resolver.discoveredOverride = false;\n      for (let _values = Set_values(overrideStubs), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        let overrideInstances = resolver.resolveOverrides(instance);\n        if (overrideInstances) {\n          for (let i = 0, k = overrideInstances.length; i < k; ++i) {\n            this.compileFunction(overrideInstances[i]);\n          }\n        }\n        overrrideStubsSeen.add(instance);\n      }\n    } while (overrideStubs.size > overrrideStubsSeen.size || resolver.discoveredOverride);\n    overrrideStubsSeen.clear();\n    for (let _values = Set_values(overrideStubs), i = 0, k = _values.length; i < k; ++i) {\n      this.finalizeOverrideStub(_values[i]);\n    }\n\n    // finalize runtime features\n    module.removeGlobal(BuiltinNames.rtti_base);\n    if (this.runtimeFeatures & RuntimeFeatures.Rtti) compileRTTI(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);\n\n    let memoryOffset = i64_align(this.memoryOffset, options.usizeType.byteSize);\n\n    // finalize data\n    module.removeGlobal(BuiltinNames.data_end);\n    if ((this.runtimeFeatures & RuntimeFeatures.Data) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize stack (grows down from __heap_base to __data_end)\n    module.removeGlobal(BuiltinNames.stack_pointer);\n    if ((this.runtimeFeatures & RuntimeFeatures.Stack) != 0 || hasShadowStack) {\n      memoryOffset = i64_align(\n        i64_add(memoryOffset, i64_new(options.stackSize)),\n        options.usizeType.byteSize\n      );\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I64, true,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I32, true,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize heap\n    module.removeGlobal(BuiltinNames.heap_base);\n    if ((this.runtimeFeatures & RuntimeFeatures.Heap) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // setup default memory & table\n    this.initDefaultMemory(memoryOffset);\n    this.initDefaultTable();\n\n    // expose the arguments length helper if there are varargs exports\n    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {\n      module.addFunction(BuiltinNames.setArgumentsLength, TypeRef.I32, TypeRef.None, null,\n        module.global_set(this.ensureArgumentsLength(), module.local_get(0, TypeRef.I32))\n      );\n      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);\n    }\n\n    // NOTE: no more element compiles from here. may go to the start function!\n\n    // compile the start function if not empty or if explicitly requested\n    let startIsEmpty = !startFunctionBody.length;\n    let exportStart = options.exportStart;\n    if (!startIsEmpty || exportStart != null) {\n      let signature = startFunctionInstance.signature;\n      if (!startIsEmpty && exportStart != null) {\n        module.addGlobal(BuiltinNames.started, TypeRef.I32, true, module.i32(0));\n        startFunctionBody.unshift(\n          module.global_set(BuiltinNames.started, module.i32(1))\n        );\n        startFunctionBody.unshift(\n          module.if(\n            module.global_get(BuiltinNames.started, TypeRef.I32),\n            module.return()\n          )\n        );\n      }\n      let funcRef = module.addFunction(\n        startFunctionInstance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(startFunctionInstance.getNonParameterLocalTypes()),\n        module.flatten(startFunctionBody)\n      );\n      startFunctionInstance.finalize(module, funcRef);\n      if (exportStart == null) module.setStart(funcRef);\n      else {\n        if (!isIdentifier(exportStart) || module.hasExport(exportStart)) {\n          this.error(\n            DiagnosticCode.Start_function_name_0_is_invalid_or_conflicts_with_another_export,\n            Source.native.range, exportStart\n          );\n        } else {\n          module.addFunctionExport(startFunctionInstance.internalName, exportStart);\n        }\n      }\n    }\n\n    // Run custom passes\n    if (hasShadowStack) {\n      this.shadowStack.walkModule();\n    }\n    if (program.lookup(\"ASC_RTRACE\") != null) {\n      new RtraceMemory(this).walkModule();\n    }\n\n    return module;\n  }\n\n  private initDefaultMemory(memoryOffset: i64): void {\n    this.memoryOffset = memoryOffset;\n\n    let options = this.options;\n    let module = this.module;\n    let memorySegments = this.memorySegments;\n\n    let initialPages: u32 = 0;\n    let maximumPages = Module.UNLIMITED_MEMORY;\n    let isSharedMemory = false;\n\n    if (options.memoryBase /* is specified */ || memorySegments.length) {\n      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));\n    }\n\n    if (options.initialMemory) {\n      if (options.initialMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        initialPages = options.initialMemory;\n      }\n    }\n\n    if (options.maximumMemory) {\n      if (options.maximumMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        maximumPages = options.maximumMemory;\n      }\n    }\n\n    if (options.sharedMemory) {\n      isSharedMemory = true;\n      if (!options.maximumMemory) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,\n          null\n        );\n        isSharedMemory = false;\n      }\n      if (!options.hasFeature(Feature.Threads)) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,\n          null\n        );\n        isSharedMemory = false;\n      }\n    }\n\n    // check that we didn't exceed lowMemoryLimit already\n    let lowMemoryLimit32 = options.lowMemoryLimit;\n    if (lowMemoryLimit32) {\n      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);\n      if (i64_gt(memoryOffset, lowMemoryLimit)) {\n        this.error(\n          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,\n          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)\n        );\n      }\n    }\n\n    // Setup internal memory with default name \"0\"\n    module.setMemory(\n      initialPages,\n      maximumPages,\n      memorySegments,\n      options.target,\n      options.exportMemory ? ExportNames.Memory : null,\n      CommonNames.DefaultMemory,\n      isSharedMemory\n    );\n\n    // import memory if requested (default memory is named '0' by Binaryen)\n    if (options.importMemory) {\n      module.addMemoryImport(\n        CommonNames.DefaultMemory,\n        ImportNames.DefaultNamespace,\n        ImportNames.Memory,\n        isSharedMemory\n      );\n    }\n  }\n\n  private initDefaultTable(): void {\n    let options = this.options;\n    let module = this.module;\n\n    // import and/or export table if requested (default table is named '0' by Binaryen)\n    if (options.importTable) {\n      module.addTableImport(\n        CommonNames.DefaultTable,\n        ImportNames.DefaultNamespace,\n        ImportNames.Table\n      );\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n    if (options.exportTable) {\n      module.addTableExport(CommonNames.DefaultTable, ExportNames.Table);\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n\n    // set up function table (first elem is blank)\n    let tableBase = options.tableBase;\n    if (!tableBase) tableBase = 1; // leave first elem blank\n    let functionTable = this.functionTable;\n    let functionTableNames = new Array<string>(functionTable.length);\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      functionTableNames[i] = functionTable[i].internalName;\n    }\n\n    let initialTableSize = <Index>tableBase + functionTable.length;\n    let maximumTableSize = Module.UNLIMITED_TABLE;\n\n    if (!(options.importTable || options.exportTable)) {\n      // use fixed size for non-imported and non-exported tables\n      maximumTableSize = initialTableSize;\n      if (options.willOptimize) {\n        // Hint for directize pass which indicate table's content will not change\n        // and can be better optimized\n        module.setPassArgument(\"directize-initial-contents-immutable\", \"true\");\n      }\n    }\n    module.addFunctionTable(\n      CommonNames.DefaultTable,\n      initialTableSize,\n      maximumTableSize,\n      functionTableNames,\n      module.i32(tableBase)\n    );\n  }\n\n  // === Exports ==================================================================================\n\n  /** Compiles the respective module exports for the specified entry file. */\n  private compileModuleExports(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let [elementName, element] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let elementName = unchecked(_keys[i]);\n        let element = assert(exports.get(elementName));\n        this.compileModuleExport(elementName, element);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar)  {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.compileModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Compiles the respective module export(s) for the specified element. */\n  private compileModuleExport(name: string, element: DeclaredElement, prefix: string = \"\"): void {\n    let module = this.module;\n    switch (element.kind) {\n      case ElementKind.FunctionPrototype: {\n        // obtain the default instance\n        let functionPrototype = <FunctionPrototype>element;\n        if (!functionPrototype.is(CommonFlags.Generic)) {\n          let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n          if (functionInstance) {\n            this.compileModuleExport(name, functionInstance, prefix);\n          }\n          return;\n        }\n        break;\n      }\n      case ElementKind.Function: {\n        let functionInstance = <Function>element;\n        if (!functionInstance.hasDecorator(DecoratorFlags.Builtin)) {\n          let signature = functionInstance.signature;\n          if (signature.requiredParameters < signature.parameterTypes.length) {\n            // utilize varargs stub to fill in omitted arguments\n            functionInstance = this.ensureVarargsStub(functionInstance);\n            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;\n          }\n          this.compileFunction(functionInstance);\n          if (functionInstance.is(CommonFlags.Compiled)) {\n            let exportName = prefix + name;\n            if (!module.hasExport(exportName)) {\n              module.addFunctionExport(functionInstance.internalName, exportName);\n              this.hasCustomFunctionExports = true;\n              let hasManagedOperands = signature.hasManagedOperands;\n              if (hasManagedOperands) {\n                this.shadowStack.noteExport(exportName, signature.getManagedOperandIndices());\n              }\n              if (!this.desiresExportRuntime) {\n                let thisType = signature.thisType;\n                if (\n                  thisType && lowerRequiresExportRuntime(thisType) ||\n                  liftRequiresExportRuntime(signature.returnType)\n                ) {\n                  this.desiresExportRuntime = true;\n                } else {\n                  let parameterTypes = signature.parameterTypes;\n                  for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n                    if (lowerRequiresExportRuntime(parameterTypes[i])) {\n                      this.desiresExportRuntime = true;\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n            return;\n          }\n        }\n        break;\n      }\n      case ElementKind.Global: {\n        let global = <Global>element;\n        let isConst = global.is(CommonFlags.Const) || global.is(CommonFlags.Static | CommonFlags.Readonly);\n        if (!isConst && !this.options.hasFeature(Feature.MutableGlobals)) {\n          this.warning(\n            DiagnosticCode.Feature_0_is_not_enabled,\n            global.identifierNode.range, \"mutable-globals\"\n          );\n          return;\n        }\n        this.compileGlobal(global);\n        if (global.is(CommonFlags.Compiled)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n            if (!this.desiresExportRuntime) {\n              let type = global.type;\n              if (\n                liftRequiresExportRuntime(type) ||\n                !global.is(CommonFlags.Const) && lowerRequiresExportRuntime(type)\n              ) {\n                this.desiresExportRuntime = true;\n              }\n            }\n          }\n          if (global.type == Type.v128) {\n            this.warning(\n              DiagnosticCode.Exchange_of_0_values_is_not_supported_by_all_embeddings,\n              global.typeNode\n                ? assert(global.typeNode).range\n                : global.identifierNode.range,\n              \"v128\"\n            );\n          }\n          return;\n        }\n        break;\n      }\n      case ElementKind.Enum: {\n        this.compileEnum(<Enum>element);\n        let members = element.members;\n        if (members) {\n          let subPrefix = prefix + name + STATIC_DELIMITER;\n          for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let member = assert(members.get(memberName));\n            if (!member.is(CommonFlags.Private)) {\n              this.compileModuleExport(memberName, member, subPrefix);\n            }\n          }\n        }\n        return;\n      }\n      case ElementKind.EnumValue: {\n        let enumValue = <EnumValue>element;\n        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MutableGlobals)) {\n          this.error(\n            DiagnosticCode.Feature_0_is_not_enabled,\n            enumValue.identifierNode.range, \"mutable-globals\"\n          );\n          return;\n        }\n        if (enumValue.is(CommonFlags.Compiled)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n          }\n          return;\n        }\n        break;\n      }\n    }\n    this.warning(\n      DiagnosticCode.Only_variables_functions_and_enums_become_WebAssembly_module_exports,\n      element.identifierNode.range\n    );\n  }\n\n  // files\n\n  /** Compiles the file matching the specified path. */\n  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\n    let file: File;\n    let filesByName = this.program.filesByName;\n    let pathWithIndex: string;\n    if (filesByName.has(normalizedPathWithoutExtension)) {\n      file = assert(filesByName.get(normalizedPathWithoutExtension));\n    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {\n      file = assert(filesByName.get(pathWithIndex));\n    } else {\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        reportNode.range, normalizedPathWithoutExtension\n      );\n      return;\n    }\n    this.compileFile(file);\n  }\n\n  /** Compiles the specified file. */\n  compileFile(file: File): void {\n    if (file.is(CommonFlags.Compiled)) return;\n    file.set(CommonFlags.Compiled);\n\n    // compile top-level statements within the file's start function\n    let startFunction = file.startFunction;\n    let startSignature = startFunction.signature;\n    let previousBody = this.currentBody;\n    let startFunctionBody = new Array<ExpressionRef>();\n    this.currentBody = startFunctionBody;\n\n    // compile top-level statements\n    let previousFlow = this.currentFlow;\n    let flow = startFunction.flow;\n    this.currentFlow = flow;\n    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {\n      this.compileTopLevelStatement(statements[i], startFunctionBody);\n    }\n    // no need to insert unreachable since last statement should have done that\n    this.currentFlow = previousFlow;\n    this.currentBody = previousBody;\n\n    // if top-level statements are present, make the per-file start function and call it in start\n    if (startFunctionBody.length) {\n      let module = this.module;\n      let locals = startFunction.localsByIndex;\n      let numLocals = locals.length;\n      let varTypes = new Array<TypeRef>(numLocals);\n      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toRef();\n      const funcRef = module.addFunction(\n        startFunction.internalName,\n        startSignature.paramRefs,\n        startSignature.resultRefs,\n        varTypes,\n        module.flatten(startFunctionBody)\n      );\n      startFunction.finalize(module, funcRef);\n      previousBody.push(\n        module.call(startFunction.internalName, null, TypeRef.None)\n      );\n    }\n  }\n\n  // === Globals ==================================================================================\n\n  /** Compiles a global variable. */\n  compileGlobal(global: Global): bool {\n    if (global.is(CommonFlags.Compiled)) return !global.is(CommonFlags.Errored);\n    global.set(CommonFlags.Compiled);\n\n    let pendingElements = this.pendingElements;\n    pendingElements.add(global);\n\n    let module = this.module;\n    let initExpr: ExpressionRef = 0;\n    let typeNode = global.typeNode;\n    let initializerNode = global.initializerNode;\n\n    if (!global.is(CommonFlags.Resolved)) {\n\n      // Resolve type if annotated\n      if (typeNode) {\n        let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports\n        if (!resolvedType) {\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        if (resolvedType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(resolvedType);\n        this.program.checkTypeSupported(resolvedType, typeNode);\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, Type.auto, // reports\n          Constraints.MustWrap | Constraints.PreferStatic\n        );\n        this.currentFlow = previousFlow;\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            initializerNode.range, this.currentType.toString(), \"<auto>\"\n          );\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(this.currentType);\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          global.identifierNode.range.atEnd\n        );\n        global.set(CommonFlags.Errored);\n        pendingElements.delete(global);\n        return false;\n      }\n    }\n\n    // Handle ambient builtins like '__heap_base' that need to be resolved but are added explicitly\n    if (global.is(CommonFlags.Ambient) && global.hasDecorator(DecoratorFlags.Builtin)) {\n      let internalName = global.internalName;\n      if (internalName == BuiltinNames.data_end) this.runtimeFeatures |= RuntimeFeatures.Data;\n      else if (internalName == BuiltinNames.stack_pointer) this.runtimeFeatures |= RuntimeFeatures.Stack;\n      else if (internalName == BuiltinNames.heap_base) this.runtimeFeatures |= RuntimeFeatures.Heap;\n      else if (internalName == BuiltinNames.rtti_base) this.runtimeFeatures |= RuntimeFeatures.Rtti;\n      pendingElements.delete(global);\n      return true;\n    }\n\n    let type = global.type;\n\n    // Enforce either an initializer, a definitive assignment or a nullable type\n    // to guarantee soundness when globals are accessed. In the absence of an\n    // initializer, a definitive assignment guarantees a runtime check, whereas\n    // a nullable type guarantees that obtaining default `null` is OK. Avoids:\n    //\n    //   let foo: string;\n    //   function bar() {\n    //     foo.length; // no error in TS even though undefined\n    //   }\n    //   bar();\n    if (\n      !initializerNode && !global.is(CommonFlags.DefinitelyAssigned) &&\n      type.isReference && !type.isNullableReference\n    ) {\n      this.error(\n        DiagnosticCode.Initializer_definitive_assignment_or_nullable_type_expected,\n        global.identifierNode.range\n      );\n    }\n\n    let typeRef = type.toRef();\n    let isDeclaredConstant = global.is(CommonFlags.Const) || global.is(CommonFlags.Static | CommonFlags.Readonly);\n    let isDeclaredInline = global.hasDecorator(DecoratorFlags.Inline);\n\n    // Handle imports\n    if (global.is(CommonFlags.Ambient)) {\n\n      // Constant global or mutable globals enabled\n      if (isDeclaredConstant || this.options.hasFeature(Feature.MutableGlobals)) {\n        mangleImportName(global, global.declaration);\n        this.program.markModuleImport(mangleImportName_moduleName, mangleImportName_elementName, global);\n        module.addGlobalImport(\n          global.internalName,\n          mangleImportName_moduleName,\n          mangleImportName_elementName,\n          typeRef,\n          !isDeclaredConstant\n        );\n        pendingElements.delete(global);\n        if (!this.desiresExportRuntime && lowerRequiresExportRuntime(type)) {\n          this.desiresExportRuntime = true;\n        }\n        return true;\n      }\n\n      // Importing mutable globals is not supported in the MVP\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        global.declaration.range, \"mutable-globals\"\n      );\n      global.set(CommonFlags.Errored);\n      pendingElements.delete(global);\n      return false;\n    }\n\n    // The MVP does not yet support initializer expressions other than constants and gets of\n    // imported immutable globals, hence such initializations must be performed in the start.\n    let initializeInStart = false;\n\n    // Evaluate initializer if present\n    if (initializerNode) {\n      if (!initExpr) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, type,\n          Constraints.ConvImplicit | Constraints.MustWrap | Constraints.PreferStatic\n        );\n        this.currentFlow = previousFlow;\n      }\n\n      // If not a constant expression, attempt to precompute\n      if (!module.isConstExpression(initExpr)) {\n        if (isDeclaredConstant) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp;\n          } else {\n            initializeInStart = true;\n          }\n        } else {\n          initializeInStart = true;\n        }\n      }\n\n      // Handle special case of initializing from imported immutable global\n      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {\n        let fromName = assert(getGlobalGetName(initExpr));\n        if (!isGlobalMutable(module.getGlobal(fromName))) {\n          let elementsByName = this.program.elementsByName;\n          if (elementsByName.has(fromName)) {\n            let global = assert(elementsByName.get(fromName));\n            if (global.is(CommonFlags.Ambient)) initializeInStart = false;\n          }\n        }\n      }\n\n      // Explicitly inline if annotated\n      if (isDeclaredInline) {\n        if (initializeInStart) {\n          this.warning(\n            DiagnosticCode.Mutable_value_cannot_be_inlined,\n            initializerNode.range\n          );\n        } else {\n          assert(getExpressionId(initExpr) == ExpressionId.Const);\n          let exprType = getExpressionType(initExpr);\n          switch (<u32>exprType) {\n            case <u32>TypeRef.I32: {\n              global.constantValueKind = ConstantValueKind.Integer;\n              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);\n              break;\n            }\n            case <u32>TypeRef.I64: {\n              global.constantValueKind = ConstantValueKind.Integer;\n              global.constantIntegerValue = i64_new(\n                getConstValueI64Low(initExpr),\n                getConstValueI64High(initExpr)\n              );\n              break;\n            }\n            case <u32>TypeRef.F32: {\n              global.constantValueKind = ConstantValueKind.Float;\n              global.constantFloatValue = getConstValueF32(initExpr);\n              break;\n            }\n            case <u32>TypeRef.F64: {\n              global.constantValueKind = ConstantValueKind.Float;\n              global.constantFloatValue = getConstValueF64(initExpr);\n              break;\n            }\n            default: {\n              assert(false);\n              global.set(CommonFlags.Errored);\n              pendingElements.delete(global);\n              return false;\n            }\n          }\n          global.set(CommonFlags.Inlined); // inline the value from now on\n        }\n      }\n\n    // Initialize to zero if there's no initializer\n    } else {\n      if (global.is(CommonFlags.Inlined)) {\n        initExpr = this.compileInlineConstant(global, global.type, Constraints.PreferStatic);\n      } else {\n        initExpr = this.makeZero(type);\n      }\n    }\n\n    let internalName = global.internalName;\n\n    if (initializeInStart) { // initialize to mutable zero and set the actual value in start\n      if (isDeclaredInline) {\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          findDecorator(DecoratorKind.Inline, global.decoratorNodes)!.range, \"inline\"\n        );\n      }\n      module.addGlobal(internalName, typeRef, true, this.makeZero(type));\n      this.currentBody.push(\n        module.global_set(internalName, initExpr)\n      );\n    } else if (!isDeclaredInline) { // compile normally\n      module.addGlobal(internalName, typeRef, !isDeclaredConstant, initExpr);\n    }\n    pendingElements.delete(global);\n    return true;\n  }\n\n  // === Enums ====================================================================================\n\n  /** Compiles an enum. */\n  compileEnum(element: Enum): bool {\n    if (element.is(CommonFlags.Compiled)) return !element.is(CommonFlags.Errored);\n    element.set(CommonFlags.Compiled);\n\n    let pendingElements = this.pendingElements;\n    pendingElements.add(element);\n\n    let module = this.module;\n    let previousParent = this.currentParent;\n    this.currentParent = element;\n    let previousValue: EnumValue | null = null;\n    let previousValueIsMut = false;\n    let isInline = element.is(CommonFlags.Const) || element.hasDecorator(DecoratorFlags.Inline);\n\n    let members = element.members;\n    if (members) {\n      // TODO: for (let member of element.members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.EnumValue) continue; // happens if an enum is also a namespace\n        let initInStart = false;\n        let enumValue = <EnumValue>member;\n        let valueNode = enumValue.valueNode;\n        enumValue.set(CommonFlags.Compiled);\n        let previousFlow = this.currentFlow;\n        if (element.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = element.file.startFunction.flow;\n        }\n        let initExpr: ExpressionRef;\n        if (valueNode) {\n          initExpr = this.compileExpression(valueNode, Type.i32,\n            Constraints.ConvImplicit\n          );\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.Const)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  valueNode.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        } else if (previousValue == null) {\n          initExpr = module.i32(0);\n        } else {\n          if (previousValueIsMut) {\n            this.error(\n              DiagnosticCode.Enum_member_must_have_initializer,\n              enumValue.identifierNode.range.atEnd\n            );\n          }\n          if (isInline) {\n            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));\n            assert(!i64_high(value));\n            initExpr = module.i32(i64_low(value));\n          } else {\n            initExpr = module.binary(BinaryOp.AddI32,\n              module.global_get(previousValue.internalName, TypeRef.I32),\n              module.i32(1)\n            );\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.Const)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  member.declaration.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        }\n        this.currentFlow = previousFlow;\n        if (initInStart) {\n          module.addGlobal(enumValue.internalName, TypeRef.I32, true, module.i32(0));\n          this.currentBody.push(\n            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)\n          );\n          previousValueIsMut = true;\n        } else {\n          if (isInline) {\n            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);\n            if (enumValue.is(CommonFlags.ModuleExport)) {\n              module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n            }\n          } else {\n            module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n          }\n          enumValue.isImmutable = true;\n          previousValueIsMut = false;\n        }\n        previousValue = enumValue;\n      }\n    }\n    this.currentParent = previousParent;\n    pendingElements.delete(element);\n    return true;\n  }\n\n  // === Functions ================================================================================\n\n  /** Compiles a priorly resolved function. */\n  compileFunction(\n    /** Function to compile. */\n    instance: Function,\n    /** Force compilation of stdlib alternative if a builtin. */\n    forceStdAlternative: bool = false\n  ): bool {\n    if (instance.is(CommonFlags.Compiled)) return !instance.is(CommonFlags.Errored);\n\n    if (!forceStdAlternative) {\n      if (instance.hasDecorator(DecoratorFlags.Builtin)) return true;\n      if (instance.hasDecorator(DecoratorFlags.Lazy)) {\n        this.lazyFunctions.add(instance);\n        return true;\n      }\n    }\n\n    // ensure the function has no duplicate parameters\n    let parameters = instance.prototype.functionTypeNode.parameters;\n    let numParameters = parameters.length;\n    if (numParameters >= 2) {\n      let visited = new Set<string>();\n      visited.add(parameters[0].name.text);\n      for (let i = 1; i < numParameters; i++) {\n        let paramIdentifier = parameters[i].name;\n        let paramName = paramIdentifier.text;\n        if (!visited.has(paramName)) {\n          visited.add(paramName);\n        } else {\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            paramIdentifier.range, paramName\n          );\n        }\n      }\n    }\n\n    instance.set(CommonFlags.Compiled);\n    let pendingElements = this.pendingElements;\n    pendingElements.add(instance);\n\n    let previousType = this.currentType;\n    let module = this.module;\n    let signature = instance.signature;\n    let bodyNode = instance.prototype.bodyNode;\n    let declarationNode = instance.declaration;\n    assert(declarationNode.kind == NodeKind.FunctionDeclaration || declarationNode.kind == NodeKind.MethodDeclaration);\n    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);\n\n    let funcRef: FunctionRef = 0;\n\n    // concrete function\n    if (bodyNode) {\n\n      // must not be ambient\n      if (instance.is(CommonFlags.Ambient)) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          instance.identifierNode.range\n        );\n      }\n\n      // cannot have an annotated external name or code\n      if (instance.hasAnyDecorator(DecoratorFlags.External | DecoratorFlags.ExternalJs)) {\n        let decoratorNodes = instance.decoratorNodes;\n        let decorator: DecoratorNode | null;\n        if (decorator = findDecorator(DecoratorKind.External, decoratorNodes)) {\n          this.error(\n            DiagnosticCode.Decorator_0_is_not_valid_here,\n            decorator.range, \"external\"\n          );\n        }\n        if (decorator = findDecorator(DecoratorKind.ExternalJs, decoratorNodes)) {\n          this.error(\n            DiagnosticCode.Decorator_0_is_not_valid_here,\n            decorator.range, \"external.js\"\n          );\n        }\n      }\n\n      // compile body in this function's context\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n      let stmts = new Array<ExpressionRef>();\n\n      if (!this.compileFunctionBody(instance, stmts)) {\n        stmts.push(module.unreachable());\n      }\n\n      this.currentFlow = previousFlow;\n\n      // create the function\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(instance.getNonParameterLocalTypes()),\n        module.flatten(stmts, instance.signature.returnType.toRef())\n      );\n\n    // imported function\n    } else if (instance.is(CommonFlags.Ambient)) {\n      mangleImportName(instance, declarationNode); // TODO: check for duplicates\n      this.program.markModuleImport(mangleImportName_moduleName, mangleImportName_elementName, instance);\n      module.addFunctionImport(\n        instance.internalName,\n        mangleImportName_moduleName,\n        mangleImportName_elementName,\n        signature.paramRefs,\n        signature.resultRefs\n      );\n      funcRef = module.getFunction(instance.internalName);\n      if (!this.desiresExportRuntime) {\n        let thisType = signature.thisType;\n        if (\n          thisType && liftRequiresExportRuntime(thisType) ||\n          lowerRequiresExportRuntime(signature.returnType)\n        ) {\n          this.desiresExportRuntime = true;\n        } else {\n          let parameterTypes = signature.parameterTypes;\n          for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n            if (liftRequiresExportRuntime(parameterTypes[i])) {\n              this.desiresExportRuntime = true;\n              break;\n            }\n          }\n        }\n      }\n\n    // abstract or interface function\n    } else if (instance.is(CommonFlags.Abstract) || instance.parent.kind == ElementKind.Interface) {\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        null,\n        module.unreachable()\n      );\n\n    } else {\n      // built-in field accessor?\n      if (instance.isAny(CommonFlags.Get | CommonFlags.Set)) {\n        let propertyName = instance.declaration.name.text;\n        let propertyParent = assert(instance.parent.getMember(propertyName));\n        assert(propertyParent.kind == ElementKind.PropertyPrototype);\n        let propertyInstance = (<PropertyPrototype>propertyParent).instance;\n        if (propertyInstance && propertyInstance.isField) {\n          funcRef = instance.is(CommonFlags.Get)\n            ? this.makeBuiltinFieldGetter(propertyInstance)\n            : this.makeBuiltinFieldSetter(propertyInstance);\n          assert(instance.is(CommonFlags.Compiled));\n        }\n      }\n      if (!funcRef) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          instance.identifierNode.range\n        );\n        instance.set(CommonFlags.Errored);\n      }\n    }\n\n    if (instance.is(CommonFlags.Ambient) || instance.is(CommonFlags.Export)) {\n      // Verify and print warn if signature has v128 type for imported or exported functions\n      let hasVectorValueOperands = signature.hasVectorValueOperands;\n      if (hasVectorValueOperands) {\n        let range: Range;\n        let fnTypeNode = instance.prototype.functionTypeNode;\n        if (signature.returnType == Type.v128) {\n          range = fnTypeNode.returnType.range;\n        } else {\n          let firstIndex = signature.getVectorValueOperandIndices()[0];\n          range = fnTypeNode.parameters[firstIndex].range;\n        }\n        this.warning(\n          DiagnosticCode.Exchange_of_0_values_is_not_supported_by_all_embeddings,\n          range, \"v128\"\n        );\n      }\n    }\n\n    instance.finalize(module, funcRef);\n    this.currentType = previousType;\n    pendingElements.delete(instance);\n    return true;\n  }\n\n  /** Compiles the body of a function within the specified flow. */\n  private compileFunctionBody(\n    /** Function to compile. */\n    instance: Function,\n    /** Target array of statements also being returned. Creates a new array if omitted. */\n    stmts: ExpressionRef[]\n  ): bool {\n    let module = this.module;\n    let bodyNode = assert(instance.prototype.bodyNode);\n    let returnType = instance.signature.returnType;\n    let flow = this.currentFlow;\n    let thisLocal = instance.signature.thisType\n      ? assert(flow.lookupLocal(CommonNames.this_))\n      : null;\n    let bodyStartIndex = stmts.length;\n\n    // compile statements\n    if (bodyNode.kind == NodeKind.Block) {\n      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, stmts);\n    } else {\n      // must be an expression statement if not a block\n      assert(bodyNode.kind == NodeKind.Expression);\n\n      // must be an arrow function\n      assert(instance.prototype.arrowKind);\n\n      // none of the following can be an arrow function\n      assert(!instance.isAny(CommonFlags.Constructor | CommonFlags.Get | CommonFlags.Set));\n\n      let expr = this.compileExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.ConvImplicit);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n\n      if (!stmts) stmts = [ expr ];\n      else stmts.push(expr);\n\n      if (!flow.is(FlowFlags.Terminates)) {\n        if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n        if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n        flow.set(FlowFlags.Returns | FlowFlags.Terminates);\n      }\n    }\n\n    // Make constructors return their instance pointer, and prepend a conditional\n    // allocation if any code path accesses `this`.\n    if (instance.is(CommonFlags.Constructor)) {\n      assert(instance.is(CommonFlags.Instance));\n      thisLocal = assert(thisLocal);\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n\n      if (flow.isAny(FlowFlags.AccessesThis | FlowFlags.ConditionallyAccessesThis) || !flow.is(FlowFlags.Terminates)) {\n\n        // Allocate `this` if not a super call, and initialize fields\n        let allocStmts = new Array<ExpressionRef>();\n        allocStmts.push(\n          this.makeConditionalAllocation(classInstance, thisLocal.index)\n        );\n        this.makeFieldInitializationInConstructor(classInstance, allocStmts);\n\n        // Insert right before the body\n        for (let i = stmts.length - 1; i >= bodyStartIndex; --i) {\n          stmts[i + 1] = stmts[i];\n        }\n        stmts[bodyStartIndex] = module.flatten(allocStmts, TypeRef.None);\n\n        // Just prepended allocation is dropped when returning non-'this'\n        if (flow.is(FlowFlags.MayReturnNonThis)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,\n              instance.identifierNode.range\n            );\n          }\n        }\n      }\n\n      // Returning something else than 'this' would break 'super()' calls\n      if (flow.is(FlowFlags.MayReturnNonThis) && !classInstance.hasDecorator(DecoratorFlags.Final)) {\n        this.error(\n          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,\n          classInstance.identifierNode.range\n        );\n      }\n\n      // Implicitly return `this` if the flow falls through\n      if (!flow.is(FlowFlags.Terminates)) {\n        stmts.push(\n          module.local_get(thisLocal.index, this.options.sizeTypeRef)\n        );\n        flow.set(FlowFlags.Returns | FlowFlags.ReturnsNonNull | FlowFlags.Terminates);\n      }\n\n      // check that super has been called if this is a derived class\n      if (classInstance.base && !classInstance.prototype.implicitlyExtendsObject && !flow.is(FlowFlags.CallsSuper)) {\n        this.error(\n          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,\n          instance.prototype.declaration.range\n        );\n      }\n\n    // if this is a normal function, make sure that all branches terminate\n    } else if (returnType != Type.void && !flow.is(FlowFlags.Terminates)) {\n      this.error(\n        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\n        instance.prototype.functionTypeNode.returnType.range\n      );\n      return false; // not recoverable\n    }\n\n    return true;\n  }\n\n  /** Makes a built-in getter of a property that is a field. */\n  private makeBuiltinFieldGetter(property: Property): FunctionRef {\n    let getterInstance = assert(property.getterInstance);\n    let module = this.module;\n    let valueType = property.type;\n    let valueTypeRef = valueType.toRef();\n    let thisTypeRef = this.options.sizeTypeRef;\n    getterInstance.set(CommonFlags.Compiled);\n    let body = module.load(valueType.byteSize, valueType.isSignedIntegerValue,\n      module.local_get(0, thisTypeRef),\n      valueTypeRef, property.memoryOffset\n    );\n    let flowBefore = this.currentFlow;\n    let flow = getterInstance.flow;\n    this.currentFlow = flow;\n    if (property.is(CommonFlags.DefinitelyAssigned) && valueType.isReference && !valueType.isNullableReference) {\n      body = this.makeRuntimeNonNullCheck(body, valueType, getterInstance.identifierNode);\n    }\n    this.currentFlow = flowBefore;\n    return module.addFunction(\n      getterInstance.internalName,\n      thisTypeRef,\n      valueTypeRef,\n      typesToRefs(getterInstance.getNonParameterLocalTypes()),\n      body\n    );\n  }\n\n  /** Makes a built-in setter of a property that is a field. */\n  private makeBuiltinFieldSetter(property: Property): FunctionRef {\n    let setterInstance = assert(property.setterInstance);\n    let module = this.module;\n    let valueType = property.type;\n    let thisTypeRef = this.options.sizeTypeRef;\n    let valueTypeRef = valueType.toRef();\n    // void(this.field = value)\n    let bodyExpr = module.store(valueType.byteSize,\n      module.local_get(0, thisTypeRef),\n      module.local_get(1, valueTypeRef),\n      valueTypeRef, property.memoryOffset\n    );\n    if (valueType.isManaged) {\n      let parent = setterInstance.parent;\n      assert(parent.kind == ElementKind.Class);\n      if ((<Class>parent).type.isManaged) {\n        let linkInstance = this.program.linkInstance;\n        this.compileFunction(linkInstance);\n        bodyExpr = module.block(null, [\n          bodyExpr,\n          module.call(linkInstance.internalName, [\n            module.local_get(0, thisTypeRef),\n            module.local_get(1, valueTypeRef),\n            module.i32(0)\n          ], TypeRef.None)\n        ], TypeRef.None);\n      }\n    }\n    setterInstance.set(CommonFlags.Compiled);\n    return module.addFunction(\n      setterInstance.internalName,\n      createType([ thisTypeRef, valueTypeRef ]),\n      TypeRef.None,\n      null,\n      bodyExpr\n    );\n  }\n\n  // === Memory ===================================================================================\n\n  /** Adds a static memory segment with the specified data. */\n  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {\n    assert(isPowerOf2(alignment));\n    let memoryOffset = i64_align(this.memoryOffset, alignment);\n    let segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Adds a static memory segment representing a runtime object. */\n  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {\n    let memoryOffset = this.program.computeBlockStart64(this.memoryOffset);\n    let segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer expression. Deduplicates. */\n  ensureStaticString(stringValue: string): ExpressionRef {\n    let ptr = this.ensureStaticStringPtr(stringValue);\n    this.currentType = this.program.stringInstance.type;\n    return this.module.usize(ptr);\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */\n  ensureStaticStringPtr(stringValue: string): i64 {\n    let program = this.program;\n    let totalOverhead = program.totalOverhead;\n    let stringInstance = assert(program.stringInstance);\n    let stringSegment: MemorySegment;\n    let segments = this.stringSegments;\n    if (segments.has(stringValue)) {\n      stringSegment = assert(segments.get(stringValue)); // reuse\n    } else {\n      let len = stringValue.length;\n      let buf = stringInstance.createBuffer(len << 1);\n      for (let i = 0; i < len; ++i) {\n        writeI16(stringValue.charCodeAt(i), buf, totalOverhead + (i << 1));\n      }\n      stringSegment = this.addRuntimeMemorySegment(buf);\n      segments.set(stringValue, stringSegment);\n    }\n    return i64_add(stringSegment.offset, i64_new(totalOverhead));\n  }\n\n  /** Writes a series of static values of the specified type to a buffer. */\n  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {\n    let length = values.length;\n    let byteSize = elementType.byteSize;\n    let elementTypeRef = elementType.toRef();\n    switch (<u32>elementTypeRef) {\n      case <u32>TypeRef.I32: {\n        switch (byteSize) {\n          case 1: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI8(getConstValueI32(value), buf, pos);\n              pos += 1;\n            }\n            break;\n          }\n          case 2: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI16(getConstValueI32(value), buf, pos);\n              pos += 2;\n            }\n            break;\n          }\n          case 4: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI32(getConstValueI32(value), buf, pos);\n              pos += 4;\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF32(getConstValueF32(value), buf, pos);\n          pos += 4;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF64(getConstValueF64(value), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.V128: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeV128(getConstValueV128(value), buf, pos);\n          pos += 16;\n        }\n        break;\n      }\n      case <u32>TypeRef.None: {\n        // nothing to write\n        break;\n      }\n      default: assert(false);\n    }\n    return pos;\n  }\n\n  /** Adds a buffer to static memory and returns the created segment. */\n  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {\n    let program = this.program;\n    let arrayBufferInstance = program.arrayBufferInstance;\n    let buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);\n    this.program.OBJECTInstance.writeField(\"rtId\", id, buf, 0); // use specified rtId\n    this.writeStaticBuffer(buf, program.totalOverhead, elementType, values);\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  /** Adds an array header to static memory and returns the created segment. */\n  private addStaticArrayHeader(\n    elementType: Type,\n    bufferSegment: MemorySegment,\n    /** Optional array instance override. */\n    arrayInstance: Class | null = null\n  ): MemorySegment {\n    let program = this.program;\n    if (!arrayInstance) {\n      arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ elementType ]));\n    }\n    let bufferLength = readI32(bufferSegment.buffer, program.OBJECTInstance.offsetof(\"rtSize\"));\n    let arrayLength = i32(bufferLength / elementType.byteSize);\n    let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n    let buf = arrayInstance.createBuffer();\n    assert(arrayInstance.writeField(\"buffer\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"dataStart\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"byteLength\", bufferLength, buf));\n    assert(arrayInstance.writeField(\"length_\", arrayLength, buf));\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  // === Table ====================================================================================\n\n  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */\n  ensureRuntimeFunction(instance: Function): i64 {\n    assert(instance.is(CommonFlags.Compiled) && !instance.is(CommonFlags.Stub));\n    let program = this.program;\n    let memorySegment = instance.memorySegment;\n    if (!memorySegment) {\n\n      // Add to the function table\n      let functionTable = this.functionTable;\n      let tableBase = this.options.tableBase;\n      if (!tableBase) tableBase = 1; // leave first elem blank\n      let index = tableBase + functionTable.length;\n      functionTable.push(instance);\n\n      // Create runtime function\n      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));\n      let buf = rtInstance.createBuffer();\n      assert(rtInstance.writeField(\"_index\", index, buf));\n      assert(rtInstance.writeField(\"_env\", 0, buf));\n      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);\n    }\n    return i64_add(memorySegment.offset, i64_new(program.totalOverhead));\n  }\n\n  // === Statements ===============================================================================\n\n  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */\n  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {\n    switch (statement.kind) {\n      case NodeKind.ClassDeclaration: {\n        let memberStatements = (<ClassDeclaration>statement).members;\n        for (let i = 0, k = memberStatements.length; i < k; ++i) {\n          this.compileTopLevelStatement(memberStatements[i], body);\n        }\n        break;\n      }\n      case NodeKind.EnumDeclaration: {\n        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);\n        if (element) {\n          assert(element.kind == ElementKind.Enum);\n          if (!element.hasDecorator(DecoratorFlags.Lazy)) this.compileEnum(<Enum>element);\n        }\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        let declaration = <NamespaceDeclaration>statement;\n        let element = this.program.getElementByDeclaration(declaration);\n        if (element) {\n          // any potentiall merged element\n          let previousParent = this.currentParent;\n          this.currentParent = element;\n          let memberStatements = declaration.members;\n          for (let i = 0, k = memberStatements.length; i < k; ++i) {\n            this.compileTopLevelStatement(memberStatements[i], body);\n          }\n          this.currentParent = previousParent;\n        }\n        break;\n      }\n      case NodeKind.Variable: {\n        let declarations = (<VariableStatement>statement).declarations;\n        for (let i = 0, k = declarations.length; i < k; ++i) {\n          let element = this.program.getElementByDeclaration(declarations[i]);\n          if (element) {\n            assert(element.kind == ElementKind.Global);\n            if (\n              !element.is(CommonFlags.Ambient) && // delay imports\n              !element.hasDecorator(DecoratorFlags.Lazy)\n            ) this.compileGlobal(<Global>element);\n          }\n        }\n        break;\n      }\n      case NodeKind.FieldDeclaration: {\n        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);\n        if (element && element.kind == ElementKind.Global) { // static\n          if (!element.hasDecorator(DecoratorFlags.Lazy)) this.compileGlobal(<Global>element);\n        }\n        break;\n      }\n      case NodeKind.Export: {\n        let exportStatement = <ExportStatement>statement;\n        let internalPath = exportStatement.internalPath;\n        if (internalPath != null) {\n          this.compileFileByPath(internalPath, assert(exportStatement.path));\n        }\n        break;\n      }\n      case NodeKind.ExportDefault: {\n        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);\n        break;\n      }\n      case NodeKind.Import: {\n        let importStatement = <ImportStatement>statement;\n        this.compileFileByPath(importStatement.internalPath, importStatement.path);\n        break;\n      }\n      case NodeKind.FunctionDeclaration:\n      case NodeKind.MethodDeclaration:\n      case NodeKind.InterfaceDeclaration:\n      case NodeKind.IndexSignature:\n      case NodeKind.TypeDeclaration: break;\n      default: { // otherwise a top-level statement that is part of the start function's body\n        let stmt = this.compileStatement(statement);\n        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);\n        break;\n      }\n    }\n  }\n\n  /** Compiles a statement. */\n  compileStatement(\n    /** Statement to compile. */\n    statement: Statement\n  ): ExpressionRef {\n    let module = this.module;\n    let stmt: ExpressionRef;\n    switch (statement.kind) {\n      case NodeKind.Block: {\n        stmt = this.compileBlockStatement(<BlockStatement>statement);\n        break;\n      }\n      case NodeKind.Break: {\n        stmt = this.compileBreakStatement(<BreakStatement>statement);\n        break;\n      }\n      case NodeKind.Continue: {\n        stmt = this.compileContinueStatement(<ContinueStatement>statement);\n        break;\n      }\n      case NodeKind.Do: {\n        stmt = this.compileDoStatement(<DoStatement>statement);\n        break;\n      }\n      case NodeKind.Empty: {\n        stmt = this.compileEmptyStatement(<EmptyStatement>statement);\n        break;\n      }\n      case NodeKind.Expression: {\n        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);\n        break;\n      }\n      case NodeKind.For: {\n        stmt = this.compileForStatement(<ForStatement>statement);\n        break;\n      }\n      case NodeKind.ForOf: {\n        stmt = this.compileForOfStatement(<ForOfStatement>statement);\n        break;\n      }\n      case NodeKind.If: {\n        stmt = this.compileIfStatement(<IfStatement>statement);\n        break;\n      }\n      case NodeKind.Return: {\n        stmt = this.compileReturnStatement(<ReturnStatement>statement);\n        break;\n      }\n      case NodeKind.Switch: {\n        stmt = this.compileSwitchStatement(<SwitchStatement>statement);\n        break;\n      }\n      case NodeKind.Throw: {\n        stmt = this.compileThrowStatement(<ThrowStatement>statement);\n        break;\n      }\n      case NodeKind.Try: {\n        stmt = this.compileTryStatement(<TryStatement>statement);\n        break;\n      }\n      case NodeKind.Variable: {\n        stmt = this.compileVariableStatement(<VariableStatement>statement);\n        if (!stmt) stmt = module.nop();\n        break;\n      }\n      case NodeKind.Void: {\n        stmt = this.compileVoidStatement(<VoidStatement>statement);\n        break;\n      }\n      case NodeKind.While: {\n        stmt = this.compileWhileStatement(<WhileStatement>statement);\n        break;\n      }\n      case NodeKind.TypeDeclaration: {\n        // TODO: integrate inner type declaration into flow\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          statement.range,\n          \"Inner type alias\"\n        );\n        stmt = module.unreachable();\n        break;\n      }\n      case NodeKind.Module: {\n        stmt = module.nop();\n        break;\n      }\n      default: {\n        assert(false);\n        stmt = module.unreachable();\n      }\n    }\n    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);\n    return stmt;\n  }\n\n  /** Compiles a series of statements. */\n  compileStatements(\n    /** Statements to compile. */\n    statements: Statement[],\n    /** Statements to append to. Also returned, created if omitted. */\n    stmts: ExpressionRef[] | null = null\n  ): ExpressionRef[] {\n    let numStatements = statements.length;\n    if (!stmts) {\n      stmts = new Array<ExpressionRef>(numStatements);\n      stmts.length = 0;\n    }\n    let flow = this.currentFlow;\n    for (let i = 0; i < numStatements; ++i) {\n      let stmt = this.compileStatement(statements[i]);\n      switch (getExpressionId(stmt)) {\n        case ExpressionId.Block: {\n          if (!getBlockName(stmt)) {\n            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));\n            break;\n          }\n          // fall-through\n        }\n        default: stmts.push(stmt);\n        case ExpressionId.Nop:\n      }\n      if (flow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) break;\n    }\n    return stmts;\n  }\n\n  private compileBlockStatement(\n    statement: BlockStatement\n  ): ExpressionRef {\n    let statements = statement.statements;\n    let outerFlow = this.currentFlow;\n    let innerFlow = outerFlow.fork();\n    this.currentFlow = innerFlow;\n\n    let stmts = this.compileStatements(statements);\n    outerFlow.inherit(innerFlow);\n    this.currentFlow = outerFlow;\n    return this.module.flatten(stmts);\n  }\n\n  private compileBreakStatement(\n    statement: BreakStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let labelNode = statement.label;\n    if (labelNode) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        labelNode.range,\n        \"Break label\"\n      );\n      return module.unreachable();\n    }\n    let flow = this.currentFlow;\n    let breakLabel = flow.breakLabel;\n    if (breakLabel == null) {\n      this.error(\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.Breaks);\n    return module.br(breakLabel);\n  }\n\n  private compileContinueStatement(\n    statement: ContinueStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let label = statement.label;\n    if (label) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        label.range,\n        \"Continue label\"\n      );\n      return module.unreachable();\n    }\n    // Check if 'continue' is allowed here\n    let flow = this.currentFlow;\n    let continueLabel = flow.continueLabel;\n    if (continueLabel == null) {\n      this.error(\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.Continues | FlowFlags.Terminates);\n    return module.br(continueLabel);\n  }\n\n  private compileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    return this.doCompileDoStatement(statement);\n  }\n\n  private doCompileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (block $break\n    //  (loop $loop\n    //   (?block $continue\n    //    (body)\n    //   )\n    //   (br_if $loop (condition))\n    //  )\n    // )\n\n    // Cases of interest:\n    // * If the body never falls through or continues, the condition never executes\n    // * If the condition is always true and body never breaks, overall flow terminates\n    // * If the body terminates with a continue, condition is still reached\n\n    // Compile the body (always executes)\n    let flow = outerFlow.fork(/* resetBreakContext */ true);\n    let label = flow.pushControlFlowLabel();\n    let breakLabel = `do-break|${label}`;\n    flow.breakLabel = breakLabel;\n    let continueLabel = `do-continue|${label}`;\n    flow.continueLabel = continueLabel;\n    let loopLabel = `do-loop|${label}`;\n    this.currentFlow = flow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n    flow.popControlFlowLabel(label);\n\n    let possiblyContinues = flow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    let possiblyBreaks = flow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    let possiblyFallsThrough = !flow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n\n    // Shortcut if the condition is never reached\n    if (!possiblyFallsThrough && !possiblyContinues) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      outerFlow.inherit(flow);\n\n      // If the body also never breaks, the overall flow terminates\n      if (!possiblyBreaks) {\n        outerFlow.set(FlowFlags.Terminates);\n      }\n\n    // Otherwise compile and evaluate the condition (from here on always executes)\n    } else {\n      let condExpr = this.compileExpression(statement.condition, Type.bool);\n      let condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, statement.condition);\n      let condKind = this.evaluateCondition(condExprTrueish);\n\n      // Detect if local flags are incompatible before and after looping, and\n      // if so recompile by unifying local flags between iterations. Note that\n      // this may be necessary multiple times where locals depend on each other.\n      let possiblyLoops = condKind != ConditionKind.False && (possiblyContinues || possiblyFallsThrough);\n      if (possiblyLoops && outerFlow.resetIfNeedsRecompile(flow.forkThen(condExpr), numLocalsBefore)) {\n        this.currentFlow = outerFlow;\n        return this.doCompileDoStatement(statement);\n      }\n\n      if (possiblyContinues) {\n        bodyStmts[0] = module.block(continueLabel, bodyStmts);\n        bodyStmts.length = 1;\n        flow.unset(FlowFlags.Terminates); // Continue breaks to condition\n      }\n      bodyStmts.push(\n        module.br(loopLabel,\n          condExprTrueish\n        )\n      );\n      outerFlow.inherit(flow);\n\n      // Terminate if the condition is always true and body never breaks\n      if (condKind == ConditionKind.True && !possiblyBreaks) {\n        outerFlow.set(FlowFlags.Terminates);\n      }\n    }\n\n    // Finalize and leave everything else to the optimizer\n    this.currentFlow = outerFlow;\n    let expr = module.loop(loopLabel,\n      module.flatten(bodyStmts)\n    );\n    if (possiblyBreaks) {\n      expr = module.block(breakLabel, [\n        expr\n      ]);\n    }\n    if (outerFlow.is(FlowFlags.Terminates)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  private compileEmptyStatement(\n    statement: EmptyStatement\n  ): ExpressionRef {\n    return this.module.nop();\n  }\n\n  private compileExpressionStatement(\n    statement: ExpressionStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void, Constraints.ConvImplicit);\n  }\n\n  private compileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    return this.doCompileForStatement(statement);\n  }\n\n  private doCompileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (initializer)          \u2514\u25BA\u2510 flow\n    // (?block $break           \u2502 (initializer)\n    //  (?loop $loop          \u250C\u25C4\u2524 (condition) shortcut if false \u25C4\u2510\n    //   (if (condition)        \u251C\u25BA\u2510 bodyFlow                     \u2502\n    //    (then                 \u2502 \u2502 (body)                       \u2502\n    //     (?block $continue    \u2502 \u2502 if loops: (incrementor) \u2500\u2500\u2500\u2500\u2500\u2518\n    //      (body)              \u2502 \u2502           recompile body?\n    //     )                    \u251C\u25C4\u2518    \n    //     (incrementor)      \u250C\u25C4\u2518\n    //     (br $loop)\n    //    )\n    //   )\n    //  )\n    // )\n\n    // Compile initializer if present. The initializer might introduce scoped\n    // locals bound to the for statement, so create a new flow early.\n    let flow = outerFlow.fork();\n    this.currentFlow = flow;\n    let stmts = new Array<ExpressionRef>();\n    let initializer = statement.initializer;\n    if (initializer) {\n      assert(\n        initializer.kind == NodeKind.Expression ||\n        initializer.kind == NodeKind.Variable\n      );\n      stmts.push(this.compileStatement(initializer));\n    }\n\n    // Precompute the condition if present, or default to `true`\n    let condExpr: ExpressionRef;\n    let condExprTrueish: ExpressionRef;\n    let condKind: ConditionKind;\n    let condition = statement.condition;\n    if (condition) {\n      condExpr = this.compileExpression(condition, Type.bool);\n      condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, condition);\n      condKind = this.evaluateCondition(condExprTrueish);\n\n      // Shortcut if condition is always false (body never executes)\n      if (condKind == ConditionKind.False) {\n        stmts.push(\n          module.drop(condExprTrueish)\n        );\n        outerFlow.inherit(flow);\n        this.currentFlow = outerFlow;\n        return module.flatten(stmts);\n      }\n    } else {\n      condExpr = module.i32(1);\n      condExprTrueish = condExpr;\n      condKind = ConditionKind.True;\n    }\n    // From here on condition is either true or unknown\n\n    // Compile the body assuming the condition turned out true\n    let bodyFlow = flow.forkThen(condExpr, /* newBreakContext */ true);\n    let label = bodyFlow.pushControlFlowLabel();\n    let breakLabel = `for-break${label}`;\n    bodyFlow.breakLabel = breakLabel;\n    let continueLabel = `for-continue|${label}`;\n    bodyFlow.continueLabel = continueLabel;\n    let loopLabel = `for-loop|${label}`;\n    this.currentFlow = bodyFlow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n    bodyFlow.popControlFlowLabel(label);\n    bodyFlow.breakLabel = null;\n    bodyFlow.continueLabel = null;\n\n    let possiblyFallsThrough = !bodyFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n    let possiblyContinues = bodyFlow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    let possiblyBreaks = bodyFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n\n    if (possiblyContinues) {\n      bodyStmts[0] = module.block(continueLabel, bodyStmts);\n      bodyStmts.length = 1;\n    }\n\n    // Compile the incrementor if it possibly executes\n    let possiblyLoops = possiblyContinues || possiblyFallsThrough;\n    if (possiblyLoops) {\n      let incrementor = statement.incrementor;\n      if (incrementor) {\n        bodyStmts.push(\n          this.compileExpression(incrementor, Type.void, Constraints.ConvImplicit | Constraints.WillDrop)\n        );\n      }\n      bodyStmts.push(\n        module.br(loopLabel)\n      );\n\n      // Detect if local flags are incompatible before and after looping, and if\n      // so recompile by unifying local flags between iterations. Note that this\n      // may be necessary multiple times where locals depend on each other.\n      if (outerFlow.resetIfNeedsRecompile(bodyFlow.forkThen(condExpr), numLocalsBefore)) {\n        this.currentFlow = outerFlow;\n        return this.doCompileForStatement(statement);\n      }\n    }\n\n    // Body executes at least once\n    if (condKind == ConditionKind.True) {\n      flow.inherit(bodyFlow);\n\n    // Otherwise executes conditionally\n    } else {\n      flow.mergeBranch(bodyFlow);\n    }\n\n    // Finalize\n    outerFlow.inherit(flow);\n    this.currentFlow = outerFlow;\n    let expr = module.if(condExprTrueish,\n      module.flatten(bodyStmts)\n    );\n    if (possiblyLoops) {\n      expr = module.loop(loopLabel, expr);\n    }\n    if (possiblyBreaks) {\n      expr = module.block(breakLabel, [ expr ]);\n    }\n    stmts.push(expr);\n    if (outerFlow.is(FlowFlags.Terminates)) {\n      stmts.push(module.unreachable());\n    }\n    return module.flatten(stmts);\n  }\n\n  private compileForOfStatement(\n    statement: ForOfStatement\n  ): ExpressionRef {\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Iterators\"\n    );\n    return this.module.unreachable();\n  }\n\n  private compileIfStatement(\n    statement: IfStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let ifTrue = statement.ifTrue;\n    let ifFalse = statement.ifFalse;\n\n    // (if (condition)\n    //  (then (ifTrue))\n    //  (?else (ifFalse))\n    // )\n\n    // Cases of interest:\n    // * If the condition is always true or false, the other branch is eliminated\n    // * If both then and else terminate, the overall flow does as well\n    // * Without an else, when then terminates, follow-up flow acts like an else\n\n    // Precompute the condition (always executes)\n    let condExpr = this.compileExpression(statement.condition, Type.bool);\n    let condExprTrueish = this.makeIsTrueish(\n      condExpr,\n      this.currentType,\n      statement.condition\n    );\n    let condKind = this.evaluateCondition(condExprTrueish);\n\n    // Shortcut if the condition is constant\n    switch (condKind) {\n      case ConditionKind.True: {\n        return module.block(null, [\n          module.drop(condExprTrueish),\n          this.compileStatement(ifTrue)\n        ]);\n      }\n      case ConditionKind.False: {\n        return ifFalse\n          ? module.block(null, [\n              module.drop(condExprTrueish),\n              this.compileStatement(ifFalse)\n            ])\n          : module.drop(condExprTrueish);\n      }\n    }\n\n    // From here on condition is always unknown\n\n    let flow = this.currentFlow;\n\n    // Compile ifTrue assuming the condition turned out true\n    let thenStmts = new Array<ExpressionRef>();\n    let thenFlow = flow.forkThen(condExpr);\n    this.currentFlow = thenFlow;\n    if (ifTrue.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>ifTrue).statements, thenStmts);\n    } else {\n      thenStmts.push(this.compileStatement(ifTrue));\n    }\n    this.currentFlow = flow;\n\n    // Compile ifFalse assuming the condition turned out false, if present\n    let elseFlow = flow.forkElse(condExpr);\n    if (ifFalse) {\n      this.currentFlow = elseFlow;\n      let elseStmts = new Array<ExpressionRef>();\n      if (ifFalse.kind == NodeKind.Block) {\n        this.compileStatements((<BlockStatement>ifFalse).statements, elseStmts);\n      } else {\n        elseStmts.push(this.compileStatement(ifFalse));\n      }\n      flow.inheritAlternatives(thenFlow, elseFlow); // terminates if both do\n      this.currentFlow = flow;\n      return module.if(condExprTrueish,\n        module.flatten(thenStmts),\n        module.flatten(elseStmts)\n      );\n    } else {\n      if (thenFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) {\n        // Only getting past if condition was false (acts like else)\n        flow.inherit(elseFlow);\n        flow.mergeSideEffects(thenFlow);\n      } else {\n        // Otherwise getting past conditionally\n        flow.inheritAlternatives(thenFlow, elseFlow);\n      }\n      this.currentFlow = flow;\n      return module.if(condExprTrueish,\n        module.flatten(thenStmts)\n      );\n    }\n  }\n\n  private compileReturnStatement(\n    statement: ReturnStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let expr: ExpressionRef = 0;\n    let flow = this.currentFlow;\n    let returnType = flow.returnType;\n\n    let valueExpression = statement.value;\n    if (valueExpression) {\n      let constraints = Constraints.ConvImplicit;\n      if (flow.sourceFunction.is(CommonFlags.ModuleExport)) constraints |= Constraints.MustWrap;\n\n      expr = this.compileExpression(valueExpression, returnType, constraints);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n      if (flow.sourceFunction.is(CommonFlags.Constructor) && valueExpression.kind != NodeKind.This) {\n        flow.set(FlowFlags.MayReturnNonThis);\n      }\n    } else if (returnType != Type.void) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        statement.range, \"void\", returnType.toString()\n      );\n      this.currentType = returnType;\n      return module.unreachable();\n    }\n\n    // Remember that this flow returns\n    flow.set(FlowFlags.Returns | FlowFlags.Terminates);\n\n    // Handle inline return\n    if (flow.isInline) {\n      let inlineReturnLabel = assert(flow.inlineReturnLabel);\n      return expr\n        ? this.currentType == Type.void\n          ? module.block(null, [ expr, module.br(inlineReturnLabel) ])\n          : module.br(inlineReturnLabel, 0, expr)\n        : module.br(inlineReturnLabel);\n    }\n\n    // Otherwise emit a normal return\n    return expr\n      ? this.currentType == Type.void\n        ? module.block(null, [ expr, module.return() ])\n        : module.return(expr)\n      : module.return();\n  }\n\n  private compileSwitchStatement(\n    statement: SwitchStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let cases = statement.cases;\n    let numCases = cases.length;\n\n    // Compile the condition (always executes)\n    let condExpr = this.compileExpression(statement.condition, Type.u32,\n      Constraints.ConvImplicit\n    );\n\n    // Shortcut if there are no cases\n    if (!numCases) return module.drop(condExpr);\n    \n    // Assign the condition to a temporary local as we compare it multiple times\n    let outerFlow = this.currentFlow;\n    let tempLocal = outerFlow.getTempLocal(Type.u32);\n    let tempLocalIndex = tempLocal.index;\n    let breaks = new Array<ExpressionRef>(1 + numCases);\n    breaks[0] = module.local_set(tempLocalIndex, condExpr, false); // u32\n    \n    // Make one br_if per labeled case and leave it to Binaryen to optimize the\n    // sequence of br_ifs to a br_table according to optimization levels\n    let breakIndex = 1;\n    let defaultIndex = -1;\n    let label = outerFlow.pushControlFlowLabel();\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      if (case_.isDefault) {\n        defaultIndex = i;\n        continue;\n      }\n      breaks[breakIndex++] = module.br(`case${i}|${label}`,\n        module.binary(BinaryOp.EqI32,\n          module.local_get(tempLocalIndex, TypeRef.I32),\n          this.compileExpression(assert(case_.label), Type.u32,\n            Constraints.ConvImplicit\n          )\n        )\n      );\n    }\n\n    // If there is a default case, break to it, otherwise break out of the switch\n    breaks[breakIndex] = module.br(defaultIndex >= 0\n      ? `case${defaultIndex}|${label}`\n      : `break|${label}`\n    );\n\n    // Nest the case blocks in order, to be targeted by the br_if sequence\n    let currentBlock = module.block(`case0|${label}`, breaks, TypeRef.None);\n    let fallThroughFlow: Flow | null = null;\n    let breakingFlowAlternatives: Flow | null = null;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let statements = case_.statements;\n      let numStatements = statements.length;\n\n      // Can get here by matching the case or possibly by fall-through\n      let innerFlow = outerFlow.fork(/* newBreakContext */ true, /* newContinueContext */ false);\n      if (fallThroughFlow) innerFlow.mergeBranch(fallThroughFlow);\n      this.currentFlow = innerFlow;\n      let breakLabel = `break|${label}`;\n      innerFlow.breakLabel = breakLabel;\n\n      let isLast = i == numCases - 1;\n      let nextLabel = isLast ? breakLabel : `case${i + 1}|${label}`;\n      let stmts = new Array<ExpressionRef>(1 + numStatements);\n      stmts[0] = currentBlock;\n      let count = 1;\n      let possiblyFallsThrough = true;\n      for (let j = 0; j < numStatements; ++j) {\n        let stmt = this.compileStatement(statements[j]);\n        if (getExpressionId(stmt) != ExpressionId.Nop) {\n          stmts[count++] = stmt;\n        }\n        if (innerFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) {\n          possiblyFallsThrough = false;\n          break;\n        }\n      }\n      stmts.length = count;\n      fallThroughFlow = possiblyFallsThrough ? innerFlow : null;\n      let possiblyBreaks = innerFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n      innerFlow.unset(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks); // clear\n\n      // Combine all alternatives that merge again with outer flow\n      if (possiblyBreaks || (isLast && possiblyFallsThrough)) {\n        if (breakingFlowAlternatives) breakingFlowAlternatives.inheritAlternatives(breakingFlowAlternatives, innerFlow);\n        else breakingFlowAlternatives = innerFlow;\n\n      // Otherwise just merge the effects of a non-merging branch\n      } else if (!possiblyFallsThrough) {\n        outerFlow.mergeSideEffects(innerFlow);\n      }\n\n      this.currentFlow = outerFlow;\n      currentBlock = module.block(nextLabel, stmts, TypeRef.None); // must be a labeled block\n    }\n    outerFlow.popControlFlowLabel(label);\n\n    // If the switch has a default, we only get past through any breaking flow\n    if (defaultIndex >= 0) {\n      if (breakingFlowAlternatives) outerFlow.inherit(breakingFlowAlternatives);\n      else outerFlow.set(FlowFlags.Terminates);\n\n    // Otherwise either none or any breaking flow can get past conditionally\n    } else if (breakingFlowAlternatives) {\n      outerFlow.mergeBranch(breakingFlowAlternatives);\n    }\n\n    this.currentFlow = outerFlow;\n    return currentBlock;\n  }\n\n  private compileThrowStatement(\n    statement: ThrowStatement\n  ): ExpressionRef {\n    // TODO: requires exception-handling spec.\n    let flow = this.currentFlow;\n\n    // Remember that this branch throws\n    flow.set(FlowFlags.Throws | FlowFlags.Terminates);\n\n    let stmts = new Array<ExpressionRef>();\n    let value = statement.value;\n    let message: Expression | null = null;\n    if (value.kind == NodeKind.New) {\n      let newArgs = (<NewExpression>value).args;\n      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string\n    }\n    stmts.push(\n      this.makeAbort(message, statement)\n    );\n    return this.module.flatten(stmts);\n  }\n\n  private compileTryStatement(\n    statement: TryStatement\n  ): ExpressionRef {\n    // TODO: can't yet support something like: try { return ... } finally { ... }\n    // worthwhile to investigate lowering returns to block results (here)?\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Exceptions\"\n    );\n    return this.module.unreachable();\n  }\n\n  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */\n  private compileVariableStatement(\n    statement: VariableStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let declarations = statement.declarations;\n    let numDeclarations = declarations.length;\n    let flow = this.currentFlow;\n    let initializers = new Array<ExpressionRef>();\n    let resolver = this.resolver;\n\n    for (let i = 0; i < numDeclarations; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let type: Type | null = null;\n      let initExpr: ExpressionRef = 0;\n      let initType: Type | null = null;\n\n      if (declaration.is(CommonFlags.DefinitelyAssigned)) {\n        this.warning(\n          DiagnosticCode.Definitive_assignment_has_no_effect_on_local_variables,\n          declaration.name.range\n        );\n      }\n\n      // Resolve type if annotated\n      let typeNode = declaration.type;\n      let initializerNode = declaration.initializer;\n      if (typeNode) {\n        type = resolver.resolveType( // reports\n          typeNode,\n          flow.sourceFunction,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!type) continue;\n        this.program.checkTypeSupported(type, typeNode);\n\n        if (initializerNode) {\n          let pendingElements = this.pendingElements;\n          let dummy = flow.addScopedDummyLocal(name, type, statement); // pending dummy\n          pendingElements.add(dummy);\n          initExpr = this.compileExpression(initializerNode, type, // reports\n            Constraints.ConvImplicit\n          );\n          initType = this.currentType;\n          pendingElements.delete(dummy);\n          flow.freeScopedDummyLocal(name);\n        }\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let pendingElements = this.pendingElements;\n        let temp = flow.addScopedDummyLocal(name, Type.auto, statement); // pending dummy\n        pendingElements.add(temp);\n        initExpr = this.compileExpression(initializerNode, Type.auto); // reports\n        initType = this.currentType;\n        pendingElements.delete(temp);\n        flow.freeScopedDummyLocal(name);\n\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            declaration.range, this.currentType.toString(), \"<auto>\"\n          );\n          continue;\n        }\n        type = initType;\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          declaration.name.range.atEnd\n        );\n        continue;\n      }\n\n      // Handle constants, and try to inline if value is static\n      let isConst = declaration.is(CommonFlags.Const);\n      let isStatic = false;\n      if (isConst) {\n        if (initExpr) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp; // always use precomputed initExpr\n            let local: Local | null = null;\n            switch (<u32>getExpressionType(initExpr)) {\n              case <u32>TypeRef.I32: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI32(initExpr),\n                    0\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.I64: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI64Low(initExpr),\n                    getConstValueI64High(initExpr)\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.F32: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);\n                break;\n              }\n              case <u32>TypeRef.F64: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantFloatValue(getConstValueF64(initExpr), type);\n                break;\n              }\n            }\n            if (local) {\n              // Add as a dummy local that doesn't actually exist in WebAssembly\n              let scopedLocals = flow.scopedLocals;\n              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();\n              else if (scopedLocals.has(name)) {\n                let existing = assert(scopedLocals.get(name));\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  declaration.name.range,\n                  existing.declaration.name.range,\n                  name\n                );\n                return this.module.unreachable();\n              }\n              scopedLocals.set(name, local);\n              isStatic = true;\n            }\n          }\n        } else {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            declaration.range\n          );\n        }\n      }\n\n      // Otherwise compile as mutable\n      if (!isStatic) {\n        let local: Local;\n        if (\n          declaration.isAny(CommonFlags.Let | CommonFlags.Const) ||\n          flow.isInline\n        ) { // here: not top-level\n          let existingLocal = flow.getScopedLocal(name);\n          if (existingLocal) {\n            if (!existingLocal.declaration.range.source.isNative) {\n              this.errorRelated(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range,\n                existingLocal.declaration.name.range,\n                name\n              );\n            } else { // scoped locals are shared temps that don't track declarations\n              this.error(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range, name\n              );\n            }\n            local = existingLocal;\n          } else {\n            local = flow.addScopedLocal(name, type);\n          }\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.Constant);\n        } else {\n          let existing = flow.lookupLocal(name);\n          if (existing) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              declaration.name.range,\n              existing.declaration.name.range,\n              name\n            );\n            continue;\n          }\n          local = flow.targetFunction.addLocal(type, name, declaration);\n          flow.unsetLocalFlag(local.index, ~0);\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.Constant);\n        }\n        if (initExpr) {\n          initializers.push(\n            this.makeLocalAssignment(local, initExpr, initType ? initType : type, false)\n          );\n        } else {\n          // no need to assign zero\n          if (local.type.isShortIntegerValue) {\n            flow.setLocalFlag(local.index, LocalFlags.Wrapped);\n          }\n        }\n      }\n    }\n    this.currentType = Type.void;\n    return initializers.length == 0\n      ? 0\n      : module.flatten(initializers);\n  }\n\n  private compileVoidStatement(\n    statement: VoidStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void,\n      Constraints.ConvExplicit | Constraints.WillDrop\n    );\n  }\n\n  private compileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    return this.doCompileWhileStatement(statement);\n  }\n\n  private doCompileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (block $break\n    //  (loop $continue\n    //   (if (condition)\n    //    (then\n    //     (body)\n    //     (br $continue)\n    //    )\n    //   )\n    //  )\n\n    // Cases of interest:\n    // * If the condition is always false, eliminate the body as it never runs\n    // * If the condition is always true and the body never breaks, terminate\n    // * If the body runs but always terminates, continue as if condition was false\n\n    // Compile and evaluate the condition (always executes)\n    let condExpr = this.compileExpression(statement.condition, Type.bool);\n    let condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, statement.condition);\n    let condKind = this.evaluateCondition(condExprTrueish);\n\n    // Shortcut if condition is always false (body never runs)\n    if (condKind == ConditionKind.False) {\n      return module.drop(condExprTrueish);\n    }\n\n    // Compile the body assuming the condition turned out true\n    let thenFlow = outerFlow.forkThen(condExpr, /* newBreakContext */ true);\n    let label = thenFlow.pushControlFlowLabel();\n    let breakLabel = `while-break|${label}`;\n    thenFlow.breakLabel = breakLabel;\n    let continueLabel = `while-continue|${label}`;\n    thenFlow.continueLabel = continueLabel;\n    this.currentFlow = thenFlow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n    bodyStmts.push(\n      module.br(continueLabel)\n    );\n    thenFlow.popControlFlowLabel(label);\n\n    let possiblyContinues = thenFlow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    let possiblyBreaks = thenFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    let possiblyFallsThrough = !thenFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n\n    // Detect if local flags are incompatible before and after looping, and\n    // if so recompile by unifying local flags between iterations. Note that\n    // this may be necessary multiple times where locals depend on each other.\n    let possiblyLoops = possiblyContinues || possiblyFallsThrough;\n    if (possiblyLoops && outerFlow.resetIfNeedsRecompile(thenFlow, numLocalsBefore)) {\n      this.currentFlow = outerFlow;\n      return this.doCompileWhileStatement(statement);\n    }\n\n    // If the condition is always true, the body's effects always happen\n    let alwaysTerminates = false;\n    if (condKind == ConditionKind.True) {\n      outerFlow.inherit(thenFlow);\n\n      // If the body also never breaks, the overall flow terminates\n      if (!possiblyBreaks) {\n        alwaysTerminates = true;\n        outerFlow.set(FlowFlags.Terminates);\n      }\n\n    // Otherwise loop conditionally\n    } else {\n      let elseFlow = outerFlow.forkElse(condExpr);\n      if (!possiblyFallsThrough && !possiblyBreaks) {\n        // Only getting past if condition was false\n        outerFlow.inherit(elseFlow);\n        outerFlow.mergeSideEffects(thenFlow);\n      } else {\n        // Otherwise getting past conditionally\n        outerFlow.inheritAlternatives(thenFlow, elseFlow);\n      }\n    }\n\n    // Finalize and leave everything else to the optimizer\n    this.currentFlow = outerFlow;\n    let stmts: ExpressionRef[] = [\n      module.loop(continueLabel,\n        module.if(condExprTrueish,\n          module.flatten(bodyStmts)\n        )\n      )\n    ];\n    if (alwaysTerminates) stmts.push(module.unreachable());\n    return module.block(breakLabel, stmts);\n  }\n\n  // === Expressions ==============================================================================\n\n  /** Compiles the value of an inlined constant element. */\n  compileInlineConstant(\n    element: VariableLikeElement,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    assert(element.is(CommonFlags.Inlined | CommonFlags.Resolved));\n    let type = element.type;\n    this.currentType = type;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            // @ts-ignore\n            ? <i32>i64_ne(element.constantIntegerValue, i64_zero)\n            : 0\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        let shift = type.computeSmallIntegerShift(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue) << shift >> shift\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        let mask = element.type.computeSmallIntegerMask(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue) & mask\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue)\n            : 0\n        );\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (!element.program.options.isWasm64) {\n          return this.module.i32(\n            element.constantValueKind == ConstantValueKind.Integer\n              ? i64_low(element.constantIntegerValue)\n              : 0\n          );\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return element.constantValueKind == ConstantValueKind.Integer\n          ? this.module.i64(\n              i64_low(element.constantIntegerValue),\n              i64_high(element.constantIntegerValue)\n            )\n          : this.module.i64(0);\n      }\n      case TypeKind.F64: {\n        // monkey-patch for converting built-in floats to f32 implicitly\n        if (!(element.hasDecorator(DecoratorFlags.Builtin) && contextualType == Type.f32)) {\n          return this.module.f64(element.constantFloatValue);\n        }\n        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity\n        this.currentType = Type.f32;\n      }\n      case TypeKind.F32: {\n        return this.module.f32(<f32>element.constantFloatValue);\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n  }\n\n  compileExpression(\n    expression: Expression,\n    contextualType: Type,\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    while (expression.kind == NodeKind.Parenthesized) { // skip\n      expression = (<ParenthesizedExpression>expression).expression;\n    }\n    this.currentType = contextualType;\n    if (contextualType == Type.void) constraints |= Constraints.WillDrop;\n    let expr: ExpressionRef;\n    switch (expression.kind) {\n      case NodeKind.Assertion: {\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Binary: {\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Call: {\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Comma: {\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.ElementAccess: {\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Function: {\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.This:\n      case NodeKind.Super:\n      case NodeKind.True: {\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.InstanceOf: {\n        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Literal: {\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.New: {\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.PropertyAccess: {\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Ternary: {\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UnaryPostfix: {\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Compiled: {\n        let compiled = <CompiledExpression>expression;\n        expr = compiled.expr;\n        this.currentType = compiled.type;\n        break;\n      }\n      case NodeKind.Class: {\n        // TODO: compile as class expression\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Block-scoped class declarations or expressions\"\n        );\n        expr = this.module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    // ensure conversion and wrapping in case the respective function doesn't on its own\n    let currentType = this.currentType;\n    let wrap = (constraints & Constraints.MustWrap) != 0;\n    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable\n      if (constraints & Constraints.ConvExplicit) {\n        expr = this.convertExpression(expr, currentType, contextualType, true, expression);\n        this.currentType = currentType = contextualType;\n      } else if (constraints & Constraints.ConvImplicit) {\n        expr = this.convertExpression(expr, currentType, contextualType, false, expression);\n        this.currentType = currentType = contextualType;\n      }\n    }\n    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);\n    // debug location is added here so the caller doesn't have to. means: compilation of an expression\n    // must go through this function, with the respective per-kind functions not being used directly.\n    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n    return expr;\n  }\n\n  /** Converts an expression's result from one type to another. */\n  convertExpression(\n    expr: ExpressionRef,\n    /** Original type. */\n    fromType: Type,\n    /** New type. */\n    toType: Type,\n    /** Whether the conversion is explicit. */\n    explicit: bool,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let module = this.module;\n\n    if (fromType.kind == TypeKind.Void) {\n      if (toType.kind == TypeKind.Void) {\n        // void to void: Can happen as a result of a foregoing error. Since we\n        // have an `expr` here that is already supposed to be void, return it.\n        return expr;\n      }\n      // void to any\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    // any to void\n    if (toType.kind == TypeKind.Void) return module.drop(expr);\n\n    // reference involved\n    if (fromType.isReference || toType.isReference) {\n      if (this.currentFlow.isNonnull(expr, fromType)) {\n        fromType = fromType.nonNullableType;\n      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {\n        // explicit conversion from nullable to non-nullable requires a runtime\n        // check here because nonnull state above already didn't know better\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);\n        }\n        fromType = fromType.nonNullableType;\n      }\n      if (fromType.isAssignableTo(toType)) { // upcast or same\n        assert(toType.isExternalReference || fromType.kind == toType.kind);\n        this.currentType = toType;\n        return expr;\n      }\n      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // downcast\n        // <Cat | null>(<Animal>maybeCat)\n        if (toType.isExternalReference) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            reportNode.range,\n            \"ref.cast\"\n          );\n          this.currentType = toType;\n          return module.unreachable();\n        }\n        assert(fromType.kind == toType.kind);\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeDowncastCheck(expr, fromType, toType, reportNode);\n        }\n        this.currentType = toType;\n        return expr;\n      }\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      this.currentType = toType;\n      return module.unreachable();\n    }\n\n    // not dealing with references from here on\n    assert(!fromType.isReference && !toType.isReference);\n\n    // Early return if we have same types\n    if (toType.kind == fromType.kind) {\n      this.currentType = toType;\n      return expr;\n    }\n\n    // v128 to any / any to v128\n    // except v128 to bool\n    //\n    // NOTE:In case we would have more conversions to and from v128 type it's better\n    // to make these checks more individual and integrate in below flow.\n    if (\n      !toType.isBooleanValue &&\n      (toType.isVectorValue || fromType.isVectorValue)\n    ) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    if (!fromType.isAssignableTo(toType)) {\n      if (!explicit) {\n        this.error(\n          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\n          reportNode.range, fromType.toString(), toType.toString()\n        ); // recoverable\n      }\n    }\n\n    if (fromType.isFloatValue) {\n\n      // float to float\n      if (toType.isFloatValue) {\n        if (fromType.kind == TypeKind.F32) {\n\n          // f32 to f64\n          if (toType.kind == TypeKind.F64) {\n            expr = module.unary(UnaryOp.PromoteF32ToF64, expr);\n          }\n\n          // otherwise f32 to f32\n\n        // f64 to f32\n        } else if (toType.kind == TypeKind.F32) {\n          expr = module.unary(UnaryOp.DemoteF64ToF32, expr);\n        }\n\n        // otherwise f64 to f64\n\n      // float to int\n      } else if (toType.isIntegerValue) {\n\n        // f32 to int\n        if (fromType.kind == TypeKind.F32) {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f32, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI64 : UnaryOp.TruncF32ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI32 : UnaryOp.TruncF32ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU64 : UnaryOp.TruncF32ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU32 : UnaryOp.TruncF32ToU32, expr);\n            }\n          }\n\n        // f64 to int\n        } else {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f64, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI64 : UnaryOp.TruncF64ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI32 : UnaryOp.TruncF64ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU64 : UnaryOp.TruncF64ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU32 : UnaryOp.TruncF64ToU32, expr);\n            }\n          }\n        }\n\n      // float to void\n      } else {\n        assert(toType.flags == TypeFlags.None, \"void type expected\");\n        expr = module.drop(expr);\n      }\n\n    // int to float\n    } else if (fromType.isIntegerValue && toType.isFloatValue) {\n\n      // int to f32\n      if (toType.kind == TypeKind.F32) {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF32\n              : UnaryOp.ConvertU64ToF32,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF32\n              : UnaryOp.ConvertU32ToF32,\n            expr\n          );\n        }\n\n      // int to f64\n      } else {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF64\n              : UnaryOp.ConvertU64ToF64,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF64\n              : UnaryOp.ConvertU32ToF64,\n            expr\n          );\n        }\n      }\n\n    // v128 to bool\n    } else if (fromType == Type.v128 && toType.isBooleanValue) {\n      expr = this.makeIsTrueish(expr, Type.v128, reportNode);\n\n    // int to int\n    } else {\n      // i64 to ...\n      if (fromType.isLongIntegerValue) {\n\n        // i64 to i32 or smaller\n        if (toType.isBooleanValue) {\n          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));\n        } else if (!toType.isLongIntegerValue) {\n          expr = module.unary(UnaryOp.WrapI64ToI32, expr); // discards upper bits\n        }\n\n      // i32 or smaller to i64\n      } else if (toType.isLongIntegerValue) {\n        expr = module.unary(\n          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32ToI64 : UnaryOp.ExtendU32ToU64,\n          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits\n        );\n\n      // i32 to i32\n      } else {\n        // small i32 to ...\n        if (fromType.isShortIntegerValue) {\n          // small i32 to larger i32\n          if (fromType.size < toType.size) {\n            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits\n          }\n        // same size\n        } else {\n          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {\n            this.warning(\n              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,\n              reportNode.range, fromType.toString(), toType.toString()\n            );\n          }\n        }\n      }\n    }\n\n    this.currentType = toType;\n    return expr;\n  }\n\n  private compileAssertionExpression(\n    expression: AssertionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let inheritedConstraints = constraints & ~(Constraints.ConvImplicit | Constraints.ConvExplicit);\n    switch (expression.assertionKind) {\n      case AssertionKind.Prefix:\n      case AssertionKind.As: {\n        let flow = this.currentFlow;\n        let toType = this.resolver.resolveType( // reports\n          assert(expression.toType),\n          flow.sourceFunction,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!toType) return this.module.unreachable();\n        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.ConvExplicit);\n      }\n      case AssertionKind.NonNull: {\n        assert(!expression.toType);\n        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);\n        let type = this.currentType;\n        if (this.currentFlow.isNonnull(expr, type)) {\n          this.info(\n            DiagnosticCode.Expression_is_never_null,\n            expression.expression.range\n          );\n        } else if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, type, expression);\n        }\n        this.currentType = type.nonNullableType;\n        return expr;\n      }\n      case AssertionKind.Const: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let operand = expression.expression;\n        // if (operand.kind == NodeKind.Literal && (<LiteralExpression>operand).literalKind == LiteralKind.Array) {\n        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);\n        //   if (!element) return this.module.unreachable();\n        //   if (element.kind == ElementKind.Class) {\n        //     let arrayInstance = <Class>element;\n        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {\n        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);\n        //     }\n        //   }\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Const assertion\"\n        );\n        return this.module.unreachable();\n      }\n      default: assert(false);\n    }\n    return this.module.unreachable();\n  }\n\n  private f32ModInstance: Function | null = null;\n  private f64ModInstance: Function | null = null;\n  private f32PowInstance: Function | null = null;\n  private f64PowInstance: Function | null = null;\n  private i32PowInstance: Function | null = null;\n  private i64PowInstance: Function | null = null;\n\n  private compileBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let left = expression.left;\n    let right = expression.right;\n\n    let leftExpr: ExpressionRef;\n    let leftType: Type;\n    let rightExpr: ExpressionRef;\n    let rightType: Type;\n    let commonType: Type | null;\n\n    let expr: ExpressionRef;\n    let compound = false;\n\n    let operator = expression.operator;\n    switch (operator) {\n      case Token.LessThan: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Lt);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Gt);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.LessThan_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Le);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GreaterThan_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Ge);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n\n      case Token.Equals_Equals_Equals:\n      case Token.Equals_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Eq);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n        if (commonType.isFloatValue) {\n          if (\n            isConstExpressionNaN(module, rightExpr) ||\n            isConstExpressionNaN(module, leftExpr)\n          ) {\n            this.warning(\n              DiagnosticCode._NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead,\n              expression.range\n            );\n          }\n          if (isConstNegZero(rightExpr) || isConstNegZero(leftExpr)) {\n            this.warning(\n              DiagnosticCode.Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters,\n              expression.range\n            );\n          }\n        }\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeEq(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Exclamation_Equals_Equals:\n      case Token.Exclamation_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClass();\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Ne);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n        if (commonType.isFloatValue) {\n          if (\n            isConstExpressionNaN(module, rightExpr) ||\n            isConstExpressionNaN(module, leftExpr)\n          ) {\n            this.warning(\n              DiagnosticCode._NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead,\n              expression.range\n            );\n          }\n          if (isConstNegZero(rightExpr) || isConstNegZero(leftExpr)) {\n            this.warning(\n              DiagnosticCode.Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters,\n              expression.range\n            );\n          }\n        }\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeNe(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Equals: {\n        return this.compileAssignment(left, right, contextualType);\n      }\n      case Token.Plus_Equals: compound = true;\n      case Token.Plus: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Add);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"+\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"+\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAdd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Minus_Equals: compound = true;\n      case Token.Minus: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Sub);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"-\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeSub(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Asterisk_Equals: compound = true;\n      case Token.Asterisk: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Mul);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"*\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"*\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeMul(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Asterisk_Asterisk_Equals: compound = true;\n      case Token.Asterisk_Asterisk: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Pow);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"**\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"**\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makePow(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.Slash_Equals: compound = true;\n      case Token.Slash: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Div);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"/\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"/\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeDiv(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Percent_Equals: compound = true;\n      case Token.Percent: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Rem);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"%\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"%\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.LessThan_LessThan_Equals: compound = true;\n      case Token.LessThan_LessThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShl);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"<<\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShl(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GreaterThan_GreaterThan_Equals: compound = true;\n      case Token.GreaterThan_GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShr);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>\", leftType.toString()\n          );\n          return this.module.unreachable();\n        }\n\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShr(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals: compound = true;\n      case Token.GreaterThan_GreaterThan_GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShrU);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>>\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShru(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.Ampersand_Equals: compound = true;\n      case Token.Ampersand: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overloadd\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseAnd);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"&\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAnd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Bar_Equals: compound = true;\n      case Token.Bar: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseOr);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"|\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"|\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeOr(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Caret_Equals: compound = true;\n      case Token.Caret: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseXor);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"^\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"^\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeXor(leftExpr, rightExpr, commonType);\n        break;\n      }\n\n      // logical (no overloading)\n\n      case Token.Ampersand_Ampersand: { // left && right -> (t = left) ? right : t\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MustWrap;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.forkThen(leftExpr);\n        this.currentFlow = rightFlow;\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always false\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.False) {\n            expr = leftExpr;\n            // RHS is not compiled\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always true\n            if (condKind == ConditionKind.True) {\n              expr = rightExpr;\n              flow.inherit(rightFlow); // true && RHS -> RHS always executes\n            } else {\n              expr = module.if(leftExpr, rightExpr, module.i32(0));\n              flow.mergeBranch(rightFlow); // LHS && RHS -> RHS conditionally executes\n              flow.noteThen(expr, rightFlow); // LHS && RHS == true -> RHS always executes\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.ConvImplicit);\n          rightType = this.currentType;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, this.currentType, left),\n              rightExpr,\n              expr\n            );\n\n          // if not possible, tee left to a temp\n          } else {\n            let tempLocal = flow.getTempLocal(leftType);\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.Wrapped);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NonNull);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr, leftType.isManaged), leftType, left),\n              rightExpr,\n              module.local_get(tempLocal.index, leftType.toRef())\n            );\n          }\n          flow.mergeBranch(rightFlow); // LHS && RHS -> RHS conditionally executes\n          flow.noteThen(expr, rightFlow); // LHS && RHS == true -> RHS always executes\n          this.currentFlow = flow;\n          this.currentType = leftType;\n        }\n        break;\n      }\n      case Token.Bar_Bar: { // left || right -> ((t = left) ? t : right)\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MustWrap;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.forkElse(leftExpr);\n        this.currentFlow = rightFlow;\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always true\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.True) {\n            expr = leftExpr;\n            // RHS is not compiled\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always false\n            if (condKind == ConditionKind.False) {\n              expr = rightExpr;\n              flow.inherit(rightFlow); // false || RHS -> RHS always executes\n            } else {\n              expr = module.if(leftExpr, module.i32(1), rightExpr);\n              flow.mergeBranch(rightFlow); // LHS || RHS -> RHS conditionally executes\n              flow.noteElse(expr, rightFlow); // LHS || RHS == false -> RHS always executes\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.ConvImplicit);\n          rightType = this.currentType;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, leftType, left),\n              expr,\n              rightExpr\n            );\n\n          // if not possible, tee left to a temp. local\n          } else {\n            let temp = flow.getTempLocal(leftType);\n            let tempIndex = temp.index;\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempIndex, LocalFlags.Wrapped);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempIndex, LocalFlags.NonNull);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempIndex, leftExpr, leftType.isManaged), leftType, left),\n              module.local_get(tempIndex, leftType.toRef()),\n              rightExpr\n            );\n          }\n          flow.mergeBranch(rightFlow); // LHS || RHS -> RHS conditionally executes\n          flow.noteElse(expr, rightFlow); // LHS || RHS == false -> RHS always executes\n          this.currentFlow = flow;\n          this.currentType = leftType;\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(left, this.currentFlow);\n    if (!target) return module.unreachable();\n    let targetType = resolver.getTypeOfElement(target);\n    if (!targetType) targetType = Type.void;\n    if (!this.currentType.isStrictlyAssignableTo(targetType)) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, this.currentType.toString(), targetType.toString()\n      );\n      return module.unreachable();\n    }\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      right,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.LtISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.LtUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.GtISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.GtUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.LeISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.LeUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.GeISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.GeUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.EqSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AllTrueI8x16,\n          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Eqref:\n      case TypeKind.I31ref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref: return module.ref_eq(leftExpr, rightExpr);\n      case TypeKind.Stringref: return module.string_eq(leftExpr, rightExpr);\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter:\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.NeSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128,\n          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Eqref:\n      case TypeKind.I31ref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref: {\n        return module.unary(UnaryOp.EqzI32,\n          module.ref_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Stringref: {\n        return module.unary(UnaryOp.EqzI32,\n          module.string_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter:\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.AddSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.SubSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.MulSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        return module.select(\n          module.i32(1),\n          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),\n          leftExpr,\n          TypeRef.I32\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueI32(leftExpr);\n            let rightValue = getConstValueI32(rightExpr);\n            this.currentType = type;\n            return module.i32(i64_low(i64_pow(\n              i64_new(leftValue),\n              i64_new(rightValue)\n            )));\n          }\n        }\n        let instance = this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n        if (type.size < 32) {\n          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,\n          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?\n          expr = this.ensureSmallIntegerWrap(expr, type);\n        }\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr) == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue = i64_new(getConstValueI64Low(leftExpr), getConstValueI64High(leftExpr));\n            let rightValue = i64_new(getConstValueI64Low(rightExpr), getConstValueI64High(rightExpr));\n            let result = i64_pow(leftValue, rightValue);\n            this.currentType = type;\n            return module.i64(i64_low(result), i64_high(result));\n          }\n        }\n        let instance = this.i64PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow64);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow64\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let isWasm64 = this.options.isWasm64;\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr) == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            if (isWasm64) {\n              let leftValue  = i64_new(getConstValueI64Low(leftExpr), getConstValueI64High(leftExpr));\n              let rightValue = i64_new(getConstValueI64Low(rightExpr), getConstValueI64High(rightExpr));\n              let result = i64_pow(leftValue, rightValue);\n              this.currentType = type;\n              return module.i64(i64_low(result), i64_high(result));\n            } else {\n              let leftValue  = getConstValueI32(leftExpr);\n              let rightValue = getConstValueI32(rightExpr);\n              this.currentType = type;\n              return module.i32(i64_low(i64_pow(\n                i64_new(leftValue),\n                i64_new(rightValue)\n              )));\n            }\n          }\n        }\n        let instance = isWasm64\n          ? this.i64PowInstance\n          : this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(isWasm64\n            ? CommonNames.ipow64\n            : CommonNames.ipow32\n          );\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, isWasm64 ? \"ipow64\" : \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n          if (isWasm64) {\n            this.i64PowInstance = instance;\n          } else {\n            this.i32PowInstance = instance;\n          }\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F32: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueF32(leftExpr);\n            let rightValue = getConstValueF32(rightExpr);\n            this.currentType = type;\n            return module.f32(f32(accuratePow64(leftValue, rightValue)));\n          }\n        }\n        let instance = this.f32PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.pow);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.pow\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      // Math.pow otherwise (result is f64)\n      case TypeKind.F64: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueF64(leftExpr);\n            let rightValue = getConstValueF64(rightExpr);\n            this.currentType = type;\n            return module.f64(accuratePow64(leftValue, rightValue));\n          }\n        }\n        let instance = this.f64PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.pow);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.pow\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.DivISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.DivUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.RemISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.RemUSize, leftExpr, rightExpr);\n      case TypeKind.F32: {\n        let instance = this.f32ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.mod);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.mod\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F64: {\n        let instance = this.f64ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.mod);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.mod\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr << (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShlI32,\n          leftExpr,\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.ShlSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,\n    // and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        // leftExpr >> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrI32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.ShrISize, leftExpr, rightExpr);\n      case TypeKind.U32: return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.ShrUSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.ShrUSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.AndSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.OrSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.XorSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileUnaryOverload(\n    operatorInstance: Function,\n    value: Expression,\n    valueExpr: ExpressionRef,\n    reportNode: Node\n  ): ExpressionRef {\n    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch\n    // is a bad idea currently. so this assumes that the type matches.\n    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);\n  }\n\n  private compileBinaryOverload(\n    operatorInstance: Function,\n    left: Expression,\n    leftExpr: ExpressionRef,\n    leftType: Type,\n    right: Expression,\n    reportNode: Node\n  ): ExpressionRef {\n    let rightType: Type;\n    let signature = operatorInstance.signature;\n    let parameterTypes = signature.parameterTypes;\n    if (operatorInstance.is(CommonFlags.Instance)) {\n      leftExpr = this.convertExpression(leftExpr, leftType, assert(signature.thisType), false, left);\n      rightType = parameterTypes[0];\n    } else {\n      leftExpr = this.convertExpression(leftExpr, leftType, parameterTypes[0], false, left);\n      rightType = parameterTypes[1];\n    }\n    let rightExpr = this.compileExpression(right, rightType, Constraints.ConvImplicit);\n    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);\n  }\n\n  private compileAssignment(\n    expression: Expression,\n    valueExpression: Expression,\n    contextualType: Type\n  ): ExpressionRef {\n    let program = this.program;\n    let resolver = program.resolver;\n    let flow = this.currentFlow;\n    let target = resolver.lookupExpression(expression, flow); // reports\n    if (!target) return this.module.unreachable();\n    let thisExpression = resolver.currentThisExpression;\n    let elementExpression = resolver.currentElementExpression;\n\n    // to compile just the value, we need to know the target's type\n    let targetType: Type;\n    switch (target.kind) {\n      case ElementKind.Global: {\n        // not yet compiled if a static field compiled as a global\n        if (!this.compileGlobal(<Global>target)) return this.module.unreachable(); // reports\n        // fall-through\n      }\n      case ElementKind.Local: {\n        if (this.pendingElements.has(target)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            target.internalName\n          );\n          return this.module.unreachable();\n        }\n        targetType = (<VariableLikeElement>target).type;\n        if (target.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return this.module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        if (propertyInstance.isField) {\n          if (this.pendingElements.has(target)) {\n            this.error(\n              DiagnosticCode.Variable_0_used_before_its_declaration,\n              expression.range,\n              target.internalName\n            );\n            return this.module.unreachable();\n          }\n        }\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            expression.range, propertyInstance.internalName\n          );\n          return this.module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this\n        targetType = setterInstance.signature.parameterTypes[0];\n        if (setterInstance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.IndexSignature: {\n        let parent = (<IndexSignature>target).parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        let isUnchecked = flow.is(FlowFlags.UncheckedContext);\n        let indexedSet = classInstance.lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n        if (!indexedSet) {\n          let indexedGet = classInstance.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n          if (!indexedGet) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              expression.range, classInstance.internalName\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n              expression.range, classInstance.internalName\n            );\n          }\n          return this.module.unreachable();\n        }\n        let parameterTypes = indexedSet.signature.parameterTypes;\n\n        assert(parameterTypes.length == 2); // parser must guarantee this\n        targetType = parameterTypes[1];     // 2nd parameter is the element\n\n        if (indexedSet.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        if (!isUnchecked && this.options.pedantic) {\n          this.pedantic(\n            DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n            expression.range\n          );\n        }\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n          expression.range, target.internalName\n        );\n        return this.module.unreachable();\n      }\n    }\n\n    // compile the value and do the assignment\n    assert(targetType != Type.void);\n    let valueExpr = this.compileExpression(valueExpression, targetType);\n    let valueType = this.currentType;\n    return this.makeAssignment(\n      target,\n      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),\n      valueType,\n      valueExpression,\n      thisExpression,\n      elementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  /** Makes an assignment expression or block, assigning a value to a target. */\n  makeAssignment(\n    /** Target element, e.g. a Local. */\n    target: Element,\n    /** Value expression that has been compiled in a previous step already. */\n    valueExpr: ExpressionRef,\n    /** Value expression type. */\n    valueType: Type,\n    /** Expression reference. Has already been compiled to `valueExpr`. */\n    valueExpression: Expression,\n    /** `this` expression reference if a field or property set. */\n    thisExpression: Expression | null,\n    /** Index expression reference if an indexed set. */\n    indexExpression: Expression | null,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    switch (target.kind) {\n      case ElementKind.Local: {\n        let local = <Local>target;\n        if (flow.isLocalFlag(local.index, LocalFlags.Constant, true)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          this.currentType = tee ? local.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeLocalAssignment(local, valueExpr, valueType, tee);\n      }\n      case ElementKind.Global: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable();\n        if (target.isAny(CommonFlags.Const | CommonFlags.Readonly)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range,\n            target.internalName\n          );\n          this.currentType = tee ? global.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        if (propertyInstance.isField) {\n          // Cannot assign to readonly fields except in constructors if there's no initializer\n          let isConstructor = flow.sourceFunction.is(CommonFlags.Constructor);\n          if (propertyInstance.is(CommonFlags.Readonly)) {\n            let initializerNode = propertyInstance.initializerNode;\n            if (!isConstructor || initializerNode) {\n              this.error(\n                DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n                valueExpression.range, propertyInstance.internalName\n              );\n              return module.unreachable();\n            }\n          }\n          // Mark initialized fields in constructors\n          thisExpression = assert(thisExpression);\n          if (isConstructor && thisExpression.kind == NodeKind.This) {\n            flow.setThisFieldFlag(propertyInstance, FieldFlags.Initialized);\n          }\n        }\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1);\n        if (propertyInstance.is(CommonFlags.Instance)) {\n          let thisType = assert(setterInstance.signature.thisType);\n          let thisExpr = this.compileExpression(\n            assert(thisExpression),\n            thisType,\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          assert(getterInstance.signature.thisType == thisType);\n          let returnType = getterInstance.signature.returnType;\n          let returnTypeRef = returnType.toRef();\n          let tempThis = flow.getTempLocal(returnType);\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempThis.index, thisExpr, returnType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempThis.index, returnTypeRef)\n            ], valueExpression)\n          ], returnTypeRef);\n          return ret;\n        } else {\n          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          return module.block(null, [\n            this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression),\n            this.makeCallDirect(getterInstance, null, valueExpression)\n          ], getterInstance.signature.returnType.toRef());\n        }\n      }\n      case ElementKind.IndexSignature: {\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        assert(classInstance.kind == ElementKind.Class);\n        let isUnchecked = flow.is(FlowFlags.UncheckedContext);\n        let getterInstance = classInstance.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_is_missing_in_type_0,\n            valueExpression.range, classInstance.internalName\n          );\n          return module.unreachable();\n        }\n        let setterInstance = classInstance.lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n            valueExpression.range, classInstance.internalName\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 2);\n        let thisType = classInstance.type;\n        let thisExpr = this.compileExpression(\n          assert(thisExpression),\n          thisType,\n          Constraints.ConvImplicit | Constraints.IsThis\n        );\n        let setterIndexType = setterInstance.signature.parameterTypes[0];\n        let getterIndexType = getterInstance.signature.parameterTypes[0];\n        if (!setterIndexType.equals(getterIndexType)) {\n          this.errorRelated(\n            DiagnosticCode.Index_signature_accessors_in_type_0_differ_in_types,\n            getterInstance.identifierAndSignatureRange,\n            setterInstance.identifierAndSignatureRange,\n            classInstance.internalName,\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        let elementExpr = this.compileExpression(assert(indexExpression), setterIndexType, Constraints.ConvImplicit);\n        let elementType = this.currentType;\n        if (tee) {\n          let tempTarget = flow.getTempLocal(thisType);\n          let tempElement = flow.getTempLocal(elementType);\n          let returnType = getterInstance.signature.returnType;\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempTarget.index, thisExpr, thisType.isManaged),\n              module.local_tee(tempElement.index, elementExpr, elementType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempTarget.index, tempTarget.type.toRef()),\n              module.local_get(tempElement.index, tempElement.type.toRef())\n            ], valueExpression)\n          ], returnType.toRef());\n          return ret;\n        } else {\n          return this.makeCallDirect(setterInstance, [\n            thisExpr,\n            elementExpr,\n            valueExpr\n          ], valueExpression);\n        }\n      }\n      default: {\n        this.error(\n          DiagnosticCode.The_target_of_an_assignment_must_be_a_variable_or_a_property_access,\n          valueExpression.range\n        );\n      }\n    }\n    return module.unreachable();\n  }\n\n  /** Makes an assignment to a local, keeping track of wrap and null states. */\n  private makeLocalAssignment(\n    /** Local to assign to. */\n    local: Local,\n    /** Value to assign. */\n    valueExpr: ExpressionRef,\n    /** Value type. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let type = local.type;\n    assert(type != Type.void);\n    let localIndex = local.index;\n\n    if (type.isNullableReference) {\n      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NonNull);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.NonNull);\n    }\n    flow.setLocalFlag(localIndex, LocalFlags.Initialized);\n    if (type.isShortIntegerValue) {\n      if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.Wrapped);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.Wrapped);\n    }\n    if (tee) { // local = value\n      this.currentType = type;\n      return module.local_tee(localIndex, valueExpr, type.isManaged);\n    } else { // void(local = value)\n      this.currentType = Type.void;\n      return module.local_set(localIndex, valueExpr, type.isManaged);\n    }\n  }\n\n  /** Makes an assignment to a global. */\n  private makeGlobalAssignment(\n    /** The global variable to assign to. */\n    global: VariableLikeElement,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let type = global.type;\n    assert(type != Type.void);\n    let typeRef = type.toRef();\n\n    valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped\n    if (tee) { // (global = value), global\n      this.currentType = type;\n      return module.block(null, [\n        module.global_set(global.internalName, valueExpr),\n        module.global_get(global.internalName, typeRef) // known to be assigned now\n      ], typeRef);\n    } else { // global = value\n      this.currentType = Type.void;\n      return module.global_set(global.internalName,\n        valueExpr\n      );\n    }\n  }\n\n  /** Compiles a call expression according to the specified context. */\n  private compileCallExpression(\n    /** Call expression to compile. */\n    expression: CallExpression,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints\n  ): ExpressionRef {\n\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // handle call to super\n    if (expression.expression.kind == NodeKind.Super) {\n      let flow = this.currentFlow;\n      let sourceFunction = flow.sourceFunction;\n      if (!sourceFunction.is(CommonFlags.Constructor)) {\n        this.error(\n          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,\n          expression.range\n        );\n        return module.unreachable();\n      }\n\n      let parent = assert(sourceFunction.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n      let baseClassInstance = classInstance.base;\n      if (!baseClassInstance || classInstance.prototype.implicitlyExtendsObject) {\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.expression.range\n        );\n        return module.unreachable();\n      }\n      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n      let sizeTypeRef = this.options.sizeTypeRef;\n\n      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);\n      this.checkFieldInitialization(baseClassInstance, expression);\n      let superCall = this.compileCallDirect(\n        baseCtorInstance,\n        expression.args,\n        expression,\n        module.local_get(thisLocal.index, sizeTypeRef)\n      );\n\n      // check that super had been called before accessing `this`\n      if (flow.isAny(\n        FlowFlags.AccessesThis |\n        FlowFlags.ConditionallyAccessesThis\n      )) {\n        this.error(\n          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,\n          expression.range\n        );\n        return module.unreachable();\n      }\n      flow.set(FlowFlags.AccessesThis | FlowFlags.CallsSuper);\n      this.currentType = Type.void;\n      return module.local_set(thisLocal.index, superCall, classInstance.type.isManaged);\n    }\n\n    // otherwise resolve normally\n    let target = this.resolver.lookupExpression(expression.expression, flow); // reports\n    if (!target) return module.unreachable();\n    let thisExpression = this.resolver.currentThisExpression;\n\n    // handle direct call\n    switch (target.kind) {\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        if (functionPrototype.hasDecorator(DecoratorFlags.Builtin)) {\n          // builtins handle present respectively omitted type arguments on their own\n          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);\n        }\n        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);\n        if (!functionInstance) return this.module.unreachable();\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.Function: {\n        let functionInstance = <Function>target;\n        let thisArg: ExpressionRef = 0;\n        if (functionInstance.is(CommonFlags.Instance)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(functionInstance.signature.thisType),\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n        }\n        return this.compileCallDirect(\n          functionInstance,\n          expression.args,\n          expression,\n          thisArg,\n          constraints\n        );\n      }\n    }\n\n    // handle indirect call\n    let functionArg = this.compileExpression(expression.expression, Type.auto);\n    let signature = this.currentType.getSignature();\n    if (signature) {\n      return this.compileCallIndirect(\n        signature,\n        functionArg,\n        expression.args,\n        expression,\n        0,\n        contextualType == Type.void\n      );\n    }\n    this.error(\n      DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n      expression.range, this.currentType.toString()\n    );\n    if (target.kind == ElementKind.PropertyPrototype) {\n      let getterPrototype = (<PropertyPrototype>target).getterPrototype;\n      if (getterPrototype) {\n        this.infoRelated(\n          DiagnosticCode.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without,\n          expression.range, getterPrototype.identifierNode.range\n        );\n      }\n    }\n    return module.unreachable();\n  }\n\n  /** Compiles the given arguments like a call expression according to the specified context. */\n  private compileCallExpressionLike(\n    /** Called expression. */\n    expression: Expression,\n    /** Call type arguments. */\n    typeArguments: TypeNode[] | null,\n    /** Call arguments. */\n    args: Expression[],\n    /** Diagnostic range. */\n    range: Range,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    // Desugaring like this can happen many times. Let's cache the intermediate allocation.\n    let call = this._reusableCallExpression;\n    if (call) {\n      call.expression = expression;\n      call.typeArguments = typeArguments;\n      call.args = args;\n      call.range = range;\n    } else {\n      this._reusableCallExpression = call = Node.createCallExpression(expression, typeArguments, args, range);\n    }\n    return this.compileCallExpression(call, contextualType, constraints);\n  }\n  private _reusableCallExpression: CallExpression | null = null;\n\n  private compileCallExpressionBuiltin(\n    prototype: FunctionPrototype,\n    expression: CallExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (prototype.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n\n    let typeArguments: Type[] | null = null;\n\n    // builtins handle omitted type arguments on their own. if present, however, resolve them here\n    // and pass them to the builtin, even if it's still up to the builtin how to handle them.\n    let typeParameterNodes = prototype.typeParameterNodes;\n    let typeArgumentNodes = expression.typeArguments;\n    if (expression.typeArguments) {\n      if (!prototype.is(CommonFlags.Generic)) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          expression.range, prototype.internalName\n        );\n      }\n      typeArguments = this.resolver.resolveTypeArguments(\n        assert(typeParameterNodes),\n        typeArgumentNodes,\n        this.currentFlow.sourceFunction.parent,\n        cloneMap(this.currentFlow.contextualTypeArguments), // don't update\n        expression\n      );\n    }\n    let callee = expression.expression;\n    let ctx = new BuiltinContext(\n      this,\n      prototype,\n      typeArguments,\n      expression.args,\n      callee.kind == NodeKind.PropertyAccess\n        ? (<PropertyAccessExpression>callee).expression\n        : null,\n      contextualType,\n      expression,\n      false\n    );\n    // global builtins\n    let internalName = prototype.internalName;\n    if (builtins.has(internalName)) {\n      let fn = assert(builtins.get(internalName));\n      return fn(ctx);\n    }\n    // class builtins\n    let parent = prototype.parent;\n    if (parent.kind == ElementKind.Class) {\n      let classPrototype = (<Class>parent).prototype;\n      if (classPrototype == this.program.functionPrototype) {\n        let methodName = prototype.name;\n        if (function_builtins.has(methodName)) {\n          let fn = assert(function_builtins.get(methodName));\n          return fn(ctx);\n        }\n      }\n    }\n    assert(false);\n    return this.module.unreachable();\n  }\n\n  /**\n   * Checks that a call with the given number as arguments can be performed according to the\n   * specified signature.\n   */\n  checkCallSignature(\n    signature: Signature,\n    numArguments: i32,\n    hasThis: bool,\n    reportNode: Node\n  ): bool {\n\n    // cannot call an instance method without a `this` argument (TODO: `.call`?)\n    let thisType = signature.thisType;\n    if (hasThis != (thisType != null)) {\n      this.error(\n        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n        reportNode.range\n      );\n      return false;\n    }\n\n    // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)\n    let hasRest = signature.hasRest;\n    if (hasRest) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        reportNode.range, \"Rest parameters\"\n      );\n      return false;\n    }\n\n    let minimum = signature.requiredParameters;\n    let maximum = signature.parameterTypes.length;\n\n    // must at least be called with required arguments\n    if (numArguments < minimum) {\n      this.error(\n        minimum < maximum\n          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1\n          : DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, minimum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    // must not be called with more than the maximum arguments\n    if (numArguments > maximum && !hasRest) {\n      this.error(\n        DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, maximum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Checks that an unsafe expression is allowed. */\n  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {\n    // Library files may always use unsafe features\n    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {\n      if (relatedReportNode) {\n        this.errorRelated(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range, relatedReportNode.range\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range\n        );\n      }\n    }\n  }\n\n  /** Compiles a direct call to a concrete function. */\n  compileCallDirect(\n    instance: Function,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    let numArguments = argumentExpressions.length;\n    let signature = instance.signature;\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      this.currentType = signature.returnType;\n      return this.module.unreachable();\n    }\n    if (instance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(reportNode);\n\n    // handle call on `this` in constructors\n    let sourceFunction = this.currentFlow.sourceFunction;\n    if (sourceFunction.is(CommonFlags.Constructor) && reportNode.isAccessOnThis) {\n      let parent = sourceFunction.parent;\n      assert(parent.kind == ElementKind.Class);\n      this.checkFieldInitialization(<Class>parent, reportNode);\n    }\n\n    // Inline if explicitly requested\n    if (instance.hasDecorator(DecoratorFlags.Inline) && (!instance.is(CommonFlags.Overridden) || reportNode.isAccessOnSuper)) {\n      assert(!instance.is(CommonFlags.Stub)); // doesn't make sense\n      let inlineStack = this.inlineStack;\n      if (inlineStack.includes(instance)) {\n        this.warning(\n          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n          reportNode.range, instance.internalName\n        );\n      } else {\n        let parameterTypes = signature.parameterTypes;\n        assert(numArguments <= parameterTypes.length);\n        // compile argument expressions *before* pushing to the inline stack\n        // otherwise, the arguments may not be inlined, e.g. `abc(abc(123))`\n        let args = new Array<ExpressionRef>(numArguments);\n        for (let i = 0; i < numArguments; ++i) {\n          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i], Constraints.ConvImplicit);\n        }\n        // make the inlined call\n        inlineStack.push(instance);\n        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WillDrop) != 0);\n        inlineStack.pop();\n        return expr;\n      }\n    }\n\n    // Otherwise compile to just a call\n    let numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    let operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    let index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    let parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      let paramType = parameterTypes[i];\n      let paramExpr = this.compileExpression(argumentExpressions[i], paramType, Constraints.ConvImplicit);\n      operands[index] = paramExpr;\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallDirect(instance, operands, reportNode, (constraints & Constraints.WillDrop) != 0);\n  }\n\n  makeCallInline(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    let module = this.module;\n    let numArguments = operands ? operands.length : 0;\n    let signature = instance.signature;\n    let parameterTypes = signature.parameterTypes;\n    let numParameters = parameterTypes.length;\n\n    // Create a new inline flow and use it to compile the function as a block\n    let previousFlow = this.currentFlow;\n    let flow = Flow.createInline(previousFlow.targetFunction, instance);\n    let body = [];\n\n    if (thisArg) {\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n      let thisType = assert(instance.signature.thisType);\n      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType);\n      body.push(\n        module.local_set(thisLocal.index, thisArg, thisType.isManaged)\n      );\n      flow.setLocalFlag(thisLocal.index, LocalFlags.Initialized);\n      let base = classInstance.base;\n      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);\n    } else {\n      assert(!instance.signature.thisType);\n    }\n    for (let i = 0; i < numArguments; ++i) {\n      let paramExpr = operands![i];\n      let paramType = parameterTypes[i];\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType);\n      // inlining is aware of wrap/nonnull states:\n      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.Wrapped);\n      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NonNull);\n      body.push(\n        module.local_set(argumentLocal.index, paramExpr, paramType.isManaged)\n      );\n      flow.setLocalFlag(argumentLocal.index, LocalFlags.Initialized);\n    }\n\n    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of\n    // side-effects within earlier expressions because these already happened on set.\n    this.currentFlow = flow;\n    let isConstructor = instance.is(CommonFlags.Constructor);\n    if (isConstructor) flow.set(FlowFlags.CtorParamContext);\n    for (let i = numArguments; i < numParameters; ++i) {\n      let initType = parameterTypes[i];\n      let initExpr = this.compileExpression(\n        assert(instance.prototype.functionTypeNode.parameters[i].initializer),\n        initType,\n        Constraints.ConvImplicit\n      );\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);\n      body.push(\n        this.makeLocalAssignment(argumentLocal, initExpr, initType, false)\n      );\n    }\n    flow.unset(FlowFlags.CtorParamContext);\n\n    // Compile the called function's body in the scope of the inlined flow\n    this.compileFunctionBody(instance, body);\n\n    // If a constructor, perform field init checks on its flow directly\n    if (isConstructor) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.Class);\n      this.checkFieldInitializationInFlow(<Class>parent, flow);\n    }\n\n    // Free any new scoped locals and reset to the original flow\n    let returnType = flow.returnType;\n    this.currentFlow = previousFlow;\n\n    // Create an outer block that we can break to when returning a value out of order\n    this.currentType = returnType;\n    return module.block(flow.inlineReturnLabel, body, returnType.toRef());\n  }\n\n  /** Makes sure that the arguments length helper global is present. */\n  ensureArgumentsLength(): string {\n    let name = BuiltinNames.argumentsLength;\n    if (!this.builtinArgumentsLength) {\n      let module = this.module;\n      this.builtinArgumentsLength = module.addGlobal(name, TypeRef.I32, true, module.i32(0));\n    }\n    return name;\n  }\n\n  /** Ensures compilation of the varargs stub for the specified function. */\n  ensureVarargsStub(original: Function): Function {\n    // A varargs stub is a function called with omitted arguments being zeroed,\n    // reading the `argumentsLength` helper global to decide which initializers\n    // to inject before calling the original function. It is typically attempted\n    // to circumvent the varargs stub where possible, for example where omitted\n    // arguments are constants and can be inlined into the original call.\n    let stub = original.varargsStub;\n    if (stub) return stub;\n\n    let originalSignature = original.signature;\n    let originalParameterTypes = originalSignature.parameterTypes;\n    let originalParameterDeclarations = original.prototype.functionTypeNode.parameters;\n    let returnType = originalSignature.returnType;\n    let isInstance = original.is(CommonFlags.Instance);\n\n    // arguments excl. `this`, operands incl. `this`\n    let minArguments = originalSignature.requiredParameters;\n    let minOperands = minArguments;\n    let maxArguments = originalParameterTypes.length;\n    let maxOperands = maxArguments;\n    if (isInstance) {\n      ++minOperands;\n      ++maxOperands;\n    }\n    let numOptional = assert(maxOperands - minOperands);\n\n    let forwardedOperands = new Array<ExpressionRef>(minOperands);\n    let operandIndex = 0;\n    let stmts = new Array<ExpressionRef>();\n\n    // forward `this` if applicable\n    let module = this.module;\n    let thisType = originalSignature.thisType;\n    if (thisType) {\n      forwardedOperands[0] = module.local_get(0, thisType.toRef());\n      operandIndex = 1;\n    }\n\n    // forward required arguments\n    for (let i = 0; i < minArguments; ++i, ++operandIndex) {\n      let paramType = originalParameterTypes[i];\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, paramType.toRef());\n    }\n    assert(operandIndex == minOperands);\n\n    // create the varargs stub\n    stub = original.newStub(\"varargs\", maxArguments);\n\n    original.varargsStub = stub;\n\n    // compile initializers of omitted arguments in the scope of the stub,\n    // accounting for additional locals and a proper `this` context.\n    let previousFlow = this.currentFlow;\n    let flow = stub.flow;\n    if (original.is(CommonFlags.Constructor)) flow.set(FlowFlags.CtorParamContext);\n    this.currentFlow = flow;\n\n    // create a br_table switching over the number of optional parameters provided\n    let numNames = numOptional + 1; // incl. outer block\n    let names = new Array<string>(numNames);\n    let ofN = `of${numOptional}`;\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = `${i}${ofN}`;\n    }\n    let argumentsLength = this.ensureArgumentsLength();\n    let table = module.block(names[0], [\n      module.block(\"outOfRange\", [\n        module.switch(names, \"outOfRange\",\n          // condition is number of provided optional arguments, so subtract required arguments\n          minArguments\n            ? module.binary(\n                BinaryOp.SubI32,\n                module.global_get(argumentsLength, TypeRef.I32),\n                module.i32(minArguments)\n              )\n            : module.global_get(argumentsLength, TypeRef.I32)\n        )\n      ]),\n      module.unreachable()\n    ]);\n    for (let i = 0; i < numOptional; ++i, ++operandIndex) {\n      let type = originalParameterTypes[minArguments + i];\n      let declaration = originalParameterDeclarations[minArguments + i];\n      let initializer = declaration.initializer;\n      let initExpr: ExpressionRef;\n      if (initializer) {\n        initExpr = this.compileExpression(\n          initializer,\n          type,\n          Constraints.ConvImplicit\n        );\n        initExpr = module.local_set(operandIndex, initExpr, type.isManaged);\n      } else {\n        this.error(\n          DiagnosticCode.Optional_parameter_must_have_an_initializer,\n          declaration.range\n        );\n        initExpr = module.unreachable();\n      }\n      table = module.block(names[i + 1], [\n        table,\n        initExpr,\n      ]);\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toRef());\n    }\n    assert(operandIndex == maxOperands);\n\n    stmts.push(\n      table\n    );\n    stmts.push(\n      // assume this will always succeed (can just use name as the reportNode)\n      this.makeCallDirect(original, forwardedOperands, original.declaration.name)\n    );\n    this.currentFlow = previousFlow;\n\n    let funcRef = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      typesToRefs(stub.getNonParameterLocalTypes()),\n      module.flatten(stmts, returnType.toRef())\n    );\n    stub.set(CommonFlags.Compiled);\n    stub.finalize(module, funcRef);\n    return stub;\n  }\n\n  /** Ensures compilation of the override stub for the specified function. */\n  ensureOverrideStub(original: Function): Function {\n    // An override stub is a function redirecting virtual calls to the actual\n    // override targeted by the call. It utilizes varargs stubs where necessary\n    // and as such has the same semantics as one. Here, we only make sure that\n    // a placeholder exist, with actual code being generated as a finalization\n    // step once module compilation is otherwise complete.\n    let stub = original.overrideStub;\n    if (stub) return stub;\n    stub = original.newStub(\"override\");\n    original.overrideStub = stub;\n    let module = this.module;\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      null,\n      module.unreachable()\n    );\n    this.overrideStubs.add(original);\n    return stub;\n  }\n\n  /** Finalizes the override stub of the specified function. */\n  private finalizeOverrideStub(instance: Function): void {\n    let stub = this.ensureOverrideStub(instance);\n    if (stub.is(CommonFlags.Compiled)) return;\n\n    assert(instance.parent.kind == ElementKind.Class || instance.parent.kind == ElementKind.Interface);\n    let module = this.module;\n    let usizeType = this.options.usizeType;\n    let sizeTypeRef = usizeType.toRef();\n    let parameterTypes = instance.signature.parameterTypes;\n    let returnType = instance.signature.returnType;\n    let numParameters = parameterTypes.length;\n    let tempIndex = 1 + parameterTypes.length; // incl. `this`\n\n    // Switch over this's rtId and map it to the respective overload\n    let builder = new SwitchBuilder(this.module,\n      module.load(4, false,\n        module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          module.local_get(0, sizeTypeRef),\n          sizeTypeRef == TypeRef.I64\n            ? module.i64(8) // rtId offset = -8\n            : module.i32(8)\n        ),\n        TypeRef.I32\n      )\n    );\n    let overrideInstances = this.resolver.resolveOverrides(instance);\n    if (overrideInstances) {\n      for (let i = 0, k = overrideInstances.length; i < k; ++i) {\n        let overrideInstance = overrideInstances[i];\n        if (!overrideInstance.is(CommonFlags.Compiled)) continue; // errored\n        let overrideType = overrideInstance.type;\n        let originalType = instance.type;\n        if (!overrideType.isAssignableTo(originalType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            overrideInstance.identifierNode.range, overrideType.toString(), originalType.toString()\n          );\n          continue;\n        }\n        // TODO: additional optional parameters are not permitted by `isAssignableTo` yet\n        let overrideSignature = overrideInstance.signature;\n        let overrideParameterTypes = overrideSignature.parameterTypes;\n        let overrideNumParameters = overrideParameterTypes.length;\n        let paramExprs = new Array<ExpressionRef>(1 + overrideNumParameters);\n        paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n        for (let n = 1; n <= numParameters; ++n) {\n          paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toRef());\n        }\n        let needsVarargsStub = false;\n        for (let n = numParameters; n < overrideNumParameters; ++n) {\n          // TODO: inline constant initializers and skip varargs stub\n          paramExprs[1 + n] = this.makeZero(overrideParameterTypes[n]);\n          needsVarargsStub = true;\n        }\n        let calledName = needsVarargsStub\n          ? this.ensureVarargsStub(overrideInstance).internalName\n          : overrideInstance.internalName;\n        let returnTypeRef = overrideSignature.returnType.toRef();\n        let stmts = new Array<ExpressionRef>();\n        if (needsVarargsStub) {\n          // Safe to prepend since paramExprs are local.get's\n          stmts.push(module.global_set(this.ensureArgumentsLength(), module.i32(numParameters)));\n        }\n        if (returnType == Type.void) {\n          stmts.push(\n            module.call(calledName, paramExprs, returnTypeRef)\n          );\n          stmts.push(\n            module.return()\n          );\n        } else {\n          stmts.push(\n            module.return(\n              module.call(calledName, paramExprs, returnTypeRef)\n            )\n          );\n        }\n        let classInstance = assert(overrideInstance.getBoundClassOrInterface());\n        builder.addCase(classInstance.id, stmts);\n        // Also alias each extender inheriting this exact overload\n        let extenders = classInstance.extenders;\n        if (extenders) {\n          for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n            let extender = _values[i];\n            let instanceMembers = extender.prototype.instanceMembers;\n            if (instanceMembers && instanceMembers.has(instance.declaration.name.text)) {\n              continue; // skip those not inheriting\n            }\n            builder.addCase(extender.id, stmts);\n          }\n        }\n      }\n    }\n\n    // Call the original function if no other id matches and the method is not\n    // abstract or part of an interface. Note that doing so will not catch an\n    // invalid id, but can reduce code size significantly since we also don't\n    // have to add branches for extenders inheriting the original function.\n    let body: ExpressionRef;\n    let instanceClass = instance.getBoundClassOrInterface();\n    if (!instance.is(CommonFlags.Abstract) && !(instanceClass && instanceClass.kind == ElementKind.Interface)) {\n      let paramExprs = new Array<ExpressionRef>(numParameters);\n      paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toRef());\n      }\n      body = module.call(instance.internalName, paramExprs, returnType.toRef());\n\n    // Otherwise trap\n    } else {\n      body = module.unreachable();\n    }\n\n    // Create the stub function\n    let ref = stub.ref;\n    if (ref) module.removeFunction(stub.internalName);\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      [ TypeRef.I32 ],\n      module.block(null, [\n        builder.render(tempIndex),\n        body\n      ], returnType.toRef())\n    );\n    stub.set(CommonFlags.Compiled);\n  }\n\n  /** Marks managed call operands for the shadow stack. */\n  private operandsTostack(signature: Signature, operands: ExpressionRef[]): void {\n    if (!this.options.stackSize) return;\n    let module = this.module;\n    let operandIndex = 0;\n    let thisType = signature.thisType;\n    if (thisType) {\n      if (thisType.isManaged) {\n        let operand = operands[0];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n    }\n    let parameterIndex = 0;\n    let parameterTypes = signature.parameterTypes;\n    assert(parameterTypes.length >= operands.length - operandIndex);\n    while (operandIndex < operands.length) {\n      let paramType = parameterTypes[parameterIndex];\n      if (paramType.isManaged) {\n        let operand = operands[operandIndex];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n      ++parameterIndex;\n    }\n  }\n\n  /** Creates a direct call to the specified function. */\n  makeCallDirect(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    reportNode: Node,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    if (instance.hasDecorator(DecoratorFlags.Inline)) {\n      if (!instance.is(CommonFlags.Overridden)) {\n        assert(!instance.is(CommonFlags.Stub)); // doesn't make sense\n        let inlineStack = this.inlineStack;\n        if (inlineStack.includes(instance)) {\n          this.warning(\n            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n            reportNode.range, instance.internalName\n          );\n        } else {\n          inlineStack.push(instance);\n          let expr: ExpressionRef;\n          if (instance.is(CommonFlags.Instance)) {\n            let theOperands = assert(operands);\n            assert(theOperands.length);\n            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);\n          } else {\n            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);\n          }\n          inlineStack.pop();\n          return expr;\n        }\n      } else {\n        this.warning(\n          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,\n          reportNode.range, instance.internalName\n        );\n      }\n    }\n    let module = this.module;\n    let numOperands = operands ? operands.length : 0;\n    let numArguments = numOperands;\n    let minArguments = instance.signature.requiredParameters;\n    let minOperands = minArguments;\n    let parameterTypes = instance.signature.parameterTypes;\n    let maxArguments = parameterTypes.length;\n    let maxOperands = maxArguments;\n    if (instance.is(CommonFlags.Instance)) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    if (!this.compileFunction(instance)) return module.unreachable();\n    let returnType = instance.signature.returnType;\n\n    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterNodes = instance.prototype.functionTypeNode.parameters;\n      assert(parameterNodes.length == parameterTypes.length);\n      let allOptionalsAreConstant = true;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        let initializer = parameterNodes[i].initializer;\n        if (initializer) {\n          if (initializer.compilesToConst) {\n            operands.push(this.compileExpression(\n              initializer,\n              parameterTypes[i],\n              Constraints.ConvImplicit\n            ));\n            continue;\n          }\n          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.Swallow);\n          if (resolved && resolved.kind == ElementKind.Global) {\n            let global = <Global>resolved;\n            if (this.compileGlobal(global) && global.is(CommonFlags.Inlined)) {\n              operands.push(\n                this.compileInlineConstant(global, parameterTypes[i], Constraints.ConvImplicit)\n              );\n              continue;\n            }\n          }\n        }\n        operands.push(this.makeZero(parameterTypes[i]));\n        allOptionalsAreConstant = false;\n      }\n      if (!allOptionalsAreConstant && !instance.is(CommonFlags.ModuleImport)) {\n        let original = instance;\n        instance = this.ensureVarargsStub(instance);\n        if (!this.compileFunction(instance)) return module.unreachable();\n        instance.flow.flags = original.flow.flags;\n        let returnTypeRef = returnType.toRef();\n        // We know the last operand is optional and omitted, so inject setting\n        // ~argumentsLength into that operand, which is always safe.\n        let lastOperand = operands[maxOperands - 1];\n        assert(!(getSideEffects(lastOperand, module.ref) & SideEffects.WritesGlobal));\n        let lastOperandType = parameterTypes[maxArguments - 1];\n        operands[maxOperands - 1] = module.block(null, [\n          module.global_set(this.ensureArgumentsLength(), module.i32(numArguments)),\n          lastOperand\n        ], lastOperandType.toRef());\n        this.operandsTostack(instance.signature, operands);\n        let expr = module.call(instance.internalName, operands, returnTypeRef);\n        if (returnType != Type.void && immediatelyDropped) {\n          expr = module.drop(expr);\n          this.currentType = Type.void;\n        } else {\n          this.currentType = returnType;\n        }\n        return expr;\n      }\n    }\n\n    // Call the override stub if the function has overloads\n    if (instance.is(CommonFlags.Overridden) && !reportNode.isAccessOnSuper) {\n      instance = this.ensureOverrideStub(instance);\n    }\n\n    if (operands) this.operandsTostack(instance.signature, operands);\n    let expr = module.call(instance.internalName, operands, returnType.toRef());\n    this.currentType = returnType;\n    return expr;\n  }\n\n  /** Compiles an indirect call to a first-class function. */\n  compileCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    let numArguments = argumentExpressions.length;\n\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      return this.module.unreachable();\n    }\n\n    let numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    let operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    let index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    let parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.ConvImplicit\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallIndirect(signature, functionArg, reportNode, operands, immediatelyDropped);\n  }\n\n  /** Creates an indirect call to a first-class function. */\n  makeCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    reportNode: Node,\n    operands: ExpressionRef[] | null = null,\n    immediatelyDropped: bool = false,\n  ): ExpressionRef {\n    let module = this.module;\n    let numOperands = operands ? operands.length : 0;\n    let numArguments = numOperands;\n    let minArguments = signature.requiredParameters;\n    let minOperands = minArguments;\n    let parameterTypes = signature.parameterTypes;\n    let returnType = signature.returnType;\n    let maxArguments = parameterTypes.length;\n    let maxOperands = maxArguments;\n    if (signature.thisType) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    // fill up omitted arguments with zeroes\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        operands.push(this.makeZero(parameterTypes[i]));\n      }\n    }\n\n    // We might be calling a varargs stub here, even if all operands have been\n    // provided, so we must set `argumentsLength` in any case. Inject setting it\n    // into the index argument, which becomes executed last after any operands.\n    let argumentsLength = this.ensureArgumentsLength();\n    let sizeTypeRef = this.options.sizeTypeRef;\n    if (getSideEffects(functionArg, module.ref) & SideEffects.WritesGlobal) {\n      let flow = this.currentFlow;\n      let temp = flow.getTempLocal(this.options.usizeType);\n      let tempIndex = temp.index;\n      functionArg = module.block(null, [\n        module.local_set(tempIndex, functionArg, true), // Function\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        module.local_get(tempIndex, sizeTypeRef)\n      ], sizeTypeRef);\n    } else { // simplify\n      functionArg = module.block(null, [\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        functionArg\n      ], sizeTypeRef);\n    }\n    if (operands) this.operandsTostack(signature, operands);\n    let expr = module.call_indirect(\n      null, // TODO: handle multiple tables\n      module.load(4, false, functionArg, TypeRef.I32), // ._index\n      operands,\n      signature.paramRefs,\n      signature.resultRefs\n    );\n    this.currentType = returnType;\n    return expr;\n  }\n\n  private compileCommaExpression(\n    expression: CommaExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let expressions = expression.expressions;\n    let numExpressions = expressions.length;\n    let exprs = new Array<ExpressionRef>(numExpressions--);\n    for (let i = 0; i < numExpressions; ++i) {\n      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last\n        Constraints.ConvImplicit | Constraints.WillDrop\n      );\n    }\n    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);\n    return this.module.flatten(exprs, this.currentType.toRef());\n  }\n\n  private compileElementAccessExpression(\n    expression: ElementAccessExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let targetExpression = expression.expression;\n    let targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports\n    if (targetType) {\n      let classReference = targetType.getClassOrWrapper(this.program);\n      if (classReference) {\n        let isUnchecked = this.currentFlow.is(FlowFlags.UncheckedContext);\n        let indexedGet = classReference.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n        if (indexedGet) {\n          let thisType = assert(indexedGet.signature.thisType);\n          let thisArg = this.compileExpression(targetExpression, thisType,\n            Constraints.ConvImplicit\n          );\n          if (!isUnchecked && this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n              expression.range\n            );\n          }\n          return this.compileCallDirect(indexedGet, [\n            expression.elementExpression\n          ], expression, thisArg, constraints);\n        }\n      }\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        expression.expression.range, targetType.toString()\n      );\n    }\n    return module.unreachable();\n  }\n\n  private compileFunctionExpression(\n    expression: FunctionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let declaration = expression.declaration.clone(); // generic contexts can have multiple\n    assert(!declaration.typeParameters); // function expression cannot be generic\n    let flow = this.currentFlow;\n    let sourceFunction = flow.sourceFunction;\n    let isNamed = declaration.name.text.length > 0;\n    let isSemanticallyAnonymous = !isNamed || contextualType != Type.void;\n    let prototype = new FunctionPrototype(\n      isSemanticallyAnonymous\n        ? `${isNamed ? declaration.name.text : \"anonymous\"}|${sourceFunction.nextAnonymousId++}`\n        : declaration.name.text,\n      sourceFunction,\n      declaration,\n      DecoratorFlags.None\n    );\n    let instance: Function | null;\n    let contextualTypeArguments = cloneMap(flow.contextualTypeArguments);\n    let module = this.module;\n\n    // compile according to context. this differs from a normal function in that omitted parameter\n    // and return types can be inferred and omitted arguments can be replaced with dummies.\n    let contextualSignature = contextualType.signatureReference;\n    if (contextualSignature) {\n      let signatureNode = prototype.functionTypeNode;\n      let parameterNodes = signatureNode.parameters;\n      let numPresentParameters = parameterNodes.length;\n\n      // must not require more than the maximum number of parameters\n      let parameterTypes = contextualSignature.parameterTypes;\n      let numParameters = parameterTypes.length;\n      if (numPresentParameters > numParameters) {\n        this.error(\n          DiagnosticCode.Expected_0_arguments_but_got_1,\n          expression.range, numParameters.toString(), numPresentParameters.toString()\n        );\n        return module.unreachable();\n      }\n\n      // check non-omitted parameter types\n      for (let i = 0; i < numPresentParameters; ++i) {\n        let parameterNode = parameterNodes[i];\n        if (!isTypeOmitted(parameterNode.type)) {\n          let resolvedType = this.resolver.resolveType(\n            parameterNode.type,\n            sourceFunction.parent,\n            contextualTypeArguments\n          );\n          if (!resolvedType) return module.unreachable();\n          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        // any unused parameters are inherited but ignored\n      }\n\n      // check non-omitted return type\n      let returnType = contextualSignature.returnType;\n      if (!isTypeOmitted(signatureNode.returnType)) {\n        let resolvedType = this.resolver.resolveType(\n          signatureNode.returnType,\n          sourceFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (\n          returnType == Type.void\n            ? resolvedType != Type.void\n            : !resolvedType.isStrictlyAssignableTo(returnType)\n        ) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      // check explicit this type\n      let thisType = contextualSignature.thisType;\n      let thisTypeNode = signatureNode.explicitThisType;\n      if (thisTypeNode) {\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            thisTypeNode.range\n          );\n          return module.unreachable();\n        }\n        let resolvedType = this.resolver.resolveType(\n          thisTypeNode,\n          sourceFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (!thisType.isStrictlyAssignableTo(resolvedType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            thisTypeNode.range, thisType.toString(), resolvedType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      let signature = Signature.create(this.program, parameterTypes, returnType, thisType, numParameters);\n      instance = new Function(\n        prototype.name,\n        prototype,\n        null,\n        signature,\n        contextualTypeArguments\n      );\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = contextualSignature.type;\n      if (!worked) return module.unreachable();\n\n    // otherwise compile like a normal function\n    } else {\n      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);\n      if (!instance) return this.module.unreachable();\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = instance.signature.type;\n      if (!worked) return module.unreachable();\n    }\n\n    let offset = this.ensureRuntimeFunction(instance); // reports\n    let expr = this.options.isWasm64\n      ? module.i64(i64_low(offset), i64_high(offset))\n      : module.i32(i64_low(offset));\n\n    // add a constant local referring to the function if applicable\n    if (!isSemanticallyAnonymous) {\n      let fname = instance.name;\n      let existingLocal = flow.getScopedLocal(fname);\n      if (existingLocal) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existingLocal.declaration.name.range,\n            fname\n          );\n        } else { // scoped locals are shared temps that don't track declarations\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range, fname\n          );\n        }\n      } else {\n        let ftype = instance.type;\n        let local = flow.addScopedLocal(instance.name, ftype);\n        flow.setLocalFlag(local.index, LocalFlags.Constant | LocalFlags.Initialized);\n        expr = module.local_tee(local.index, expr, ftype.isManaged);\n      }\n    }\n\n    return expr;\n  }\n\n  /** Makes sure the enclosing source file of the specified expression has been compiled. */\n  private maybeCompileEnclosingSource(expression: Expression): void {\n    let internalPath = expression.range.source.internalPath;\n    let filesByName = this.program.filesByName;\n    assert(filesByName.has(internalPath));\n    let enclosingFile = assert(filesByName.get(internalPath));\n    if (!enclosingFile.is(CommonFlags.Compiled)) {\n      this.compileFileByPath(internalPath, expression);\n    }\n  }\n\n  private compileIdentifierExpression(\n    expression: IdentifierExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let sourceFunction = flow.sourceFunction;\n\n    // check special keywords first\n    switch (expression.kind) {\n      case NodeKind.Null: {\n        let options = this.options;\n        if (contextualType.isReference) {\n          let classReference = contextualType.getClass();\n          if (classReference) {\n            this.currentType = classReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          let signatureReference = contextualType.getSignature();\n          if (signatureReference) {\n            this.currentType = signatureReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          return this.makeZero(contextualType);\n        }\n        this.currentType = options.usizeType;\n        this.warning(\n          DiagnosticCode.Expression_resolves_to_unusual_type_0,\n          expression.range, this.currentType.toString()\n        );\n        return options.isWasm64\n          ? module.i64(0)\n          : module.i32(0);\n      }\n      case NodeKind.True: {\n        this.currentType = Type.bool;\n        return module.i32(1);\n      }\n      case NodeKind.False: {\n        this.currentType = Type.bool;\n        return module.i32(0);\n      }\n      case NodeKind.This: {\n        let thisType = sourceFunction.signature.thisType;\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            expression.range\n          );\n          this.currentType = this.options.usizeType;\n          return module.unreachable();\n        }\n        if (sourceFunction.is(CommonFlags.Constructor)) {\n          if (flow.is(FlowFlags.CtorParamContext)) {\n            this.error(\n              DiagnosticCode._this_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          }\n          if (!(constraints & Constraints.IsThis)) {\n            let parent = sourceFunction.parent;\n            assert(parent.kind == ElementKind.Class);\n            this.checkFieldInitialization(<Class>parent, expression);\n          }\n        }\n        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n        flow.set(FlowFlags.AccessesThis);\n        this.currentType = thisType;\n        return module.local_get(thisLocal.index, thisType.toRef());\n      }\n      case NodeKind.Super: {\n        if (sourceFunction.is(CommonFlags.Constructor)) {\n          if (flow.is(FlowFlags.CtorParamContext)) {\n            this.error(\n              DiagnosticCode._super_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          } else if (!flow.is(FlowFlags.CallsSuper)) {\n            // TS1034 in the parser effectively limits this to property accesses\n            this.error(\n              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,\n              expression.range\n            );\n          }\n        }\n        if (flow.isInline) {\n          let scopedThis = flow.lookupLocal(CommonNames.this_);\n          if (scopedThis) {\n            let scopedThisClass = assert(scopedThis.type.getClass());\n            let base = scopedThisClass.base;\n            if (base) {\n              this.currentType = base.type;\n              return module.local_get(scopedThis.index, base.type.toRef());\n            }\n          }\n        }\n        if (sourceFunction.is(CommonFlags.Instance)) {\n          let parent = assert(sourceFunction.parent);\n          assert(parent.kind == ElementKind.Class);\n          let classInstance = <Class>parent;\n          let baseClassInstance = classInstance.base;\n          if (baseClassInstance) {\n            let superType = baseClassInstance.type;\n            this.currentType = superType;\n            return module.local_get(0, superType.toRef());\n          }\n        }\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.range\n        );\n        this.currentType = this.options.usizeType;\n        return module.unreachable();\n      }\n    }\n\n    this.maybeCompileEnclosingSource(expression);\n\n    // otherwise resolve\n    let currentParent = this.currentParent;\n    if (!currentParent) currentParent = sourceFunction;\n    let target = this.resolver.lookupIdentifierExpression( // reports\n      expression,\n      flow,\n      currentParent\n    );\n    if (!target) {\n      // make a guess to avoid assertions in calling code\n      if (this.currentType == Type.void) this.currentType = Type.i32;\n      return module.unreachable();\n    }\n\n    switch (target.kind) {\n      case ElementKind.Local: {\n        let local = <Local>target;\n        let localType = local.type;\n        assert(localType != Type.void);\n        if (this.pendingElements.has(local)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            local.internalName\n          );\n          this.currentType = localType;\n          return module.unreachable();\n        }\n        if (local.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(local, contextualType, constraints);\n        }\n        let localIndex = local.index;\n        if (!flow.isLocalFlag(localIndex, LocalFlags.Initialized)) {\n          this.error(\n            DiagnosticCode.Variable_0_is_used_before_being_assigned,\n            expression.range, local.name\n          );\n        }\n        assert(localIndex >= 0);\n        if (localType.isNullableReference && flow.isLocalFlag(localIndex, LocalFlags.NonNull, false)) {\n          localType = localType.nonNullableType;\n        }\n        this.currentType = localType;\n\n        if (target.parent != flow.targetFunction) {\n          // TODO: closures\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range,\n            \"Closures\"\n          );\n          return module.unreachable();\n        }\n        return module.local_get(localIndex, localType.toRef());\n      }\n      case ElementKind.Global: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) { // reports; not yet compiled if a static field\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        assert(globalType != Type.void);\n        if (global.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(global, contextualType, constraints);\n        }\n        let expr = module.global_get(global.internalName, globalType.toRef());\n        if (global.is(CommonFlags.DefinitelyAssigned) && globalType.isReference && !globalType.isNullableReference) {\n          expr = this.makeRuntimeNonNullCheck(expr, globalType, expression);\n        }\n        this.currentType = globalType;\n        return expr;\n      }\n      case ElementKind.EnumValue: { // here: if referenced from within the same enum\n        let enumValue = <EnumValue>target;\n        if (!target.is(CommonFlags.Compiled)) {\n          this.error(\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\n            expression.range\n          );\n          this.currentType = Type.i32;\n          return module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.Inlined)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.Integer);\n          return module.i32(i64_low(enumValue.constantIntegerValue));\n        }\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\n\n        if (typeParameterNodes && typeParameterNodes.length != 0) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            expression.range\n          );\n          break; // also diagnose 'not a value at runtime'\n        }\n\n        let functionInstance = this.resolver.resolveFunction(\n          functionPrototype,\n          null,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();\n        if (functionInstance.hasDecorator(DecoratorFlags.Builtin)) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range, \"First-class built-ins\"\n          );\n          this.currentType = functionInstance.type;\n          return module.unreachable();\n        }\n        if (contextualType.isExternalReference) {\n          // TODO: Concrete function types currently map to first class functions implemented in\n          // linear memory (on top of `usize`), leaving only generic `funcref` for use here. In the\n          // future, once functions become Wasm GC objects, the actual signature type can be used.\n          this.currentType = Type.funcref;\n          return module.ref_func(functionInstance.internalName, ensureType(functionInstance.type));\n        }\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        this.currentType = functionInstance.signature.type;\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return module.unreachable();\n  }\n\n  private compileInstanceOfExpression(\n    expression: InstanceOfExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let flow = this.currentFlow;\n    let isType = expression.isType;\n\n    // Mimic `instanceof CLASS`\n    if (isType.kind == NodeKind.NamedType) {\n      let namedType = <NamedTypeNode>isType;\n      if (!(namedType.isNullable || namedType.hasTypeArguments)) {\n        let element = this.resolver.resolveTypeName(namedType.name, flow.sourceFunction, ReportMode.Swallow);\n        if (element && element.kind == ElementKind.ClassPrototype) {\n          let prototype = <ClassPrototype>element;\n          if (prototype.is(CommonFlags.Generic)) {\n            return this.makeInstanceofClass(expression, prototype);\n          }\n        }\n      }\n    }\n\n    // Fall back to `instanceof TYPE`\n    let expectedType = this.resolver.resolveType(\n      expression.isType,\n      flow.sourceFunction,\n      cloneMap(flow.contextualTypeArguments)\n    );\n    if (!expectedType) {\n      this.currentType = Type.bool;\n      return this.module.unreachable();\n    }\n    return this.makeInstanceofType(expression, expectedType);\n  }\n\n  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let expr = this.compileExpression(expression.expression, expectedType);\n    let actualType = this.currentType;\n    this.currentType = Type.bool;\n\n    // instanceof <value> - must be exact\n    if (expectedType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));\n    }\n\n    // <value> instanceof <nonValue> - always false\n    if (actualType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(0));\n    }\n\n    // both LHS and RHS are references now\n    let sizeTypeRef = actualType.toRef();\n\n    // <nullable> instanceof <nonNullable> - LHS must be != 0\n    if (actualType.isNullableReference && !expectedType.isNullableReference) {\n\n      // same or upcast - check statically\n      if (actualType.nonNullableType.isAssignableTo(expectedType)) {\n        return module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          expr,\n          this.makeZero(actualType)\n        );\n      }\n\n      // potential downcast - check dynamically\n      if (actualType.nonNullableType.hasSubtypeAssignableTo(expectedType)) {\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,\n              expression.range\n            );\n          }\n          let temp = flow.getTempLocal(actualType);\n          let tempIndex = temp.index;\n          return module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(tempIndex, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            module.call(this.prepareInstanceOf(expectedType.classReference!), [\n              module.local_get(tempIndex, sizeTypeRef)\n            ], TypeRef.I32)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n\n    // either none or both nullable\n    } else {\n\n      // same or upcast - check statically\n      if (actualType.isAssignableTo(expectedType)) {\n        return module.maybeDropCondition(expr, module.i32(1));\n      }\n\n      // potential downcast - check dynamically\n      if (actualType.hasSubtypeAssignableTo(expectedType)) {\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          let temp = flow.getTempLocal(actualType);\n          let tempIndex = temp.index;\n          return module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(tempIndex, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            module.call(this.prepareInstanceOf(expectedType.classReference!), [\n              module.local_get(tempIndex, sizeTypeRef)\n            ], TypeRef.I32)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  /** Prepares the instanceof helper for the given class or interface instance. */\n  private prepareInstanceOf(instance: Class): string {\n    let name = `~instanceof|${instance.internalName}`;\n    let pending = this.pendingInstanceOf;\n    if (pending.has(instance)) return assert(pending.get(instance));\n    pending.set(instance, name);\n    let module = this.module;\n    module.addFunction(name, this.options.sizeTypeRef, TypeRef.I32, null,\n      module.unreachable()\n    );\n    return name;\n  }\n\n  /** Finalizes the instanceof helper of the given class or interface instance. */\n  private finalizeInstanceOf(\n    /** Class to finalize the helper for. */\n    instance: Class,\n    /** Name of the helper function. */\n    name: string\n  ): void {\n    let program = this.program;\n    let module = this.module;\n    let sizeType = this.options.sizeTypeRef;\n    let stmts = new Array<ExpressionRef>();\n    // (block $is_instance\n    //  (local.set $1 (i32.load (...))) ;; class id\n    //  (br_if $is_instance (i32.eq (local.get $1) (ID)))\n    //  ...\n    //  (return (i32.const 0))\n    // )\n    // (i32.const 1)\n    stmts.push(\n      module.local_set(1,\n        module.load(4, false,\n          module.binary(\n            sizeType == TypeRef.I64\n              ? BinaryOp.SubI64\n              : BinaryOp.SubI32,\n            module.local_get(0, sizeType),\n            module.i32(\n              program.totalOverhead - program.OBJECTInstance.offsetof(\"rtId\")\n            )\n          ),\n          TypeRef.I32\n        ), false // managedness is irrelevant here, isn't interrupted\n      )\n    );\n    let allInstances: Set<Class> | null;\n    if (instance.isInterface) {\n      allInstances = instance.implementers;\n    } else {\n      allInstances = new Set();\n      allInstances.add(instance);\n      let extenders = instance.extenders;\n      if (extenders) {\n        for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n          let extender = _values[i];\n          allInstances.add(extender);\n        }\n      }\n    }\n    if (allInstances) {\n      for (let _values = Set_values(allInstances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = _values[i];\n        stmts.push(\n          module.br(\"is_instance\",\n            module.binary(BinaryOp.EqI32,\n              module.local_get(1, TypeRef.I32),\n              module.i32(instance.id)\n            )\n          )\n        );\n      }\n    }\n    stmts.push(\n      module.return(\n        module.i32(0)\n      )\n    );\n    stmts[0] = module.block(\"is_instance\", stmts, TypeRef.None);\n    stmts.length = 1;\n    stmts.push(\n      module.i32(1)\n    ); \n    module.removeFunction(name);\n    module.addFunction(name, sizeType, TypeRef.I32, [ TypeRef.I32 ], module.block(null, stmts, TypeRef.I32));\n  }\n\n  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {\n    let module = this.module;\n    let expr = this.compileExpression(expression.expression, Type.auto);\n    let actualType = this.currentType;\n    let sizeTypeRef = actualType.toRef();\n\n    this.currentType = Type.bool;\n\n    // exclusively interested in class references here\n    let classReference = actualType.getClass();\n    if (classReference) {\n\n      // static check\n      if (classReference.extendsPrototype(prototype)) {\n\n        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0\n        if (actualType.isNullableReference) {\n          return module.binary(\n            sizeTypeRef == TypeRef.I64\n              ? BinaryOp.NeI64\n              : BinaryOp.NeI32,\n            expr,\n            this.makeZero(actualType)\n          );\n\n        // <nonNullable> is just `true`\n        } else {\n          return module.maybeDropCondition(expr, module.i32(1));\n        }\n\n      // dynamic check against all possible concrete ids\n      } else if (prototype.extends(classReference.prototype)) {\n        let flow = this.currentFlow;\n        let temp = flow.getTempLocal(actualType);\n        let tempIndex = temp.index;\n        // !(t = expr) ? 0 : anyinstanceof(t)\n        return module.if(\n          module.unary(\n            sizeTypeRef == TypeRef.I64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            module.local_tee(tempIndex, expr, actualType.isManaged),\n          ),\n          module.i32(0),\n          module.call(this.prepareAnyInstanceOf(prototype), [\n            module.local_get(tempIndex, sizeTypeRef)\n          ], TypeRef.I32)\n        );\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  /** Prepares the instanceof helper for the given class or interface prototype. */\n  private prepareAnyInstanceOf(prototype: ClassPrototype): string {\n    let name = `~anyinstanceof|${prototype.internalName}`;\n    let pending = this.pendingInstanceOf;\n    if (pending.has(prototype)) return assert(pending.get(prototype));\n    pending.set(prototype, name);\n    let module = this.module;\n    module.addFunction(name, this.options.sizeTypeRef, TypeRef.I32, null,\n      module.unreachable()\n    );\n    return name;\n  }\n\n  /** Finalizes the instanceof helper of the given class prototype. */\n  private finalizeAnyInstanceOf(prototype: ClassPrototype, name: string): void {\n    let module = this.module;\n    let sizeType = this.options.sizeTypeRef;\n    let stmts = new Array<ExpressionRef>();\n    let instances = prototype.instances;\n    // (block $is_instance\n    //  (local.set $1 (i32.load(...)))\n    //  (br_if $is_instance (i32.eq (local.get $1) (ID))\n    //  ...\n    //  (return (i32.const 0))\n    // )\n    // (i32.const 1)\n    if (instances) {\n      let program = this.program;\n      stmts.push(\n        module.local_set(1,\n          module.load(4, false,\n            module.binary(\n              sizeType == TypeRef.I64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              module.local_get(0, sizeType),\n              module.i32(\n                program.totalOverhead - program.OBJECTInstance.offsetof(\"rtId\")\n              )\n            ),\n            TypeRef.I32\n          ), false // managedness is irrelevant here, isn't interrupted\n        )\n      );\n      let allInstances = new Set<Class>();\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = _values[i];\n        if (instance.isInterface) {\n          let implementers = instance.implementers;\n          if (implementers) {\n            for (let _values = Set_values(implementers), i = 0, k = _values.length; i < k; ++i) {\n              let implementer = _values[i];\n              allInstances.add(implementer);\n            }\n          }\n        } else {\n          allInstances.add(instance);\n          let extenders = instance.extenders;\n          if (extenders) {\n            for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n              let extender = _values[i];\n              allInstances.add(extender);\n            }\n          }\n        }\n      }\n      for (let _values = Set_values(allInstances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = _values[i];\n        stmts.push(\n          module.br(\"is_instance\",\n            module.binary(BinaryOp.EqI32,\n              module.local_get(1, TypeRef.I32),\n              module.i32(instance.id)\n            )\n          )\n        );\n      }\n    }\n    stmts.push(\n      module.return(\n        module.i32(0)\n      )\n    );\n    stmts[0] = module.block(\"is_instance\", stmts, TypeRef.None);\n    stmts.length = 1;\n    stmts.push(\n      module.i32(1)\n    );\n    module.removeFunction(name);\n    module.addFunction(name, sizeType, TypeRef.I32, [ TypeRef.I32 ], module.block(null, stmts, TypeRef.I32));\n  }\n\n  private compileLiteralExpression(\n    expression: LiteralExpression,\n    contextualType: Type,\n    constraints: Constraints,\n    implicitlyNegate: bool = false\n  ): ExpressionRef {\n    let module = this.module;\n    switch (expression.literalKind) {\n      case LiteralKind.Array: {\n        assert(!implicitlyNegate);\n        return this.compileArrayLiteral(\n          <ArrayLiteralExpression>expression,\n          contextualType,\n          constraints\n        );\n      }\n      case LiteralKind.Float: {\n        let floatValue = (<FloatLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          floatValue = -floatValue;\n        }\n        if (contextualType == Type.f32) {\n          return module.f32(<f32>floatValue);\n        }\n        this.currentType = Type.f64;\n        return module.f64(floatValue);\n      }\n      case LiteralKind.Integer: {\n        let expr = <IntegerLiteralExpression>expression;\n        let type = this.resolver.determineIntegerLiteralType(expr, implicitlyNegate, contextualType);\n        this.currentType = type;\n        let intValue = expr.value;\n        let sign = 1.0; // should multiply for float literals\n        if (implicitlyNegate) {\n          if (type.isFloatValue) {\n            sign = -1.0;\n          } else {\n            intValue = i64_neg(intValue);\n          }\n        }\n        switch (type.kind) {\n          case TypeKind.Isize: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.Usize: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.F32: return module.f32(<f32>sign * i64_to_f32(intValue));\n          case TypeKind.F64: return module.f64(sign * i64_to_f64(intValue));\n          default: return module.i32(i64_low(intValue));\n        }\n      }\n      case LiteralKind.String: {\n        assert(!implicitlyNegate);\n        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.Template: {\n        assert(!implicitlyNegate);\n        return this.compileTemplateLiteral(<TemplateLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.Object: {\n        assert(!implicitlyNegate);\n        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);\n      }\n      case LiteralKind.RegExp: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Regular expressions\"\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileStringLiteral(\n    expression: StringLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    return this.ensureStaticString(expression.value);\n  }\n\n  private compileTemplateLiteral(\n    expression: TemplateLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    let tag = expression.tag;\n    let parts = expression.parts;\n    let numParts = parts.length;\n    let expressions = expression.expressions;\n    let numExpressions = expressions.length;\n    assert(numExpressions == numParts - 1);\n\n    let module = this.module;\n    let stringInstance = this.program.stringInstance;\n    let stringType = stringInstance.type;\n\n    if (!tag) {\n      // Shortcut if just a (multi-line) string\n      if (numParts == 1) {\n        return this.ensureStaticString(parts[0]);\n      }\n\n      // Shortcut for `${expr}`, `<prefix>${expr}`, `${expr}<suffix>`\n      if (numParts == 2) {\n        let expression = expressions[0];\n        let lhsLen = parts[0].length;\n        let rhsLen = parts[1].length;\n        // Shortcut for `${expr}`  ->   expr.toString()\n        if (!lhsLen && !rhsLen) {\n          return this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n        }\n        // Shortcuts for\n        // `<prefix>${expr}`  ->  \"<prefix>\" + expr.toString()\n        // `${expr}<suffix>`  ->  expr.toString() + \"<suffix>\"\n        let hasPrefix = lhsLen != 0;\n        // @ts-ignore: cast\n        if (hasPrefix ^ (rhsLen != 0)) {\n          let lhs: ExpressionRef;\n          let rhs: ExpressionRef;\n          let expr = this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n          if (hasPrefix) {\n            lhs = this.ensureStaticString(parts[0]);\n            rhs = expr;\n          } else {\n            // suffix\n            lhs = expr;\n            rhs = this.ensureStaticString(parts[1]);\n          }\n          let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n          return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n        }\n      }\n\n      // Shortcut for `${exprA}${exprB}`  ->  exprA.toString() + exprB.toString()\n      if (numParts == 3 && !parts[0].length && !parts[1].length && !parts[2].length) {\n        let exprA = expressions[0];\n        let exprB = expressions[1];\n\n        let lhs = this.makeToString(\n          this.compileExpression(exprA, stringType),\n          this.currentType, exprA\n        );\n        let rhs = this.makeToString(\n          this.compileExpression(exprB, stringType),\n          this.currentType, exprB\n        );\n        let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n        return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n      }\n\n      // Compile to a `StaticArray<string>#join(\"\") in the general case\n      let expressionPositions = new Array<i32>(numExpressions);\n      let values = new Array<usize>();\n      if (parts[0].length > 0) values.push(this.ensureStaticString(parts[0]));\n      for (let i = 1; i < numParts; ++i) {\n        expressionPositions[i - 1] = values.length;\n        values.push(module.usize(0));\n        if (parts[i].length > 0) values.push(this.ensureStaticString(parts[i]));\n      }\n      let arrayInstance = assert(this.resolver.resolveClass(this.program.staticArrayPrototype, [ stringType ]));\n      let segment = this.addStaticBuffer(stringType, values, arrayInstance.id);\n      this.program.OBJECTInstance.writeField(\"gcInfo\", 3, segment.buffer, 0); // use transparent gcinfo\n      let offset = i64_add(segment.offset, i64_new(this.program.totalOverhead));\n      let joinInstance = assert(arrayInstance.getMethod(\"join\"));\n      let indexedSetInstance = assert(arrayInstance.lookupOverload(OperatorKind.IndexedSet, true));\n      let stmts = new Array<ExpressionRef>(2 * numExpressions + 1);\n      // Use one local per toString'ed subexpression, since otherwise recursion on the same\n      // static array would overwrite already prepared parts. Avoids a temporary array.\n      let temps = new Array<Local>(numExpressions);\n      let flow = this.currentFlow;\n      for (let i = 0; i < numExpressions; ++i) {\n        let expression = expressions[i];\n        let temp = flow.getTempLocal(stringType);\n        temps[i] = temp;\n        stmts[i] = module.local_set(temp.index,\n          this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          ),\n          true\n        );\n      }\n      // Populate the static array with the toString'ed subexpressions and call .join(\"\")\n      for (let i = 0; i < numExpressions; ++i) {\n        stmts[numExpressions + i] = this.makeCallDirect(indexedSetInstance, [\n          module.usize(offset),\n          module.i32(expressionPositions[i]),\n          module.local_get(temps[i].index, stringType.toRef())\n        ], expression);\n      }\n      stmts[2 * numExpressions] = this.makeCallDirect(joinInstance, [\n        module.usize(offset),\n        this.ensureStaticString(\"\")\n      ], expression);\n      return module.flatten(stmts, stringType.toRef());\n    }\n\n    // Try to find out whether the template function takes a full-blown TemplateStringsArray or if\n    // it is sufficient to compile to a normal array. While technically incorrect, this allows us\n    // to avoid generating unnecessary static data that is not explicitly signaled to be used.\n    let tsaArrayInstance = this.program.templateStringsArrayInstance;\n    let arrayInstance = tsaArrayInstance;\n    let target = this.resolver.lookupExpression(tag, this.currentFlow, Type.auto, ReportMode.Swallow);\n    if (target) {\n      switch (target.kind) {\n        case ElementKind.FunctionPrototype: {\n          let instance = this.resolver.resolveFunction(\n            <FunctionPrototype>target,\n            null,\n            new Map(),\n            ReportMode.Swallow\n          );\n          if (!instance) break;\n          target = instance;\n          // fall-through\n        }\n        case ElementKind.Function: {\n          let instance = <Function>target;\n          let parameterTypes = instance.signature.parameterTypes;\n          if (parameterTypes.length) {\n            let first = parameterTypes[0].getClass();\n            if (first && !first.extendsPrototype(tsaArrayInstance.prototype)) {\n              arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ stringType ]));\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    // Compile to a call to the tag function\n    let rawParts = expression.rawParts;\n    assert(rawParts.length == numParts);\n    let partExprs = new Array<ExpressionRef>(numParts);\n    for (let i = 0; i < numParts; ++i) {\n      partExprs[i] = this.ensureStaticString(parts[i]);\n    }\n    let arraySegment: MemorySegment;\n    if (arrayInstance == tsaArrayInstance) {\n      let rawExprs = new Array<ExpressionRef>(numParts);\n      for (let i = 0; i < numParts; ++i) {\n        rawExprs[i] = this.ensureStaticString(rawParts[i]);\n      }\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n      let rawHeaderSegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, rawExprs)\n      );\n      arrayInstance.writeField(\"raw\",\n        i64_add(rawHeaderSegment.offset, i64_new(this.program.totalOverhead)),\n        arraySegment.buffer\n      );\n    } else {\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n    }\n\n    // Desugar to compileCallExpression\n    let args = expressions.slice();\n    args.unshift(\n      Node.createCompiledExpression(\n        module.usize(i64_add(arraySegment.offset, i64_new(this.program.totalOverhead))),\n        arrayInstance.type,\n        Source.native.range\n      )\n    );\n    // TODO: Requires ReadonlyArray to be safe\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      expression.range, \"Tagged template literals\"\n    );\n    return this.compileCallExpressionLike(tag, null, args, expression.range, stringType);\n  }\n\n  private compileArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let program = this.program;\n\n    // handle static arrays\n    let contextualClass = contextualType.getClass();\n    if (contextualClass && contextualClass.extendsPrototype(program.staticArrayPrototype)) {\n      return this.compileStaticArrayLiteral(expression, contextualType, constraints);\n    }\n\n    // handle normal arrays\n    let element = this.resolver.lookupExpression(expression, flow, this.currentType);\n    if (!element) return module.unreachable();\n    assert(element.kind == ElementKind.Class);\n    let arrayInstance = <Class>element;\n    let arrayType = arrayInstance.type;\n    let elementType = arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0];\n    let arrayBufferInstance = assert(program.arrayBufferInstance);\n\n    // block those here so compiling expressions doesn't conflict\n    let tempThis = flow.getTempLocal(this.options.usizeType);\n    let tempDataStart = flow.getTempLocal(arrayBufferInstance.type);\n\n    // compile value expressions and find out whether all are constant\n    let expressions = expression.elementExpressions;\n    let length = expressions.length;\n    let values = new Array<ExpressionRef>(length);\n    let isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = this.compileExpression(<Expression>elementExpression, elementType, Constraints.ConvImplicit);\n        if (getExpressionType(expr) != elementType.toRef()) {\n          isStatic = false;\n        } else {\n          let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            expr = precomp;\n          } else {\n            isStatic = false;\n          }\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType);\n      }\n    }\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      let totalOverhead = program.totalOverhead;\n      let bufferSegment = this.addStaticBuffer(elementType, values);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(totalOverhead));\n\n      // make both the buffer and array header static if assigned to a global. this can't be done\n      // if inside of a function because each invocation must create a new array reference then.\n      if (constraints & Constraints.PreferStatic) {\n        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);\n        let arrayAddress = i64_add(arraySegment.offset, i64_new(totalOverhead));\n        this.currentType = arrayType;\n        return program.options.isWasm64\n          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))\n          : this.module.i32(i64_low(arrayAddress));\n\n      // otherwise allocate a new array header and make it wrap a copy of the static buffer\n      } else {\n        return this.makeNewArray(arrayInstance, length, bufferAddress, expression);\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    let indexedSet = arrayInstance.lookupOverload(OperatorKind.IndexedSet, true);\n    if (!indexedSet) {\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    let arrayTypeRef = arrayType.toRef();\n\n    let stmts = new Array<ExpressionRef>();\n    // tempThis = __newArray(length, alignLog2, classId, source = 0)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeNewArray(arrayInstance, length, i64_new(0), expression),\n        arrayType.isManaged\n      )\n    );\n    // tempData = tempThis.dataStart\n    let dataStartMember = assert(arrayInstance.getMember(\"dataStart\"));\n    assert(dataStartMember.kind == ElementKind.PropertyPrototype);\n    // is a field, so should have been resolved during class finalization\n    let dataStartProperty = (<PropertyPrototype>dataStartMember).instance;\n    if (!dataStartProperty) return module.unreachable();\n    assert(dataStartProperty.isField && dataStartProperty.memoryOffset >= 0);\n    stmts.push(\n      module.local_set(tempDataStart.index,\n        module.load(arrayType.byteSize, false,\n          module.local_get(tempThis.index, arrayTypeRef),\n          arrayTypeRef,\n          dataStartProperty.memoryOffset\n        ),\n        true // ArrayBuffer\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // this[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  /** Makes a new array instance from a static buffer segment. */\n  private makeNewArray(\n    /** Concrete array class. */\n    arrayInstance: Class,\n    /** Length of the array. */\n    length: i32,\n    /** Source address to copy from. Array is zeroed if `0`. */\n    source: i64,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let module = this.module;\n    assert(!arrayInstance.extendsPrototype(program.staticArrayPrototype));\n    let elementType = arrayInstance.getArrayValueType(); // asserts\n\n    // __newArray(length, alignLog2, classId, staticBuffer)\n    let expr = this.makeCallDirect(program.newArrayInstance, [\n      module.i32(length),\n      program.options.isWasm64\n        ? module.i64(elementType.alignLog2)\n        : module.i32(elementType.alignLog2),\n      module.i32(arrayInstance.id),\n      program.options.isWasm64\n        ? module.i64(i64_low(source), i64_high(source))\n        : module.i32(i64_low(source))\n    ], reportNode);\n    this.currentType = arrayInstance.type;\n    return expr;\n  }\n\n  /** Compiles a special `fixed` array literal. */\n  private compileStaticArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let program = this.program;\n\n    // make sure this method is only called with a valid contextualType\n    let arrayInstance = assert(contextualType.getClass());\n    let arrayType = arrayInstance.type;\n    let typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));\n    let elementType = typeArguments[0];\n\n    // block those here so compiling expressions doesn't conflict\n    let tempThis = flow.getTempLocal(this.options.usizeType);\n\n    // compile value expressions and check if all are compile-time constants\n    let expressions = expression.elementExpressions;\n    let length = expressions.length;\n    let values = new Array<ExpressionRef>(length);\n    let isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = this.compileExpression(elementExpression, elementType, Constraints.ConvImplicit);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType);\n      }\n    }\n\n    let isWasm64 = this.options.isWasm64;\n    let bufferSize = values.length << elementType.alignLog2;\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n\n      // return the static buffer directly if assigned to a global\n      if (constraints & Constraints.PreferStatic) {\n        let expr = this.options.isWasm64\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n          : module.i32(i64_low(bufferAddress));\n        this.currentType = arrayType;\n        return expr;\n\n      // otherwise allocate a new chunk of memory and return a copy of the buffer\n      } else {\n        // __newBuffer(bufferSize, id, buffer)\n        let expr = this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id),\n          isWasm64\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n            : module.i32(i64_low(bufferAddress))\n        ], expression);\n        this.currentType = arrayType;\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    let indexedSet = arrayInstance.lookupOverload(OperatorKind.IndexedSet, true);\n    if (!indexedSet) {\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    let arrayTypeRef = arrayType.toRef();\n\n    let stmts = new Array<ExpressionRef>();\n    // tempThis = __newBuffer(bufferSize, classId)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id)\n        ], expression),\n        arrayType.isManaged\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // array[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {\n    let module = this.module;\n\n    // Check that contextual type is a class (TODO: hidden class for interfaces?)\n    let classReference = contextualType.getClass();\n    if (!classReference) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, \"<object>\", contextualType.toString()\n      );\n      return module.unreachable();\n    }\n    let classType = classReference.type;\n    this.currentType = classType.nonNullableType;\n    if (classReference.kind == ElementKind.Interface) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        expression.range, \"Interface hidden classes\"\n      );\n      return module.unreachable();\n    }\n    if (classReference.is(CommonFlags.Abstract)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.range\n      );\n      return module.unreachable();\n    }\n\n    // Check that the class is compatible with object literals\n    let ctorPrototype = classReference.prototype.constructorPrototype;\n    if (ctorPrototype) {\n      this.errorRelated(\n        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,\n        expression.range, ctorPrototype.identifierNode.range, classType.toString()\n      );\n      return module.unreachable();\n    }\n\n    let isManaged = classType.isManaged;\n    if (!isManaged) {\n      this.checkUnsafe(expression, findDecorator(DecoratorKind.Unmanaged, classReference.decoratorNodes));\n    }\n\n    // check and compile field values\n    let names = expression.names;\n    let numNames = names.length;\n    let values = expression.values;\n    let members = classReference.members;\n    let hasErrors = false;\n    let exprs = new Array<ExpressionRef>();\n    let flow = this.currentFlow;\n    let tempLocal = flow.getTempLocal(classType);\n    let classTypeRef = classType.toRef();\n    assert(numNames == values.length);\n\n    // Assume all class fields will be omitted, and add them to our omitted list\n    let omittedFields = new Set<Property>();\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberKey = _keys[i];\n        let member = assert(members.get(memberKey));\n        if (member && member.kind == ElementKind.PropertyPrototype) {\n          // only interested in fields (resolved during class finalization)\n          let property = (<PropertyPrototype>member).instance;\n          if (property && property.isField) {\n            omittedFields.add(property); // incl. private/protected\n          }\n        }\n      }\n    }\n\n    // Iterate through the members defined in our expression\n    let deferredProperties = new Array<Property>();\n    for (let i = 0; i < numNames; ++i) {\n      let memberName = names[i].text;\n      let member = classReference.getMember(memberName);\n      if (!member || member.kind != ElementKind.PropertyPrototype) {\n        this.error(\n          DiagnosticCode.Property_0_does_not_exist_on_type_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.Private)) {\n        this.error(\n          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.Protected)) {\n        this.error(\n          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>member);\n      if (!propertyInstance) continue;\n      let setterInstance = propertyInstance.setterInstance;\n      if (!setterInstance) {\n        this.error(\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n\n      // This member is no longer omitted, so delete from our omitted fields\n      omittedFields.delete(propertyInstance);\n\n      // Defer real properties to be set after fields are initialized\n      if (!propertyInstance.isField) {\n        deferredProperties.push(propertyInstance);\n        continue;\n      }\n\n      let propertyType = propertyInstance.type;\n      let expr = this.makeCallDirect(setterInstance, [\n        module.local_get(tempLocal.index, classTypeRef),\n        this.compileExpression(values[i], propertyType, Constraints.ConvImplicit),\n      ], setterInstance.identifierNode, true);\n      if (this.currentType != Type.void) { // in case\n        expr = module.drop(expr);\n      }\n      exprs.push(expr);\n    }\n\n    // Call deferred real property setters after\n    for (let i = 0, k = deferredProperties.length; i < k; ++i) {\n      let propertyInstance = deferredProperties[i];\n      let setterInstance = assert(propertyInstance.setterInstance);\n      exprs.push(\n        this.makeCallDirect(setterInstance, [\n          module.local_get(tempLocal.index, classTypeRef),\n          this.compileExpression(values[i], propertyInstance.type, Constraints.ConvImplicit)\n        ], setterInstance.identifierNode)\n      );\n    }\n\n    this.currentType = classType.nonNullableType;\n    if (hasErrors) return module.unreachable();\n\n    // Check remaining omitted fields\n    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {\n      let propertyInstance = _values[j];\n      assert(propertyInstance.isField);\n      let propertyType = propertyInstance.type;\n\n      if (propertyInstance.initializerNode) {\n        continue; // set by generated ctor\n      }\n\n      if (propertyType.isReference) {\n        if (!propertyType.isNullableReference) {\n          this.error(\n            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n            expression.range, propertyInstance.name, \"<object>\", classType.toString()\n          );\n          hasErrors = true;\n          continue;\n        }\n      }\n\n      switch (propertyType.kind) {\n        // Number Types (and Number alias types)\n        case TypeKind.Bool:\n        case TypeKind.I8:\n        case TypeKind.I16:\n        case TypeKind.I32:\n        case TypeKind.I64:\n        case TypeKind.Isize:\n        case TypeKind.U8:\n        case TypeKind.U16:\n        case TypeKind.U32:\n        case TypeKind.U64:\n        case TypeKind.Usize:\n        case TypeKind.F32:\n        case TypeKind.F64: {\n          // Can store zeroes directly (no need to __link)\n          exprs.push(\n            module.store(\n              propertyType.byteSize,\n              module.local_get(tempLocal.index, classTypeRef),\n              this.makeZero(propertyType),\n              propertyType.toRef(),\n              propertyInstance.memoryOffset\n            )\n          );\n          continue;\n        }\n      }\n\n      // Otherwise error\n      this.error(\n        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n        expression.range, propertyInstance.name, \"<object>\", classType.toString()\n      );\n      hasErrors = true;\n    }\n    if (hasErrors) return module.unreachable();\n\n    // generate the default constructor\n    let ctor = this.ensureConstructor(classReference, expression);\n    // note that this is not checking field initialization within the ctor, but\n    // instead checks conditions above with provided fields taken into account.\n\n    // allocate a new instance first and assign 'this' to the temp. local\n    exprs.unshift(\n      module.local_set(tempLocal.index,\n        this.compileInstantiate(ctor, [], Constraints.None, expression),\n        classType.isManaged\n      )\n    );\n\n    // once all field values have been set, return 'this'\n    exprs.push(\n      module.local_get(tempLocal.index, classTypeRef)\n    );\n\n    this.currentType = classType.nonNullableType;\n    return module.flatten(exprs, classTypeRef);\n  }\n\n  private compileNewExpression(\n    expression: NewExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // obtain the class being instantiated\n    let target = this.resolver.resolveTypeName(expression.typeName, flow.sourceFunction);\n    if (!target) return module.unreachable();\n    if (target.kind != ElementKind.ClassPrototype) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    if (target.is(CommonFlags.Abstract)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    let classPrototype = <ClassPrototype>target;\n    let classInstance: Class | null = null;\n    let typeArguments = expression.typeArguments;\n    let classReference: Class | null;\n    if (\n      !typeArguments &&\n      (classReference = contextualType.classReference) &&\n      classReference.prototype == classPrototype &&\n      classReference.is(CommonFlags.Generic)\n    ) {\n      // e.g. `arr: Array<T> = new Array()`\n      classInstance = this.resolver.resolveClass(\n        classPrototype,\n        classReference.typeArguments,\n        cloneMap(flow.contextualTypeArguments)\n      );\n    } else {\n      classInstance = this.resolver.resolveClassInclTypeArguments(\n        classPrototype,\n        typeArguments,\n        flow.sourceFunction.parent, // relative to caller\n        cloneMap(flow.contextualTypeArguments),\n        expression\n      );\n    }\n    if (!classInstance) return module.unreachable();\n    if (contextualType == Type.void) constraints |= Constraints.WillDrop;\n    let ctor = this.ensureConstructor(classInstance, expression);\n    if (!ctor.hasDecorator(DecoratorFlags.Inline)) {\n      // Inlined ctors haven't been compiled yet and are checked upon inline\n      // compilation of their body instead.\n      this.checkFieldInitialization(classInstance, expression);\n    }\n    return this.compileInstantiate(ctor, expression.args, constraints, expression);\n  }\n\n  /** Gets the compiled constructor of the specified class or generates one if none is present. */\n  ensureConstructor(\n    /** Class wanting a constructor. */\n    classInstance: Class,\n    /** Report node. */\n    reportNode: Node\n  ): Function {\n    let instance = classInstance.constructorInstance;\n    if (instance) {\n      // shortcut if already compiled\n      if (instance.is(CommonFlags.Compiled)) return instance;\n      // do not attempt to compile if inlined anyway\n      if (!instance.hasDecorator(DecoratorFlags.Inline)) this.compileFunction(instance);\n    } else {\n      // clone base constructor if a derived class. note that we cannot just\n      // call the base ctor since the derived class may have additional fields.\n      let baseClass = classInstance.base;\n      let contextualTypeArguments = cloneMap(classInstance.contextualTypeArguments);\n      if (baseClass) {\n        let baseCtor = this.ensureConstructor(baseClass, reportNode);\n        this.checkFieldInitialization(baseClass, reportNode);\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance,\n            // declaration is important, i.e. to access optional parameter initializers\n            (<FunctionDeclaration>baseCtor.declaration).clone()\n          ),\n          null,\n          baseCtor.signature,\n          contextualTypeArguments\n        );\n\n      // otherwise make a default constructor\n      } else {\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance, // bound\n            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,\n              CommonFlags.Instance | CommonFlags.Constructor\n            )\n          ),\n          null,\n          Signature.create(this.program, [], classInstance.type, classInstance.type),\n          contextualTypeArguments\n        );\n      }\n\n      instance.set(CommonFlags.Compiled);\n      instance.prototype.setResolvedInstance(\"\", instance);\n      if (classInstance.is(CommonFlags.ModuleExport)) {\n        instance.set(CommonFlags.ModuleExport);\n      }\n      classInstance.constructorInstance = instance;\n      let members = classInstance.members;\n      if (!members) classInstance.members = members = new Map();\n      members.set(\"constructor\", instance.prototype);\n\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n\n      // generate body\n      let signature = instance.signature;\n      let module = this.module;\n      let sizeTypeRef = this.options.sizeTypeRef;\n      let stmts = new Array<ExpressionRef>();\n\n      // {\n      //   this = <COND_ALLOC>\n      //   IF_DERIVED: this = super(this, ...args)\n      //   this.a = X\n      //   this.b = Y\n      //   return this\n      // }\n      stmts.push(\n        this.makeConditionalAllocation(classInstance, 0)\n      );\n      if (baseClass) {\n        let parameterTypes = signature.parameterTypes;\n        let numParameters = parameterTypes.length;\n        let operands = new Array<ExpressionRef>(1 + numParameters);\n        operands[0] = module.local_get(0, sizeTypeRef);\n        for (let i = 1; i <= numParameters; ++i) {\n          operands[i] = module.local_get(i, parameterTypes[i - 1].toRef());\n        }\n        stmts.push(\n          module.local_set(0,\n            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false),\n            baseClass.type.isManaged\n          )\n        );\n      }\n      this.makeFieldInitializationInConstructor(classInstance, stmts);\n      stmts.push(\n        module.local_get(0, sizeTypeRef)\n      );\n      this.currentFlow = previousFlow;\n\n      // make the function\n      let locals = instance.localsByIndex;\n      let varTypes = new Array<TypeRef>(); // of temp. vars added while compiling initializers\n      let numOperands = 1 + signature.parameterTypes.length;\n      let numLocals = locals.length;\n      if (numLocals > numOperands) {\n        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toRef());\n      }\n      let funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        varTypes,\n        module.flatten(stmts, sizeTypeRef)\n      );\n      instance.finalize(module, funcRef);\n    }\n\n    return instance;\n  }\n\n  /** Checks that all class fields have been initialized. */\n  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {\n    if (classInstance.didCheckFieldInitialization) return;\n    classInstance.didCheckFieldInitialization = true;\n    let ctor = assert(classInstance.constructorInstance);\n    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);\n  }\n\n  /** Checks that all class fields have been initialized in the specified flow. */\n  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {\n    let members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let element = _values[i];\n        if (element.kind != ElementKind.PropertyPrototype || element.parent != classInstance) continue;\n        // only interested in fields (resolved during class finalization)\n        let property = (<PropertyPrototype>element).instance;\n        if (!property || !property.isField) continue;\n        if (!property.initializerNode && !flow.isThisFieldFlag(property, FieldFlags.Initialized)) {\n          if (!property.is(CommonFlags.DefinitelyAssigned)) {\n            if (relatedNode) {\n              this.errorRelated(\n                DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                property.declaration.name.range,\n                relatedNode.range,\n                property.internalName\n              );\n            } else {\n              this.error(\n                DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                property.declaration.name.range,\n                property.internalName\n              );\n            }\n          }\n        } else if (property.is(CommonFlags.DefinitelyAssigned)) {\n          if (property.type.isReference) {\n            this.warning( // involves a runtime check\n              DiagnosticCode.Property_0_is_always_assigned_before_being_used,\n              property.identifierNode.range,\n              property.internalName\n            );\n          } else {\n            this.pedantic( // is a nop anyway\n              DiagnosticCode.Unnecessary_definite_assignment,\n              property.identifierNode.range\n            );\n          }\n        }\n      }\n    }\n  }\n\n  compileInstantiate(\n    /** Constructor to call. */\n    ctorInstance: Function,\n    /** Constructor arguments. */\n    argumentExpressions: Expression[],\n    /** Contextual flags. */\n    constraints: Constraints,\n    /** Node to report on. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(ctorInstance.is(CommonFlags.Constructor));\n    let parent = ctorInstance.parent;\n    assert(parent.kind == ElementKind.Class);\n    let classInstance = <Class>parent;\n    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(reportNode);\n    let expr = this.compileCallDirect(\n      ctorInstance,\n      argumentExpressions,\n      reportNode,\n      this.makeZero(this.options.usizeType),\n      constraints\n    );\n    if (getExpressionType(expr) != TypeRef.None) { // possibly WILL_DROP\n      this.currentType = classInstance.type; // important because a super ctor could be called\n    }\n    return expr;\n  }\n\n  private compilePropertyAccessExpression(\n    expression: PropertyAccessExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    this.maybeCompileEnclosingSource(expression);\n\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression, flow, ctxType); // reports\n    if (!target) return module.unreachable();\n    let thisExpression = resolver.currentThisExpression;\n    if (target.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n\n    switch (target.kind) {\n      case ElementKind.Global: { // static field\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable(); // reports\n        let globalType = global.type;\n        assert(globalType != Type.void);\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        if (global.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(global, ctxType, constraints);\n        }\n        let expr = module.global_get(global.internalName, globalType.toRef());\n        if (global.is(CommonFlags.DefinitelyAssigned) && globalType.isReference && !globalType.isNullableReference) {\n          expr = this.makeRuntimeNonNullCheck(expr, globalType, expression);\n        }\n        this.currentType = globalType;\n        return expr;\n      }\n      case ElementKind.EnumValue: { // enum value\n        let enumValue = <EnumValue>target;\n        let parent = assert(enumValue.parent);\n        assert(parent.kind == ElementKind.Enum);\n        let parentEnum = <Enum>parent;\n        if (!this.compileEnum(parentEnum)) {\n          this.currentType = Type.i32;\n          return this.module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.Inlined)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.Integer);\n          return this.compileInlineConstant(enumValue, ctxType, constraints);\n        }\n        assert(enumValue.type == Type.i32);\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        if (propertyInstance.isField) {\n          if (\n            flow.sourceFunction.is(CommonFlags.Constructor) &&\n            assert(thisExpression).kind == NodeKind.This &&\n            !flow.isThisFieldFlag(propertyInstance, FieldFlags.Initialized) &&\n            !propertyInstance.is(CommonFlags.DefinitelyAssigned)\n          ) {\n            this.errorRelated(\n              DiagnosticCode.Property_0_is_used_before_being_assigned,\n              expression.range,\n              propertyInstance.identifierNode.range,\n              propertyInstance.internalName\n            );\n          }\n        }\n        let getterInstance = propertyInstance.getterInstance;\n        if (!getterInstance) return module.unreachable(); // failed earlier\n        let thisArg: ExpressionRef = 0;\n        if (getterInstance.is(CommonFlags.Instance)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n        }\n        return this.compileCallDirect(getterInstance, [], expression, thisArg);\n      }\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n        if (!functionInstance) return module.unreachable();\n        if (!this.compileFunction(functionInstance)) return module.unreachable();\n        this.currentType = functionInstance.type;\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return this.module.unreachable();\n  }\n\n  private compileTernaryExpression(\n    expression: TernaryExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let ifThen = expression.ifThen;\n    let ifElse = expression.ifElse;\n\n    let condExpr = this.compileExpression(expression.condition, Type.bool);\n    let condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, expression.condition);\n    // Try to eliminate unnecesssary branches if the condition is constant\n    // FIXME: skips common denominator, inconsistently picking branch type\n    let condKind = this.evaluateCondition(condExprTrueish);\n    if (condKind == ConditionKind.True) {\n      return module.maybeDropCondition(condExprTrueish, this.compileExpression(ifThen, ctxType));\n    }\n    if (condKind == ConditionKind.False) {\n      return module.maybeDropCondition(condExprTrueish, this.compileExpression(ifElse, ctxType));\n    }\n\n    let outerFlow = this.currentFlow;\n    let ifThenFlow = outerFlow.forkThen(condExpr);\n    this.currentFlow = ifThenFlow;\n    let ifThenExpr = this.compileExpression(ifThen, ctxType);\n    let ifThenType = this.currentType;\n\n    let ifElseFlow = outerFlow.forkElse(condExpr);\n    this.currentFlow = ifElseFlow;\n    let ifElseExpr = this.compileExpression(ifElse, ctxType == Type.auto ? ifThenType : ctxType);\n    let ifElseType = this.currentType;\n\n    if (ctxType == Type.void) { // values, including type mismatch, are irrelevant\n      if (ifThenType != Type.void) {\n        ifThenExpr = module.drop(ifThenExpr);\n        ifThenType = Type.void;\n      }\n      if (ifElseType != Type.void) {\n        ifElseExpr = module.drop(ifElseExpr);\n        ifElseType = Type.void;\n      }\n      this.currentType = Type.void;\n    } else {\n      let commonType = Type.commonDenominator(ifThenType, ifElseType, false);\n      if (!commonType) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n          ifElse.range, ifElseType.toString(), ifThenType.toString()\n        );\n        this.currentType = ctxType;\n        return module.unreachable();\n      }\n      ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);\n      ifThenType = commonType;\n      ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);\n      ifElseType = commonType;\n      this.currentType = commonType;\n    }\n\n    outerFlow.inheritAlternatives(ifThenFlow, ifElseFlow);\n    this.currentFlow = outerFlow;\n\n    return module.if(condExprTrueish, ifThenExpr, ifElseExpr);\n  }\n\n  private compileUnaryPostfixExpression(\n    expression: UnaryPostfixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // make a getter for the expression (also obtains the type)\n    let getValue = this.compileExpression( // reports\n      expression.operand,\n      contextualType.exceptVoid,\n      Constraints.None\n    );\n\n    // if the value isn't dropped, a temp. local is required to remember the original value,\n    // except if a static overload is found, which reverses the use of a temp. (see below)\n    let tempLocal: Local | null = null;\n    if (contextualType != Type.void) {\n      tempLocal = flow.getTempLocal(this.currentType);\n      getValue = module.local_tee(\n        tempLocal.index,\n        getValue,\n        this.currentType.isManaged\n      );\n    }\n\n    let expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.Plus_Plus: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PostfixInc);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.Instance);\n            if (tempLocal && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (isInstance) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(\n              BinaryOp.AddI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.AddI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.AddSize,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.AddF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.AddF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Minus_Minus: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PostfixDec);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.Instance);\n            if (tempLocal && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (overload.is(CommonFlags.Instance)) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(\n              BinaryOp.SubI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.SubI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.SubF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.SubF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression.operand, flow); // reports\n    if (!target) {\n      return module.unreachable();\n    }\n\n    // simplify if dropped anyway\n    if (!tempLocal) {\n      return this.makeAssignment(\n        target,\n        expr,\n        this.currentType,\n        expression.operand,\n        resolver.currentThisExpression,\n        resolver.currentElementExpression,\n        false\n      );\n    }\n\n    // otherwise use the temp. local for the intermediate value (always possibly overflows)\n    let setValue = this.makeAssignment(\n      target,\n      expr, // includes a tee of getValue to tempLocal\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      false\n    );\n\n    this.currentType = tempLocal.type;\n    let typeRef = tempLocal.type.toRef();\n\n    return module.block(null, [\n      setValue,\n      module.local_get(tempLocal.index, typeRef)\n    ], typeRef); // result of 'x++' / 'x--' might overflow\n  }\n\n  private compileUnaryPrefixExpression(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let compound = false;\n    let expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.Plus: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Plus);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"+\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        // nop\n        break;\n      }\n      case Token.Minus: {\n        let operand = expression.operand;\n        if (operand.isNumericLiteral) {\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\n          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.None, true);\n          // compileExpression normally does this:\n          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n          break;\n        }\n\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Minus);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"-\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              this.makeZero(this.currentType),\n              expr\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.unary(UnaryOp.NegF32, expr);\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.unary(UnaryOp.NegF64, expr);\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Plus_Plus: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PrefixInc);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.Instance)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.AddSize,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Minus_Minus: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PrefixDec);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.Instance)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Exclamation: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Not);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n          // fall back to compare by value\n        }\n\n        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Tilde: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType == Type.void\n            ? Type.i32\n            : contextualType.isFloatValue\n              ? Type.i64\n              : contextualType,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseNot);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"~\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.XorSize,\n              expr,\n              this.makeNegOne(this.currentType)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"~\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.TypeOf: {\n        return this.compileTypeof(expression, contextualType, constraints);\n      }\n      case Token.Dot_Dot_Dot: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range, \"Spread operator\"\n        );\n        return module.unreachable();\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression.operand, this.currentFlow);\n    if (!target) return module.unreachable();\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  private compileTypeof(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let operand = expression.operand;\n    let expr: ExpressionRef = 0;\n    let stringInstance = this.program.stringInstance;\n    let typeString: string;\n    if (operand.kind == NodeKind.Null) {\n      typeString = \"object\"; // special since `null` without type context is usize\n    } else {\n      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.Swallow);\n      if (!element) {\n        switch (operand.kind) {\n          case NodeKind.Identifier: break; // ignore error: typeof doesntExist -> undefined\n          case NodeKind.PropertyAccess:\n          case NodeKind.ElementAccess: {\n            operand = operand.kind == NodeKind.PropertyAccess\n              ? (<PropertyAccessExpression>operand).expression\n              : (<ElementAccessExpression>operand).expression;\n            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.Report);\n            if (!targetType) { // access on non-object\n              this.currentType = stringInstance.type;\n              return this.module.unreachable();\n            }\n            // fall-through\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto); // may trigger an error\n            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);\n          }\n        }\n        typeString = \"undefined\";\n      } else {\n        switch (element.kind) {\n          case ElementKind.ClassPrototype:\n          case ElementKind.Namespace:\n          case ElementKind.Enum: {\n            typeString = \"object\";\n            break;\n          }\n          case ElementKind.FunctionPrototype: {\n            typeString = \"function\";\n            break;\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto);\n            let type = this.currentType;\n            expr = this.convertExpression(expr, type, Type.void, true, operand);\n            if (type.isReference) {\n              let signatureReference = type.getSignature();\n              if (signatureReference) {\n                typeString = \"function\";\n              } else {\n                let classReference = type.getClass();\n                if (classReference) {\n                  if (classReference.prototype == stringInstance.prototype) {\n                    typeString = \"string\";\n                  } else {\n                    typeString = \"object\";\n                  }\n                } else {\n                  typeString = \"externref\"; // TODO?\n                }\n              }\n            } else if (type == Type.bool) {\n              typeString = \"boolean\";\n            } else if (type.isNumericValue) {\n              typeString = \"number\";\n            } else {\n              typeString = \"undefined\"; // failed to compile?\n            }\n            break;\n          }\n        }\n      }\n    }\n    this.currentType = stringInstance.type;\n    return expr\n      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.sizeTypeRef)\n      : this.ensureStaticString(typeString);\n  }\n\n  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */\n  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        if (flow.canOverflow(expr, type)) {\n          // bool is special in that it compares to 0 instead of masking with 0x1\n          expr = module.binary(BinaryOp.NeI32,\n            expr,\n            module.i32(0)\n          );\n        }\n        break;\n      }\n      case TypeKind.I8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SignExtension)\n            ? module.unary(UnaryOp.Extend8I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(24)\n                ),\n                module.i32(24)\n              );\n        }\n        break;\n      }\n      case TypeKind.I16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SignExtension)\n            ? module.unary(UnaryOp.Extend16I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(16)\n                ),\n                module.i32(16)\n              );\n        }\n        break;\n      }\n      case TypeKind.U8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xff)\n          );\n        }\n        break;\n      }\n      case TypeKind.U16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xffff)\n          );\n        }\n        break;\n      }\n    }\n    return expr;\n  }\n\n  /** Adds the debug location of the specified expression at the specified range to the source map. */\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\n    let targetFunction = this.currentFlow.targetFunction;\n    let source = range.source;\n    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\n    range.debugInfoRef = expr;\n    targetFunction.debugLocations.push(range);\n  }\n\n  /** Checks whether a particular function signature is supported. */\n  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {\n    let supported = true;\n    let explicitThisType = reportNode.explicitThisType;\n    if (explicitThisType) {\n      if (!this.program.checkTypeSupported(assert(signature.thisType), explicitThisType)) {\n        supported = false;\n      }\n    }\n    let parameterTypes = signature.parameterTypes;\n    let parameterNodes = reportNode.parameters;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let parameterReportNode: Node;\n      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];\n      else parameterReportNode = reportNode;\n      if (!this.program.checkTypeSupported(parameterTypes[i], parameterReportNode)) {\n        supported = false;\n      }\n    }\n    if (!this.program.checkTypeSupported(signature.returnType, reportNode.returnType)) {\n      supported = false;\n    }\n    return supported;\n  }\n\n  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */\n  evaluateCondition(expr: ExpressionRef): ConditionKind {\n    let type = getExpressionType(expr);\n    if (type == TypeRef.Unreachable)\n      return ConditionKind.Unknown;\n\n    assert(type == TypeRef.I32);\n    let module = this.module;\n    let evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);\n    if (evaled) {\n      return getConstValueI32(evaled)\n        ? ConditionKind.True\n        : ConditionKind.False;\n    }\n    return ConditionKind.Unknown;\n  }\n\n  // === Specialized code generation ==============================================================\n\n  /** Makes a constant zero of the specified type. */\n  makeZero(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(0);\n      case TypeKind.F32: return module.f32(0);\n      case TypeKind.F64: return module.f64(0);\n      case TypeKind.V128: return module.v128(v128_zero);\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Dataref:\n      case TypeKind.Arrayref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        // TODO: what if not nullable?\n        return module.ref_null(type.toRef());\n      }\n      case TypeKind.I31ref: {\n        if (type.is(TypeFlags.Nullable)) return module.ref_null(type.toRef());\n        return module.i31_new(module.i32(0));\n      }\n    }\n  }\n\n  /** Makes a constant one of the specified type. */\n  makeOne(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(1);\n      case TypeKind.F32: return module.f32(1);\n      case TypeKind.F64: return module.f64(1);\n      case TypeKind.I31ref: return module.i31_new(module.i32(1));\n    }\n  }\n\n  /** Makes a constant negative one of the specified type. */\n  makeNegOne(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(-1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(-1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(-1, -1);\n      case TypeKind.F32: return module.f32(-1);\n      case TypeKind.F64: return module.f64(-1);\n      case TypeKind.V128: return module.v128(v128_ones);\n      case TypeKind.I31ref: return module.i31_new(module.i32(-1));\n    }\n  }\n\n  /** Creates a comparison whether an expression is 'true' in a broader sense. */\n  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        expr = this.ensureSmallIntegerWrap(expr, type);\n        // fall-through\n      }\n      case TypeKind.Bool: // not a mask, just != 0\n      case TypeKind.I32:\n      case TypeKind.U32: return expr;\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64, expr, module.i64(0));\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return type.size == 64\n          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))\n          : expr;\n      }\n      case TypeKind.F32: {\n        let options = this.options;\n        if (\n          options.shrinkLevelHint > 1 &&\n          options.hasFeature(Feature.NontrappingF2I)\n        ) {\n          // Use more compact but slower 5-byte (3 bytes in best case) approach\n          // !!(i32.trunc_sat_f32_u(f32.ceil(f32.abs(x))))\n          return module.unary(UnaryOp.EqzI32,\n            module.unary(UnaryOp.EqzI32,\n              module.unary(UnaryOp.TruncSatF32ToU32,\n                module.unary(UnaryOp.CeilF32,\n                  module.unary(UnaryOp.AbsF32, expr)\n                )\n              )\n            )\n          );\n        } else {\n          // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n          // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1\n          //\n          // and finally:\n          // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)\n          return module.binary(BinaryOp.LeU32,\n            module.binary(BinaryOp.SubI32,\n              module.binary(BinaryOp.ShlI32,\n                module.unary(UnaryOp.ReinterpretF32ToI32, expr),\n                module.i32(1)\n              ),\n              module.i32(2) // 1 << 1\n            ),\n            module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1\n          );\n        }\n      }\n      case TypeKind.F64: {\n        let options = this.options;\n        if (\n          options.shrinkLevelHint > 1 &&\n          options.hasFeature(Feature.NontrappingF2I)\n        ) {\n          // Use more compact but slower 5-byte (3 bytes in best case) approach\n          // !!(i32.trunc_sat_f64_u(f64.ceil(f64.abs(x))))\n          return module.unary(UnaryOp.EqzI32,\n            module.unary(UnaryOp.EqzI32,\n              module.unary(UnaryOp.TruncSatF64ToU32,\n                module.unary(UnaryOp.CeilF64,\n                  module.unary(UnaryOp.AbsF64, expr)\n                )\n              )\n            )\n          );\n        } else {\n          // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n          // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1\n          //\n          // and finally:\n          // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)\n          return module.binary(BinaryOp.LeU64,\n            module.binary(BinaryOp.SubI64,\n              module.binary(BinaryOp.ShlI64,\n                module.unary(UnaryOp.ReinterpretF64ToI64, expr),\n                module.i64(1)\n              ),\n              module.i64(2) // 1 << 1\n            ),\n            module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1\n          );\n        }\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128, expr);\n      }\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.I31ref:\n      case TypeKind.Dataref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        // Needs to be true (i.e. not zero) when the ref is _not_ null,\n        // which means `ref.is_null` returns false (i.e. zero).\n        return module.unary(UnaryOp.EqzI32, module.ref_is_null(expr));\n      }\n      case TypeKind.Void:\n      default: {\n        this.error(\n          DiagnosticCode.An_expression_of_type_0_cannot_be_tested_for_truthiness,\n          reportNode.range, type.toString()\n        );\n        return module.i32(0);\n      }\n    }\n  }\n\n  /** Makes a string conversion of the given expression. */\n  makeToString(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    let stringType = this.program.stringInstance.type;\n    if (type == stringType) {\n      return expr;\n    }\n    let classType = type.getClassOrWrapper(this.program);\n    if (classType) {\n      let toStringInstance = classType.getMethod(\"toString\");\n      if (toStringInstance) {\n        let toStringSignature = toStringInstance.signature;\n        if (!this.checkCallSignature( // reports\n          toStringSignature,\n          0,\n          true,\n          reportNode\n        )) {\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        if (!type.isStrictlyAssignableTo(assert(toStringSignature.thisType))) {\n          this.errorRelated(\n            DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n            reportNode.range, toStringInstance.identifierAndSignatureRange\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        let toStringReturnType = toStringSignature.returnType;\n        if (!toStringReturnType.isStrictlyAssignableTo(stringType)) {\n          this.errorRelated(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            reportNode.range, toStringInstance.identifierAndSignatureRange, toStringReturnType.toString(), stringType.toString()\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        return this.makeCallDirect(toStringInstance, [ expr ], reportNode);\n      }\n    }\n    this.error(\n      DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n      reportNode.range, type.toString(), stringType.toString()\n    );\n    this.currentType = stringType;\n    return this.module.unreachable();\n  }\n\n  /** Makes an allocation suitable to hold the data of an instance of the given class. */\n  makeAllocation(\n    classInstance: Class\n  ): ExpressionRef {\n    let program = this.program;\n    assert(classInstance.program == program);\n    let module = this.module;\n    let options = this.options;\n    this.currentType = classInstance.type;\n    if (classInstance.hasDecorator(DecoratorFlags.Unmanaged)) {\n      let allocInstance = program.allocInstance;\n      this.compileFunction(allocInstance);\n      return module.call(allocInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset)\n      ], options.sizeTypeRef);\n    } else {\n      let newInstance = program.newInstance;\n      this.compileFunction(newInstance);\n      return module.call(newInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset),\n        module.i32(classInstance.id)\n      ], options.sizeTypeRef);\n    }\n  }\n\n  /** Makes a conditional allocation where `this` might not have been initialized yet. */\n  makeConditionalAllocation(\n    classInstance: Class,\n    thisIndex: i32\n  ): ExpressionRef {\n    let module = this.module;\n    let classType = classInstance.type;\n    let classTypeRef = classType.toRef();\n    assert(classTypeRef == this.options.sizeTypeRef);\n    return module.if(\n      module.unary(classTypeRef == TypeRef.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n        module.local_get(thisIndex, classTypeRef)\n      ),\n      module.local_set(thisIndex,\n        this.makeAllocation(classInstance),\n        classInstance.type.isManaged\n      )\n    );\n  }\n\n  /** Makes the initializers for a class's fields within the constructor. */\n  makeFieldInitializationInConstructor(\n    /** Class being initialized. */\n    classInstance: Class,\n    /** Statements to append to also being returned. Created if omitted. */\n    stmts: ExpressionRef[] = []\n  ): ExpressionRef[] {\n    let members = classInstance.members;\n    if (!members) return stmts;\n\n    let module = this.module;\n    let flow = this.currentFlow;\n    let isInline = flow.isInline;\n    let thisLocalIndex = isInline ? flow.lookupLocal(CommonNames.this_)!.index : 0;\n    let sizeTypeRef = this.options.sizeTypeRef;\n    let nonParameterFields: Property[] | null = null;\n\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      if (member.kind != ElementKind.PropertyPrototype) continue;\n      // only interested in fields (resolved during class finalization)\n      let property = (<PropertyPrototype>member).instance;\n      if (!property || !property.isField || property.getBoundClassOrInterface() != classInstance) continue;\n      assert(!property.isAny(CommonFlags.Const));\n      let fieldPrototype = property.prototype;\n      let parameterIndex = fieldPrototype.parameterIndex;\n\n      // Defer non-parameter fields until parameter fields are initialized\n      if (parameterIndex < 0) {\n        if (!nonParameterFields) nonParameterFields = new Array();\n        nonParameterFields.push(property);\n        continue;\n      }\n\n      // Initialize constructor parameter field\n      let fieldType = property.type;\n      let fieldTypeRef = fieldType.toRef();\n      assert(!fieldPrototype.initializerNode);\n      let setterInstance = assert(property.setterInstance);\n      let expr = this.makeCallDirect(setterInstance, [\n        module.local_get(thisLocalIndex, sizeTypeRef),\n        module.local_get(\n          isInline\n            ? flow.lookupLocal(property.name)!.index\n            : 1 + parameterIndex, // `this` is local 0\n          fieldTypeRef\n        )\n      ], setterInstance.identifierNode, true);\n      if (this.currentType != Type.void) { // in case\n        expr = module.drop(expr);\n      }\n      stmts.push(expr);\n    }\n\n    // Initialize deferred non-parameter fields\n    if (nonParameterFields) {\n      for (let i = 0, k = nonParameterFields.length; i < k; ++i) {\n        let field = unchecked(nonParameterFields[i]);\n        let fieldType = field.type;\n        let fieldPrototype = field.prototype;\n        let initializerNode = fieldPrototype.initializerNode;\n        assert(fieldPrototype.parameterIndex < 0);\n        let setterInstance = assert(field.setterInstance);\n        let expr = this.makeCallDirect(setterInstance, [\n          module.local_get(thisLocalIndex, sizeTypeRef),\n          initializerNode // use initializer if present, otherwise initialize with zero\n            ? this.compileExpression(initializerNode, fieldType, Constraints.ConvImplicit)\n            : this.makeZero(fieldType)\n        ], field.identifierNode, true);\n        if (this.currentType != Type.void) { // in case\n          expr = module.drop(expr);\n        }\n        stmts.push(expr);\n      }\n    }\n\n    this.currentType = Type.void;\n    return stmts;\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeAbort(\n    /** Message argument of type string, if any. */\n    message: Expression | null,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();\n\n    let stringInstance = program.stringInstance;\n    let messageArg: ExpressionRef;\n    if (message) {\n      messageArg = this.compileExpression(message, stringInstance.type, Constraints.ConvImplicit);\n    } else {\n      messageArg = this.makeZero(stringInstance.type);\n    }\n\n    return this.makeStaticAbort(messageArg, codeLocation);\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeStaticAbort(\n    /** Message argument of type string. May be zero. */\n    messageExpr: ExpressionRef,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let module = this.module;\n    let abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return module.unreachable();\n\n    let filenameExpr = this.ensureStaticString(codeLocation.range.source.normalizedPath);\n    let range = codeLocation.range;\n    let source = range.source;\n    return module.block(null, [\n      module.call(\n        abortInstance.internalName, [\n          messageExpr,\n          filenameExpr,\n          module.i32(source.lineAt(range.start)),\n          module.i32(source.columnAt())\n        ],\n        TypeRef.None\n      ),\n      module.unreachable()\n    ]);\n  }\n\n  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */\n  makeRuntimeNonNullCheck(\n    /** Expression being checked. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let temp = flow.getTempLocal(type);\n    let tempIndex = temp.index;\n    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(tempIndex, LocalFlags.Wrapped);\n    flow.setLocalFlag(tempIndex, LocalFlags.NonNull);\n\n    let staticAbortCallExpr = this.makeStaticAbort(\n      this.ensureStaticString(\"Unexpected 'null' (not assigned or failed cast)\"),\n      reportNode\n    ); // TODO: throw\n\n    if (type.isExternalReference) {\n      let nonNullExpr = module.local_get(tempIndex, type.toRef());\n      if (this.options.hasFeature(Feature.GC)) {\n        nonNullExpr = module.ref_as_nonnull(nonNullExpr);\n      }\n      expr = module.if(\n        module.ref_is_null(\n          module.local_tee(tempIndex, expr, false)\n        ),\n        staticAbortCallExpr,\n        nonNullExpr\n      );\n    } else {\n      expr = module.if(\n        module.local_tee(tempIndex, expr, type.isManaged),\n        module.local_get(tempIndex, type.toRef()),\n        staticAbortCallExpr\n      );\n    }\n    this.currentType = type.nonNullableType;\n    return expr;\n  }\n\n  /** Makes a runtime downcast check, e.g. on `<Child>parent`. */\n  makeRuntimeDowncastCheck(\n    /** Expression being downcast. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Type casting to. */\n    toType: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));\n    let module = this.module;\n    let flow = this.currentFlow;\n    let temp = flow.getTempLocal(type);\n    let tempIndex = temp.index;\n\n    let staticAbortCallExpr = this.makeStaticAbort(\n      this.ensureStaticString(\"invalid downcast\"),\n      reportNode\n    ); // TODO: throw\n\n    if (!toType.isNullableReference || flow.isNonnull(expr, type)) {\n      // Simplify if the value cannot be `null`. If toType is non-nullable, a\n      // null-check would have been emitted separately so is not necessary here.\n      // instanceof(t = expr) ? t : abort()\n      expr = module.if(\n        module.call(this.prepareInstanceOf(toType.classReference!), [\n          module.local_tee(tempIndex, expr, type.isManaged)\n        ], TypeRef.I32),\n        module.local_get(tempIndex, type.toRef()),\n        staticAbortCallExpr\n      );\n    } else {\n      // !(t = expr) ? 0 : instanceof(t) ? t : abort()\n      expr = module.if(\n        module.unary(\n          UnaryOp.EqzI32,\n          module.local_tee(tempIndex, expr, type.isManaged)\n        ),\n        module.usize(0),\n        module.if(\n          module.call(this.prepareInstanceOf(toType.classReference!), [\n            module.local_get(tempIndex, type.toRef()),\n          ], TypeRef.I32),\n          module.local_get(tempIndex, type.toRef()),\n          staticAbortCallExpr\n        )\n      );\n    }\n    this.currentType = toType;\n    return expr;\n  }\n}\n\n// helpers\nfunction mangleImportName(\n  element: Element,\n  declaration: DeclarationStatement\n): void {\n  // by default, use the file name as the module name\n  mangleImportName_moduleName = declaration.range.source.simplePath;\n  // and the internal name of the element within that file as the element name\n  mangleImportName_elementName = mangleInternalName(\n    element.name, element.parent, element.is(CommonFlags.Instance), true\n  );\n  // override module name if a `module` statement is present\n  let overriddenModuleName = declaration.overriddenModuleName;\n  if (overriddenModuleName) mangleImportName_moduleName = overriddenModuleName;\n\n  if (!element.hasDecorator(DecoratorFlags.External)) return;\n\n  let program = element.program;\n  let decorator = assert(findDecorator(DecoratorKind.External, declaration.decorators));\n  let args = decorator.args;\n  if (args && args.length > 0) {\n    let arg = args[0];\n    // if one argument is given, override just the element name\n    // if two arguments are given, override both module and element name\n    if (arg.isLiteralKind(LiteralKind.String)) {\n      mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n      if (args.length >= 2) {\n        arg = args[1];\n        if (arg.isLiteralKind(LiteralKind.String)) {\n          mangleImportName_moduleName = mangleImportName_elementName;\n          mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n          if (args.length > 2) {\n            program.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              decorator.range, \"2\", args.length.toString()\n            );\n          }\n        } else {\n          program.error(\n            DiagnosticCode.String_literal_expected,\n            arg.range\n          );\n        }\n      }\n    } else {\n      program.error(\n        DiagnosticCode.String_literal_expected,\n        arg.range\n      );\n    }\n  } else {\n    program.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      decorator.range, \"1\", \"0\"\n    );\n  }\n}\n\nlet mangleImportName_moduleName: string = \"\";\nlet mangleImportName_elementName: string = \"\";\n", "import {\n  Source\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  Global,\n  Program,\n  Function,\n  Class,\n  Interface,\n  Enum,\n  ElementKind,\n  Element,\n  PropertyPrototype\n} from \"../program\";\n\nimport {\n  Type,\n  TypeFlags\n} from \"../types\";\n\nimport {\n  CharCode,\n  escapeString,\n  indent, isIdentifier\n} from \"../util\";\n\nimport {\n  ExportsWalker\n} from \"./util\";\n\n/** A TypeScript definitions builder. */\nexport class TSDBuilder extends ExportsWalker {\n\n  /** Builds TypeScript definitions for the specified program. */\n  static build(program: Program, esm: bool = true): string {\n    return new TSDBuilder(program, esm).build();\n  }\n\n  private esm: bool;\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n  private seenObjectTypes: Map<Class,string> = new Map();\n  private deferredTypings: string[] = new Array();\n\n  /** Constructs a new TypeScript definitions builder. */\n  constructor(program: Program, esm: bool, includePrivate: bool = false) {\n    super(program, includePrivate);\n    this.esm = esm;\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    let tsType = this.toTypeScriptType(type, Mode.EXPORT);\n    indent(sb, this.indentLevel);\n    sb.push(\"/** \");\n    sb.push(element.internalName);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"const \");\n    sb.push(name);\n    sb.push(\": {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"/** @type `\");\n    sb.push(type.toString());\n    sb.push(\"` */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"get value(): \");\n    sb.push(tsType);\n    if (!element.is(CommonFlags.Const)) {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"set value(value: \");\n      sb.push(tsType);\n      sb.push(\");\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"};\\n\");\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    let sb = this.sb;\n    indent(sb, this.indentLevel);\n    sb.push(\"/** \");\n    sb.push(element.internalName);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"enum \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    let members = element.members;\n    if (members) {\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.EnumValue) continue;\n        indent(sb, this.indentLevel);\n        sb.push(\"/** @type `i32` */\\n\");\n        indent(sb, this.indentLevel);\n        sb.push(memberName);\n        sb.push(\",\\n\");\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    let sb = this.sb;\n    let signature = element.signature;\n    indent(sb, this.indentLevel);\n    sb.push(\"/**\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\" * \");\n    sb.push(element.internalName);\n    sb.push(\"\\n\");\n    let parameterTypes = signature.parameterTypes;\n    let numParameters = parameterTypes.length;\n    for (let i = 0; i < numParameters; ++i) {\n      indent(sb, this.indentLevel);\n      sb.push(\" * @param \");\n      sb.push(element.getParameterName(i));\n      sb.push(\" `\");\n      sb.push(parameterTypes[i].toString());\n      sb.push(\"`\\n\");\n    }\n    let returnType = signature.returnType;\n    if (returnType != Type.void) {\n      indent(sb, this.indentLevel);\n      sb.push(\" * @returns `\");\n      sb.push(returnType.toString());\n      sb.push(\"`\\n\");\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"function \");\n    sb.push(name);\n    sb.push(\"(\");\n    let requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      sb.push(element.getParameterName(i));\n      if (i >= requiredParameters) sb.push(\"?\");\n      sb.push(\": \");\n      sb.push(this.toTypeScriptType(parameterTypes[i], Mode.IMPORT));\n    }\n    sb.push(\"): \");\n    sb.push(this.toTypeScriptType(returnType, Mode.EXPORT));\n    sb.push(\";\\n\");\n  }\n\n  visitClass(name: string, element: Class): void {\n    // not implemented\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    // not implemented\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    // not implemented\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // not implemented\n  }\n\n  build(): string {\n    let sb = this.sb;\n    if (!this.esm) {\n      sb.push(\"declare namespace __AdaptedExports {\\n\");\n      ++this.indentLevel;\n    }\n    if (this.program.options.exportMemory) {\n      indent(sb, this.indentLevel);\n      sb.push(\"/** Exported memory */\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}const memory: WebAssembly.Memory;\\n`);\n    }\n    if (this.program.options.exportTable) {\n      indent(sb, this.indentLevel);\n      sb.push(\"/** Exported table */\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}const table: WebAssembly.Table;\\n`);\n    }\n    this.walk();\n    if (!this.esm) {\n      --this.indentLevel;\n      sb.push(\"}\\n\");\n    }\n    let deferredTypes = this.deferredTypings;\n    for (let i = 0, k = deferredTypes.length; i < k; ++i) {\n      sb.push(deferredTypes[i]);\n    }\n    if (!this.esm) {\n      sb.push(\"/** Instantiates the compiled WebAssembly module with the given imports. */\\n\");\n      sb.push(\"export declare function instantiate(module: WebAssembly.Module, imports: {\\n\");\n      let moduleImports = this.program.moduleImports;\n      for (let _keys = Map_keys(moduleImports), i = 0, k = _keys.length; i < k; ++i) {\n        let moduleName = _keys[i];\n        sb.push(\"  \");\n        if (isIdentifier(moduleName)) {\n          sb.push(moduleName);\n        } else {\n          sb.push(\"\\\"\");\n          sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n          sb.push(\"\\\"\");\n        }\n        sb.push(\": unknown,\\n\");\n      }\n      sb.push(\"}): Promise<typeof __AdaptedExports>;\\n\");\n    }\n    return sb.join(\"\");\n  }\n\n  isPlainObject(clazz: Class): bool {\n    // A plain object does not inherit and does not have a constructor or private properties\n    if (clazz.base && !clazz.prototype.implicitlyExtendsObject) return false;\n    let members = clazz.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.isAny(CommonFlags.Private | CommonFlags.Protected)) return false;\n        if (member.is(CommonFlags.Constructor)) {\n          // a generated constructor is ok\n          if (member.declaration.range != Source.native.range) return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  toTypeScriptType(type: Type, mode: Mode): string {\n    if (type.isInternalReference) {\n      const sb = new Array<string>();\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extendsPrototype(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"ArrayBuffer\");\n      } else if (clazz.extendsPrototype(this.program.stringInstance.prototype)) {\n        sb.push(\"string\");\n      } else if (clazz.extendsPrototype(this.program.arrayPrototype)) {\n        const valueType = clazz.getArrayValueType();\n        sb.push(\"Array<\");\n        sb.push(this.toTypeScriptType(valueType, mode));\n        sb.push(\">\");\n      } else if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        const valueType = clazz.getArrayValueType();\n        sb.push(\"ArrayLike<\");\n        sb.push(this.toTypeScriptType(valueType, mode));\n        sb.push(\">\");\n      } else if (clazz.extendsPrototype(this.program.arrayBufferViewInstance.prototype)) {\n        const valueType = clazz.getArrayValueType();\n        if (valueType == Type.i8) {\n          sb.push(\"Int8Array\");\n        } else if (valueType == Type.u8) {\n          if (clazz.extendsPrototype(this.program.uint8ClampedArrayPrototype)) {\n            sb.push(\"Uint8ClampedArray\");\n          } else {\n            sb.push(\"Uint8Array\");\n          }\n        } else if (valueType == Type.i16) {\n          sb.push(\"Int16Array\");\n        } else if (valueType == Type.u16) {\n          sb.push(\"Uint16Array\");\n        } else if (valueType == Type.i32) {\n          sb.push(\"Int32Array\");\n        } else if (valueType == Type.u32) {\n          sb.push(\"Uint32Array\");\n        } else if (valueType == Type.i64) {\n          sb.push(\"BigInt64Array\");\n        } else if (valueType == Type.u64) {\n          sb.push(\"BigUint64Array\");\n        } else if (valueType == Type.f32) {\n          sb.push(\"Float32Array\");\n        } else if (valueType == Type.f64) {\n          sb.push(\"Float64Array\");\n        } else {\n          sb.push(\"unknown\");\n        }\n      } else {\n        let seenObjectTypes = this.seenObjectTypes;\n        let typeName: string;\n        if (seenObjectTypes.has(clazz)) {\n          typeName = assert(seenObjectTypes.get(clazz));\n          sb.push(typeName);\n          if (this.isPlainObject(clazz)) {\n            sb.push(mode == Mode.EXPORT ? \"<never>\" : \"<undefined>\");\n          }\n        } else {\n          let isPlain = this.isPlainObject(clazz);\n          typeName = `${isPlain ? \"__Record\" : \"__Internref\"}${clazz.id}`;\n          sb.push(typeName);\n          seenObjectTypes.set(clazz, typeName);\n          if (isPlain) {\n            sb.push(mode == Mode.EXPORT ? \"<never>\" : \"<undefined>\");\n            this.deferredTypings.push(this.makeRecordType(clazz, mode));\n          } else {\n            this.deferredTypings.push(this.makeInternrefType(clazz));\n          }\n        }\n      }\n      if (type.is(TypeFlags.Nullable)) {\n        sb.push(\" | null\");\n      }\n      return sb.join(\"\");\n    } else {\n      if (type == Type.bool) {\n        return \"boolean\";\n      }\n      if (type == Type.void) {\n        return \"void\";\n      }\n      if (type.isNumericValue) {\n        if (type.isLongIntegerValue) {\n          return \"bigint\";\n        }\n        return \"number\";\n      }\n    }\n    return \"unknown\";\n  }\n\n  makeRecordType(clazz: Class, mode: Mode): string {\n    let sb = new Array<string>();\n    let members = clazz.members;\n    sb.push(\"/** \");\n    sb.push(clazz.internalName);\n    sb.push(\" */\\ndeclare interface __Record\");\n    sb.push(clazz.id.toString());\n    sb.push(\"<TOmittable> {\\n\");\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        let property = (<PropertyPrototype>member).instance; // resolved during class finalization\n        if (!property || !property.isField) continue;\n        sb.push(\"  /** @type `\");\n        sb.push(property.type.toString());\n        sb.push(\"` */\\n  \");\n        sb.push(property.name);\n        sb.push(\": \");\n        sb.push(this.toTypeScriptType(property.type, mode));\n        if (this.fieldAcceptsUndefined(property.type)) {\n          sb.push(\" | TOmittable\");\n        }\n        sb.push(\";\\n\");\n      }\n    }\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n\n  fieldAcceptsUndefined(type: Type): bool {\n    if (type.isInternalReference) {\n      return type.is(TypeFlags.Nullable);\n    }\n    return true;\n  }\n\n  makeInternrefType(clazz: Class): string {\n    let sb = new Array<string>();\n    sb.push(\"/** \");\n    sb.push(clazz.internalName);\n    sb.push(\" */\\n\");\n    sb.push(\"declare class __Internref\");\n    sb.push(clazz.id.toString());\n    sb.push(\" extends Number {\\n\");\n    let base: Class | null = clazz;\n    do {\n      sb.push(\"  private __nominal\");\n      sb.push(base.id.toString());\n      sb.push(\": symbol;\\n\");\n      base = base.base;\n    } while (base);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n// Helpers\n\nenum Mode {\n  IMPORT,\n  EXPORT\n}\n", "/**\n * @fileoverview The C-like and re-exported public compiler interface.\n *\n * The intended way to consume the compiler sources is to import this\n * file, which again exports all relevant functions, classes and constants\n * as a flat namespace.\n *\n * Note though that the compiler sources are written in \"portable\n * AssemblyScript\" that can be compiled to both JavaScript with tsc and\n * to WebAssembly with asc, and as such require additional glue code\n * depending on the target.\n *\n * When compiling to JavaScript `glue/js/index.js` must be included.\n * When compiling to WebAssembly `glue/wasm/index.ts` must be included.\n */\n\nimport {\n  Target,\n  Runtime,\n  Feature\n} from \"./common\";\n\nimport {\n  Compiler,\n  Options,\n  UncheckedBehavior\n} from \"./compiler\";\n\nimport {\n  TSDBuilder,\n  JSBuilder\n} from \"./bindings\";\n\nimport {\n  Range,\n  DiagnosticMessage,\n  DiagnosticCategory,\n  formatDiagnosticMessage\n} from \"./diagnostics\";\n\nimport { Module } from \"./module\";\nimport { Program } from \"./program\";\nimport { Source } from \"./ast\";\n\n// Options\n\n/** Creates a new set of compiler options. */\nexport function newOptions(): Options {\n  return new Options();\n}\n\n/** Sets the `target` option. */\nexport function setTarget(options: Options, target: Target): void {\n  options.target = target;\n}\n\nexport function setRuntime(options: Options, runtime: Runtime): void {\n  options.runtime = runtime;\n}\n\n/** Sets the `noAssert` option. */\nexport function setNoAssert(options: Options, noAssert: bool): void {\n  options.noAssert = noAssert;\n}\n\n/** Sets the `exportMemory` option. */\nexport function setExportMemory(options: Options, exportMemory: bool): void {\n  options.exportMemory = exportMemory;\n}\n\n/** Sets the `importMemory` option. */\nexport function setImportMemory(options: Options, importMemory: bool): void {\n  options.importMemory = importMemory;\n}\n\n/** Sets the `initialMemory` option. */\nexport function setInitialMemory(options: Options, initialMemory: u32): void {\n  options.initialMemory = initialMemory;\n}\n\n/** Sets the `maximumMemory` option. */\nexport function setMaximumMemory(options: Options, maximumMemory: u32): void {\n  options.maximumMemory = maximumMemory;\n}\n\n/** Sets the `sharedMemory` option. */\nexport function setSharedMemory(options: Options, sharedMemory: bool): void {\n  options.sharedMemory = sharedMemory;\n}\n\n/** Sets the `importTable` option. */\nexport function setImportTable(options: Options, importTable: bool): void {\n  options.importTable = importTable;\n}\n\n/** Sets the `exportTable` option. */\nexport function setExportTable(options: Options, exportTable: bool): void {\n  options.exportTable = exportTable;\n}\n\n/** Sets the `sourceMap` option. */\nexport function setSourceMap(options: Options, sourceMap: bool): void {\n  options.sourceMap = sourceMap;\n}\n\n/** Sets the `uncheckedBehavior` option. */\nexport function setUncheckedBehavior(options: Options, uncheckedBehavior: UncheckedBehavior): void {\n  options.uncheckedBehavior = uncheckedBehavior;\n}\n\n/** Sets the `memoryBase` option. */\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\n  options.memoryBase = memoryBase;\n}\n\n/** Sets the `tableBase` option. */\nexport function setTableBase(options: Options, tableBase: u32): void {\n  options.tableBase = tableBase;\n}\n\n/** Adds a 'globalAliases' value. */\nexport function addGlobalAlias(options: Options, alias: string, name: string): void {\n  let globalAliases = options.globalAliases;\n  if (!globalAliases) options.globalAliases = globalAliases = new Map();\n  globalAliases.set(alias, name);\n}\n\n/** Removes a 'globalAliases' value. */\nexport function removeGlobalAlias(options: Options, alias: string): void {\n  let globalAliases = options.globalAliases;\n  if (globalAliases) globalAliases.delete(alias);\n}\n\n/** Sets the `exportStart` option. */\nexport function setExportStart(options: Options, exportStart: string | null): void {\n  options.exportStart = exportStart;\n}\n\n/** Sets the `noUnsafe` option. */\nexport function setNoUnsafe(options: Options, noUnsafe: bool): void {\n  options.noUnsafe = noUnsafe;\n}\n\n/** Sets the `lowMemoryLimit` option. */\nexport function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {\n  options.lowMemoryLimit = lowMemoryLimit;\n}\n\n/** Sets the `exportRuntime` option. */\nexport function setExportRuntime(options: Options, exportRuntime: bool): void {\n  options.exportRuntime = exportRuntime;\n}\n\n/** Default stack size. */\nexport const DEFAULT_STACK_SIZE = 32768;\n\n/** Sets the `stackSize` option. */\nexport function setStackSize(options: Options, stackSize: i32): void {\n  options.stackSize = stackSize;\n}\n\n/** Sets the bundle semantic version. */\nexport function setBundleVersion(\n  options: Options,\n  bundleMajorVersion: i32,\n  bundleMinorVersion: i32,\n  bundlePatchVersion: i32,\n): void {\n  options.bundleMajorVersion = bundleMajorVersion;\n  options.bundleMinorVersion = bundleMinorVersion;\n  options.bundlePatchVersion = bundlePatchVersion;\n}\n\n/** Sign extension operations. */\nexport const FEATURE_SIGN_EXTENSION = Feature.SignExtension;\n/** Mutable global imports and exports. */\nexport const FEATURE_MUTABLE_GLOBALS = Feature.MutableGlobals;\n/** Non-trapping float to int conversion operations. */\nexport const FEATURE_NONTRAPPING_F2I = Feature.NontrappingF2I;\n/** Bulk memory operations. */\nexport const FEATURE_BULK_MEMORY = Feature.BulkMemory;\n/** SIMD types and operations. */\nexport const FEATURE_SIMD = Feature.Simd;\n/** Threading and atomic operations. */\nexport const FEATURE_THREADS = Feature.Threads;\n/** Exception handling operations. */\nexport const FEATURE_EXCEPTION_HANDLING = Feature.ExceptionHandling;\n/** Tail call operations. */\nexport const FEATURE_TAIL_CALLS = Feature.TailCalls;\n/** Reference types. */\nexport const FEATURE_REFERENCE_TYPES = Feature.ReferenceTypes;\n/** Multi value types. */\nexport const FEATURE_MULTI_VALUE = Feature.MultiValue;\n/** Garbage collection. */\nexport const FEATURE_GC = Feature.GC;\n/** Memory64. */\nexport const FEATURE_MEMORY64 = Feature.Memory64;\n/** Relaxed SIMD. */\nexport const FEATURE_RELAXED_SIMD = Feature.RelaxedSimd;\n/** Extended const expressions. */\nexport const FEATURE_EXTENDED_CONST = Feature.ExtendedConst;\n/** String references. */\nexport const FEATURE_STRINGREF = Feature.Stringref;\n\n/** Enables a specific feature. */\nexport function enableFeature(options: Options, feature: Feature): void {\n  options.features |= feature;\n}\n\n/** Disables a specific feature. */\nexport function disableFeature(options: Options, feature: Feature): void {\n  options.features &= ~feature;\n}\n\n/** Gives the compiler a hint at the optimize levels that will be used later on. */\nexport function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {\n  options.optimizeLevelHint = optimizeLevel;\n  options.shrinkLevelHint = shrinkLevel;\n}\n\n/** Gives the compiler a hint of the emitted module's basename. */\nexport function setBasenameHint(options: Options, basename: string): void {\n  options.basenameHint = basename;\n}\n\n/** Gives the compiler a hint that bindings will be generated. */\nexport function setBindingsHint(options: Options, bindings: bool): void {\n  options.bindingsHint = bindings;\n}\n\n/** Sets the `pedantic` option. */\nexport function setPedantic(options: Options, pedantic: bool): void {\n  options.pedantic = pedantic;\n}\n\nexport function setDebugInfo(options: Options, debug: bool): void {\n  options.debugInfo = debug;\n}\n\n// Program\n\n/** Creates a new Program. */\nexport function newProgram(options: Options): Program {\n  return new Program(options);\n}\n\n/** Obtains the next diagnostic message. Returns `null` once complete. */\nexport function nextDiagnostic(program: Program): DiagnosticMessage | null {\n  return program.diagnosticsOffset < program.diagnostics.length\n    ? program.diagnostics[program.diagnosticsOffset++]\n    : null;\n}\n\n/** Obtains the source of the given file. */\nexport function getSource(program: Program, internalPath: string): string | null {\n  return program.getSource(internalPath);\n}\n\n/** Formats a diagnostic message to a string. */\nexport { formatDiagnosticMessage as formatDiagnostic };\n\n/** Gets the code of a diagnostic message. */\nexport function getDiagnosticCode(diagnostic: DiagnosticMessage): i32 {\n  return diagnostic.code;\n}\n\n/** Gets the category of a diagnostic message. */\nexport function getDiagnosticCategory(diagnostic: DiagnosticMessage): DiagnosticCategory {\n  return diagnostic.category;\n}\n\n/** Gets the textual message of a diagnostic message. */\nexport function getDiagnosticMessage(diagnostic: DiagnosticMessage): string {\n  return diagnostic.message;\n}\n\n/** Gets the primary range, if any, of a diagnostic message. */\nexport function getDiagnosticRange(diagnostic: DiagnosticMessage): Range | null {\n  return diagnostic.range;\n}\n\n/** Gets the related range, if any, of a diagnostic message. */\nexport function getDiagnosticRelatedRange(diagnostic: DiagnosticMessage): Range | null {\n  return diagnostic.relatedRange;\n}\n\n/** Gets a range's start offset. */\nexport function getRangeStart(range: Range): i32 {\n  return range.start;\n}\n\n/** Gets a range's end offsset. */\nexport function getRangeEnd(range: Range): i32 {\n  return range.end;\n}\n\n/** Gets a range's relevant source. */\nexport function getRangeSource(range: Range): Source {\n  return range.source;\n}\n\n/** Gets a source's normalized path. */\nexport function getSourceNormalizedPath(source: Source): string {\n  return source.normalizedPath;\n}\n\n/** Tests whether a diagnostic is informatory. */\nexport function isInfo(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Info;\n}\n\n/** Tests whether a diagnostic is a warning. */\nexport function isWarning(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Warning;\n}\n\n/** Tests whether a diagnostic is an error. */\nexport function isError(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Error;\n}\n\n// Parser\n\n/** Parses a source file. If `parser` has been omitted a new one is created. */\nexport function parse(\n  /** Program reference. */\n  program: Program,\n  /** Source text of the file, or `null` to indicate not found. */\n  text: string | null,\n  /** Normalized path of the file. */\n  path: string,\n  /** Whether this is an entry file. */\n  isEntry: bool = false\n): void {\n  program.parser.parseFile(text, path, isEntry);\n}\n\n/** Obtains the next required file's path. Returns `null` once complete. */\nexport function nextFile(program: Program): string | null {\n  return program.parser.nextFile();\n}\n\n/** Obtains the path of the dependee of a given imported file. */\nexport function getDependee(program: Program, file: string): string | null {\n  return program.parser.getDependee(file);\n}\n\n// Compiler\n\n/** Initializes the program pre-emptively for transform hooks. */\nexport function initializeProgram(program: Program): void {\n  program.initialize();\n}\n\n/** Compiles the parsed sources to a module. */\nexport function compile(program: Program): Module {\n  program.parser.finish();\n  return new Compiler(program).compile();\n}\n\n/** Builds TypeScript definitions for the specified program. */\nexport function buildTSD(program: Program, esm: bool): string {\n  return TSDBuilder.build(program, esm);\n}\n\n/** Builds JavaScript glue code for the specified program. */\nexport function buildJS(program: Program, esm: bool): string {\n  return JSBuilder.build(program, esm);\n}\n\n/** Gets the Binaryen module reference of a module. */\nexport function getBinaryenModuleRef(module: Module): usize {\n  return module.ref;\n}\n\n/** Validates a module. */\nexport function validate(module: Module): bool {\n  return module.validate();\n}\n\n/** Optimizes a module. */\nexport function optimize(\n  module: Module,\n  optimizeLevel: i32,\n  shrinkLevel: i32,\n  debugInfo: bool = false,\n  zeroFilledMemory: bool = false\n): void {\n  module.optimize(optimizeLevel, shrinkLevel, debugInfo, zeroFilledMemory);\n}\n", "/**\n * @fileoverview Abstract Syntax Tree extras.\n *\n * Provides serialization of the AssemblyScript AST back to it source form.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  ArrowKind,\n\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  TypeName,\n  TypeParameterNode,\n\n  Expression,\n  IdentifierExpression,\n  LiteralExpression,\n  LiteralKind,\n  FloatLiteralExpression,\n  IntegerLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  RegexpLiteralExpression,\n  ArrayLiteralExpression,\n  AssertionExpression,\n  AssertionKind,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FunctionExpression,\n  NewExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  UnaryPostfixExpression,\n  UnaryExpression,\n  UnaryPrefixExpression,\n  ClassExpression,\n  ObjectLiteralExpression,\n\n  BlockStatement,\n  BreakStatement,\n  ContinueStatement,\n  DoStatement,\n  EmptyStatement,\n  ExportImportStatement,\n  ExportStatement,\n  ExportDefaultStatement,\n  ExpressionStatement,\n  ForStatement,\n  ForOfStatement,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  WhileStatement,\n  ModuleDeclaration,\n\n  DeclarationStatement,\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  DecoratorNode,\n  ParameterNode,\n  ParameterKind,\n  ExportMember,\n  SwitchCase,\n  IndexSignatureNode,\n\n  isTypeOmitted\n} from \"../ast\";\n\nimport {\n  operatorTokenToString\n} from \"../tokenizer\";\n\nimport {\n  CharCode,\n  indent,\n  escapeString\n} from \"../util\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\n/** An AST builder. */\nexport class ASTBuilder {\n\n  /** Rebuilds the textual source from the specified AST, as far as possible. */\n  static build(node: Node): string {\n    let builder = new ASTBuilder();\n    builder.visitNode(node);\n    return builder.finish();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  visitNode(node: Node): void {\n    switch (node.kind) {\n      case NodeKind.Source: {\n        this.visitSource(<Source>node);\n        break;\n      }\n\n      // types\n\n      case NodeKind.NamedType: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FunctionType: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      case NodeKind.TypeParameter: {\n        this.visitTypeParameter(<TypeParameterNode>node);\n        break;\n      }\n\n      // expressions\n\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.Super:\n      case NodeKind.This:\n      case NodeKind.True:\n      case NodeKind.Constructor:\n      case NodeKind.Identifier: {\n        this.visitIdentifierExpression(<IdentifierExpression>node);\n        break;\n      }\n      case NodeKind.Assertion: {\n        this.visitAssertionExpression(<AssertionExpression>node);\n        break;\n      }\n      case NodeKind.Binary: {\n        this.visitBinaryExpression(<BinaryExpression>node);\n        break;\n      }\n      case NodeKind.Call: {\n        this.visitCallExpression(<CallExpression>node);\n        break;\n      }\n      case NodeKind.Class: {\n        this.visitClassExpression(<ClassExpression>node);\n        break;\n      }\n      case NodeKind.Comma: {\n        this.visitCommaExpression(<CommaExpression>node);\n        break;\n      }\n      case NodeKind.ElementAccess: {\n        this.visitElementAccessExpression(<ElementAccessExpression>node);\n        break;\n      }\n      case NodeKind.Function: {\n        this.visitFunctionExpression(<FunctionExpression>node);\n        break;\n      }\n      case NodeKind.InstanceOf: {\n        this.visitInstanceOfExpression(<InstanceOfExpression>node);\n        break;\n      }\n      case NodeKind.Literal: {\n        this.visitLiteralExpression(<LiteralExpression>node);\n        break;\n      }\n      case NodeKind.New: {\n        this.visitNewExpression(<NewExpression>node);\n        break;\n      }\n      case NodeKind.Parenthesized: {\n        this.visitParenthesizedExpression(<ParenthesizedExpression>node);\n        break;\n      }\n      case NodeKind.PropertyAccess: {\n        this.visitPropertyAccessExpression(<PropertyAccessExpression>node);\n        break;\n      }\n      case NodeKind.Ternary: {\n        this.visitTernaryExpression(<TernaryExpression>node);\n        break;\n      }\n      case NodeKind.UnaryPostfix: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n\n      // statements\n\n      case NodeKind.Block: {\n        this.visitBlockStatement(<BlockStatement>node);\n        break;\n      }\n      case NodeKind.Break: {\n        this.visitBreakStatement(<BreakStatement>node);\n        break;\n      }\n      case NodeKind.Continue: {\n        this.visitContinueStatement(<ContinueStatement>node);\n        break;\n      }\n      case NodeKind.Do: {\n        this.visitDoStatement(<DoStatement>node);\n        break;\n      }\n      case NodeKind.Empty: {\n        this.visitEmptyStatement(<EmptyStatement>node);\n        break;\n      }\n      case NodeKind.Export: {\n        this.visitExportStatement(<ExportStatement>node);\n        break;\n      }\n      case NodeKind.ExportDefault: {\n        this.visitExportDefaultStatement(<ExportDefaultStatement>node);\n        break;\n      }\n      case NodeKind.ExportImport: {\n        this.visitExportImportStatement(<ExportImportStatement>node);\n        break;\n      }\n      case NodeKind.Expression: {\n        this.visitExpressionStatement(<ExpressionStatement>node);\n        break;\n      }\n      case NodeKind.For: {\n        this.visitForStatement(<ForStatement>node);\n        break;\n      }\n      case NodeKind.ForOf: {\n        this.visitForOfStatement(<ForOfStatement>node);\n        break;\n      }\n      case NodeKind.If: {\n        this.visitIfStatement(<IfStatement>node);\n        break;\n      }\n      case NodeKind.Import: {\n        this.visitImportStatement(<ImportStatement>node);\n        break;\n      }\n      case NodeKind.Return: {\n        this.visitReturnStatement(<ReturnStatement>node);\n        break;\n      }\n      case NodeKind.Switch: {\n        this.visitSwitchStatement(<SwitchStatement>node);\n        break;\n      }\n      case NodeKind.Throw: {\n        this.visitThrowStatement(<ThrowStatement>node);\n        break;\n      }\n      case NodeKind.Try: {\n        this.visitTryStatement(<TryStatement>node);\n        break;\n      }\n      case NodeKind.Variable: {\n        this.visitVariableStatement(<VariableStatement>node);\n        break;\n      }\n      case NodeKind.While: {\n        this.visitWhileStatement(<WhileStatement>node);\n        break;\n      }\n      case NodeKind.Module: {\n        this.visitModuleDeclaration(<ModuleDeclaration>node);\n        break;\n      }\n\n      // declaration statements\n\n      case NodeKind.ClassDeclaration: {\n        this.visitClassDeclaration(<ClassDeclaration>node);\n        break;\n      }\n      case NodeKind.EnumDeclaration: {\n        this.visitEnumDeclaration(<EnumDeclaration>node);\n        break;\n      }\n      case NodeKind.EnumValueDeclaration: {\n        this.visitEnumValueDeclaration(<EnumValueDeclaration>node);\n        break;\n      }\n      case NodeKind.FieldDeclaration: {\n        this.visitFieldDeclaration(<FieldDeclaration>node);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>node);\n        break;\n      }\n      case NodeKind.ImportDeclaration: {\n        this.visitImportDeclaration(<ImportDeclaration>node);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>node);\n        break;\n      }\n      case NodeKind.MethodDeclaration: {\n        this.visitMethodDeclaration(<MethodDeclaration>node);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>node);\n        break;\n      }\n      case NodeKind.TypeDeclaration: {\n        this.visitTypeDeclaration(<TypeDeclaration>node);\n        break;\n      }\n      case NodeKind.VariableDeclaration: {\n        this.visitVariableDeclaration(<VariableDeclaration>node);\n        break;\n      }\n\n      // other\n\n      case NodeKind.Decorator: {\n        this.serializeDecorator(<DecoratorNode>node);\n        break;\n      }\n      case NodeKind.ExportMember: {\n        this.visitExportMember(<ExportMember>node);\n        break;\n      }\n      case NodeKind.Parameter: {\n        this.serializeParameter(<ParameterNode>node);\n        break;\n      }\n      case NodeKind.SwitchCase: {\n        this.visitSwitchCase(<SwitchCase>node);\n        break;\n      }\n      case NodeKind.IndexSignature: {\n        this.visitIndexSignature(<IndexSignatureNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitSource(source: Source): void {\n    let statements = source.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      this.visitNodeAndTerminate(statements[i]);\n    }\n  }\n\n  // types\n\n  visitTypeNode(node: TypeNode): void {\n    switch (node.kind) {\n      case NodeKind.NamedType: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FunctionType: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitTypeName(node: TypeName): void {\n    this.visitIdentifierExpression(node.identifier);\n    let sb = this.sb;\n    let current = node.next;\n    while (current) {\n      sb.push(\".\");\n      this.visitIdentifierExpression(current.identifier);\n      current = current.next;\n    }\n  }\n\n  visitNamedTypeNode(node: NamedTypeNode): void {\n    this.visitTypeName(node.name);\n    let typeArguments = node.typeArguments;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      let sb = this.sb;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">\");\n      }\n      if (node.isNullable) sb.push(\" | null\");\n    }\n  }\n\n  visitFunctionTypeNode(node: FunctionTypeNode): void {\n    let isNullable = node.isNullable;\n    let sb = this.sb;\n    sb.push(isNullable ? \"((\" : \"(\");\n    let explicitThisType = node.explicitThisType;\n    if (explicitThisType) {\n      sb.push(\"this: \");\n      this.visitTypeNode(explicitThisType);\n    }\n    let parameters = node.parameters;\n    let numParameters = parameters.length;\n    if (numParameters) {\n      if (explicitThisType) sb.push(\", \");\n      this.serializeParameter(parameters[0]);\n      for (let i = 1; i < numParameters; ++i) {\n        sb.push(\", \");\n        this.serializeParameter(parameters[i]);\n      }\n    }\n    let returnType = node.returnType;\n    if (returnType) {\n      sb.push(\") => \");\n      this.visitTypeNode(returnType);\n    } else {\n      sb.push(\") => void\");\n    }\n    if (isNullable) sb.push(\") | null\");\n  }\n\n  visitTypeParameter(node: TypeParameterNode): void {\n    this.visitIdentifierExpression(node.name);\n    let extendsType = node.extendsType;\n    if (extendsType) {\n      this.sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    let defaultType = node.defaultType;\n    if (defaultType) {\n      this.sb.push(\"=\");\n      this.visitTypeNode(defaultType);\n    }\n  }\n\n  // expressions\n\n  visitIdentifierExpression(node: IdentifierExpression): void {\n    if (node.isQuoted) this.visitStringLiteral(node.text);\n    else this.sb.push(node.text);\n  }\n\n  visitArrayLiteralExpression(node: ArrayLiteralExpression): void {\n    let sb = this.sb;\n    sb.push(\"[\");\n    let elements = node.elementExpressions;\n    let numElements = elements.length;\n    if (numElements) {\n      let element = elements[0];\n      if (element) this.visitNode(element);\n      for (let i = 1; i < numElements; ++i) {\n        element = elements[i];\n        sb.push(\", \");\n        if (element) this.visitNode(element);\n      }\n    }\n    sb.push(\"]\");\n  }\n\n  visitObjectLiteralExpression(node: ObjectLiteralExpression): void {\n    let sb = this.sb;\n    let names = node.names;\n    let values = node.values;\n    let numElements = names.length;\n    assert(numElements == values.length);\n    if (numElements) {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      this.visitNode(names[0]);\n      sb.push(\": \");\n      this.visitNode(values[0]);\n      for (let i = 1; i < numElements; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        let name = names[i];\n        let value = values[i];\n        if (name == value) {\n          this.visitNode(name);\n        } else {\n          this.visitNode(name);\n          sb.push(\": \");\n          this.visitNode(value);\n        }\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitAssertionExpression(node: AssertionExpression): void {\n    let sb = this.sb;\n    switch (node.assertionKind) {\n      case AssertionKind.Prefix: {\n        sb.push(\"<\");\n        this.visitTypeNode(assert(node.toType));\n        sb.push(\">\");\n        this.visitNode(node.expression);\n        break;\n      }\n      case AssertionKind.As: {\n        this.visitNode(node.expression);\n        sb.push(\" as \");\n        this.visitTypeNode(assert(node.toType));\n        break;\n      }\n      case AssertionKind.NonNull: {\n        this.visitNode(node.expression);\n        sb.push(\"!\");\n        break;\n      }\n      case AssertionKind.Const: {\n        this.visitNode(node.expression);\n        sb.push(\" as const\");\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitBinaryExpression(node: BinaryExpression): void {\n    let sb = this.sb;\n    this.visitNode(node.left);\n    sb.push(\" \");\n    sb.push(operatorTokenToString(node.operator));\n    sb.push(\" \");\n    this.visitNode(node.right);\n  }\n\n  visitCallExpression(node: CallExpression): void {\n    this.visitNode(node.expression);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  private visitArguments(typeArguments: TypeNode[] | null, args: Expression[]): void {\n    let sb = this.sb;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">(\");\n      }\n    } else {\n      sb.push(\"(\");\n    }\n    let numArgs = args.length;\n    if (numArgs) {\n      this.visitNode(args[0]);\n      for (let i = 1; i < numArgs; ++i) {\n        sb.push(\", \");\n        this.visitNode(args[i]);\n      }\n    }\n    sb.push(\")\");\n  }\n\n  visitClassExpression(node: ClassExpression): void {\n    let declaration = node.declaration;\n    this.visitClassDeclaration(declaration);\n  }\n\n  visitCommaExpression(node: CommaExpression): void {\n    let expressions = node.expressions;\n    let numExpressions = assert(expressions.length);\n    this.visitNode(expressions[0]);\n    let sb = this.sb;\n    for (let i = 1; i < numExpressions; ++i) {\n      sb.push(\",\");\n      this.visitNode(expressions[i]);\n    }\n  }\n\n  visitElementAccessExpression(node: ElementAccessExpression): void {\n    let sb = this.sb;\n    this.visitNode(node.expression);\n    sb.push(\"[\");\n    this.visitNode(node.elementExpression);\n    sb.push(\"]\");\n  }\n\n  visitFunctionExpression(node: FunctionExpression): void {\n    let declaration = node.declaration;\n    if (!declaration.arrowKind) {\n      if (declaration.name.text.length) {\n        this.sb.push(\"function \");\n      } else {\n        this.sb.push(\"function\");\n      }\n    } else {\n      assert(declaration.name.text.length == 0);\n    }\n    this.visitFunctionCommon(declaration);\n  }\n\n  visitLiteralExpression(node: LiteralExpression): void {\n    switch (node.literalKind) {\n      case LiteralKind.Float: {\n        this.visitFloatLiteralExpression(<FloatLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Integer: {\n        this.visitIntegerLiteralExpression(<IntegerLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.String: {\n        this.visitStringLiteralExpression(<StringLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Template: {\n        this.visitTemplateLiteralExpression(<TemplateLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.RegExp: {\n        this.visitRegexpLiteralExpression(<RegexpLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Array: {\n        this.visitArrayLiteralExpression(<ArrayLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.Object: {\n        this.visitObjectLiteralExpression(<ObjectLiteralExpression>node);\n        break;\n      }\n      default: {\n        assert(false);\n        break;\n      }\n    }\n  }\n\n  visitFloatLiteralExpression(node: FloatLiteralExpression): void {\n    this.sb.push(node.value.toString());\n  }\n\n  visitInstanceOfExpression(node: InstanceOfExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\" instanceof \");\n    this.visitTypeNode(node.isType);\n  }\n\n  visitIntegerLiteralExpression(node: IntegerLiteralExpression): void {\n    let range = node.range;\n    let hasExplicitSign = range.source.text.startsWith(\"-\", range.start);\n    this.sb.push(i64_to_string(node.value, !hasExplicitSign));\n  }\n\n  visitStringLiteral(str: string): void {\n    let sb = this.sb;\n    sb.push(\"\\\"\");\n    sb.push(escapeString(str, CharCode.DoubleQuote));\n    sb.push(\"\\\"\");\n  }\n\n  visitStringLiteralExpression(node: StringLiteralExpression): void {\n    this.visitStringLiteral(node.value);\n  }\n\n  visitTemplateLiteralExpression(node: TemplateLiteralExpression): void {\n    let sb = this.sb;\n    let tag = node.tag;\n    let parts = node.parts;\n    let expressions = node.expressions;\n    if (tag) this.visitNode(tag);\n    sb.push(\"`\");\n    sb.push(escapeString(parts[0], CharCode.Backtick));\n    assert(parts.length == expressions.length + 1);\n    for (let i = 0, k = expressions.length; i < k; ++i) {\n      sb.push(\"${\");\n      this.visitNode(expressions[i]);\n      sb.push(\"}\");\n      sb.push(escapeString(parts[i + 1], CharCode.Backtick));\n    }\n    sb.push(\"`\");\n  }\n\n  visitRegexpLiteralExpression(node: RegexpLiteralExpression): void {\n    let sb = this.sb;\n    sb.push(\"/\");\n    sb.push(node.pattern);\n    sb.push(\"/\");\n    sb.push(node.patternFlags);\n  }\n\n  visitNewExpression(node: NewExpression): void {\n    this.sb.push(\"new \");\n    this.visitTypeName(node.typeName);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  visitParenthesizedExpression(node: ParenthesizedExpression): void {\n    let sb = this.sb;\n    sb.push(\"(\");\n    this.visitNode(node.expression);\n    sb.push(\")\");\n  }\n\n  visitPropertyAccessExpression(node: PropertyAccessExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\".\");\n    this.visitIdentifierExpression(node.property);\n  }\n\n  visitTernaryExpression(node: TernaryExpression): void {\n    let sb = this.sb;\n    this.visitNode(node.condition);\n    sb.push(\" ? \");\n    this.visitNode(node.ifThen);\n    sb.push(\" : \");\n    this.visitNode(node.ifElse);\n  }\n\n  visitUnaryExpression(node: UnaryExpression): void {\n    switch (node.kind) {\n      case NodeKind.UnaryPostfix: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitUnaryPostfixExpression(node: UnaryPostfixExpression): void {\n    this.visitNode(node.operand);\n    this.sb.push(operatorTokenToString(node.operator));\n  }\n\n  visitUnaryPrefixExpression(node: UnaryPrefixExpression): void {\n    this.sb.push(operatorTokenToString(node.operator));\n    this.visitNode(node.operand);\n  }\n\n  // statements\n\n  visitNodeAndTerminate(node: Node): void {\n    this.visitNode(node);\n    let sb = this.sb;\n    if (\n      !sb.length ||                     // leading EmptyStatement\n      node.kind == NodeKind.Variable || // potentially assigns a FunctionExpression\n      node.kind == NodeKind.Expression  // potentially assigns a FunctionExpression\n    ) {\n      sb.push(\";\\n\");\n    } else {\n      let last = sb[sb.length - 1];\n      let lastCharPos = last.length - 1;\n      if (lastCharPos >= 0 && (\n        last.charCodeAt(lastCharPos) == CharCode.CloseBrace ||\n        last.charCodeAt(lastCharPos) == CharCode.Semicolon)\n      ) {\n        sb.push(\"\\n\");\n      } else {\n        sb.push(\";\\n\");\n      }\n    }\n  }\n\n  visitBlockStatement(node: BlockStatement): void {\n    let sb = this.sb;\n    let statements = node.statements;\n    let numStatements = statements.length;\n    if (numStatements) {\n      sb.push(\"{\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitBreakStatement(node: BreakStatement): void {\n    let label = node.label;\n    if (label) {\n      this.sb.push(\"break \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"break\");\n    }\n  }\n\n  visitContinueStatement(node: ContinueStatement): void {\n    let label = node.label;\n    if (label) {\n      this.sb.push(\"continue \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"continue\");\n    }\n  }\n\n  visitClassDeclaration(node: ClassDeclaration, isDefault: bool = false): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.Abstract)) sb.push(\"abstract \");\n    if (node.name.text.length) {\n      sb.push(\"class \");\n      this.visitIdentifierExpression(node.name);\n    } else {\n      sb.push(\"class\");\n    }\n    let typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    let extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    let implementsTypes = node.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        sb.push(\" implements \");\n        this.visitTypeNode(implementsTypes[0]);\n        for (let i = 1; i < numImplementsTypes; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(implementsTypes[i]);\n        }\n      }\n    }\n    let indexSignature = node.indexSignature;\n    let members = node.members;\n    let numMembers = members.length;\n    if (indexSignature || numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      if (indexSignature) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(indexSignature);\n      }\n      for (let i = 0, k = members.length; i < k; ++i) {\n        let member = members[i];\n        if (member.kind != NodeKind.FieldDeclaration || (<FieldDeclaration>member).parameterIndex < 0) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(member);\n        }\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitDoStatement(node: DoStatement): void {\n    let sb = this.sb;\n    sb.push(\"do \");\n    this.visitNode(node.body);\n    if (node.body.kind == NodeKind.Block) {\n      sb.push(\" while (\");\n    } else {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"while (\");\n    }\n    this.visitNode(node.condition);\n    sb.push(\")\");\n  }\n\n  visitEmptyStatement(node: EmptyStatement): void {\n    /* nop */\n  }\n\n  visitEnumDeclaration(node: EnumDeclaration, isDefault: bool = false): void {\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.Const)) sb.push(\"const \");\n    sb.push(\"enum \");\n    this.visitIdentifierExpression(node.name);\n    let values = node.values;\n    let numValues = values.length;\n    if (numValues) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitEnumValueDeclaration(node.values[0]);\n      for (let i = 1; i < numValues; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitEnumValueDeclaration(node.values[i]);\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitEnumValueDeclaration(node: EnumValueDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    let initializer = node.initializer;\n    if (initializer) {\n      this.sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitExportImportStatement(node: ExportImportStatement): void {\n    let sb = this.sb;\n    sb.push(\"export import \");\n    this.visitIdentifierExpression(node.externalName);\n    sb.push(\" = \");\n    this.visitIdentifierExpression(node.name);\n  }\n\n  visitExportMember(node: ExportMember): void {\n    this.visitIdentifierExpression(node.localName);\n    if (node.exportedName.text != node.localName.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(node.exportedName);\n    }\n  }\n\n  visitExportStatement(node: ExportStatement): void {\n    let sb = this.sb;\n    if (node.isDeclare) {\n      sb.push(\"declare \");\n    }\n    let members = node.members;\n    if (members == null) {\n      sb.push(\"export *\");\n    } else if (members.length > 0) {\n      let numMembers = members.length;\n      sb.push(\"export {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitExportMember(members[0]);\n      for (let i = 1; i < numMembers; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitExportMember(members[i]);\n      }\n      --this.indentLevel;\n      sb.push(\"\\n}\");\n    } else {\n      sb.push(\"export {}\");\n    }\n    let path = node.path;\n    if (path) {\n      sb.push(\" from \");\n      this.visitStringLiteralExpression(path);\n    }\n    sb.push(\";\");\n  }\n\n  visitExportDefaultStatement(node: ExportDefaultStatement): void {\n    let declaration = node.declaration;\n    switch (declaration.kind) {\n      case NodeKind.EnumDeclaration: {\n        this.visitEnumDeclaration(<EnumDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.ClassDeclaration: {\n        this.visitClassDeclaration(<ClassDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>declaration, true);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitExpressionStatement(node: ExpressionStatement): void {\n    this.visitNode(node.expression);\n  }\n\n  visitFieldDeclaration(node: FieldDeclaration): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    this.visitIdentifierExpression(node.name);\n    let sb = this.sb;\n    if (node.flags & CommonFlags.DefinitelyAssigned) {\n      sb.push(\"!\");\n    }\n    let type = node.type;\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    let initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitForStatement(node: ForStatement): void {\n    let sb = this.sb;\n    sb.push(\"for (\");\n    let initializer = node.initializer;\n    if (initializer) {\n      this.visitNode(initializer);\n    }\n    let condition = node.condition;\n    if (condition) {\n      sb.push(\"; \");\n      this.visitNode(condition);\n    } else {\n      sb.push(\";\");\n    }\n    let incrementor = node.incrementor;\n    if (incrementor) {\n      sb.push(\"; \");\n      this.visitNode(incrementor);\n    } else {\n      sb.push(\";\");\n    }\n    sb.push(\") \");\n    this.visitNode(node.body);\n  }\n\n  visitForOfStatement(node: ForOfStatement): void {\n    let sb = this.sb;\n    sb.push(\"for (\");\n    this.visitNode(node.variable);\n    sb.push(\" of \");\n    this.visitNode(node.iterable);\n    sb.push(\") \");\n    this.visitNode(node.body);\n  }\n\n  visitFunctionDeclaration(node: FunctionDeclaration, isDefault: bool = false): void {\n    let sb = this.sb;\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n      this.serializeAccessModifiers(node);\n    }\n    if (node.name.text.length) {\n      sb.push(\"function \");\n    } else {\n      sb.push(\"function\");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitFunctionCommon(node: FunctionDeclaration): void {\n    let sb = this.sb;\n    this.visitIdentifierExpression(node.name);\n    let signature = node.signature;\n    let typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        this.visitTypeParameter(typeParameters[0]);\n        for (let i = 1; i < numTypeParameters; ++i) {\n          sb.push(\", \");\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    if (node.arrowKind == ArrowKind.Single) {\n      let parameters = signature.parameters;\n      assert(parameters.length == 1);\n      assert(!signature.explicitThisType);\n      this.serializeParameter(parameters[0]);\n    } else {\n      sb.push(\"(\");\n      let parameters = signature.parameters;\n      let numParameters = parameters.length;\n      let explicitThisType = signature.explicitThisType;\n      if (explicitThisType) {\n        sb.push(\"this: \");\n        this.visitTypeNode(explicitThisType);\n      }\n      if (numParameters) {\n        if (explicitThisType) sb.push(\", \");\n        this.serializeParameter(parameters[0]);\n        for (let i = 1; i < numParameters; ++i) {\n          sb.push(\", \");\n          this.serializeParameter(parameters[i]);\n        }\n      }\n    }\n    let body = node.body;\n    let returnType = signature.returnType;\n    if (node.arrowKind) {\n      if (body) {\n        if (node.arrowKind == ArrowKind.Single) {\n          assert(isTypeOmitted(returnType));\n        } else {\n          if (isTypeOmitted(returnType)) {\n            sb.push(\")\");\n          } else {\n            sb.push(\"): \");\n            this.visitTypeNode(returnType);\n          }\n        }\n        sb.push(\" => \");\n        this.visitNode(body);\n      } else {\n        assert(!isTypeOmitted(returnType));\n        sb.push(\" => \");\n        this.visitTypeNode(returnType);\n      }\n    } else {\n      if (\n        !isTypeOmitted(returnType) &&\n        !node.isAny(CommonFlags.Constructor | CommonFlags.Set)\n      ) {\n        sb.push(\"): \");\n        this.visitTypeNode(returnType);\n      } else {\n        sb.push(\")\");\n      }\n      if (body) {\n        sb.push(\" \");\n        this.visitNode(body);\n      }\n    }\n  }\n\n  visitIfStatement(node: IfStatement): void {\n    let sb = this.sb;\n    sb.push(\"if (\");\n    this.visitNode(node.condition);\n    sb.push(\") \");\n    let ifTrue = node.ifTrue;\n    this.visitNode(ifTrue);\n    if (ifTrue.kind != NodeKind.Block) {\n      sb.push(\";\\n\");\n    }\n    let ifFalse = node.ifFalse;\n    if (ifFalse) {\n      if (ifTrue.kind == NodeKind.Block) {\n        sb.push(\" else \");\n      } else {\n        sb.push(\"else \");\n      }\n      this.visitNode(ifFalse);\n    }\n  }\n\n  visitImportDeclaration(node: ImportDeclaration): void {\n    let externalName = node.foreignName;\n    let name = node.name;\n    this.visitIdentifierExpression(externalName);\n    if (externalName.text != name.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(name);\n    }\n  }\n\n  visitImportStatement(node: ImportStatement): void {\n    let sb = this.sb;\n    sb.push(\"import \");\n    let declarations = node.declarations;\n    let namespaceName = node.namespaceName;\n    if (declarations) {\n      let numDeclarations = declarations.length;\n      if (numDeclarations) {\n        sb.push(\"{\\n\");\n        let indentLevel = ++this.indentLevel;\n        indent(sb, indentLevel);\n        this.visitImportDeclaration(declarations[0]);\n        for (let i = 1; i < numDeclarations; ++i) {\n          sb.push(\",\\n\");\n          indent(sb, indentLevel);\n          this.visitImportDeclaration(declarations[i]);\n        }\n        --this.indentLevel;\n        sb.push(\"\\n} from \");\n      } else {\n        sb.push(\"{} from \");\n      }\n    } else if (namespaceName) {\n      sb.push(\"* as \");\n      this.visitIdentifierExpression(namespaceName);\n      sb.push(\" from \");\n    }\n    this.visitStringLiteralExpression(node.path);\n  }\n\n  visitIndexSignature(node: IndexSignatureNode): void {\n    let sb = this.sb;\n    sb.push(\"[key: \");\n    this.visitTypeNode(node.keyType);\n    sb.push(\"]: \");\n    this.visitTypeNode(node.valueType);\n  }\n\n  visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault: bool = false): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"interface \");\n    this.visitIdentifierExpression(node.name);\n    let typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    let extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    // must not have implementsTypes\n    sb.push(\" {\\n\");\n    let indentLevel = ++this.indentLevel;\n    let members = node.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(members[i]);\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitMethodDeclaration(node: MethodDeclaration): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    if (node.is(CommonFlags.Get)) {\n      this.sb.push(\"get \");\n    } else if (node.is(CommonFlags.Set)) {\n      this.sb.push(\"set \");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault: bool = false): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"namespace \");\n    this.visitIdentifierExpression(node.name);\n    let members = node.members;\n    let numMembers = members.length;\n    if (numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0, k = members.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(members[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitReturnStatement(node: ReturnStatement): void {\n    let value = node.value;\n    if (value) {\n      this.sb.push(\"return \");\n      this.visitNode(value);\n    } else {\n      this.sb.push(\"return\");\n    }\n  }\n\n  visitSwitchCase(node: SwitchCase): void {\n    let sb = this.sb;\n    let label = node.label;\n    if (label) {\n      sb.push(\"case \");\n      this.visitNode(label);\n      sb.push(\":\\n\");\n    } else {\n      sb.push(\"default:\\n\");\n    }\n    let statements = node.statements;\n    let numStatements = statements.length;\n    if (numStatements) {\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[0]);\n      for (let i = 1; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      --this.indentLevel;\n    }\n  }\n\n  visitSwitchStatement(node: SwitchStatement): void {\n    let sb = this.sb;\n    sb.push(\"switch (\");\n    this.visitNode(node.condition);\n    sb.push(\") {\\n\");\n    let indentLevel = ++this.indentLevel;\n    let cases = node.cases;\n    for (let i = 0, k = cases.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitSwitchCase(cases[i]);\n      sb.push(\"\\n\");\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitThrowStatement(node: ThrowStatement): void {\n    this.sb.push(\"throw \");\n    this.visitNode(node.value);\n  }\n\n  visitTryStatement(node: TryStatement): void {\n    let sb = this.sb;\n    sb.push(\"try {\\n\");\n    let indentLevel = ++this.indentLevel;\n    let bodyStatements = node.bodyStatements;\n    for (let i = 0, k = bodyStatements.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(bodyStatements[i]);\n    }\n    let catchVariable = node.catchVariable;\n    if (catchVariable) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} catch (\");\n      this.visitIdentifierExpression(catchVariable);\n      sb.push(\") {\\n\");\n      let catchStatements = node.catchStatements;\n      if (catchStatements) {\n        for (let i = 0, k = catchStatements.length; i < k; ++i) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(catchStatements[i]);\n        }\n      }\n    }\n    let finallyStatements = node.finallyStatements;\n    if (finallyStatements) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} finally {\\n\");\n      for (let i = 0, k = finallyStatements.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(finallyStatements[i]);\n      }\n    }\n    indent(sb, indentLevel - 1);\n    sb.push(\"}\");\n  }\n\n  visitTypeDeclaration(node: TypeDeclaration): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    this.serializeExternalModifiers(node);\n    sb.push(\"type \");\n    this.visitIdentifierExpression(node.name);\n    let typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        for (let i = 0; i < numTypeParameters; ++i) {\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    sb.push(\" = \");\n    this.visitTypeNode(node.type);\n  }\n\n  visitModuleDeclaration(node: ModuleDeclaration): void {\n    let sb = this.sb;\n    if (node.flags & CommonFlags.Declare) {\n      sb.push(\"declare \");\n    }\n    sb.push(\"module \\\"\");\n    sb.push(escapeString(node.moduleName, CharCode.DoubleQuote));\n    sb.push(\"\\\"\");\n  }\n\n  visitVariableDeclaration(node: VariableDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    let type = node.type;\n    let sb = this.sb;\n    if (node.flags & CommonFlags.DefinitelyAssigned) {\n      sb.push(\"!\");\n    }\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    let initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitVariableStatement(node: VariableStatement): void {\n    let decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    let sb = this.sb;\n    let declarations = node.declarations;\n    let numDeclarations = assert(declarations.length);\n    let firstDeclaration = declarations[0];\n    this.serializeExternalModifiers(firstDeclaration);\n    sb.push(firstDeclaration.is(CommonFlags.Const) ? \"const \" : firstDeclaration.is(CommonFlags.Let) ? \"let \" : \"var \");\n    this.visitVariableDeclaration(node.declarations[0]);\n    for (let i = 1; i < numDeclarations; ++i) {\n      sb.push(\", \");\n      this.visitVariableDeclaration(node.declarations[i]);\n    }\n  }\n\n  visitWhileStatement(node: WhileStatement): void {\n    let sb = this.sb;\n    sb.push(\"while (\");\n    this.visitNode(node.condition);\n    let body = node.body;\n    if (body.isEmpty) {\n      sb.push(\")\");\n    } else {\n      sb.push(\") \");\n      this.visitNode(body);\n    }\n  }\n\n  // other\n\n  serializeDecorator(node: DecoratorNode): void {\n    let sb = this.sb;\n    sb.push(\"@\");\n    this.visitNode(node.name);\n    let args = node.args;\n    if (args) {\n      sb.push(\"(\");\n      let numArgs = args.length;\n      if (numArgs) {\n        this.visitNode(args[0]);\n        for (let i = 1; i < numArgs; ++i) {\n          sb.push(\", \");\n          this.visitNode(args[i]);\n        }\n      }\n      sb.push(\")\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, this.indentLevel);\n  }\n\n  serializeParameter(node: ParameterNode): void {\n    let sb = this.sb;\n    let kind = node.parameterKind;\n    let implicitFieldDeclaration = node.implicitFieldDeclaration;\n    if (implicitFieldDeclaration) {\n      this.serializeAccessModifiers(implicitFieldDeclaration);\n    }\n    if (kind == ParameterKind.Rest) {\n      sb.push(\"...\");\n    }\n    this.visitIdentifierExpression(node.name);\n    let type = node.type;\n    let initializer = node.initializer;\n    if (type) {\n      if (kind == ParameterKind.Optional && !initializer) sb.push(\"?\");\n      if (!isTypeOmitted(type)) {\n        sb.push(\": \");\n        this.visitTypeNode(type);\n      }\n    }\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  serializeExternalModifiers(node: DeclarationStatement): void {\n    let sb = this.sb;\n    if (node.is(CommonFlags.Export)) {\n      sb.push(\"export \");\n    } else if (node.is(CommonFlags.Import)) {\n      sb.push(\"import \");\n    } else if (node.is(CommonFlags.Declare)) {\n      sb.push(\"declare \");\n    }\n  }\n\n  serializeAccessModifiers(node: DeclarationStatement): void {\n    let sb = this.sb;\n    if (node.is(CommonFlags.Declare)) {\n      sb.push(\"declare \");\n    }\n    if (node.is(CommonFlags.Public)) {\n      sb.push(\"public \");\n    } else if (node.is(CommonFlags.Private)) {\n      sb.push(\"private \");\n    } else if (node.is(CommonFlags.Protected)) {\n      sb.push(\"protected \");\n    }\n    if (node.is(CommonFlags.Static)) {\n      sb.push(\"static \");\n    } else if (node.is(CommonFlags.Abstract)) {\n      sb.push(\"abstract \");\n    }\n    if (node.is(CommonFlags.Readonly)) {\n      sb.push(\"readonly \");\n    }\n  }\n\n  finish(): string {\n    let ret = this.sb.join(\"\");\n    this.sb = [];\n    return ret;\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * from \"./index-js\";\nimport * as assemblyscript from \"./index-js\";\nexport default assemblyscript;\n"],
  "mappings": "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,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,IAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,MAC1B,EACMH,GAA4B,IAC5BC,GAA4B,OAG5BM,GAA+B,CAEnC,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,IACxD,IAAQ,IAAQ,IAAQ,IAAQ,IAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,IAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KACxD,KAAQ,KAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,MACxD,MAAQ,MAAQ,MAAQ,MAAQ,MAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACxD,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OACx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",
  "names": ["index_js_exports", "__export", "ASTBuilder", "ArrayLiteralExpression", "ArrowKind", "AssertionExpression", "AssertionKind", "AtomicRMWOp", "BinaryExpression", "BinaryModule", "BinaryOp", "BlockStatement", "BrOnOp", "BreakStatement", "CallExpression", "Class", "ClassDeclaration", "ClassExpression", "ClassPrototype", "CommaExpression", "CommentKind", "CommentNode", "CommonFlags", "CommonNames", "CompiledExpression", "Compiler", "ConditionKind", "ConstantValueKind", "Constraints", "ConstructorExpression", "ContinueStatement", "DEFAULT_STACK_SIZE", "DeclarationStatement", "DeclaredElement", "DecoratorFlags", "DecoratorKind", "DecoratorNode", "DiagnosticCategory", "DiagnosticCode", "DiagnosticEmitter", "DiagnosticMessage", "DoStatement", "Element", "ElementAccessExpression", "ElementKind", "EmptyStatement", "Enum", "EnumDeclaration", "EnumValue", "EnumValueDeclaration", "ExportDefaultStatement", "ExportImportStatement", "ExportMember", "ExportNames", "ExportStatement", "Expression", "ExpressionId", "ExpressionRunnerFlags", "ExpressionStatement", "ExternalKind", "FEATURE_BULK_MEMORY", "FEATURE_EXCEPTION_HANDLING", "FEATURE_EXTENDED_CONST", "FEATURE_GC", "FEATURE_MEMORY64", "FEATURE_MULTI_VALUE", "FEATURE_MUTABLE_GLOBALS", "FEATURE_NONTRAPPING_F2I", "FEATURE_REFERENCE_TYPES", "FEATURE_RELAXED_SIMD", "FEATURE_SIGN_EXTENSION", "FEATURE_SIMD", "FEATURE_STRINGREF", "FEATURE_TAIL_CALLS", "FEATURE_THREADS", "FalseExpression", "Feature", "FeatureFlags", "FieldDeclaration", "FieldFlags", "File", "FloatLiteralExpression", "Flow", "FlowFlags", "ForOfStatement", "ForStatement", "Function", "FunctionDeclaration", "FunctionExpression", "FunctionPrototype", "FunctionTypeNode", "GETTER_PREFIX", "Global", "HeapTypeRef", "INDEX_SUFFIX", "INNER_DELIMITER", "INSTANCE_DELIMITER", "IdentifierExpression", "IdentifierHandling", "IfStatement", "ImportDeclaration", "ImportNames", "ImportStatement", "IndexSignature", "IndexSignatureNode", "InstanceOfExpression", "IntegerLiteralExpression", "Interface", "InterfaceDeclaration", "InterfacePrototype", "JSBuilder", "LIBRARY_PREFIX", "LIBRARY_SUBST", "LiteralExpression", "LiteralKind", "Local", "LocalFlags", "MemorySegment", "MethodDeclaration", "Module", "ModuleDeclaration", "NamedTypeNode", "Namespace", "NamespaceDeclaration", "NewExpression", "Node", "NodeKind", "NullExpression", "ObjectLiteralExpression", "OmittedExpression", "OperatorKind", "Options", "PARENT_SUBST", "PATH_DELIMITER", "PackedType", "Parameter", "ParameterKind", "ParameterNode", "ParenthesizedExpression", "Parser", "Precedence", "Program", "Property", "PropertyAccessExpression", "PropertyPrototype", "Range", "RefAsOp", "RefIsOp", "RegexpLiteralExpression", "Relooper", "ReportMode", "Resolver", "ReturnStatement", "Runtime", "RuntimeFeatures", "SETTER_PREFIX", "SIMDExtractOp", "SIMDLoadOp", "SIMDLoadStoreLaneOp", "SIMDReplaceOp", "SIMDShiftOp", "SIMDTernaryOp", "STATIC_DELIMITER", "STUB_DELIMITER", "SideEffects", "Signature", "Source", "SourceKind", "State", "Statement", "StringAsOp", "StringEncodeOp", "StringIterMoveOp", "StringLiteralExpression", "StringMeasureOp", "StringNewOp", "StringSliceWTFOp", "SuperExpression", "SwitchBuilder", "SwitchCase", "SwitchStatement", "TSDBuilder", "Target", "TemplateLiteralExpression", "TernaryExpression", "ThisExpression", "ThrowStatement", "Token", "Tokenizer", "TrueExpression", "TryStatement", "Type", "TypeBuilderErrorReason", "TypeDeclaration", "TypeDefinition", "TypeFlags", "TypeKind", "TypeName", "TypeNode", "TypeParameterNode", "TypeRef", "TypeSystem", "TypedElement", "Typeinfo", "TypeinfoFlags", "UnaryExpression", "UnaryOp", "UnaryPostfixExpression", "UnaryPrefixExpression", "UncheckedBehavior", "VariableDeclaration", "VariableLikeDeclarationStatement", "VariableLikeElement", "VariableStatement", "VoidStatement", "WhileStatement", "addGlobalAlias", "allocPtrArray", "buildJS", "buildTSD", "compile", "createType", "diagnosticCategoryToColor", "diagnosticCategoryToString", "diagnosticCodeToString", "disableFeature", "enableFeature", "ensureType", "expandType", "featureToString", "findDecorator", "formatDiagnosticMessage", "getBinaryLeft", "getBinaryOp", "getBinaryRight", "getBinaryenModuleRef", "getBlockChildAt", "getBlockChildCount", "getBlockName", "getBreakCondition", "getBreakName", "getCallOperandAt", "getCallOperandCount", "getCallTarget", "getConstValueF32", "getConstValueF64", "getConstValueI32", "getConstValueI64High", "getConstValueI64Low", "getConstValueV128", "getDefaultParameterName", "getDependee", "getDiagnosticCategory", "getDiagnosticCode", "getDiagnosticMessage", "getDiagnosticRange", "getDiagnosticRelatedRange", "getDropValue", "getExpressionId", "getExpressionType", "getFunctionBody", "getFunctionName", "getFunctionParams", "getFunctionResults", "getFunctionVars", "getGlobalGetName", "getGlobalInit", "getGlobalName", "getGlobalType", "getIfCondition", "getIfFalse", "getIfTrue", "getLoadBytes", "getLoadOffset", "getLoadPtr", "getLocalGetIndex", "getLocalSetIndex", "getLocalSetValue", "getLoopBody", "getLoopName", "getMemoryGrowDelta", "getRangeEnd", "getRangeSource", "getRangeStart", "getReturnValue", "getSelectCondition", "getSelectElse", "getSelectThen", "getSideEffects", "getSource", "getSourceNormalizedPath", "getStoreBytes", "getStoreOffset", "getStorePtr", "getStoreValue", "getTagName", "getTagParams", "getTagResults", "getUnaryOp", "getUnaryValue", "initializeProgram", "isConstExpressionNaN", "isConstNaN", "isConstNegZero", "isConstNonZero", "isConstZero", "isDeclaredElement", "isError", "isGlobalMutable", "isIllegalVariableIdentifier", "isInfo", "isLoadSigned", "isLocalTee", "isNullableType", "isTypeOmitted", "isTypedElement", "isWarning", "mangleInternalName", "mangleInternalPath", "mustPreserveSideEffects", "newOptions", "newProgram", "nextDiagnostic", "nextFile", "operatorTokenToString", "optimize", "parse", "readString", "removeGlobalAlias", "setBasenameHint", "setBindingsHint", "setBundleVersion", "setDebugInfo", "setExportMemory", "setExportRuntime", "setExportStart", "setExportTable", "setImportMemory", "setImportTable", "setInitialMemory", "setLowMemoryLimit", "setMaximumMemory", "setMemoryBase", "setNoAssert", "setNoUnsafe", "setOptimizeLevelHints", "setPedantic", "setRuntime", "setSharedMemory", "setSourceMap", "setStackSize", "setTableBase", "setTarget", "setUncheckedBehavior", "tokenFromKeyword", "tokenIsAlsoIdentifier", "typesToRefs", "typesToString", "util_exports", "validate", "globalScope", "UnreachableError", "AssertionError", "message", "defaultComparator", "b", "nanA", "nanB", "F64", "U64", "value", "shift", "y", "ifTrue", "ifFalse", "condition", "x", "a", "isTrueish", "arr", "len", "index", "parts", "search", "replacment", "res", "arraySort", "comparator", "Ctr", "fn", "i", "buffer", "byteOffset", "length", "arg", "expr", "n", "binaryen_exports", "__export", "default", "__reExport", "binaryen_star", "_BinaryenTypeCreate", "_BinaryenTypeArity", "_BinaryenTypeExpand", "_BinaryenTypeGetHeapType", "_BinaryenTypeFromHeapType", "_BinaryenTypeIsNullable", "_BinaryenTypeFuncref", "_BinaryenTypeExternref", "_BinaryenTypeAnyref", "_BinaryenTypeEqref", "_BinaryenTypeI31ref", "_BinaryenTypeDataref", "_BinaryenTypeArrayref", "_BinaryenTypeStringref", "_BinaryenTypeStringviewWTF8", "_BinaryenTypeStringviewWTF16", "_BinaryenTypeStringviewIter", "_BinaryenTypeNullref", "_BinaryenTypeNullExternref", "_BinaryenTypeNullFuncref", "_BinaryenHeapTypeFunc", "_BinaryenHeapTypeExt", "_BinaryenHeapTypeAny", "_BinaryenHeapTypeEq", "_BinaryenHeapTypeI31", "_BinaryenHeapTypeData", "_BinaryenHeapTypeArray", "_BinaryenHeapTypeString", "_BinaryenHeapTypeStringviewWTF8", "_BinaryenHeapTypeStringviewWTF16", "_BinaryenHeapTypeStringviewIter", "_BinaryenHeapTypeNone", "_BinaryenHeapTypeNoext", "_BinaryenHeapTypeNofunc", "_BinaryenHeapTypeIsBasic", "_BinaryenHeapTypeIsSignature", "_BinaryenHeapTypeIsStruct", "_BinaryenHeapTypeIsArray", "_BinaryenHeapTypeIsBottom", "_BinaryenHeapTypeGetBottom", "_BinaryenHeapTypeIsSubType", "_BinaryenStructTypeGetNumFields", "_BinaryenStructTypeGetFieldType", "_BinaryenStructTypeGetFieldPackedType", "_BinaryenStructTypeIsFieldMutable", "_BinaryenArrayTypeGetElementType", "_BinaryenArrayTypeGetElementPackedType", "_BinaryenArrayTypeIsElementMutable", "_BinaryenSignatureTypeGetParams", "_BinaryenSignatureTypeGetResults", "_BinaryenModuleCreate", "_BinaryenModuleDispose", "_BinaryenSizeofLiteral", "_BinaryenLiteralInt32", "_BinaryenLiteralInt64", "_BinaryenLiteralFloat32", "_BinaryenLiteralFloat64", "_BinaryenLiteralVec128", "_BinaryenLiteralFloat32Bits", "_BinaryenLiteralFloat64Bits", "_BinaryenExpressionGetId", "_BinaryenExpressionGetType", "_BinaryenExpressionSetType", "_BinaryenExpressionPrint", "_BinaryenExpressionCopy", "_BinaryenExpressionFinalize", "_BinaryenBlock", "_BinaryenBlockGetName", "_BinaryenBlockSetName", "_BinaryenBlockGetNumChildren", "_BinaryenBlockGetChildAt", "_BinaryenBlockSetChildAt", "_BinaryenBlockAppendChild", "_BinaryenBlockInsertChildAt", "_BinaryenBlockRemoveChildAt", "_BinaryenIf", "_BinaryenIfGetCondition", "_BinaryenIfSetCondition", "_BinaryenIfGetIfTrue", "_BinaryenIfSetIfTrue", "_BinaryenIfGetIfFalse", "_BinaryenIfSetIfFalse", "_BinaryenLoop", "_BinaryenLoopGetName", "_BinaryenLoopSetName", "_BinaryenLoopGetBody", "_BinaryenLoopSetBody", "_BinaryenBreak", "_BinaryenBreakGetName", "_BinaryenBreakSetName", "_BinaryenBreakGetCondition", "_BinaryenBreakSetCondition", "_BinaryenBreakGetValue", "_BinaryenBreakSetValue", "_BinaryenSwitch", "_BinaryenSwitchGetNumNames", "_BinaryenSwitchGetNameAt", "_BinaryenSwitchSetNameAt", "_BinaryenSwitchAppendName", "_BinaryenSwitchInsertNameAt", "_BinaryenSwitchRemoveNameAt", "_BinaryenSwitchGetDefaultName", "_BinaryenSwitchSetDefaultName", "_BinaryenSwitchGetCondition", "_BinaryenSwitchSetCondition", "_BinaryenSwitchGetValue", "_BinaryenSwitchSetValue", "_BinaryenCall", "_BinaryenCallGetTarget", "_BinaryenCallSetTarget", "_BinaryenCallGetNumOperands", "_BinaryenCallGetOperandAt", "_BinaryenCallSetOperandAt", "_BinaryenCallAppendOperand", "_BinaryenCallInsertOperandAt", "_BinaryenCallRemoveOperandAt", "_BinaryenCallIsReturn", "_BinaryenCallSetReturn", "_BinaryenReturnCall", "_BinaryenCallIndirect", "_BinaryenCallIndirectGetTable", "_BinaryenCallIndirectSetTable", "_BinaryenCallIndirectGetTarget", "_BinaryenCallIndirectSetTarget", "_BinaryenCallIndirectGetNumOperands", "_BinaryenCallIndirectGetOperandAt", "_BinaryenCallIndirectSetOperandAt", "_BinaryenCallIndirectAppendOperand", "_BinaryenCallIndirectInsertOperandAt", "_BinaryenCallIndirectRemoveOperandAt", "_BinaryenCallIndirectIsReturn", "_BinaryenCallIndirectSetReturn", "_BinaryenReturnCallIndirect", "_BinaryenLocalGet", "_BinaryenLocalGetGetIndex", "_BinaryenLocalGetSetIndex", "_BinaryenLocalSet", "_BinaryenLocalSetIsTee", "_BinaryenLocalSetGetIndex", "_BinaryenLocalSetSetIndex", "_BinaryenLocalSetGetValue", "_BinaryenLocalSetSetValue", "_BinaryenLocalTee", "_BinaryenGlobalGet", "_BinaryenGlobalGetGetName", "_BinaryenGlobalGetSetName", "_BinaryenGlobalSet", "_BinaryenGlobalSetGetName", "_BinaryenGlobalSetSetName", "_BinaryenGlobalSetGetValue", "_BinaryenGlobalSetSetValue", "_BinaryenMemorySize", "_BinaryenMemoryGrow", "_BinaryenMemoryGrowGetDelta", "_BinaryenMemoryGrowSetDelta", "_BinaryenLoad", "_BinaryenLoadIsAtomic", "_BinaryenLoadSetAtomic", "_BinaryenLoadIsSigned", "_BinaryenLoadSetSigned", "_BinaryenLoadGetOffset", "_BinaryenLoadSetOffset", "_BinaryenLoadGetBytes", "_BinaryenLoadSetBytes", "_BinaryenLoadGetAlign", "_BinaryenLoadSetAlign", "_BinaryenLoadGetPtr", "_BinaryenLoadSetPtr", "_BinaryenAtomicLoad", "_BinaryenStore", "_BinaryenStoreIsAtomic", "_BinaryenStoreSetAtomic", "_BinaryenStoreGetBytes", "_BinaryenStoreSetBytes", "_BinaryenStoreGetOffset", "_BinaryenStoreSetOffset", "_BinaryenStoreGetAlign", "_BinaryenStoreSetAlign", "_BinaryenStoreGetPtr", "_BinaryenStoreSetPtr", "_BinaryenStoreGetValue", "_BinaryenStoreSetValue", "_BinaryenStoreGetValueType", "_BinaryenStoreSetValueType", "_BinaryenAtomicStore", "_BinaryenConst", "_BinaryenConstGetValueI32", "_BinaryenConstSetValueI32", "_BinaryenConstGetValueI64Low", "_BinaryenConstSetValueI64Low", "_BinaryenConstGetValueI64High", "_BinaryenConstSetValueI64High", "_BinaryenConstGetValueF32", "_BinaryenConstSetValueF32", "_BinaryenConstGetValueF64", "_BinaryenConstSetValueF64", "_BinaryenConstGetValueV128", "_BinaryenConstSetValueV128", "_BinaryenUnary", "_BinaryenUnaryGetOp", "_BinaryenUnarySetOp", "_BinaryenUnaryGetValue", "_BinaryenUnarySetValue", "_BinaryenBinary", "_BinaryenBinaryGetOp", "_BinaryenBinarySetOp", "_BinaryenBinaryGetLeft", "_BinaryenBinarySetLeft", "_BinaryenBinaryGetRight", "_BinaryenBinarySetRight", "_BinaryenSelect", "_BinaryenSelectGetIfTrue", "_BinaryenSelectSetIfTrue", "_BinaryenSelectGetIfFalse", "_BinaryenSelectSetIfFalse", "_BinaryenSelectGetCondition", "_BinaryenSelectSetCondition", "_BinaryenDrop", "_BinaryenDropGetValue", "_BinaryenDropSetValue", "_BinaryenReturn", "_BinaryenReturnGetValue", "_BinaryenReturnSetValue", "_BinaryenNop", "_BinaryenUnreachable", "_BinaryenAtomicRMW", "_BinaryenAtomicRMWGetOp", "_BinaryenAtomicRMWSetOp", "_BinaryenAtomicRMWGetBytes", "_BinaryenAtomicRMWSetBytes", "_BinaryenAtomicRMWGetOffset", "_BinaryenAtomicRMWSetOffset", "_BinaryenAtomicRMWGetPtr", "_BinaryenAtomicRMWSetPtr", "_BinaryenAtomicRMWGetValue", "_BinaryenAtomicRMWSetValue", "_BinaryenAtomicCmpxchg", "_BinaryenAtomicCmpxchgGetBytes", "_BinaryenAtomicCmpxchgSetBytes", "_BinaryenAtomicCmpxchgGetOffset", "_BinaryenAtomicCmpxchgSetOffset", "_BinaryenAtomicCmpxchgGetPtr", "_BinaryenAtomicCmpxchgSetPtr", "_BinaryenAtomicCmpxchgGetExpected", "_BinaryenAtomicCmpxchgSetExpected", "_BinaryenAtomicCmpxchgGetReplacement", "_BinaryenAtomicCmpxchgSetReplacement", "_BinaryenAtomicWait", "_BinaryenAtomicWaitGetPtr", "_BinaryenAtomicWaitSetPtr", "_BinaryenAtomicWaitGetExpected", "_BinaryenAtomicWaitSetExpected", "_BinaryenAtomicWaitGetTimeout", "_BinaryenAtomicWaitSetTimeout", "_BinaryenAtomicWaitGetExpectedType", "_BinaryenAtomicWaitSetExpectedType", "_BinaryenAtomicNotify", "_BinaryenAtomicNotifyGetPtr", "_BinaryenAtomicNotifySetPtr", "_BinaryenAtomicNotifyGetNotifyCount", "_BinaryenAtomicNotifySetNotifyCount", "_BinaryenAtomicFence", "_BinaryenAtomicFenceGetOrder", "_BinaryenAtomicFenceSetOrder", "_BinaryenSIMDExtract", "_BinaryenSIMDExtractGetOp", "_BinaryenSIMDExtractSetOp", "_BinaryenSIMDExtractGetVec", "_BinaryenSIMDExtractSetVec", "_BinaryenSIMDExtractGetIndex", "_BinaryenSIMDExtractSetIndex", "_BinaryenSIMDReplace", "_BinaryenSIMDReplaceGetOp", "_BinaryenSIMDReplaceSetOp", "_BinaryenSIMDReplaceGetVec", "_BinaryenSIMDReplaceSetVec", "_BinaryenSIMDReplaceGetIndex", "_BinaryenSIMDReplaceSetIndex", "_BinaryenSIMDReplaceGetValue", "_BinaryenSIMDReplaceSetValue", "_BinaryenSIMDShuffle", "_BinaryenSIMDShuffleGetLeft", "_BinaryenSIMDShuffleSetLeft", "_BinaryenSIMDShuffleGetRight", "_BinaryenSIMDShuffleSetRight", "_BinaryenSIMDShuffleGetMask", "_BinaryenSIMDShuffleSetMask", "_BinaryenSIMDTernary", "_BinaryenSIMDTernaryGetOp", "_BinaryenSIMDTernarySetOp", "_BinaryenSIMDTernaryGetA", "_BinaryenSIMDTernarySetA", "_BinaryenSIMDTernaryGetB", "_BinaryenSIMDTernarySetB", "_BinaryenSIMDTernaryGetC", "_BinaryenSIMDTernarySetC", "_BinaryenSIMDShift", "_BinaryenSIMDShiftGetOp", "_BinaryenSIMDShiftSetOp", "_BinaryenSIMDShiftGetVec", "_BinaryenSIMDShiftSetVec", "_BinaryenSIMDShiftGetShift", "_BinaryenSIMDShiftSetShift", "_BinaryenSIMDLoad", "_BinaryenSIMDLoadGetOp", "_BinaryenSIMDLoadSetOp", "_BinaryenSIMDLoadGetOffset", "_BinaryenSIMDLoadSetOffset", "_BinaryenSIMDLoadGetAlign", "_BinaryenSIMDLoadSetAlign", "_BinaryenSIMDLoadGetPtr", "_BinaryenSIMDLoadSetPtr", "_BinaryenSIMDLoadStoreLane", "_BinaryenSIMDLoadStoreLaneGetOp", "_BinaryenSIMDLoadStoreLaneSetOp", "_BinaryenSIMDLoadStoreLaneGetOffset", "_BinaryenSIMDLoadStoreLaneSetOffset", "_BinaryenSIMDLoadStoreLaneGetAlign", "_BinaryenSIMDLoadStoreLaneSetAlign", "_BinaryenSIMDLoadStoreLaneGetIndex", "_BinaryenSIMDLoadStoreLaneSetIndex", "_BinaryenSIMDLoadStoreLaneGetPtr", "_BinaryenSIMDLoadStoreLaneSetPtr", "_BinaryenSIMDLoadStoreLaneGetVec", "_BinaryenSIMDLoadStoreLaneSetVec", "_BinaryenSIMDLoadStoreLaneIsStore", "_BinaryenMemoryInit", "_BinaryenMemoryInitGetSegment", "_BinaryenMemoryInitSetSegment", "_BinaryenMemoryInitGetDest", "_BinaryenMemoryInitSetDest", "_BinaryenMemoryInitGetOffset", "_BinaryenMemoryInitSetOffset", "_BinaryenMemoryInitGetSize", "_BinaryenMemoryInitSetSize", "_BinaryenDataDrop", "_BinaryenDataDropGetSegment", "_BinaryenDataDropSetSegment", "_BinaryenMemoryCopy", "_BinaryenMemoryCopyGetDest", "_BinaryenMemoryCopySetDest", "_BinaryenMemoryCopyGetSource", "_BinaryenMemoryCopySetSource", "_BinaryenMemoryCopyGetSize", "_BinaryenMemoryCopySetSize", "_BinaryenMemoryFill", "_BinaryenMemoryFillGetDest", "_BinaryenMemoryFillSetDest", "_BinaryenMemoryFillGetValue", "_BinaryenMemoryFillSetValue", "_BinaryenMemoryFillGetSize", "_BinaryenMemoryFillSetSize", "_BinaryenRefNull", "_BinaryenRefIs", "_BinaryenRefIsGetOp", "_BinaryenRefIsSetOp", "_BinaryenRefIsGetValue", "_BinaryenRefIsSetValue", "_BinaryenRefAs", "_BinaryenRefAsGetOp", "_BinaryenRefAsSetOp", "_BinaryenRefAsGetValue", "_BinaryenRefAsSetValue", "_BinaryenRefFunc", "_BinaryenRefFuncGetFunc", "_BinaryenRefFuncSetFunc", "_BinaryenRefEq", "_BinaryenRefEqGetLeft", "_BinaryenRefEqSetLeft", "_BinaryenRefEqGetRight", "_BinaryenRefEqSetRight", "_BinaryenTableGet", "_BinaryenTableGetGetTable", "_BinaryenTableGetSetTable", "_BinaryenTableGetGetIndex", "_BinaryenTableGetSetIndex", "_BinaryenTableSet", "_BinaryenTableSetGetTable", "_BinaryenTableSetSetTable", "_BinaryenTableSetGetIndex", "_BinaryenTableSetSetIndex", "_BinaryenTableSetGetValue", "_BinaryenTableSetSetValue", "_BinaryenTableSize", "_BinaryenTableSizeGetTable", "_BinaryenTableSizeSetTable", "_BinaryenTableGrow", "_BinaryenTableGrowGetTable", "_BinaryenTableGrowSetTable", "_BinaryenTableGrowGetValue", "_BinaryenTableGrowSetValue", "_BinaryenTableGrowGetDelta", "_BinaryenTableGrowSetDelta", "_BinaryenTry", "_BinaryenTryGetName", "_BinaryenTrySetName", "_BinaryenTryGetBody", "_BinaryenTrySetBody", "_BinaryenTryGetNumCatchTags", "_BinaryenTryGetNumCatchBodies", "_BinaryenTryGetCatchTagAt", "_BinaryenTrySetCatchTagAt", "_BinaryenTryAppendCatchTag", "_BinaryenTryInsertCatchTagAt", "_BinaryenTryRemoveCatchTagAt", "_BinaryenTryGetCatchBodyAt", "_BinaryenTrySetCatchBodyAt", "_BinaryenTryAppendCatchBody", "_BinaryenTryInsertCatchBodyAt", "_BinaryenTryRemoveCatchBodyAt", "_BinaryenTryHasCatchAll", "_BinaryenTryGetDelegateTarget", "_BinaryenTrySetDelegateTarget", "_BinaryenTryIsDelegate", "_BinaryenThrow", "_BinaryenThrowGetTag", "_BinaryenThrowSetTag", "_BinaryenThrowGetNumOperands", "_BinaryenThrowGetOperandAt", "_BinaryenThrowSetOperandAt", "_BinaryenThrowAppendOperand", "_BinaryenThrowInsertOperandAt", "_BinaryenThrowRemoveOperandAt", "_BinaryenRethrow", "_BinaryenRethrowGetTarget", "_BinaryenRethrowSetDepth", "_BinaryenTupleMake", "_BinaryenTupleMakeGetNumOperands", "_BinaryenTupleMakeGetOperandAt", "_BinaryenTupleMakeSetOperandAt", "_BinaryenTupleMakeAppendOperand", "_BinaryenTupleMakeInsertOperandAt", "_BinaryenTupleMakeRemoveOperandAt", "_BinaryenTupleExtract", "_BinaryenTupleExtractGetTuple", "_BinaryenTupleExtractSetTuple", "_BinaryenTupleExtractGetIndex", "_BinaryenTupleExtractSetIndex", "_BinaryenPop", "_BinaryenI31New", "_BinaryenI31NewGetValue", "_BinaryenI31NewSetValue", "_BinaryenI31Get", "_BinaryenI31GetGetI31", "_BinaryenI31GetSetI31", "_BinaryenI31GetIsSigned", "_BinaryenI31GetSetSigned", "_BinaryenCallRef", "_BinaryenCallRefGetNumOperands", "_BinaryenCallRefGetOperandAt", "_BinaryenCallRefSetOperandAt", "_BinaryenCallRefAppendOperand", "_BinaryenCallRefInsertOperandAt", "_BinaryenCallRefRemoveOperandAt", "_BinaryenCallRefGetTarget", "_BinaryenCallRefSetTarget", "_BinaryenCallRefIsReturn", "_BinaryenCallRefSetReturn", "_BinaryenRefTest", "_BinaryenRefTestGetRef", "_BinaryenRefTestSetRef", "_BinaryenRefTestGetIntendedType", "_BinaryenRefTestSetIntendedType", "_BinaryenRefCast", "_BinaryenRefCastGetRef", "_BinaryenRefCastSetRef", "_BinaryenRefCastGetIntendedType", "_BinaryenRefCastSetIntendedType", "_BinaryenBrOn", "_BinaryenBrOnGetOp", "_BinaryenBrOnSetOp", "_BinaryenBrOnGetName", "_BinaryenBrOnSetName", "_BinaryenBrOnGetRef", "_BinaryenBrOnSetRef", "_BinaryenBrOnGetIntendedType", "_BinaryenBrOnSetIntendedType", "_BinaryenStructNew", "_BinaryenStructNewGetNumOperands", "_BinaryenStructNewGetOperandAt", "_BinaryenStructNewSetOperandAt", "_BinaryenStructNewAppendOperand", "_BinaryenStructNewInsertOperandAt", "_BinaryenStructNewRemoveOperandAt", "_BinaryenStructGet", "_BinaryenStructGetGetIndex", "_BinaryenStructGetSetIndex", "_BinaryenStructGetGetRef", "_BinaryenStructGetSetRef", "_BinaryenStructGetIsSigned", "_BinaryenStructGetSetSigned", "_BinaryenStructSet", "_BinaryenStructSetGetIndex", "_BinaryenStructSetSetIndex", "_BinaryenStructSetGetRef", "_BinaryenStructSetSetRef", "_BinaryenStructSetGetValue", "_BinaryenStructSetSetValue", "_BinaryenArrayNew", "_BinaryenArrayNewGetInit", "_BinaryenArrayNewSetInit", "_BinaryenArrayNewGetSize", "_BinaryenArrayNewSetSize", "_BinaryenArrayInit", "_BinaryenArrayInitGetNumValues", "_BinaryenArrayInitGetValueAt", "_BinaryenArrayInitSetValueAt", "_BinaryenArrayInitAppendValue", "_BinaryenArrayInitInsertValueAt", "_BinaryenArrayInitRemoveValueAt", "_BinaryenArrayGet", "_BinaryenArrayGetGetRef", "_BinaryenArrayGetSetRef", "_BinaryenArrayGetGetIndex", "_BinaryenArrayGetSetIndex", "_BinaryenArrayGetIsSigned", "_BinaryenArrayGetSetSigned", "_BinaryenArraySet", "_BinaryenArraySetGetRef", "_BinaryenArraySetSetRef", "_BinaryenArraySetGetIndex", "_BinaryenArraySetSetIndex", "_BinaryenArraySetGetValue", "_BinaryenArraySetSetValue", "_BinaryenArrayLen", "_BinaryenArrayLenGetRef", "_BinaryenArrayLenSetRef", "_BinaryenArrayCopy", "_BinaryenArrayCopyGetDestRef", "_BinaryenArrayCopySetDestRef", "_BinaryenArrayCopyGetDestIndex", "_BinaryenArrayCopySetDestIndex", "_BinaryenArrayCopyGetSrcRef", "_BinaryenArrayCopySetSrcRef", "_BinaryenArrayCopyGetSrcIndex", "_BinaryenArrayCopySetSrcIndex", "_BinaryenArrayCopyGetLength", "_BinaryenArrayCopySetLength", "_BinaryenStringNew", "_BinaryenStringNewGetOp", "_BinaryenStringNewSetOp", "_BinaryenStringNewGetPtr", "_BinaryenStringNewSetPtr", "_BinaryenStringNewGetLength", "_BinaryenStringNewSetLength", "_BinaryenStringNewGetStart", "_BinaryenStringNewSetStart", "_BinaryenStringNewGetEnd", "_BinaryenStringNewSetEnd", "_BinaryenStringConst", "_BinaryenStringConstGetString", "_BinaryenStringConstSetString", "_BinaryenStringMeasure", "_BinaryenStringMeasureGetOp", "_BinaryenStringMeasureSetOp", "_BinaryenStringMeasureGetRef", "_BinaryenStringMeasureSetRef", "_BinaryenStringEncode", "_BinaryenStringEncodeGetOp", "_BinaryenStringEncodeSetOp", "_BinaryenStringEncodeGetRef", "_BinaryenStringEncodeSetRef", "_BinaryenStringEncodeGetPtr", "_BinaryenStringEncodeSetPtr", "_BinaryenStringEncodeGetStart", "_BinaryenStringEncodeSetStart", "_BinaryenStringConcat", "_BinaryenStringConcatGetLeft", "_BinaryenStringConcatSetLeft", "_BinaryenStringConcatGetRight", "_BinaryenStringConcatSetRight", "_BinaryenStringEq", "_BinaryenStringEqGetLeft", "_BinaryenStringEqSetLeft", "_BinaryenStringEqGetRight", "_BinaryenStringEqSetRight", "_BinaryenStringAs", "_BinaryenStringAsGetOp", "_BinaryenStringAsSetOp", "_BinaryenStringAsGetRef", "_BinaryenStringAsSetRef", "_BinaryenStringWTF8Advance", "_BinaryenStringWTF8AdvanceGetRef", "_BinaryenStringWTF8AdvanceSetRef", "_BinaryenStringWTF8AdvanceGetPos", "_BinaryenStringWTF8AdvanceSetPos", "_BinaryenStringWTF8AdvanceGetBytes", "_BinaryenStringWTF8AdvanceSetBytes", "_BinaryenStringWTF16Get", "_BinaryenStringWTF16GetGetRef", "_BinaryenStringWTF16GetSetRef", "_BinaryenStringWTF16GetGetPos", "_BinaryenStringWTF16GetSetPos", "_BinaryenStringIterNext", "_BinaryenStringIterNextGetRef", "_BinaryenStringIterNextSetRef", "_BinaryenStringIterMove", "_BinaryenStringIterMoveGetOp", "_BinaryenStringIterMoveSetOp", "_BinaryenStringIterMoveGetRef", "_BinaryenStringIterMoveSetRef", "_BinaryenStringIterMoveGetNum", "_BinaryenStringIterMoveSetNum", "_BinaryenStringSliceWTF", "_BinaryenStringSliceWTFGetOp", "_BinaryenStringSliceWTFSetOp", "_BinaryenStringSliceWTFGetRef", "_BinaryenStringSliceWTFSetRef", "_BinaryenStringSliceWTFGetStart", "_BinaryenStringSliceWTFSetStart", "_BinaryenStringSliceWTFGetEnd", "_BinaryenStringSliceWTFSetEnd", "_BinaryenStringSliceIter", "_BinaryenStringSliceIterGetRef", "_BinaryenStringSliceIterSetRef", "_BinaryenStringSliceIterGetNum", "_BinaryenStringSliceIterSetNum", "_BinaryenAddFunction", "_BinaryenGetFunction", "_BinaryenRemoveFunction", "_BinaryenGetNumFunctions", "_BinaryenGetFunctionByIndex", "_BinaryenFunctionGetName", "_BinaryenFunctionGetParams", "_BinaryenFunctionGetResults", "_BinaryenFunctionGetNumVars", "_BinaryenFunctionGetVar", "_BinaryenFunctionGetNumLocals", "_BinaryenFunctionHasLocalName", "_BinaryenFunctionGetLocalName", "_BinaryenFunctionSetLocalName", "_BinaryenFunctionGetBody", "_BinaryenFunctionSetBody", "_BinaryenFunctionOptimize", "_BinaryenFunctionRunPasses", "_BinaryenFunctionSetDebugLocation", "_BinaryenAddFunctionImport", "_BinaryenAddTableImport", "_BinaryenAddMemoryImport", "_BinaryenAddGlobalImport", "_BinaryenAddTagImport", "_BinaryenAddFunctionExport", "_BinaryenAddTableExport", "_BinaryenAddMemoryExport", "_BinaryenAddGlobalExport", "_BinaryenAddTagExport", "_BinaryenGetExport", "_BinaryenRemoveExport", "_BinaryenGetNumExports", "_BinaryenGetExportByIndex", "_BinaryenExportGetKind", "_BinaryenExportGetName", "_BinaryenExportGetValue", "_BinaryenAddGlobal", "_BinaryenGetGlobal", "_BinaryenRemoveGlobal", "_BinaryenGetNumGlobals", "_BinaryenGetGlobalByIndex", "_BinaryenGlobalGetName", "_BinaryenGlobalGetType", "_BinaryenGlobalIsMutable", "_BinaryenGlobalGetInitExpr", "_BinaryenAddTag", "_BinaryenGetTag", "_BinaryenRemoveTag", "_BinaryenTagGetName", "_BinaryenTagGetParams", "_BinaryenTagGetResults", "_BinaryenAddTable", "_BinaryenRemoveTable", "_BinaryenGetNumTables", "_BinaryenGetTable", "_BinaryenGetTableByIndex", "_BinaryenTableGetName", "_BinaryenTableSetName", "_BinaryenTableGetInitial", "_BinaryenTableSetInitial", "_BinaryenTableHasMax", "_BinaryenTableGetMax", "_BinaryenTableSetMax", "_BinaryenAddActiveElementSegment", "_BinaryenAddPassiveElementSegment", "_BinaryenRemoveElementSegment", "_BinaryenGetNumElementSegments", "_BinaryenGetElementSegment", "_BinaryenGetElementSegmentByIndex", "_BinaryenSetMemory", "_BinaryenGetNumMemorySegments", "_BinaryenGetMemorySegmentByteOffset", "_BinaryenGetMemorySegmentByteLength", "_BinaryenCopyMemorySegmentData", "_BinaryenSetStart", "_BinaryenModuleParse", "_BinaryenModulePrint", "_BinaryenModulePrintAsmjs", "_BinaryenModuleValidate", "_BinaryenModuleOptimize", "_BinaryenModuleRunPasses", "_BinaryenModuleAutoDrop", "_BinaryenSizeofAllocateAndWriteResult", "_BinaryenModuleAllocateAndWrite", "_BinaryenModuleAllocateAndWriteText", "_BinaryenModuleAllocateAndWriteStackIR", "_BinaryenModuleRead", "_BinaryenModuleInterpret", "_BinaryenModuleAddDebugInfoFileName", "_BinaryenModuleGetDebugInfoFileName", "_BinaryenModuleGetFeatures", "_BinaryenModuleSetFeatures", "_BinaryenAddCustomSection", "_BinaryenExpressionGetSideEffects", "_RelooperCreate", "_RelooperAddBlock", "_RelooperAddBranch", "_RelooperAddBlockWithSwitch", "_RelooperAddBranchForSwitch", "_RelooperRenderAndDispose", "_ExpressionRunnerCreate", "_ExpressionRunnerSetLocalValue", "_ExpressionRunnerSetGlobalValue", "_ExpressionRunnerRunAndDispose", "_TypeBuilderCreate", "_TypeBuilderGrow", "_TypeBuilderGetSize", "_TypeBuilderSetBasicHeapType", "_TypeBuilderSetSignatureType", "_TypeBuilderSetStructType", "_TypeBuilderSetArrayType", "_TypeBuilderIsBasic", "_TypeBuilderGetBasic", "_TypeBuilderGetTempHeapType", "_TypeBuilderGetTempTupleType", "_TypeBuilderGetTempRefType", "_TypeBuilderSetSubType", "_TypeBuilderCreateRecGroup", "_TypeBuilderBuildAndDispose", "_BinaryenModuleSetTypeName", "_BinaryenModuleSetFieldName", "_BinaryenGetOptimizeLevel", "_BinaryenSetOptimizeLevel", "_BinaryenGetShrinkLevel", "_BinaryenSetShrinkLevel", "_BinaryenGetDebugInfo", "_BinaryenSetDebugInfo", "_BinaryenGetLowMemoryUnused", "_BinaryenSetLowMemoryUnused", "_BinaryenGetZeroFilledMemory", "_BinaryenSetZeroFilledMemory", "_BinaryenGetFastMath", "_BinaryenSetFastMath", "_BinaryenGetPassArgument", "_BinaryenSetPassArgument", "_BinaryenClearPassArguments", "_BinaryenGetAlwaysInlineMaxSize", "_BinaryenSetAlwaysInlineMaxSize", "_BinaryenGetFlexibleInlineMaxSize", "_BinaryenSetFlexibleInlineMaxSize", "_BinaryenGetOneCallerInlineMaxSize", "_BinaryenSetOneCallerInlineMaxSize", "_BinaryenGetAllowInliningFunctionsWithLoops", "_BinaryenSetAllowInliningFunctionsWithLoops", "_BinaryenGetTypeSystem", "_BinaryenSetTypeSystem", "_malloc", "_free", "__i32_store8", "__i32_store16", "__i32_store", "__f32_store", "__f64_store", "__i32_load8_s", "__i32_load8_u", "__i32_load16_s", "__i32_load16_u", "__i32_load", "__f32_load", "__f64_load", "default", "F64", "F32", "I32", "value", "Long", "value", "lo", "hi", "left", "right", "rightLo", "rightHi", "result", "alignment", "mask", "minSafeF32", "maxSafeF32", "minSafeF64", "maxSafeF64", "unsigned", "map", "set", "Feature", "featureToString", "feature", "Target", "Runtime", "Typeinfo", "TypeinfoFlags", "__decorateClass", "CommonFlags", "PATH_DELIMITER", "PARENT_SUBST", "GETTER_PREFIX", "SETTER_PREFIX", "INSTANCE_DELIMITER", "STATIC_DELIMITER", "INNER_DELIMITER", "LIBRARY_SUBST", "LIBRARY_PREFIX", "INDEX_SUFFIX", "STUB_DELIMITER", "CommonNames", "DiagnosticCode", "diagnosticCodeToString", "code", "util_exports", "__export", "BitSet", "COLOR_BLUE", "COLOR_CYAN", "COLOR_GRAY", "COLOR_GREEN", "COLOR_MAGENTA", "COLOR_RED", "COLOR_RESET", "COLOR_WHITE", "COLOR_YELLOW", "CharCode", "SURROGATE_HIGH", "SURROGATE_LOW", "accuratePow64", "cloneMap", "colorize", "combineSurrogates", "dirname", "escapeString", "indent", "isAlpha", "isAlphaOrDecimal", "isColorsEnabled", "isDecimal", "isHexBase", "isHexOrDecimal", "isHighSurrogate", "isIdentifier", "isIdentifierPart", "isIdentifierStart", "isLineBreak", "isLowSurrogate", "isOctal", "isPowerOf2", "isSurrogate", "isSurrogateHigh", "isSurrogateLow", "isWhiteSpace", "mergeMaps", "normalizePath", "numCodeUnits", "readF32", "readF64", "readI16", "readI32", "readI64", "readI8", "readV128", "resolvePath", "setColorsEnabled", "v128_ones", "v128_zero", "writeF32", "writeF64", "writeI16", "writeI32", "writeI32AsI64", "writeI64", "writeI64AsI32", "writeI8", "writeV128", "readI8", "buffer", "offset", "writeI8", "value", "readI16", "writeI16", "readI32", "writeI32", "writeI32AsI64", "unsigned", "readI64", "lo", "hi", "writeI64", "writeI64AsI32", "readF32", "writeF32", "readF64", "writeF64", "valueI64", "readV128", "writeV128", "cloneMap", "map", "out", "_keys", "i", "k", "v", "mergeMaps", "map1", "map2", "BitSet", "count", "words", "len", "word", "index", "idx", "res", "p", "mask", "isPowerOf2", "x", "accuratePow64", "y", "CharCode", "isLineBreak", "c", "isWhiteSpace", "SURROGATE_HIGH", "SURROGATE_LOW", "isSurrogate", "isSurrogateHigh", "isSurrogateLow", "isHighSurrogate", "isLowSurrogate", "combineSurrogates", "hi", "lo", "numCodeUnits", "cp", "isAlpha", "c0", "isDecimal", "isOctal", "isHexBase", "isHexOrDecimal", "isAlphaOrDecimal", "isIdentifierStart", "unicodeIdentifierStartMin", "unicodeIdentifierStartMax", "lookupInUnicodeMap", "unicodeIdentifierStart", "isIdentifierPart", "unicodeIdentifierPartMin", "unicodeIdentifierPartMax", "unicodeIdentifierPart", "isIdentifier", "str", "len", "i", "code", "map", "mid", "midVal", "indentX1", "indentX2", "indentX3", "indentX4", "indentCache", "indent", "sb", "level", "indents", "escapeString", "quote", "off", "k", "separator", "normalizePath", "path", "pos", "len", "atEnd", "ipos", "resolvePath", "normalizedPath", "origin", "dirname", "PATH_DELIMITER", "COLOR_GRAY", "COLOR_RED", "COLOR_GREEN", "COLOR_YELLOW", "COLOR_BLUE", "COLOR_MAGENTA", "COLOR_CYAN", "COLOR_WHITE", "COLOR_RESET", "colorsEnabled", "isColorsEnabled", "setColorsEnabled", "isEnabled", "wasEnabled", "colorize", "text", "color", "v128_zero", "v128_ones", "DiagnosticCategory", "Range", "start", "end", "a", "b", "range", "other", "diagnosticCategoryToString", "category", "diagnosticCategoryToColor", "COLOR_MAGENTA", "COLOR_CYAN", "COLOR_YELLOW", "COLOR_RED", "DiagnosticMessage", "code", "message", "arg0", "arg1", "arg2", "diagnosticCodeToString", "thisRange", "otherRange", "thisRelatedRange", "otherRelatedRange", "source", "path", "line", "column", "len", "formatDiagnosticMessage", "useColors", "showContext", "wasColorsEnabled", "setColorsEnabled", "sb", "isColorsEnabled", "COLOR_RESET", "relatedRange", "minLine", "formatDiagnosticContext", "relatedSource", "text", "lineNumber", "lineNumberLength", "lineSpace", "isLineBreak", "isWhiteSpace", "cc", "DiagnosticEmitter", "diagnostics", "seen", "seenInSource", "seenMessagesAtPos", "i", "k", "NodeKind", "Node", "kind", "range", "name", "TypeName", "typeArguments", "isNullable", "NamedTypeNode", "parameters", "returnType", "explicitThisType", "FunctionTypeNode", "extendsType", "defaultType", "TypeParameterNode", "parameterKind", "type", "initializer", "ParameterNode", "args", "DecoratorNode", "DecoratorKind", "commentKind", "text", "CommentNode", "isQuoted", "IdentifierExpression", "elementExpressions", "ArrayLiteralExpression", "assertionKind", "expression", "toType", "AssertionExpression", "operator", "left", "right", "BinaryExpression", "CallExpression", "declaration", "ClassExpression", "expressions", "CommaExpression", "ConstructorExpression", "elementExpression", "ElementAccessExpression", "FalseExpression", "value", "FloatLiteralExpression", "FunctionExpression", "isType", "InstanceOfExpression", "IntegerLiteralExpression", "typeName", "NewExpression", "NullExpression", "names", "values", "ObjectLiteralExpression", "OmittedExpression", "ParenthesizedExpression", "property", "PropertyAccessExpression", "pattern", "patternFlags", "RegexpLiteralExpression", "condition", "ifThen", "ifElse", "TernaryExpression", "StringLiteralExpression", "SuperExpression", "tag", "parts", "rawParts", "TemplateLiteralExpression", "ThisExpression", "TrueExpression", "operand", "UnaryPostfixExpression", "UnaryPrefixExpression", "expr", "CompiledExpression", "statements", "BlockStatement", "label", "BreakStatement", "decorators", "flags", "typeParameters", "implementsTypes", "members", "ClassDeclaration", "ContinueStatement", "body", "DoStatement", "EmptyStatement", "EnumDeclaration", "EnumValueDeclaration", "path", "isDeclare", "ExportStatement", "ExportDefaultStatement", "externalName", "ExportImportStatement", "localName", "exportedName", "ExportMember", "ExpressionStatement", "ifTrue", "ifFalse", "IfStatement", "declarations", "ImportStatement", "namespaceName", "foreignName", "ImportDeclaration", "InterfaceDeclaration", "FieldDeclaration", "incrementor", "ForStatement", "variable", "iterable", "ForOfStatement", "signature", "arrowKind", "FunctionDeclaration", "keyType", "valueType", "IndexSignatureNode", "MethodDeclaration", "NamespaceDeclaration", "ReturnStatement", "cases", "SwitchStatement", "SwitchCase", "ThrowStatement", "bodyStatements", "catchVariable", "catchStatements", "finallyStatements", "TryStatement", "TypeDeclaration", "ModuleDeclaration", "VariableStatement", "VariableDeclaration", "VoidStatement", "statement", "WhileStatement", "literalKind", "LiteralKind", "node", "TypeNode", "typeParameterNodes", "namedTypeNode", "typeArgumentNodes", "i", "k", "functionTypeNode", "parameterNodes", "identifier", "next", "ParameterKind", "flag", "fromNode", "nameNode", "nameStr", "propertyAccessNode", "propStr", "decoratorKind", "CommentKind", "Expression", "LiteralExpression", "AssertionKind", "numTypeArguments", "Range", "numArguments", "UnaryExpression", "Statement", "SourceKind", "_Source", "sourceKind", "normalizedPath", "internalPath", "mangleInternalPath", "pos", "PATH_DELIMITER", "source", "LIBRARY_PREFIX", "LIBRARY_SUBST", "lineCache", "off", "end", "l", "r", "m", "s", "Source", "DeclarationStatement", "VariableLikeDeclarationStatement", "normalizePath", "resolvePath", "parameterIndex", "ArrowKind", "moduleName", "findDecorator", "decorator", "isTypeOmitted", "Token", "IdentifierHandling", "tokenFromKeyword", "text", "len", "tokenIsAlsoIdentifier", "token", "isIllegalVariableIdentifier", "name", "operatorTokenToString", "Tokenizer", "DiagnosticEmitter", "source", "diagnostics", "end", "pos", "identifierHandling", "maxTokenLength", "c", "chr", "isDecimal", "commentStartPos", "commentKind", "closed", "isHighSurrogate", "combineSurrogates", "isIdentifierStart", "posBefore", "numCodeUnits", "isIdentifierPart", "maybeKeywordToken", "isWhiteSpace", "start", "checkOnNewLine", "maxCompoundLength", "tokenBefore", "tokenPosBefore", "nextToken", "isLineBreak", "state", "reusableState", "State", "range", "Range", "quote", "isTaggedTemplate", "result", "escaped", "flags", "isOctal", "value", "sepEnd", "i64_4", "nextValue", "overflowOccurred", "isHexBase", "i64_10", "i64_3", "sepCount", "allowLeadingZeroSep", "remain", "startIfTaggedTemplate", "value32", "invalid", "tokenPos", "TypeRef", "_BinaryenTypeFuncref", "_BinaryenTypeExternref", "_BinaryenTypeAnyref", "_BinaryenTypeEqref", "_BinaryenTypeI31ref", "_BinaryenTypeDataref", "_BinaryenTypeArrayref", "_BinaryenTypeStringref", "_BinaryenTypeStringviewWTF8", "_BinaryenTypeStringviewWTF16", "_BinaryenTypeStringviewIter", "_BinaryenTypeNullref", "_BinaryenTypeNullFuncref", "_BinaryenTypeNullExternref", "HeapTypeRef", "isBottom", "ht", "_BinaryenHeapTypeIsBottom", "getBottom", "_BinaryenHeapTypeGetBottom", "isSubtype", "superHt", "_BinaryenHeapTypeIsSubType", "PackedType", "TypeBuilderErrorReason", "toString", "reason", "TypeSystem", "FeatureFlags", "ExpressionId", "ExternalKind", "UnaryOp", "BinaryOp", "AtomicRMWOp", "SIMDExtractOp", "SIMDReplaceOp", "SIMDShiftOp", "SIMDLoadOp", "SIMDLoadStoreLaneOp", "SIMDTernaryOp", "RefIsOp", "RefAsOp", "BrOnOp", "StringNewOp", "StringMeasureOp", "StringEncodeOp", "StringAsOp", "StringIterMoveOp", "StringSliceWTFOp", "ExpressionRunnerFlags", "MemorySegment", "buffer", "offset", "_Module", "ref", "useShadowStack", "sizeType", "_malloc", "_BinaryenSizeofLiteral", "_BinaryenSetTypeSystem", "_BinaryenModuleCreate", "cArr", "allocU8Array", "module", "_BinaryenModuleRead", "_free", "value", "out", "_BinaryenLiteralInt32", "_BinaryenConst", "valueLow", "valueHigh", "_BinaryenLiteralInt64", "_BinaryenLiteralFloat32", "_BinaryenLiteralFloat64", "bytes", "i", "__i32_store8", "_BinaryenLiteralVec128", "type", "_BinaryenRefNull", "left", "right", "_BinaryenRefEq", "_BinaryenStringEq", "op", "isWam64", "_BinaryenUnary", "isWasm64", "_BinaryenBinary", "name", "CommonNames", "is64", "cStr", "_BinaryenMemorySize", "delta", "_BinaryenMemoryGrow", "_BinaryenTableSize", "_BinaryenTableGrow", "index", "_BinaryenLocalGet", "_BinaryenExpressionGetType", "BuiltinNames", "isManaged", "_BinaryenLocalTee", "_BinaryenGlobalGet", "_BinaryenTableGet", "signed", "ptr", "align", "_BinaryenLoad", "_BinaryenStore", "_BinaryenAtomicLoad", "_BinaryenAtomicStore", "_BinaryenAtomicRMW", "expected", "replacement", "_BinaryenAtomicCmpxchg", "timeout", "expectedType", "_BinaryenAtomicWait", "notifyCount", "_BinaryenAtomicNotify", "_BinaryenAtomicFence", "_BinaryenLocalSet", "_BinaryenGlobalSet", "_BinaryenTableSet", "label", "children", "allocPtrArray", "ret", "_BinaryenBlock", "stmts", "length", "single", "getExpressionId", "singleType", "getExpressionType", "condition", "_BinaryenBreak", "expression", "_BinaryenDrop", "result", "getSideEffects", "SideEffects", "body", "_BinaryenLoop", "ifTrue", "ifFalse", "_BinaryenIf", "_BinaryenNop", "_BinaryenReturn", "_BinaryenSelect", "names", "defaultName", "numNames", "strs", "_BinaryenSwitch", "target", "operands", "returnType", "isReturn", "_BinaryenReturnCall", "_BinaryenCall", "tableName", "params", "results", "_BinaryenReturnCallIndirect", "_BinaryenCallIndirect", "_BinaryenUnreachable", "dest", "source", "size", "destName", "sourceName", "cStr1", "cStr2", "_BinaryenMemoryCopy", "_BinaryenMemoryFill", "catchTags", "catchBodies", "delegateTarget", "numCatchTags", "cArr1", "cArr2", "_BinaryenTry", "tagName", "_BinaryenThrow", "_BinaryenRethrow", "_BinaryenPop", "_BinaryenTupleMake", "tuple", "_BinaryenTupleExtract", "vec", "idx", "_BinaryenSIMDExtract", "_BinaryenSIMDReplace", "vec1", "vec2", "mask", "_BinaryenSIMDShuffle", "a", "b", "c", "_BinaryenSIMDTernary", "shift", "_BinaryenSIMDShift", "_BinaryenSIMDLoad", "_BinaryenSIMDLoadStoreLane", "expr", "_BinaryenRefIs", "isNullableType", "_BinaryenRefAs", "_BinaryenRefFunc", "_BinaryenI31New", "_BinaryenI31Get", "mutable", "initializer", "_BinaryenAddGlobal", "_BinaryenGetGlobal", "_BinaryenRemoveGlobal", "_BinaryenAddTag", "_BinaryenGetTag", "_BinaryenRemoveTag", "varTypes", "_BinaryenAddFunction", "funcRef", "_BinaryenFunctionSetLocalName", "_BinaryenGetFunction", "_BinaryenRemoveFunction", "paramTypes", "tempName", "createType", "func", "_BinaryenSetStart", "internalName", "externalName", "_BinaryenAddFunctionExport", "_BinaryenAddTableExport", "_BinaryenAddMemoryExport", "_BinaryenAddGlobalExport", "_BinaryenAddTagExport", "_BinaryenRemoveExport", "_BinaryenGetExport", "externalModuleName", "externalBaseName", "cStr3", "_BinaryenAddFunctionImport", "_BinaryenAddTableImport", "shared", "_BinaryenAddMemoryImport", "globalType", "_BinaryenAddGlobalImport", "_BinaryenAddTagImport", "initial", "maximum", "segments", "exportName", "k", "segs", "psvs", "offs", "sizs", "segment", "cArr3", "cArr4", "allocU32Array", "_BinaryenSetMemory", "funcs", "tableRef", "_BinaryenGetTable", "_BinaryenTableSetInitial", "_BinaryenTableSetMax", "_BinaryenAddTable", "_BinaryenAddActiveElementSegment", "contents", "_BinaryenAddCustomSection", "_BinaryenGetOptimizeLevel", "level", "_BinaryenSetOptimizeLevel", "_BinaryenGetShrinkLevel", "_BinaryenSetShrinkLevel", "_BinaryenGetDebugInfo", "on", "_BinaryenSetDebugInfo", "_BinaryenGetLowMemoryUnused", "_BinaryenSetLowMemoryUnused", "_BinaryenGetZeroFilledMemory", "_BinaryenSetZeroFilledMemory", "_BinaryenGetFastMath", "_BinaryenSetFastMath", "key", "_BinaryenGetPassArgument", "readString", "_BinaryenSetPassArgument", "_BinaryenClearPassArguments", "_BinaryenGetAlwaysInlineMaxSize", "_BinaryenSetAlwaysInlineMaxSize", "_BinaryenGetFlexibleInlineMaxSize", "_BinaryenSetFlexibleInlineMaxSize", "_BinaryenGetOneCallerInlineMaxSize", "_BinaryenSetOneCallerInlineMaxSize", "_BinaryenGetAllowInliningFunctionsWithLoops", "enabled", "_BinaryenSetAllowInliningFunctionsWithLoops", "_BinaryenModuleGetFeatures", "featureFlags", "_BinaryenModuleSetFeatures", "passes", "cStrs", "allocString", "_BinaryenFunctionRunPasses", "_BinaryenModuleRunPasses", "optimizeLevel", "shrinkLevel", "debugInfo", "zeroFilledMemory", "_BinaryenModuleValidate", "_BinaryenModuleInterpret", "sourceMapUrl", "_BinaryenSizeofAllocateAndWriteResult", "resPtr", "urlPtr", "_BinaryenModuleAllocateAndWrite", "binaryPtr", "__i32_load", "binaryLen", "srcMapPtr", "binary", "BinaryModule", "readBuffer", "watFormat", "textPtr", "_BinaryenModuleAllocateAndWriteStackIR", "_BinaryenModuleAllocateAndWriteText", "text", "str", "cached", "_values", "_BinaryenModuleDispose", "Relooper", "_BinaryenExpressionGetId", "_BinaryenExpressionCopy", "flags", "maxDepth", "maxLoopIterations", "runner", "_ExpressionRunnerCreate", "precomp", "_ExpressionRunnerRunAndDispose", "getBinaryOp", "getBinaryLeft", "getBinaryRight", "_BinaryenModuleAddDebugInfoFileName", "_BinaryenModuleGetDebugInfoFileName", "fileIndex", "lineNumber", "columnNumber", "_BinaryenFunctionSetDebugLocation", "Module", "types", "_BinaryenTypeCreate", "expandType", "arity", "_BinaryenTypeArity", "_BinaryenTypeExpand", "_BinaryenTypeIsNullable", "getConstValueI32", "_BinaryenConstGetValueI32", "getConstValueI64Low", "_BinaryenConstGetValueI64Low", "getConstValueI64High", "_BinaryenConstGetValueI64High", "getConstValueF32", "_BinaryenConstGetValueF32", "getConstValueF64", "_BinaryenConstGetValueF64", "getConstValueV128", "_BinaryenConstGetValueV128", "__i32_load8_u", "isConstZero", "isConstNonZero", "isConstNegZero", "d", "isConstNaN", "isConstExpressionNaN", "id", "getLocalGetIndex", "_BinaryenLocalGetGetIndex", "getLocalSetIndex", "_BinaryenLocalSetGetIndex", "getLocalSetValue", "_BinaryenLocalSetGetValue", "isLocalTee", "_BinaryenLocalSetIsTee", "getGlobalGetName", "_BinaryenGlobalGetGetName", "_BinaryenBinaryGetOp", "_BinaryenBinaryGetLeft", "_BinaryenBinaryGetRight", "getUnaryOp", "_BinaryenUnaryGetOp", "getUnaryValue", "_BinaryenUnaryGetValue", "getLoadBytes", "_BinaryenLoadGetBytes", "getLoadOffset", "_BinaryenLoadGetOffset", "getLoadPtr", "_BinaryenLoadGetPtr", "isLoadSigned", "_BinaryenLoadIsSigned", "getStoreBytes", "_BinaryenStoreGetBytes", "getStoreOffset", "_BinaryenStoreGetOffset", "getStorePtr", "_BinaryenStoreGetPtr", "getStoreValue", "_BinaryenStoreGetValue", "getBlockName", "_BinaryenBlockGetName", "getBlockChildCount", "_BinaryenBlockGetNumChildren", "getBlockChildAt", "_BinaryenBlockGetChildAt", "getIfCondition", "_BinaryenIfGetCondition", "getIfTrue", "_BinaryenIfGetIfTrue", "getIfFalse", "_BinaryenIfGetIfFalse", "getLoopName", "_BinaryenLoopGetName", "getLoopBody", "_BinaryenLoopGetBody", "getBreakName", "_BinaryenBreakGetName", "getBreakCondition", "_BinaryenBreakGetCondition", "getSelectThen", "_BinaryenSelectGetIfTrue", "getSelectElse", "_BinaryenSelectGetIfFalse", "getSelectCondition", "_BinaryenSelectGetCondition", "getDropValue", "_BinaryenDropGetValue", "getReturnValue", "_BinaryenReturnGetValue", "getCallTarget", "_BinaryenCallGetTarget", "getCallOperandCount", "_BinaryenCallGetNumOperands", "getCallOperandAt", "_BinaryenCallGetOperandAt", "getMemoryGrowDelta", "_BinaryenMemoryGrowGetDelta", "getFunctionBody", "_BinaryenFunctionGetBody", "getFunctionName", "_BinaryenFunctionGetName", "getFunctionParams", "_BinaryenFunctionGetParams", "getFunctionResults", "_BinaryenFunctionGetResults", "getFunctionVars", "count", "_BinaryenFunctionGetNumVars", "_BinaryenFunctionGetVar", "getGlobalName", "global", "_BinaryenGlobalGetName", "getGlobalType", "_BinaryenGlobalGetType", "isGlobalMutable", "_BinaryenGlobalIsMutable", "getGlobalInit", "_BinaryenGlobalGetInitExpr", "getTagName", "tag", "_BinaryenTagGetName", "getTagParams", "_BinaryenTagGetParams", "getTagResults", "_BinaryenTagGetResults", "_RelooperCreate", "code", "_RelooperAddBlock", "from", "to", "_RelooperAddBranch", "_RelooperAddBlockWithSwitch", "indexes", "allocI32Array", "_RelooperAddBranchForSwitch", "entry", "labelHelper", "_RelooperRenderAndDispose", "SwitchBuilder", "cases", "localIndex", "labelPostfix", "numCases", "values", "numValues", "labels", "defaultIndex", "defaultLabel", "current", "block", "lastCase", "_BinaryenExpressionGetSideEffects", "mustPreserveSideEffects", "u8s", "len", "i32s", "val", "__i32_store", "u32s", "ptrs", "stringLengthUTF8", "c1", "isHighSurrogate", "isLowSurrogate", "u", "c2", "combineSurrogates", "arr", "cp", "u1", "u2", "u3", "ch", "SURROGATE_HIGH", "SURROGATE_LOW", "output", "sourceMap", "DEBUG_TYPEBUILDER", "ensureType", "Type", "typeRef", "tryEnsureBasicType", "originalType", "_BinaryenTypeFromHeapType", "_BinaryenTypeGetHeapType", "_BinaryenGetTypeSystem", "builder", "_TypeBuilderCreate", "seen", "prepareType", "_TypeBuilderGetSize", "_TypeBuilderBuildAndDispose", "errorIndex", "errorReason", "_keys", "seenType", "heapType", "fullType", "classInstance", "_BinaryenModuleSetTypeName", "members", "numFieldsInType", "_BinaryenStructTypeGetNumFields", "numFieldsInClass", "member", "property", "_BinaryenModuleSetFieldName", "determinePackedType", "classReference", "base", "baseRef", "_TypeBuilderGrow", "heapTypeRef", "_TypeBuilderGetTempHeapType", "_TypeBuilderGetTempRefType", "fieldTypes", "packedTypes", "fieldMutables", "fieldType", "cArrFT", "cArrPT", "cArrFM", "_TypeBuilderSetStructType", "_TypeBuilderSetSubType", "signatureReference", "tempTypeRef", "resultTypes", "parameterTypes", "paramType", "tempParamType", "_TypeBuilderGetTempTupleType", "tempResultType", "cArrRT", "_TypeBuilderSetSignatureType", "FlowFlags", "LocalFlags", "FieldFlags", "ConditionKind", "Flow", "targetFunction", "inlineFunction", "flow", "flag", "condiFlags", "newBreakContext", "newContinueContext", "branch", "thisFieldFlags", "cloneMap", "condExpr", "trueFlows", "trueFlow", "falseFlows", "falseFlow", "type", "local", "name", "scopedLocals", "scopedLocal", "mangleInternalName", "declarationNode", "scopedDummy", "Local", "index", "reportNode", "existingLocal", "scopedAlias", "current", "scope", "element", "defaultIfInlined", "localFlags", "flags", "sourceFunction", "parent", "classInstance", "members", "_values", "i", "k", "member", "property", "field", "fieldFlags", "id", "stack", "expectedLabel", "other", "otherFlags", "thisFlags", "newFlags", "thisLocalFlags", "numThisLocalFlags", "otherLocalFlags", "numOtherLocalFlags", "maxLocalFlags", "left", "right", "leftFlags", "rightFlags", "rightLocalFlags", "leftLocalFlags", "numLeftLocalFlags", "numRightLocalFlags", "leftFieldFlags", "newFieldFlags", "rightFieldFlags", "_keys", "key", "numLocalsBefore", "localsByIndex", "needsRecompile", "expr", "getExpressionId", "isLocalTee", "getLocalSetIndex", "getLocalGetIndex", "iff", "getLocalSetValue", "ifFalse", "getIfFalse", "isConstZero", "getIfCondition", "getIfTrue", "getUnaryOp", "getUnaryValue", "getBinaryOp", "getBinaryLeft", "getBinaryRight", "isConstNonZero", "getCallTarget", "BuiltinNames", "getCallOperandCount", "getCallOperandAt", "ifTrue", "operand", "canConversionOverflow", "global", "getGlobalGetName", "getConstValueI32", "Type", "shift", "value", "getExpressionType", "TypeRef", "getConstValueI64Low", "getConstValueF32", "getConstValueF64", "fromType", "signed", "isLoadSigned", "getLoadBytes", "getBlockName", "size", "getBlockChildCount", "last", "getBlockChildAt", "getSelectThen", "getSelectElse", "instancesByName", "instanceName", "instance", "functionInstance", "returnType", "levels", "sb", "toType", "ReportMode", "Resolver", "DiagnosticEmitter", "program", "node", "ctxElement", "ctxTypes", "reportMode", "nameNode", "typeArgumentNodes", "isSimpleType", "simpleName", "type", "element", "shadowType", "Type", "instance", "cloneMap", "typeDefinition", "text", "CommonNames", "typeParameterNodes", "typeArguments", "explicitThisType", "thisType", "parameterNodes", "numParameters", "parameterTypes", "requiredParameters", "hasRest", "i", "parameterNode", "parameterTypeNode", "isTypeOmitted", "parameterType", "returnTypeNode", "returnType", "signature", "Signature", "typeArgumentNode", "typeArgument", "classReference", "overload", "signatureReference", "prev", "next", "typeParameters", "alternativeReportNode", "minParameterCount", "maxParameterCount", "k", "argumentCount", "Range", "oldCtxTypes", "prototype", "ctxFlow", "contextualTypeArguments", "numTypeParameters", "typeParameterNames", "name", "argumentNodes", "numArguments", "argumentExpression", "typeNode", "resolvedTypeArguments", "typeParameterNode", "inferredType", "defaultType", "parent", "defaultTypeContextualTypeArguments", "resolvedDefaultType", "namedTypeNode", "classPrototype", "currentType", "functionTypeNode", "kind", "isTypedElement", "wrappedType", "ctxType", "resolvingExpressions", "resolved", "outerFlow", "global", "targetNode", "target", "propertyName", "variableLikeElement", "propertyInstance", "classInstance", "elementExpression", "indexedGet", "resolvedType", "functionInstance", "wrapper", "member", "basePrototype", "baseInstance", "targetExpression", "targetType", "indexSignature", "expr", "negate", "intValue", "range", "operatorTokenToString", "operand", "operator", "OperatorKind", "left", "right", "leftType", "rightType", "commonType", "thisLocal", "superLocal", "base", "intType", "fltType", "expressions", "length", "elementType", "numNullLiterals", "expression", "functionPrototype", "BuiltinNames", "targetElement", "thenType", "elseType", "declaration", "body", "functionType", "tempFlow", "Flow", "parameters", "parameter", "instanceKey", "typesToString", "resolvedInstance", "classTypeArguments", "classTypeParameters", "numClassTypeArguments", "classTypeParameterName", "signatureNode", "numFunctionTypeArguments", "signatureParameters", "numSignatureParameters", "parameterDeclaration", "nameInclTypeParameters", "Function", "methodOrPropertyName", "baseClass", "baseMember", "incompatibleOverride", "baseProperty", "baseGetter", "baseSetter", "baseFunction", "reportNode", "overridePrototypes", "parentClassInstance", "overrides", "_values", "unboundOverridePrototype", "unboundOverrideParent", "classInstances", "j", "l", "overrideInstance", "boundPropertyPrototype", "boundPropertyInstance", "boundPrototype", "Interface", "Class", "pendingClasses", "numTypeArguments", "anyPending", "current", "extendsNode", "interfacePrototypes", "interfacePrototype", "implementsNode", "iface", "thisMember", "thisClass", "hasErrors", "members", "unimplemented", "interfaces", "ifaceMembers", "_keys", "memberName", "ifaceMember", "existingMember", "memoryOffset", "implicitlyExtendsObject", "baseMembers", "instanceMemberPrototypes", "properties", "boundInstance", "fieldType", "needsLayout", "existingPrototype", "existingProperty", "byteSize", "isPowerOf2", "mask", "property", "propertyGetter", "propertySetter", "ctorPrototype", "ctorInstance", "overloadPrototypes", "overloadKind", "overloadPrototype", "operatorInstance", "overloads", "index", "IndexSignature", "pending", "dependsOnInstance", "_values2", "Property", "getterPrototype", "getterInstance", "setterPrototype", "setterInstance", "Dependee", "source", "reportNode", "Parser", "DiagnosticEmitter", "diagnostics", "sources", "text", "path", "isEntry", "normalizedPath", "normalizePath", "internalPath", "mangleInternalPath", "dependees", "dependee", "Source", "LIBRARY_PREFIX", "PATH_DELIMITER", "tn", "Tokenizer", "statements", "statement", "namespace", "flags", "startPos", "decorators", "decorator", "exportStart", "exportEnd", "defaultStart", "defaultEnd", "declareStart", "declareEnd", "contextIsAmbient", "first", "state", "abstractStart", "abstractEnd", "next", "i", "k", "Node", "backlog", "dependent", "current", "acceptParenthesized", "suppressErrors", "token", "type", "isNullableSignature", "signature", "innerType", "name", "parameters", "parameter", "notNullStart", "notNull", "bracketStart", "bracketRange", "nullable", "thisType", "isSignature", "firstParamNameNoType", "firstParamKind", "paramStart", "kind", "param", "returnType", "expression", "args", "isFor", "declarations", "declaration", "ret", "parentFlags", "parentDecorators", "identifier", "isIllegalVariableIdentifier", "initializer", "Precedence", "range", "Range", "members", "member", "value", "expr", "typeParameters", "seenOptional", "start", "typeParameter", "extendsType", "defaultType", "isConstructor", "seenRest", "reportedRest", "isRest", "isOptional", "startRange", "accessFlags", "signatureStart", "isSetter", "body", "arrowKind", "explicitThis", "bodyExpression", "isInterface", "implementsTypes", "DeclarationStatement", "parent", "accessStart", "accessEnd", "staticStart", "staticEnd", "overrideStart", "overrideEnd", "readonlyStart", "readonlyEnd", "isGetter", "getStart", "getEnd", "setStart", "setEnd", "isGetterOrSetter", "retIndex", "typeParametersStart", "implicitFieldDeclaration", "retMethod", "retField", "keyType", "valueType", "isDeclare", "currentSource", "exportPaths", "asIdentifier", "namespaceName", "skipFrom", "topLevel", "condition", "incrementor", "variable", "iterable", "elseStatement", "switchCases", "switchCase", "label", "stmt", "bodyStatements", "catchVariable", "catchStatements", "finallyStatements", "identifierName", "depth", "typeArguments", "res", "fnType", "params", "moduleName", "operand", "typeName", "arguments_", "again", "inner", "elementExpressions", "names", "values", "toType", "identifierText", "regexpPattern", "end", "precedence", "nextPrecedence", "determinePrecedence", "isType", "ifThen", "ifElse", "commaExprs", "tag", "parts", "rawParts", "exprs", "call", "callee", "potentiallyGeneric", "nextToken", "AL_SIZE", "AL_MASK", "QueuedImport", "localFile", "localIdentifier", "foreignIdentifier", "foreignPath", "foreignPathAlt", "QueuedExport", "QueuedExportStar", "pathLiteral", "OperatorKind", "fromDecorator", "decoratorKind", "arg", "fromBinaryToken", "token", "fromUnaryPrefixToken", "fromUnaryPostfixToken", "Program", "DiagnosticEmitter", "options", "diagnostics", "Module", "Parser", "Resolver", "nativeFile", "File", "Source", "cached", "CommonNames", "ElementKind", "prototype", "internalPath", "sources", "i", "source", "ref", "modifiedFunctionName", "getFunctionName", "instancesByName", "element", "currentOffset", "blockOverhead", "payloadSize", "isManaged", "blockSize", "blockMinsize", "blockMaxsize", "tagsMask", "name", "flags", "range", "Node", "identifier", "signature", "parent", "decoratorFlags", "DecoratorFlags", "Function", "FunctionPrototype", "declaration", "elementsByDeclaration", "Type", "TypeDefinition", "queuedImports", "queuedExports", "queuedExportsStar", "queuedExtends", "queuedImplements", "k", "file", "statements", "j", "l", "statement", "_keys", "starExports", "exportStar", "foreignFile", "madeProgress", "queuedImport", "localName", "exports", "exportNames", "exportName", "queuedExport", "globalElement", "isDeclaredElement", "resolver", "thisPrototype", "extendsNode", "baseElement", "basePrototype", "Range", "instanesMembers", "members", "member", "hasOverride", "instanceMembers", "implementsNodes", "implementsNode", "interfaceElement", "interfacePrototype", "interfacePrototypes", "globalAliases", "BuiltinNames", "alias", "firstChar", "elementsByName", "_values", "thisInstanceMembers", "thisMembers", "baseInstanceMembers", "thisMember", "baseMember", "baseInterfacePrototypes", "baseInterfacePrototype", "nextPrototype", "thisClass", "baseClass", "thisMethod", "baseMethod", "overrides", "baseMethodInstances", "a", "b", "thisProperty", "baseProperty", "thisIsField", "baseGetter", "thisGetter", "baseGetterInstances", "baseSetter", "thisSetter", "baseSetterInstances", "elements", "kind", "resolved", "typeArguments", "exportsStar", "propertyPrototype", "getterPrototype", "setterPrototype", "staticMembers", "moduleName", "moduleImports", "module", "type", "className", "wrapperClasses", "classElement", "value", "global", "Global", "existing", "merged", "tryMerge", "filesByName", "foreignName", "fileQueuedExports", "queuedExportForeignPath", "otherFile", "decorators", "acceptedFlags", "decorator", "DecoratorKind", "flag", "feature", "reportNode", "featureToString", "classReference", "signatureReference", "thisType", "parameterTypes", "returnType", "ClassPrototype", "implementsTypes", "numImplementsTypes", "memberDeclarations", "memberDeclaration", "methodDeclaration", "method", "PropertyPrototype", "isStatic", "classPrototype", "args", "numArgs", "firstArg", "text", "overloads", "parentMembers", "property", "isGetter", "GETTER_PREFIX", "SETTER_PREFIX", "Enum", "values", "EnumValue", "queued", "INDEX_SUFFIX", "declarations", "namespaceName", "validDecorators", "InterfacePrototype", "typeNode", "original", "Namespace", "copyMembers", "fromKind", "Element", "internalName", "program", "current", "isType", "localIdentifierIfImport", "originalDeclaration", "reportedIdentifier", "other", "vis", "declaredElements", "DeclaredElement", "identifierNode", "signatureNode", "typedElements", "isTypedElement", "TypedElement", "startFunction", "Signature", "ns", "memberName", "mangleInternalName", "ConstantValueKind", "VariableLikeElement", "Parameter", "initializer", "Local", "index", "classInstance", "boundPrototypes", "bound", "instanceKey", "instances", "instance", "nameInclTypeParameters", "contextualTypeArguments", "flow", "Flow", "localIndex", "local", "scopedLocals", "parameterType", "parameterName", "registerConcreteElement", "localsByIndex", "numTotal", "numFixed", "numAdditional", "types", "parameters", "getDefaultParameterName", "postfix", "requiredParameters", "stub", "STUB_DELIMITER", "defaultFlow", "breakStack", "debugLocations", "localNameMap", "firstDeclaration", "fieldDeclaration", "nativeRange", "getterDeclaration", "MethodDeclaration", "FunctionTypeNode", "setterDeclaration", "ParameterNode", "NamedTypeNode", "TypeName", "IdentifierExpression", "setterParameters", "Property", "IndexSignature", "isUnchecked", "_isInterface", "arrayBufferViewInstance", "basePtototype", "seen", "Class", "usizeType", "id", "typeParameters", "numTypeArguments", "lengthField", "base", "inheritedTypeArguments", "baseName", "baseType", "extenders", "extender", "nextBase", "baseInterfaces", "baseInterface", "iface", "nextIface", "implementers", "interfaces", "target", "unchecked", "uncheckedOverload", "fieldName", "overhead", "buffer", "OBJECT", "baseOffset", "offset", "typeKind", "writeI8", "writeI16", "writeI32", "writeI64", "writeI32AsI64", "writeI64AsI32", "writeF32", "writeF64", "extendedPrototype", "arrayPrototype", "staticArrayPrototype", "abvInstance", "Interface", "older", "newer", "olderIsExport", "newerIsExport", "src", "dest", "srcMembers", "destMembers", "isInstance", "asGlobal", "PATH_DELIMITER", "INNER_DELIMITER", "INSTANCE_DELIMITER", "STATIC_DELIMITER", "cachedDefaultParameterNames", "TypeKind", "TypeFlags", "_Type", "kind", "flags", "size", "program", "classReference", "signatureReference", "type", "wrapper", "wrapperClasses", "targetType", "nullableType", "other", "selfSignatureReference", "otherSignatureReference", "target", "signednessIsRelevant", "currentClass", "targetClass", "currentFunction", "targetFunction", "thisClass", "base", "baseClass", "left", "right", "signednessIsImportant", "validWat", "nullablePostfix", "CommonNames", "TypeRef", "_BinaryenTypeFromHeapType", "HeapTypeRef", "ensureType", "Type", "typesToRefs", "types", "numTypes", "ret", "i", "typesToString", "sb", "Signature", "parameterTypes", "returnType", "thisType", "requiredParameters", "hasRest", "id", "usizeType", "signatureTypes", "nextId", "signature", "uniqueKey", "existing", "numParameterTypes", "typeRefs", "createType", "thisThisType", "otherThisType", "selfParameterTypes", "otherParameterTypes", "numParameters", "selfParameterType", "otherParameterType", "checkCompatibleOverride", "targetThisType", "thisReturnType", "targetReturnType", "thisParameterTypes", "targetParameterTypes", "thisParameterType", "targetParameterType", "k", "indices", "index", "parameters", "optionalStart", "restIndex", "cloneParameterTypes", "BuiltinNames", "BuiltinContext", "compiler", "prototype", "typeArguments", "operands", "thisOperand", "contextualType", "reportNode", "contextIsExact", "builtins", "function_builtins", "builtin_isBoolean", "ctx", "module", "type", "checkConstantType", "Type", "reifyConstantType", "builtin_isInteger", "builtin_isSigned", "builtin_isFloat", "builtin_isVector", "builtin_isReference", "builtin_isString", "classReference", "builtin_isArray", "builtin_isArrayLike", "builtin_isFunction", "builtin_isNullable", "builtin_isDefined", "checkTypeAbsent", "checkArgsRequired", "element", "builtin_isConstant", "expr", "mustPreserveSideEffects", "getExpressionType", "builtin_isManaged", "builtin_isVoid", "builtin_lengthof", "signatureReference", "builtin_sizeof", "checkTypeRequired", "byteSize", "contextualUsize", "builtin_alignof", "isPowerOf2", "builtin_offsetof", "checkArgsOptional", "firstOperand", "fieldName", "fieldMember", "property", "builtin_nameof", "resultType", "value", "builtin_idof", "builtin_bswap", "checkTypeOptional", "arg0", "flow", "temp", "res", "TypeRef", "temp1", "temp2", "builtin_clz", "builtin_ctz", "builtin_popcnt", "builtin_rotl", "arg1", "builtin_rotr", "builtin_abs", "options", "builtin_max", "left", "op", "typeRef", "builtin_min", "builtin_ceil", "builtin_floor", "builtin_copysign", "builtin_nearest", "builtin_reinterpret", "isWasm64", "builtin_sqrt", "builtin_trunc", "builtin_isNaN", "getExpressionId", "getLocalGetIndex", "builtin_isFinite", "builtin_load", "outType", "numOperands", "immOffset", "immAlign", "evaluateImmediateOffset", "evaluateImmediateAlign", "builtin_store", "inType", "builtin_rem", "builtin_add", "builtin_sub", "builtin_mul", "builtin_div", "builtin_eq", "builtin_ne", "builtin_atomic_load", "checkFeatureEnabled", "builtin_atomic_store", "builtin_atomic_binary", "opName", "builtin_atomic_add", "builtin_atomic_sub", "builtin_atomic_and", "builtin_atomic_or", "builtin_atomic_xor", "builtin_atomic_xchg", "builtin_atomic_cmpxchg", "arg2", "builtin_atomic_wait", "builtin_atomic_notify", "builtin_atomic_fence", "builtin_select", "builtin_unreachable", "builtin_memory_size", "builtin_memory_grow", "builtin_memory_copy", "instance", "usizeType", "builtin_memory_fill", "builtin_memory_data", "offset", "elementType", "valuesOperand", "expressions", "numElements", "exprs", "isStatic", "i", "elementExpression", "precomp", "align", "buf", "size", "getConstValueI32", "builtin_i31_new", "builtin_i31_get", "builtin_changetype", "toType", "fromType", "builtin_assert", "evaled", "getConstValueI64Low", "getConstValueI64High", "getConstValueF32", "getConstValueF64", "abort", "builtin_unchecked", "ignoreUnchecked", "alreadyUnchecked", "builtin_call_indirect", "returnType", "indexArg", "operandExprs", "paramTypeRefs", "createType", "builtin_instantiate", "classInstance", "ctor", "builtin_diagnostic", "category", "builtin_error", "builtin_warning", "builtin_info", "builtin_function_call", "parent", "ftype", "signature", "functionArg", "thisType", "thisArg", "builtin_string_raw", "builtin_conversion", "builtin_i8", "builtin_i16", "builtin_i32", "builtin_i64", "builtin_isize", "builtin_u8", "builtin_u16", "builtin_u32", "builtin_u64", "builtin_usize", "builtin_bool", "builtin_f32", "builtin_f64", "builtin_v128", "builtin_i8x16", "bytes", "vars", "numVars", "writeI8", "vec", "fullVars", "builtin_i16x8", "writeI16", "builtin_i32x4", "writeI32", "builtin_i64x2", "off", "builtin_f32x4", "writeF32", "builtin_f64x2", "writeF64", "builtin_v128_splat", "builtin_v128_extract_lane", "idx", "maxIdx", "builtin_v128_replace_lane", "builtin_v128_shuffle", "laneWidth", "laneCount", "mask", "operand", "argN", "off8", "idx8", "builtin_v128_swizzle", "builtin_v128_load_splat", "builtin_v128_load_ext", "builtin_v128_load_zero", "builtin_v128_load_lane", "builtin_v128_store_lane", "builtin_v128_add", "builtin_v128_sub", "builtin_v128_mul", "builtin_v128_div", "builtin_v128_add_sat", "builtin_v128_sub_sat", "builtin_v128_min", "builtin_v128_max", "builtin_v128_pmin", "builtin_v128_pmax", "builtin_v128_dot", "builtin_v128_avgr", "builtin_v128_eq", "builtin_v128_ne", "builtin_v128_lt", "builtin_v128_le", "builtin_v128_gt", "builtin_v128_ge", "builtin_v128_narrow", "builtin_v128_neg", "builtin_v128_abs", "builtin_v128_sqrt", "builtin_v128_ceil", "builtin_v128_floor", "builtin_v128_trunc", "builtin_v128_nearest", "builtin_v128_convert", "builtin_v128_convert_low", "builtin_v128_trunc_sat", "builtin_v128_trunc_sat_zero", "builtin_v128_extend_low", "builtin_v128_extend_high", "builtin_v128_shl", "builtin_v128_shr", "builtin_v128_bitwise_binary", "builtin_v128_and", "builtin_v128_or", "builtin_v128_xor", "builtin_v128_andnot", "builtin_v128_bitwise_unary", "builtin_v128_not", "builtin_v128_bitwise_ternary", "builtin_v128_bitselect", "builtin_v128_any_true", "builtin_v128_all_true", "builtin_v128_bitmask", "builtin_v128_popcnt", "builtin_v128_extadd_pairwise", "builtin_v128_demote_zero", "builtin_v128_promote_low", "builtin_v128_q15mulr_sat", "builtin_v128_extmul_low", "builtin_v128_extmul_high", "builtin_visit_globals", "builtin_visit_members", "builtin_i32_clz", "builtin_i64_clz", "builtin_i32_ctz", "builtin_i64_ctz", "builtin_i32_popcnt", "builtin_i64_popcnt", "builtin_i32_rotl", "builtin_i64_rotl", "builtin_i32_rotr", "builtin_i64_rotr", "builtin_f32_abs", "builtin_f64_abs", "builtin_f32_max", "builtin_f64_max", "builtin_f32_min", "builtin_f64_min", "builtin_f32_ceil", "builtin_f64_ceil", "builtin_f32_floor", "builtin_f64_floor", "builtin_f32_copysign", "builtin_f64_copysign", "builtin_f32_nearest", "builtin_f64_nearest", "builtin_i32_reinterpret_f32", "builtin_i64_reinterpret_f64", "builtin_f32_reinterpret_i32", "builtin_f64_reinterpret_i64", "builtin_f32_sqrt", "builtin_f64_sqrt", "builtin_f32_trunc", "builtin_f64_trunc", "builtin_i32_rem_s", "builtin_i32_rem_u", "builtin_i64_rem_s", "builtin_i64_rem_u", "builtin_i32_add", "builtin_i64_add", "builtin_f32_add", "builtin_f64_add", "builtin_i32_sub", "builtin_i64_sub", "builtin_f32_sub", "builtin_f64_sub", "builtin_i32_mul", "builtin_i64_mul", "builtin_f32_mul", "builtin_f64_mul", "builtin_i32_div_s", "builtin_i32_div_u", "builtin_i64_div_s", "builtin_i64_div_u", "builtin_f32_div", "builtin_f64_div", "builtin_i32_eq", "builtin_i64_eq", "builtin_f32_eq", "builtin_f64_eq", "builtin_i32_ne", "builtin_i64_ne", "builtin_f32_ne", "builtin_f64_ne", "builtin_i32_load8_s", "builtin_i32_load8_u", "builtin_i32_load16_s", "builtin_i32_load16_u", "builtin_i32_load", "builtin_i64_load8_s", "builtin_i64_load8_u", "builtin_i64_load16_s", "builtin_i64_load16_u", "builtin_i64_load32_s", "builtin_i64_load32_u", "builtin_i64_load", "builtin_f32_load", "builtin_f64_load", "builtin_i32_store8", "builtin_i32_store16", "builtin_i32_store", "builtin_i64_store8", "builtin_i64_store16", "builtin_i64_store32", "builtin_i64_store", "builtin_f32_store", "builtin_f64_store", "builtin_i32_atomic_load8_u", "builtin_i32_atomic_load16_u", "builtin_i32_atomic_load", "builtin_i64_atomic_load8_u", "builtin_i64_atomic_load16_u", "builtin_i64_atomic_load32_u", "builtin_i64_atomic_load", "builtin_i32_atomic_store8", "builtin_i32_atomic_store16", "builtin_i32_atomic_store", "builtin_i64_atomic_store8", "builtin_i64_atomic_store16", "builtin_i64_atomic_store32", "builtin_i64_atomic_store", "builtin_i32_atomic_rmw8_add_u", "builtin_i32_atomic_rmw16_add_u", "builtin_i32_atomic_rmw_add", "builtin_i64_atomic_rmw8_add_u", "builtin_i64_atomic_rmw16_add_u", "builtin_i64_atomic_rmw32_add_u", "builtin_i64_atomic_rmw_add", "builtin_i32_atomic_rmw8_sub_u", "builtin_i32_atomic_rmw16_sub_u", "builtin_i32_atomic_rmw_sub", "builtin_i64_atomic_rmw8_sub_u", "builtin_i64_atomic_rmw16_sub_u", "builtin_i64_atomic_rmw32_sub_u", "builtin_i64_atomic_rmw_sub", "builtin_i32_atomic_rmw8_and_u", "builtin_i32_atomic_rmw16_and_u", "builtin_i32_atomic_rmw_and", "builtin_i64_atomic_rmw8_and_u", "builtin_i64_atomic_rmw16_and_u", "builtin_i64_atomic_rmw32_and_u", "builtin_i64_atomic_rmw_and", "builtin_i32_atomic_rmw8_or_u", "builtin_i32_atomic_rmw16_or_u", "builtin_i32_atomic_rmw_or", "builtin_i64_atomic_rmw8_or_u", "builtin_i64_atomic_rmw16_or_u", "builtin_i64_atomic_rmw32_or_u", "builtin_i64_atomic_rmw_or", "builtin_i32_atomic_rmw8_xor_u", "builtin_i32_atomic_rmw16_xor_u", "builtin_i32_atomic_rmw_xor", "builtin_i64_atomic_rmw8_xor_u", "builtin_i64_atomic_rmw16_xor_u", "builtin_i64_atomic_rmw32_xor_u", "builtin_i64_atomic_rmw_xor", "builtin_i32_atomic_rmw8_xchg_u", "builtin_i32_atomic_rmw16_xchg_u", "builtin_i32_atomic_rmw_xchg", "builtin_i64_atomic_rmw8_xchg_u", "builtin_i64_atomic_rmw16_xchg_u", "builtin_i64_atomic_rmw32_xchg_u", "builtin_i64_atomic_rmw_xchg", "builtin_i32_atomic_rmw8_cmpxchg_u", "builtin_i32_atomic_rmw16_cmpxchg_u", "builtin_i32_atomic_rmw_cmpxchg", "builtin_i64_atomic_rmw8_cmpxchg_u", "builtin_i64_atomic_rmw16_cmpxchg_u", "builtin_i64_atomic_rmw32_cmpxchg_u", "builtin_i64_atomic_rmw_cmpxchg", "builtin_i32_wait", "builtin_i64_wait", "builtin_v128_load", "builtin_v128_load8x8_s", "builtin_v128_load8x8_u", "builtin_v128_load16x4_s", "builtin_v128_load16x4_u", "builtin_v128_load32x2_s", "builtin_v128_load32x2_u", "builtin_v128_load8_splat", "builtin_v128_load16_splat", "builtin_v128_load32_splat", "builtin_v128_load64_splat", "builtin_v128_load32_zero", "builtin_v128_load64_zero", "builtin_v128_load8_lane", "builtin_v128_load16_lane", "builtin_v128_load32_lane", "builtin_v128_load64_lane", "builtin_v128_store8_lane", "builtin_v128_store16_lane", "builtin_v128_store32_lane", "builtin_v128_store64_lane", "builtin_v128_store", "builtin_i8x16_splat", "builtin_i8x16_extract_lane_s", "builtin_i8x16_extract_lane_u", "builtin_i8x16_replace_lane", "builtin_i8x16_add", "builtin_i8x16_sub", "builtin_i8x16_min_s", "builtin_i8x16_min_u", "builtin_i8x16_max_s", "builtin_i8x16_max_u", "builtin_i8x16_avgr_u", "builtin_i8x16_abs", "builtin_i8x16_neg", "builtin_i8x16_add_sat_s", "builtin_i8x16_add_sat_u", "builtin_i8x16_sub_sat_s", "builtin_i8x16_sub_sat_u", "builtin_i8x16_shl", "builtin_i8x16_shr_s", "builtin_i8x16_shr_u", "builtin_i8x16_all_true", "builtin_i8x16_bitmask", "builtin_i8x16_popcnt", "builtin_i8x16_eq", "builtin_i8x16_ne", "builtin_i8x16_lt_s", "builtin_i8x16_lt_u", "builtin_i8x16_le_s", "builtin_i8x16_le_u", "builtin_i8x16_gt_s", "builtin_i8x16_gt_u", "builtin_i8x16_ge_s", "builtin_i8x16_ge_u", "builtin_i8x16_narrow_i16x8_s", "builtin_i8x16_narrow_i16x8_u", "builtin_i8x16_shuffle", "builtin_i8x16_swizzle", "builtin_i16x8_splat", "builtin_i16x8_extract_lane_s", "builtin_i16x8_extract_lane_u", "builtin_i16x8_replace_lane", "builtin_i16x8_add", "builtin_i16x8_sub", "builtin_i16x8_mul", "builtin_i16x8_min_s", "builtin_i16x8_min_u", "builtin_i16x8_max_s", "builtin_i16x8_max_u", "builtin_i16x8_avgr_u", "builtin_i16x8_abs", "builtin_i16x8_neg", "builtin_i16x8_add_sat_s", "builtin_i16x8_add_sat_u", "builtin_i16x8_sub_sat_s", "builtin_i16x8_sub_sat_u", "builtin_i16x8_shl", "builtin_i16x8_shr_s", "builtin_i16x8_shr_u", "builtin_i16x8_all_true", "builtin_i16x8_bitmask", "builtin_i16x8_eq", "builtin_i16x8_ne", "builtin_i16x8_lt_s", "builtin_i16x8_lt_u", "builtin_i16x8_le_s", "builtin_i16x8_le_u", "builtin_i16x8_gt_s", "builtin_i16x8_gt_u", "builtin_i16x8_ge_s", "builtin_i16x8_ge_u", "builtin_i16x8_narrow_i32x4_s", "builtin_i16x8_narrow_i32x4_u", "builtin_i16x8_extend_low_i8x16_s", "builtin_i16x8_extend_low_i8x16_u", "builtin_i16x8_extend_high_i8x16_s", "builtin_i16x8_extend_high_i8x16_u", "builtin_i16x8_extadd_pairwise_i8x16_s", "builtin_i16x8_extadd_pairwise_i8x16_u", "builtin_i16x8_q15mulr_sat_s", "builtin_i16x8_extmul_low_i8x16_s", "builtin_i16x8_extmul_low_i8x16_u", "builtin_i16x8_extmul_high_i8x16_s", "builtin_i16x8_extmul_high_i8x16_u", "builtin_i16x8_shuffle", "builtin_i16x8_swizzle", "builtin_i32x4_splat", "builtin_i32x4_extract_lane", "builtin_i32x4_replace_lane", "builtin_i32x4_add", "builtin_i32x4_sub", "builtin_i32x4_mul", "builtin_i32x4_min_s", "builtin_i32x4_min_u", "builtin_i32x4_max_s", "builtin_i32x4_max_u", "builtin_i32x4_dot_i16x8_s", "builtin_i32x4_abs", "builtin_i32x4_neg", "builtin_i32x4_shl", "builtin_i32x4_shr_s", "builtin_i32x4_shr_u", "builtin_i32x4_all_true", "builtin_i32x4_bitmask", "builtin_i32x4_eq", "builtin_i32x4_ne", "builtin_i32x4_lt_s", "builtin_i32x4_lt_u", "builtin_i32x4_le_s", "builtin_i32x4_le_u", "builtin_i32x4_gt_s", "builtin_i32x4_gt_u", "builtin_i32x4_ge_s", "builtin_i32x4_ge_u", "builtin_i32x4_trunc_sat_f32x4_s", "builtin_i32x4_trunc_sat_f32x4_u", "builtin_i32x4_trunc_sat_f64x2_s_zero", "builtin_i32x4_trunc_sat_f64x2_u_zero", "builtin_i32x4_extend_low_i16x8_s", "builtin_i32x4_extend_low_i16x8_u", "builtin_i32x4_extend_high_i16x8_s", "builtin_i32x4_extend_high_i16x8_u", "builtin_i32x4_extadd_pairwise_i16x8_s", "builtin_i32x4_extadd_pairwise_i16x8_u", "builtin_i32x4_extmul_low_i16x8_s", "builtin_i32x4_extmul_low_i16x8_u", "builtin_i32x4_extmul_high_i16x8_s", "builtin_i32x4_extmul_high_i16x8_u", "builtin_i32x4_shuffle", "builtin_i32x4_swizzle", "builtin_i64x2_splat", "builtin_i64x2_extract_lane", "builtin_i64x2_replace_lane", "builtin_i64x2_add", "builtin_i64x2_sub", "builtin_i64x2_mul", "builtin_i64x2_abs", "builtin_i64x2_neg", "builtin_i64x2_shl", "builtin_i64x2_shr_s", "builtin_i64x2_shr_u", "builtin_i64x2_all_true", "builtin_i64x2_bitmask", "builtin_i64x2_eq", "builtin_i64x2_ne", "builtin_i64x2_lt_s", "builtin_i64x2_le_s", "builtin_i64x2_gt_s", "builtin_i64x2_ge_s", "builtin_i64x2_extend_low_i32x4_s", "builtin_i64x2_extend_low_i32x4_u", "builtin_i64x2_extend_high_i32x4_s", "builtin_i64x2_extend_high_i32x4_u", "builtin_i64x2_extmul_low_i32x4_s", "builtin_i64x2_extmul_low_i32x4_u", "builtin_i64x2_extmul_high_i32x4_s", "builtin_i64x2_extmul_high_i32x4_u", "builtin_i64x2_shuffle", "builtin_i64x2_swizzle", "builtin_f32x4_splat", "builtin_f32x4_extract_lane", "builtin_f32x4_replace_lane", "builtin_f32x4_add", "builtin_f32x4_sub", "builtin_f32x4_mul", "builtin_f32x4_div", "builtin_f32x4_neg", "builtin_f32x4_min", "builtin_f32x4_max", "builtin_f32x4_pmin", "builtin_f32x4_pmax", "builtin_f32x4_abs", "builtin_f32x4_sqrt", "builtin_f32x4_ceil", "builtin_f32x4_floor", "builtin_f32x4_trunc", "builtin_f32x4_nearest", "builtin_f32x4_eq", "builtin_f32x4_ne", "builtin_f32x4_lt", "builtin_f32x4_le", "builtin_f32x4_gt", "builtin_f32x4_ge", "builtin_f32x4_convert_i32x4_s", "builtin_f32x4_convert_i32x4_u", "builtin_f32x4_demote_f64x2_zero", "builtin_f32x4_shuffle", "builtin_f32x4_swizzle", "builtin_f64x2_splat", "builtin_f64x2_extract_lane", "builtin_f64x2_replace_lane", "builtin_f64x2_add", "builtin_f64x2_sub", "builtin_f64x2_mul", "builtin_f64x2_div", "builtin_f64x2_neg", "builtin_f64x2_min", "builtin_f64x2_max", "builtin_f64x2_pmin", "builtin_f64x2_pmax", "builtin_f64x2_abs", "builtin_f64x2_sqrt", "builtin_f64x2_ceil", "builtin_f64x2_floor", "builtin_f64x2_trunc", "builtin_f64x2_nearest", "builtin_f64x2_eq", "builtin_f64x2_ne", "builtin_f64x2_lt", "builtin_f64x2_le", "builtin_f64x2_gt", "builtin_f64x2_ge", "builtin_f64x2_convert_low_i32x4_s", "builtin_f64x2_convert_low_i32x4_u", "builtin_f64x4_promote_low_f32x4", "builtin_f64x2_shuffle", "builtin_f64x2_swizzle", "compileVisitGlobals", "sizeTypeRef", "visitInstance", "_values", "k", "global", "ensureVisitMembersOf", "program", "sizeTypeSize", "body", "base", "hasVisitImpl", "visitPrototype", "visitSignature", "visitThisType", "needsTempValue", "members", "j", "l", "member", "fieldType", "fieldOffset", "compileVisitMembers", "managedClasses", "names", "cases", "nextId", "_keys", "instanceId", "current", "typeToRuntimeFlags", "flags", "compileRTTI", "count", "data", "abvInstance", "abvPrototype", "arrayPrototype", "setPrototype", "mapPrototype", "staticArrayPrototype", "lastId", "valueType", "segment", "checkConstantType_expr", "expression", "naturalAlign", "feature", "featureToString", "setCurrentTypeOnError", "numTypeArguments", "expected", "expectedMinimum", "expectedMaximum", "Visitor", "currentExpression", "stack", "length", "expr", "name", "index", "previousExpression", "_BinaryenExpressionGetId", "_BinaryenBlockGetName", "i", "n", "_BinaryenBlockGetNumChildren", "_BinaryenBlockGetChildAt", "_BinaryenIfGetCondition", "_BinaryenIfGetIfTrue", "ifFalse", "_BinaryenIfGetIfFalse", "_BinaryenLoopGetName", "_BinaryenLoopGetBody", "_BinaryenBreakGetName", "condition", "_BinaryenBreakGetCondition", "value", "_BinaryenBreakGetValue", "defaultName", "_BinaryenSwitchGetDefaultName", "numNames", "_BinaryenSwitchGetNumNames", "_BinaryenSwitchGetNameAt", "_BinaryenSwitchGetCondition", "_BinaryenSwitchGetValue", "_BinaryenCallGetTarget", "numOperands", "_BinaryenCallGetNumOperands", "_BinaryenCallGetOperandAt", "_BinaryenCallIndirectGetTarget", "k", "_BinaryenCallIndirectGetNumOperands", "_BinaryenCallIndirectGetOperandAt", "_BinaryenLocalGetGetIndex", "_BinaryenLocalSetGetIndex", "_BinaryenLocalSetGetValue", "_BinaryenGlobalGetGetName", "_BinaryenGlobalSetGetName", "_BinaryenGlobalSetGetValue", "_BinaryenLoadGetPtr", "_BinaryenStoreGetPtr", "_BinaryenStoreGetValue", "_BinaryenUnaryGetValue", "_BinaryenBinaryGetLeft", "_BinaryenBinaryGetRight", "_BinaryenSelectGetIfTrue", "_BinaryenSelectGetIfFalse", "_BinaryenSelectGetCondition", "_BinaryenDropGetValue", "_BinaryenReturnGetValue", "_BinaryenMemoryGrowGetDelta", "_BinaryenAtomicRMWGetPtr", "_BinaryenAtomicRMWGetValue", "_BinaryenAtomicCmpxchgGetPtr", "_BinaryenAtomicCmpxchgGetExpected", "_BinaryenAtomicCmpxchgGetReplacement", "_BinaryenAtomicWaitGetPtr", "_BinaryenAtomicWaitGetExpected", "_BinaryenAtomicWaitGetTimeout", "_BinaryenAtomicNotifyGetPtr", "_BinaryenAtomicNotifyGetNotifyCount", "_BinaryenSIMDExtractGetVec", "_BinaryenSIMDReplaceGetVec", "_BinaryenSIMDReplaceGetValue", "_BinaryenSIMDShuffleGetLeft", "_BinaryenSIMDShuffleGetRight", "_BinaryenSIMDTernaryGetA", "_BinaryenSIMDTernaryGetB", "_BinaryenSIMDTernaryGetC", "_BinaryenSIMDShiftGetVec", "_BinaryenSIMDShiftGetShift", "_BinaryenSIMDLoadGetPtr", "_BinaryenSIMDLoadStoreLaneGetPtr", "_BinaryenSIMDLoadStoreLaneGetVec", "_BinaryenMemoryInitGetDest", "_BinaryenMemoryInitGetOffset", "_BinaryenMemoryInitGetSize", "_BinaryenMemoryCopyGetDest", "_BinaryenMemoryCopyGetSource", "_BinaryenMemoryCopyGetSize", "_BinaryenMemoryFillGetDest", "_BinaryenMemoryFillGetValue", "_BinaryenMemoryFillGetSize", "_BinaryenRefIsGetValue", "_BinaryenRefFuncGetFunc", "_BinaryenRefEqGetLeft", "_BinaryenRefEqGetRight", "_BinaryenTryGetBody", "numCatchBodies", "_BinaryenTryGetNumCatchBodies", "_BinaryenTryGetCatchBodyAt", "_BinaryenThrowGetTag", "_BinaryenThrowGetNumOperands", "_BinaryenThrowGetOperandAt", "_BinaryenTupleMakeGetNumOperands", "_BinaryenTupleMakeGetOperandAt", "_BinaryenTupleExtractGetTuple", "_BinaryenI31NewGetValue", "_BinaryenI31GetGetI31", "_BinaryenCallRefGetNumOperands", "_BinaryenCallRefGetOperandAt", "_BinaryenCallRefGetTarget", "_BinaryenRefTestGetRef", "_BinaryenRefCastGetRef", "_BinaryenBrOnGetName", "_BinaryenBrOnGetRef", "_BinaryenStructNewGetNumOperands", "_BinaryenStructNewGetOperandAt", "_BinaryenStructGetGetRef", "_BinaryenStructGetGetIndex", "_BinaryenStructSetGetRef", "_BinaryenStructSetGetIndex", "_BinaryenStructSetGetValue", "_BinaryenArrayNewGetSize", "init", "_BinaryenArrayNewGetInit", "numValues", "_BinaryenArrayInitGetNumValues", "_BinaryenArrayInitGetValueAt", "_BinaryenArrayGetGetRef", "_BinaryenArrayGetGetIndex", "_BinaryenArraySetGetRef", "_BinaryenArraySetGetIndex", "_BinaryenArraySetGetValue", "_BinaryenArrayLenGetRef", "_BinaryenArrayCopyGetDestRef", "_BinaryenArrayCopyGetDestIndex", "_BinaryenArrayCopyGetSrcRef", "_BinaryenArrayCopyGetSrcIndex", "_BinaryenArrayCopyGetLength", "_BinaryenRefAsGetValue", "_BinaryenStringNewGetPtr", "_BinaryenStringNewGetLength", "start", "_BinaryenStringNewGetStart", "end", "_BinaryenStringNewGetEnd", "_BinaryenStringMeasureGetRef", "_BinaryenStringEncodeGetRef", "_BinaryenStringEncodeGetPtr", "_BinaryenStringEncodeGetStart", "_BinaryenStringConcatGetLeft", "_BinaryenStringConcatGetRight", "_BinaryenStringEqGetLeft", "_BinaryenStringEqGetRight", "_BinaryenStringAsGetRef", "_BinaryenStringWTF8AdvanceGetRef", "_BinaryenStringWTF8AdvanceGetPos", "_BinaryenStringWTF8AdvanceGetBytes", "_BinaryenStringWTF16GetGetRef", "_BinaryenStringWTF16GetGetPos", "_BinaryenStringIterNextGetRef", "_BinaryenStringIterMoveGetRef", "_BinaryenStringIterMoveGetNum", "_BinaryenStringSliceWTFGetRef", "_BinaryenStringSliceWTFGetStart", "_BinaryenStringSliceWTFGetEnd", "_BinaryenStringSliceIterGetRef", "_BinaryenStringSliceIterGetNum", "Pass", "module", "currentFunction", "currentGlobal", "moduleRef", "_BinaryenGetNumFunctions", "_BinaryenGetFunctionByIndex", "func", "body", "_BinaryenFunctionGetBody", "_BinaryenGetNumGlobals", "_BinaryenGetGlobalByIndex", "global", "_BinaryenGlobalGetInitExpr", "replacement", "search", "_BinaryenFunctionSetBody", "parent", "replaceChild", "_BinaryenExpressionFinalize", "numChildren", "child", "_BinaryenBlockSetChildAt", "_BinaryenIfSetCondition", "ifTrue", "_BinaryenIfSetIfTrue", "_BinaryenIfSetIfFalse", "_BinaryenLoopSetBody", "_BinaryenBreakSetCondition", "_BinaryenBreakSetValue", "_BinaryenSwitchSetCondition", "_BinaryenSwitchSetValue", "operand", "_BinaryenCallSetOperandAt", "target", "_BinaryenCallIndirectSetTarget", "_BinaryenCallIndirectSetOperandAt", "_BinaryenLocalSetSetValue", "_BinaryenGlobalSetSetValue", "ptr", "_BinaryenLoadSetPtr", "_BinaryenStoreSetPtr", "_BinaryenStoreSetValue", "_BinaryenUnarySetValue", "left", "_BinaryenBinarySetLeft", "right", "_BinaryenBinarySetRight", "_BinaryenSelectSetIfTrue", "_BinaryenSelectSetIfFalse", "_BinaryenSelectSetCondition", "_BinaryenDropSetValue", "_BinaryenReturnSetValue", "delta", "_BinaryenMemoryGrowSetDelta", "_BinaryenAtomicRMWSetPtr", "_BinaryenAtomicRMWSetValue", "_BinaryenAtomicCmpxchgSetPtr", "expected", "_BinaryenAtomicCmpxchgSetExpected", "repl", "_BinaryenAtomicCmpxchgSetReplacement", "_BinaryenAtomicWaitSetPtr", "_BinaryenAtomicWaitSetExpected", "timeout", "_BinaryenAtomicWaitSetTimeout", "_BinaryenAtomicNotifySetPtr", "notifyCount", "_BinaryenAtomicNotifySetNotifyCount", "vec", "_BinaryenSIMDExtractSetVec", "_BinaryenSIMDReplaceSetVec", "_BinaryenSIMDReplaceSetValue", "_BinaryenSIMDShuffleSetLeft", "_BinaryenSIMDShuffleSetRight", "a", "_BinaryenSIMDTernarySetA", "b", "_BinaryenSIMDTernarySetB", "c", "_BinaryenSIMDTernarySetC", "_BinaryenSIMDShiftSetVec", "shift", "_BinaryenSIMDShiftSetShift", "_BinaryenSIMDLoadSetPtr", "_BinaryenSIMDLoadStoreLaneSetPtr", "_BinaryenSIMDLoadStoreLaneSetVec", "dest", "_BinaryenMemoryInitSetDest", "offset", "_BinaryenMemoryInitSetOffset", "size", "_BinaryenMemoryInitSetSize", "_BinaryenMemoryCopySetDest", "source", "_BinaryenMemoryCopySetSource", "_BinaryenMemoryCopySetSize", "_BinaryenMemoryFillSetDest", "_BinaryenMemoryFillSetValue", "_BinaryenMemoryFillSetSize", "_BinaryenRefIsSetValue", "_BinaryenRefEqSetLeft", "_BinaryenRefEqSetRight", "_BinaryenTrySetBody", "catchBody", "_BinaryenTrySetCatchBodyAt", "_BinaryenThrowSetOperandAt", "_BinaryenTupleMakeSetOperandAt", "tuple", "_BinaryenTupleExtractSetTuple", "_BinaryenI31NewSetValue", "i31Expr", "_BinaryenI31GetSetI31", "_BinaryenCallRefSetOperandAt", "_BinaryenCallRefSetTarget", "ref", "_BinaryenRefTestSetRef", "_BinaryenRefCastSetRef", "_BinaryenBrOnSetRef", "_BinaryenStructNewSetOperandAt", "_BinaryenStructGetSetRef", "_BinaryenStructSetSetRef", "_BinaryenStructSetSetValue", "_BinaryenArrayNewSetSize", "_BinaryenArrayNewSetInit", "_BinaryenArrayInitSetValueAt", "_BinaryenArrayGetSetRef", "_BinaryenArrayGetSetIndex", "_BinaryenArraySetSetRef", "_BinaryenArraySetSetIndex", "_BinaryenArraySetSetValue", "_BinaryenArrayLenSetRef", "destRef", "_BinaryenArrayCopySetDestRef", "destIndex", "_BinaryenArrayCopySetDestIndex", "srcRef", "_BinaryenArrayCopySetSrcRef", "srcIndex", "_BinaryenArrayCopySetSrcIndex", "_BinaryenArrayCopySetLength", "_BinaryenRefAsSetValue", "_BinaryenStringNewSetPtr", "_BinaryenStringNewSetLength", "_BinaryenStringNewSetStart", "_BinaryenStringNewSetEnd", "_BinaryenStringMeasureSetRef", "_BinaryenStringEncodeSetRef", "_BinaryenStringEncodeSetPtr", "_BinaryenStringEncodeSetStart", "_BinaryenStringConcatSetLeft", "_BinaryenStringConcatSetRight", "_BinaryenStringEqSetLeft", "_BinaryenStringEqSetRight", "_BinaryenStringAsSetRef", "_BinaryenStringWTF8AdvanceSetRef", "pos", "_BinaryenStringWTF8AdvanceSetPos", "bytes", "_BinaryenStringWTF8AdvanceSetBytes", "_BinaryenStringWTF16GetSetRef", "_BinaryenStringWTF16GetSetPos", "_BinaryenStringIterNextSetRef", "_BinaryenStringIterMoveSetRef", "num", "_BinaryenStringIterMoveSetNum", "_BinaryenStringSliceWTFSetRef", "_BinaryenStringSliceWTFSetStart", "_BinaryenStringSliceWTFSetEnd", "_BinaryenStringSliceIterSetRef", "_BinaryenStringSliceIterSetNum", "RtraceMemory", "Pass", "compiler", "_BinaryenFunctionGetName", "store", "module", "ptr", "_BinaryenStoreGetPtr", "offset", "_BinaryenStoreGetOffset", "bytes", "_BinaryenStoreGetBytes", "_BinaryenStoreSetPtr", "createType", "TypeRef", "matchPattern", "module", "expr", "_BinaryenExpressionGetId", "_BinaryenCallGetTarget", "BuiltinNames", "_BinaryenCallGetNumOperands", "_BinaryenCallGetOperandAt", "needsSlot", "value", "isConstZero", "ShadowStackPass", "Pass", "compiler", "TypeRef", "func", "localIndex", "slotMap", "slotIndex", "name", "managedOperandIndices", "type", "tempMap", "_BinaryenFunctionGetNumLocals", "offset", "frameSize", "stmts", "remain", "Source", "operands", "numSlots", "i", "k", "operand", "match", "currentFunction", "numLocals", "temp", "call", "numOperands", "_BinaryenCallSetOperandAt", "callIndirect", "_BinaryenCallIndirectGetNumOperands", "_BinaryenCallIndirectGetOperandAt", "_BinaryenCallIndirectSetOperandAt", "localSet", "_BinaryenLocalSetGetValue", "_BinaryenLocalSetSetValue", "index", "_BinaryenLocalSetGetIndex", "_BinaryenLocalSetIsTee", "funcRef", "_BinaryenFunctionGetName", "params", "_BinaryenFunctionGetParams", "results", "_BinaryenFunctionGetResults", "body", "_BinaryenFunctionGetBody", "numVars", "_BinaryenFunctionGetNumVars", "vars", "_BinaryenFunctionGetVar", "tempMaps", "_keys", "moduleRef", "_BinaryenRemoveFunction", "cArr", "allocPtrArray", "newFuncRef", "_BinaryenAddFunction", "_free", "exportRef", "_BinaryenExportGetKind", "internalNameRef", "_BinaryenExportGetValue", "internalName", "externalNameRef", "_BinaryenExportGetName", "_BinaryenGetFunction", "paramTypes", "expandType", "numParams", "wrapperName", "wrapperNameRef", "forwardedOperands", "tempIndex", "_BinaryenRemoveExport", "_BinaryenAddFunctionExport", "instrumentReturns", "InstrumentReturns", "bodyType", "_BinaryenExpressionGetType", "_BinaryenFunctionSetBody", "exportMap", "exportName", "_BinaryenGetExport", "shadowStack", "ret", "_BinaryenReturnGetValue", "returnType", "_BinaryenReturnSetValue", "ExportsWalker", "program", "includePrivate", "_values", "i", "k", "file", "exports", "_keys", "memberName", "member", "exportsStar", "exportStar", "name", "element", "seen", "propertyInstance", "getterInstance", "setterInstance", "hasCompiledMember", "instances", "instance", "members", "j", "l", "importToModule", "moduleName", "shouldInstrument", "JSBuilder", "ExportsWalker", "program", "esm", "includePrivate", "name", "element", "sb", "type", "isPlainValue", "Mode", "indent", "members", "_values", "i", "k", "value", "escapeString", "isIdentifier", "moduleId", "code", "signature", "isPlainFunction", "parameterTypes", "parameterNames", "expr", "indentText", "Type", "numReferences", "releases", "needsRetainRelease", "originalName", "decorator", "findDecorator", "args", "codeArg", "literal", "parts", "exports", "moduleImports", "options", "insertPos", "sbLengthBefore", "_keys", "module", "resetPos", "numInstrumented", "_keys2", "j", "l", "elem", "func", "global", "hasAdaptedImports", "mappings", "map", "hasAdaptedExports", "deferredCode", "objectInstance", "rtSizeOffset", "arrayBufferId", "chunkSize", "stringId", "dataStartOffset", "lengthOffset", "arrayBufferViewInstance", "arraySize", "bufferOffset", "byteLengthOffset", "size", "exportStart", "needsMaybeDefault", "importExpr", "importMap", "clazz", "valueType", "isPlainObject", "prevIndentLevel", "target", "targetName", "valueName", "skipTail", "memberName", "member", "property", "kind", "mode", "inverseMode", "Source", "text", "indentLevel", "butFirst", "lineStart", "length", "pos", "liftRequiresExportRuntime", "lowerRequiresExportRuntime", "Options", "UncheckedBehavior", "Type", "TypeRef", "feature", "Constraints", "RuntimeFeatures", "ImportNames", "ExportNames", "runtimeFunctions", "runtimeGlobals", "Compiler", "DiagnosticEmitter", "program", "module", "options", "featureFlags", "startFunctionInstance", "BuiltinNames", "Signature", "ShadowStackPass", "resolver", "hasShadowStack", "startFunctionBody", "files", "_values", "i", "k", "file", "name", "instance", "lazyFunctions", "functionsToCompile", "_keys", "elem", "functionTable", "overrideStubs", "overrrideStubsSeen", "overrideInstances", "compileRTTI", "compileVisitGlobals", "compileVisitMembers", "memoryOffset", "startIsEmpty", "exportStart", "signature", "funcRef", "typesToRefs", "isIdentifier", "Source", "RtraceMemory", "memorySegments", "initialPages", "maximumPages", "Module", "isSharedMemory", "lowMemoryLimit32", "lowMemoryLimit", "CommonNames", "tableBase", "functionTableNames", "initialTableSize", "maximumTableSize", "exports", "elementName", "element", "exportsStar", "prefix", "functionPrototype", "functionInstance", "exportName", "thisType", "lowerRequiresExportRuntime", "liftRequiresExportRuntime", "parameterTypes", "global", "type", "members", "subPrefix", "STATIC_DELIMITER", "memberName", "member", "enumValue", "normalizedPathWithoutExtension", "reportNode", "filesByName", "pathWithIndex", "INDEX_SUFFIX", "startFunction", "startSignature", "previousBody", "previousFlow", "flow", "statements", "locals", "numLocals", "varTypes", "pendingElements", "initExpr", "typeNode", "initializerNode", "resolvedType", "internalName", "typeRef", "isDeclaredConstant", "isDeclaredInline", "mangleImportName", "mangleImportName_moduleName", "mangleImportName_elementName", "initializeInStart", "precomp", "getExpressionId", "fromName", "getGlobalGetName", "isGlobalMutable", "elementsByName", "getExpressionType", "getConstValueI32", "getConstValueI64Low", "getConstValueI64High", "getConstValueF32", "getConstValueF64", "findDecorator", "previousParent", "previousValue", "previousValueIsMut", "isInline", "initInStart", "valueNode", "value", "forceStdAlternative", "parameters", "numParameters", "visited", "paramIdentifier", "paramName", "previousType", "bodyNode", "declarationNode", "decoratorNodes", "decorator", "stmts", "propertyName", "propertyParent", "propertyInstance", "range", "fnTypeNode", "firstIndex", "returnType", "thisLocal", "bodyStartIndex", "expr", "parent", "classInstance", "allocStmts", "property", "getterInstance", "valueType", "valueTypeRef", "thisTypeRef", "body", "flowBefore", "setterInstance", "bodyExpr", "linkInstance", "createType", "buffer", "alignment", "isPowerOf2", "segment", "MemorySegment", "stringValue", "ptr", "totalOverhead", "stringInstance", "stringSegment", "segments", "len", "buf", "writeI16", "pos", "elementType", "values", "length", "byteSize", "elementTypeRef", "writeI8", "writeI32", "writeI64", "writeF32", "writeF64", "writeV128", "getConstValueV128", "id", "bufferSegment", "arrayInstance", "bufferLength", "readI32", "arrayLength", "bufferAddress", "memorySegment", "index", "rtInstance", "statement", "memberStatements", "declaration", "declarations", "exportStatement", "internalPath", "importStatement", "stmt", "numStatements", "getBlockName", "j", "getBlockChildCount", "getBlockChildAt", "outerFlow", "innerFlow", "labelNode", "breakLabel", "label", "continueLabel", "numLocalsBefore", "loopLabel", "bodyStmts", "possiblyContinues", "possiblyBreaks", "possiblyFallsThrough", "condExpr", "condExprTrueish", "condKind", "initializer", "condition", "bodyFlow", "possiblyLoops", "incrementor", "ifTrue", "ifFalse", "thenStmts", "thenFlow", "elseFlow", "elseStmts", "valueExpression", "constraints", "inlineReturnLabel", "cases", "numCases", "tempLocalIndex", "breaks", "breakIndex", "defaultIndex", "case_", "currentBlock", "fallThroughFlow", "breakingFlowAlternatives", "isLast", "nextLabel", "count", "message", "newArgs", "numDeclarations", "initializers", "initType", "cloneMap", "dummy", "temp", "isConst", "isStatic", "local", "Local", "scopedLocals", "existing", "existingLocal", "alwaysTerminates", "contextualType", "shift", "mask", "expression", "compiled", "currentType", "wrap", "fromType", "toType", "explicit", "saturating", "inheritedConstraints", "left", "right", "leftExpr", "leftType", "rightExpr", "rightType", "commonType", "compound", "classReference", "overload", "operatorTokenToString", "isConstExpressionNaN", "isConstNegZero", "rightFlow", "tempLocal", "tempIndex", "target", "targetType", "leftValue", "rightValue", "prototype", "result", "isWasm64", "accuratePow64", "namespace", "operatorInstance", "valueExpr", "thisExpression", "elementExpression", "propertyPrototype", "isUnchecked", "indexedSet", "indexExpression", "tee", "isConstructor", "thisExpr", "returnTypeRef", "tempThis", "setterIndexType", "getterIndexType", "elementExpr", "tempTarget", "tempElement", "localIndex", "sourceFunction", "baseClassInstance", "sizeTypeRef", "baseCtorInstance", "superCall", "thisArg", "functionArg", "getterPrototype", "typeArguments", "args", "call", "Node", "typeParameterNodes", "typeArgumentNodes", "callee", "ctx", "BuiltinContext", "builtins", "methodName", "function_builtins", "numArguments", "hasThis", "hasRest", "minimum", "maximum", "relatedReportNode", "argumentExpressions", "inlineStack", "numArgumentsInclThis", "operands", "paramType", "paramExpr", "immediatelyDropped", "Flow", "base", "argumentLocal", "original", "stub", "originalSignature", "originalParameterTypes", "originalParameterDeclarations", "isInstance", "minArguments", "minOperands", "maxArguments", "maxOperands", "numOptional", "forwardedOperands", "operandIndex", "numNames", "names", "ofN", "argumentsLength", "table", "builder", "SwitchBuilder", "overrideInstance", "overrideType", "originalType", "overrideSignature", "overrideParameterTypes", "overrideNumParameters", "paramExprs", "n", "needsVarargsStub", "calledName", "extenders", "extender", "instanceMembers", "instanceClass", "operand", "isConstZero", "parameterIndex", "theOperands", "numOperands", "parameterNodes", "allOptionalsAreConstant", "resolved", "lastOperand", "getSideEffects", "lastOperandType", "expressions", "numExpressions", "exprs", "targetExpression", "indexedGet", "isNamed", "isSemanticallyAnonymous", "FunctionPrototype", "contextualTypeArguments", "contextualSignature", "signatureNode", "numPresentParameters", "parameterNode", "isTypeOmitted", "thisTypeNode", "Function", "worked", "offset", "fname", "ftype", "signatureReference", "scopedThis", "superType", "currentParent", "localType", "globalType", "ensureType", "isType", "namedType", "expectedType", "actualType", "pending", "sizeType", "allInstances", "instances", "implementers", "implementer", "implicitlyNegate", "floatValue", "intValue", "sign", "tag", "parts", "numParts", "stringType", "lhsLen", "rhsLen", "hasPrefix", "lhs", "rhs", "concatMethod", "exprA", "exprB", "expressionPositions", "joinInstance", "indexedSetInstance", "temps", "tsaArrayInstance", "first", "rawParts", "partExprs", "arraySegment", "rawExprs", "rawHeaderSegment", "contextualClass", "arrayType", "arrayBufferInstance", "tempDataStart", "arrayAddress", "arrayTypeRef", "dataStartMember", "dataStartProperty", "source", "bufferSize", "classType", "ctorPrototype", "hasErrors", "classTypeRef", "omittedFields", "memberKey", "deferredProperties", "propertyType", "l", "ctor", "classPrototype", "baseClass", "baseCtor", "relatedNode", "ctorInstance", "ctxType", "parentEnum", "ifThen", "ifElse", "ifThenFlow", "ifThenExpr", "ifThenType", "ifElseFlow", "ifElseExpr", "ifElseType", "getValue", "getLocalSetValue", "setValue", "typeString", "targetFunction", "supported", "explicitThisType", "parameterReportNode", "evaled", "v128_zero", "v128_ones", "toStringInstance", "toStringSignature", "toStringReturnType", "allocInstance", "newInstance", "thisIndex", "thisLocalIndex", "nonParameterFields", "fieldPrototype", "fieldTypeRef", "field", "fieldType", "codeLocation", "abortInstance", "messageArg", "messageExpr", "filenameExpr", "staticAbortCallExpr", "nonNullExpr", "mangleInternalName", "overriddenModuleName", "arg", "TSDBuilder", "ExportsWalker", "program", "esm", "includePrivate", "name", "element", "sb", "type", "tsType", "Mode", "indent", "members", "_keys", "i", "k", "memberName", "signature", "parameterTypes", "numParameters", "returnType", "Type", "requiredParameters", "originalName", "deferredTypes", "moduleImports", "moduleName", "isIdentifier", "escapeString", "clazz", "_values", "member", "Source", "mode", "valueType", "seenObjectTypes", "typeName", "isPlain", "property", "base", "newOptions", "Options", "setTarget", "options", "target", "setRuntime", "runtime", "setNoAssert", "noAssert", "setExportMemory", "exportMemory", "setImportMemory", "importMemory", "setInitialMemory", "initialMemory", "setMaximumMemory", "maximumMemory", "setSharedMemory", "sharedMemory", "setImportTable", "importTable", "setExportTable", "exportTable", "setSourceMap", "sourceMap", "setUncheckedBehavior", "uncheckedBehavior", "setMemoryBase", "memoryBase", "setTableBase", "tableBase", "addGlobalAlias", "alias", "name", "globalAliases", "removeGlobalAlias", "setExportStart", "exportStart", "setNoUnsafe", "noUnsafe", "setLowMemoryLimit", "lowMemoryLimit", "setExportRuntime", "exportRuntime", "DEFAULT_STACK_SIZE", "setStackSize", "stackSize", "setBundleVersion", "bundleMajorVersion", "bundleMinorVersion", "bundlePatchVersion", "FEATURE_SIGN_EXTENSION", "FEATURE_MUTABLE_GLOBALS", "FEATURE_NONTRAPPING_F2I", "FEATURE_BULK_MEMORY", "FEATURE_SIMD", "FEATURE_THREADS", "FEATURE_EXCEPTION_HANDLING", "FEATURE_TAIL_CALLS", "FEATURE_REFERENCE_TYPES", "FEATURE_MULTI_VALUE", "FEATURE_GC", "FEATURE_MEMORY64", "FEATURE_RELAXED_SIMD", "FEATURE_EXTENDED_CONST", "FEATURE_STRINGREF", "enableFeature", "feature", "disableFeature", "setOptimizeLevelHints", "optimizeLevel", "shrinkLevel", "setBasenameHint", "basename", "setBindingsHint", "bindings", "setPedantic", "pedantic", "setDebugInfo", "debug", "newProgram", "Program", "nextDiagnostic", "program", "getSource", "internalPath", "getDiagnosticCode", "diagnostic", "getDiagnosticCategory", "getDiagnosticMessage", "getDiagnosticRange", "getDiagnosticRelatedRange", "getRangeStart", "range", "getRangeEnd", "getRangeSource", "getSourceNormalizedPath", "source", "isInfo", "message", "isWarning", "isError", "parse", "program", "text", "path", "isEntry", "nextFile", "getDependee", "file", "initializeProgram", "compile", "Compiler", "buildTSD", "esm", "TSDBuilder", "buildJS", "JSBuilder", "getBinaryenModuleRef", "module", "validate", "optimize", "optimizeLevel", "shrinkLevel", "debugInfo", "zeroFilledMemory", "ASTBuilder", "node", "builder", "source", "statements", "i", "k", "sb", "current", "typeArguments", "numTypeArguments", "isNullable", "explicitThisType", "parameters", "numParameters", "returnType", "extendsType", "defaultType", "elements", "numElements", "element", "names", "values", "indent", "name", "value", "operatorTokenToString", "args", "numArgs", "declaration", "expressions", "numExpressions", "range", "hasExplicitSign", "str", "escapeString", "tag", "parts", "last", "lastCharPos", "numStatements", "indentLevel", "label", "isDefault", "decorators", "typeParameters", "implementsTypes", "numImplementsTypes", "indexSignature", "members", "numMembers", "member", "numValues", "initializer", "path", "type", "condition", "incrementor", "signature", "numTypeParameters", "body", "isTypeOmitted", "ifTrue", "ifFalse", "externalName", "declarations", "namespaceName", "numDeclarations", "cases", "bodyStatements", "catchVariable", "catchStatements", "finallyStatements", "firstDeclaration", "kind", "implicitFieldDeclaration", "ret", "src_default", "index_js_exports"]
}
